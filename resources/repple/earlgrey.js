require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var $targ$1 = undefined;var $targ$5 = undefined;var accum$0 = undefined;var $targ$6 = undefined;var accum$1 = undefined;var $targ$7 = undefined;var accum$2 = undefined;var $targ$8 = undefined;var accum$3 = undefined;var $targ$12 = undefined;var accum$4 = undefined;var $targ$13 = undefined;var accum$5 = undefined;var $targ$18 = undefined;var $targ$19 = undefined;var $targ$20 = undefined;var $targ$21 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var $targ$25 = undefined;var repple$0 = undefined;var Repl$0 = undefined;var Editor$0 = undefined;var Outputter$0 = undefined;var codemirror$0 = undefined;var $0$0 = undefined;var html$0 = undefined;var dom$0 = undefined;var fade__minus__in$0 = undefined;var ReloadAfterPromise$0 = undefined;var make__minus__eval$0 = undefined;var Into$0 = undefined;var Cards$0 = undefined;var fill__minus__bindings$0 = undefined;var stdrepl$0 = undefined;var dom__minus__node__minus__clear$0 = undefined;var stdeditor$0 = undefined;var div__minus__names$0 = undefined;var stdsetup$0 = undefined;var colorize$0 = undefined;repple$0 = require("repple");Repl$0 = getProperty(repple$0, "Repl", "repple");Editor$0 = getProperty(repple$0, "Editor", "repple");Outputter$0 = getProperty(repple$0, "Outputter", "repple");codemirror$0 = require("codemirror");$0$0 = require("codemirror/addon/runmode/runmode");html$0 = require("earlgrey-runtime/std/html");dom$0 = require("earlgrey-runtime/std/dom");if (typeof window === "undefined") {
  $targ$0 = undefined;global.window = $targ$0;void 0;
}if (typeof document === "undefined") {
  $targ$1 = undefined;global.document = $targ$1;void 0;
}fade__minus__in$0 = function fadeIn(out$0, contents$0) {
  var printed$0 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;printed$0 = out$0.log(contents$0);$targ$2 = "opacity 500ms";printed$0.style.transition = $targ$2;$targ$3 = 0;printed$0.style.opacity = $targ$3;window.getComputedStyle(printed$0).opacity;$targ$4 = 1;printed$0.style.opacity = $targ$4;return undefined;
};ReloadAfterPromise$0 = function ReloadAfterPromise(temp$0$0) {
  var __at___$0 = undefined;if (!getChecker(ReloadAfterPromise$0)(this)) {
    __at___$0 = Object.create(ReloadAfterPromise$0.prototype);
  } else {
    __at___$0 = this;
  }__at___$0.promise = temp$0$0;return __at___$0;
};__amp____colon__(ReloadAfterPromise$0, __amp____colon__(($targ$5 = "ReloadAfterPromise", accum$0 = {}, accum$0["::name"] = $targ$5, accum$0), ($targ$6 = true, accum$1 = {}, accum$1["::egclass"] = $targ$6, accum$1)));make__minus__eval$0 = function makeEval() {
  var ev$0 = undefined;var evaluate$0 = undefined;var targets$0 = undefined;var bindings0$0 = undefined;var bindings$0 = undefined;var dynamic__minus__bindings$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 2 && t0$0 <= 5) {
    evaluate$0 = m$0$0[0];targets$0 = m$0$0[1];if (2 >= t0$0) {
      bindings0$0 = null;
    } else {
      bindings0$0 = m$0$0[2];
    }if (3 >= t0$0) {
      bindings$0 = null;
    } else {
      bindings$0 = m$0$0[3];
    }if (4 >= t0$0) {
      dynamic__minus__bindings$0 = null;
    } else {
      dynamic__minus__bindings$0 = m$0$0[4];
    }ev$0 = function ev(text$0) {
      return spawn.call(this, regeneratorRuntime.mark(function callee$2$0() {
        var _this = this;

        var m$1, acc$0, temp$1, res$0, loc$0, loc2$0, rval$0, __at___$1, e$0, rp$0, t0$2, e$1;

        return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
          while (1) switch (context$3$0.prev = context$3$0.next) {
            case 0:
              m$1 = undefined;
              acc$0 = undefined;
              temp$1 = undefined;
              res$0 = undefined;
              loc$0 = undefined;
              loc2$0 = undefined;
              rval$0 = undefined;
              __at___$1 = undefined;
              __at___$1 = _this;rval$0 = false;context$3$0.prev = 10;
              if (bindings0$0) {
                __at___$1.setenv(bindings$0);
              }if (dynamic__minus__bindings$0) {
                __at___$1.setenv(object((acc$0 = [], temp$1 = null, m$1 = null, (function () {
                  $1: for (var _iterator = items(dynamic__minus__bindings$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                    m$1 = _step.value;
                    var k$0 = undefined;var f$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;t0$1 = m$1;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 2)) {
                      k$0 = t0$1[0];f$0 = t0$1[1];temp$1 = [k$0, f$0()];acc$0.push(temp$1);
                    } else {
                      ___match_error(m$1);
                    }
                  }
                })(), acc$0)));
              }context$3$0.prev = 13;
              context$3$0.next = 16;
              return evaluate$0(text$0);

            case 16:
              res$0 = context$3$0.sent;
              res$0;context$3$0.next = 35;
              break;

            case 20:
              context$3$0.prev = 20;
              context$3$0.t7 = context$3$0["catch"](13);
              e$0 = undefined;
              rp$0 = undefined;
              t0$2 = undefined;
              t0$2 = context$3$0.t7;
              if (!getChecker(ReloadAfterPromise$0)(t0$2)) {
                context$3$0.next = 33;
                break;
              }

              rp$0 = t0$2;context$3$0.next = 30;
              return rp$0.promise;

            case 30:
              return context$3$0.abrupt("return", ev$0(text$0));

            case 33:
              e$0 = context$3$0.t7;throw e$0;

            case 35:
              if (getChecker(Into$0)(res$0)) {
                if ((loc$0 = send(targets$0, res$0.location), loc$0)) {
                  fade__minus__in$0(Outputter$0(loc$0, true), res$0.contents);rval$0 = ["success", undefined];
                } else {
                  if ((loc2$0 = document.getElementById(res$0.location), loc2$0)) {
                    fade__minus__in$0(Outputter$0(loc2$0, true), res$0.contents);rval$0 = ["success", undefined];
                  } else {
                    rval$0 = ["success", res$0.contents];
                  }
                }
              } else {
                rval$0 = ["success", res$0];
              }rval$0;context$3$0.next = 45;
              break;

            case 39:
              context$3$0.prev = 39;
              context$3$0.t8 = context$3$0["catch"](10);
              e$1 = undefined;
              e$1 = context$3$0.t8;rval$0 = ["failure", e$1];rval$0;

            case 45:
              context$3$0.prev = 45;
              if (bindings0$0) {
                __at___$1.setenv(bindings0$0);
              }return context$3$0.finish(45);

            case 48:
              return context$3$0.abrupt("return", rval$0);

            case 49:
            case "end":
              return context$3$0.stop();
          }
        }, callee$2$0, this, [[10, 39, 45, 48], [13, 20]]);
      }));
    };return ev$0;
  } else {
    return ___match_error(m$0$0, "{evaluate\n          targets\n          bindings0 = null\n          bindings = null\n          dynamic-bindings = null}");
  }
};Into$0 = function Into(temp$2$0, temp$3$0) {
  var __at___$2 = undefined;if (!getChecker(Into$0)(this)) {
    __at___$2 = Object.create(Into$0.prototype);
  } else {
    __at___$2 = this;
  }__at___$2.location = temp$2$0;__at___$2.contents = temp$3$0;return __at___$2;
};__amp____colon__(Into$0, __amp____colon__(($targ$7 = "Into", accum$2 = {}, accum$2["::name"] = $targ$7, accum$2), ($targ$8 = true, accum$3 = {}, accum$3["::egclass"] = $targ$8, accum$3)));Cards$0 = function Cards(temp$4$0) {
  var __at___$3 = undefined;if (!getChecker(Cards$0)(this)) {
    __at___$3 = Object.create(Cards$0.prototype);
  } else {
    __at___$3 = this;
  }__at___$3.config = temp$4$0;__amp____colon__(__at___$3, __at___$3.config);__at___$3.orderCards(__at___$3.cards);return __at___$3;
};Cards$0.prototype.orderCards = function (cards$0) {
  var m$2 = undefined;var acc$1 = undefined;var temp$5 = undefined;var m$3 = undefined;var acc$2 = undefined;var temp$6 = undefined;var ord$0 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var __at___$4 = undefined;var self$0 = undefined;__at___$4 = this;self$0 = this;acc$1 = [];temp$5 = null;m$2 = null;$3: for (var _iterator = items(cards$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$2 = _step.value;
    var k$1 = undefined;var v$0 = undefined;var order$0 = undefined;var t0$3 = undefined;var t1$1 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;t0$3 = m$2;if (Array.isArray(t0$3) && (t1$1 = t0$3.length, t1$1 === 2 && (k$1 = t0$3[0], t2$0 = t0$3[1], ___hasprop(t2$0, "__main") && (t3$0 = t2$0.__main, v$0 = t3$0, ___hasprop(t3$0, "order") && (t4$0 = t3$0.order, typeof t4$0 === "number"))))) {
      order$0 = t4$0;temp$5 = v$0;acc$1.push(temp$5);
    } else {
      continue $3;acc$1.push(temp$5);
    }
  }ord$0 = acc$1;$targ$9 = ord$0.sort(function (a$0, b$0) {
    return a$0.order - b$0.order;
  });cards$0.__order = $targ$9;$targ$10 = -1;cards$0.__index = $targ$10;acc$2 = [];temp$6 = null;m$3 = null;$2: for (var _iterator2 = items(cards$0)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    m$3 = _step2.value;
    var k$2 = undefined;var v$1 = undefined;var t0$4 = undefined;var t1$2 = undefined;t0$4 = m$3;if (Array.isArray(t0$4) && (t1$2 = t0$4.length, t1$2 === 2 && (k$2 = t0$4[0], v$1 = t0$4[1], !k$2.startsWith("__")))) {
      temp$6 = __at___$4.orderCards(v$1);acc$2.push(temp$6);
    } else {
      false;
    }
  }return acc$2;
};Cards$0.prototype.get = function get(path$0) {
  var f$1 = undefined;var target$0 = undefined;var __at___$5 = undefined;var self$1 = undefined;__at___$5 = this;self$1 = this;f$1 = function f(c$0, name$0) {
    var $targ$11 = undefined;if (name$0 === null) {
      $targ$11 = (c$0.__index + 1) % c$0.__order.length;c$0.__index = $targ$11;return { __main: send(send(c$0, "__order", true), c$0.__index) };
    } else {
      return send(c$0, name$0);
    }
  };target$0 = path$0.reduce(f$1, __at___$5.cards);return target$0.__main;
};Cards$0.prototype.showCard = function () {
  var target$1 = undefined;var contents$1 = undefined;var path$1 = undefined;var t0$5 = undefined;var m$4$0 = undefined;var __at___$6 = undefined;var self$2 = undefined;__at___$6 = this;self$2 = this;m$4$0 = arguments;t0$5 = m$4$0.length;if (t0$5 >= 0) {
    path$1 = Array.prototype.slice.call(m$4$0, 0);target$1 = __at___$6.get(path$1);contents$1 = document.getElementById(target$1.divId).innerHTML;return Into$0(__at___$6.target, ENode(["div", "raw"], {}, contents$1));
  } else {
    return ___match_error(m$4$0, "{*path}");
  }
};__amp____colon__(Cards$0, __amp____colon__(($targ$12 = "Cards", accum$4 = {}, accum$4["::name"] = $targ$12, accum$4), ($targ$13 = true, accum$5 = {}, accum$5["::egclass"] = $targ$13, accum$5)));fill__minus__bindings$0 = function fillBindings(settings$0) {
  var m$5 = undefined;var acc$3 = undefined;var temp$7 = undefined;var $targ$14 = undefined;settings$0.bindings = settings$0.bindings || {};if (settings$0.resetBindings) {
    $targ$14 = object((acc$3 = [], temp$7 = null, m$5 = null, (function () {
      $4: for (var _iterator = items(settings$0.bindings)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$5 = _step.value;
        var k$3 = undefined;var v$2 = undefined;var t0$6 = undefined;var t1$3 = undefined;t0$6 = m$5;if (Array.isArray(t0$6) && (t1$3 = t0$6.length, t1$3 === 2)) {
          k$3 = t0$6[0];v$2 = t0$6[1];temp$7 = [k$3, send(global, k$3)];acc$3.push(temp$7);
        } else {
          ___match_error(m$5);
        }
      }
    })(), acc$3));
  } else {
    $targ$14 = null;
  }settings$0.bindings0 = $targ$14;settings$0.targets = settings$0.targets || {};return settings$0;
};stdrepl$0 = function stdrepl(elements$0, temp$8$0) {
  var t0$7 = undefined;var repl$0 = undefined;var settings$1 = undefined;t0$7 = getProjector(fill__minus__bindings$0)(temp$8$0);if (t0$7[0]) {
    settings$1 = t0$7[1];
  } else {
    ___match_error(temp$8$0);
  }repl$0 = Repl$0({ elements: elements$0, eval: make__minus__eval$0(settings$1.evaluate, settings$1.targets, settings$1.bindings0, settings$1.bindings, settings$1.dynamicBindings), setenv: settings$1.setenv, continuate: settings$1.continuate, codemirror: codemirror$0, lang: settings$1.lang, theme: settings$1.theme });if (!settings$1.bindings0) {
    repl$0.setenv(settings$1.bindings);
  }return repl$0;
};dom__minus__node__minus__clear$0 = function domNodeClear(x$0) {
  $5: while (x$0.children.length > 0) {
    x$0.removeChild(x$0.children[0]);
  }
};stdeditor$0 = function stdeditor(elements$1, settings$2, repl$1) {
  var accum$6 = undefined;var accum$7 = undefined;var accum$8 = undefined;var accum$9 = undefined;var ev$1 = undefined;var ed$0 = undefined;ev$1 = make__minus__eval$0(settings$2.evaluate, settings$2.targets, settings$2.bindings0, settings$2.bindings, settings$2.dynamicBindings);ed$0 = Editor$0(__amp____colon__({ elements: elements$1 }, __amp____colon__((accum$6 = {}, accum$6.eval = function (text$1) {
    return spawn.call(this, regeneratorRuntime.mark(function callee$2$0() {
      var _this = this;

      return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            if (!repl$1) {
              context$3$0.next = 7;
              break;
            }

            context$3$0.next = 3;
            return repl$1.process("compile()", true);

          case 3:
            repl$1.sink();return context$3$0.abrupt("return", ["success", undefined]);

          case 7:
            context$3$0.next = 9;
            return ev$1.call(_this, text$1);

          case 9:
            return context$3$0.abrupt("return", context$3$0.sent);

          case 10:
          case "end":
            return context$3$0.stop();
        }
      }, callee$2$0, this);
    }));
  }, accum$6), __amp____colon__({ setenv: settings$2.setenv }, __amp____colon__((accum$7 = {}, accum$7.prepare = function prepare() {
    if (elements$1.aside) {
      return dom__minus__node__minus__clear$0(elements$1.aside);
    }
  }, accum$7), __amp____colon__((accum$8 = {}, accum$8.success = function success(v$3) {
    if (elements$1.aside && v$3 !== undefined) {
      return Outputter$0(elements$1.aside, true).log(v$3);
    }
  }, accum$8), __amp____colon__((accum$9 = {}, accum$9.failure = function failure(err$0) {
    if (elements$1.aside) {
      return Outputter$0(elements$1.aside, true).log(err$0);
    }
  }, accum$9), { codemirror: codemirror$0, lang: settings$2.lang, theme: settings$2.theme })))))));if (!settings$2.bindings0) {
    repl$1.setenv(settings$2.bindings);
  }return ed$0;
};div__minus__names$0 = "\n   repl\n   aside\n   scrollback\n   inputline\n   replarea\n   editor\n   editorarea\n   ".split("\n").map(function (x$1) {
  return x$1.trim();
}).filter(function (x$2) {
  return x$2;
});stdsetup$0 = function stdsetup(config$0) {
  return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
    var m$7, acc$4, temp$9, accum$10, accum$11, accum$12, accum$13, accum$14, $targ$16, name$2, f$2, m$6$0, di$0, elements$2, targets$1, c$1, bindings$1, dynamic__minus__bindings$1, settings$3, repl$2, editor$0, focus$0, $targ$15, rval$1;
    return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          m$7 = undefined;
          acc$4 = undefined;
          temp$9 = undefined;
          accum$10 = undefined;
          accum$11 = undefined;
          accum$12 = undefined;
          accum$13 = undefined;
          accum$14 = undefined;
          $targ$16 = undefined;
          name$2 = undefined;
          f$2 = undefined;
          m$6$0 = undefined;
          di$0 = undefined;
          elements$2 = undefined;
          targets$1 = undefined;
          c$1 = undefined;
          bindings$1 = undefined;
          dynamic__minus__bindings$1 = undefined;
          settings$3 = undefined;
          repl$2 = undefined;
          editor$0 = undefined;
          focus$0 = undefined;
          $targ$15 = undefined;
          rval$1 = undefined;
          di$0 = config$0.divId;elements$2 = object((acc$4 = [], temp$9 = null, m$7 = null, (function () {
            $6: for (var _iterator = div__minus__names$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$7 = _step.value;
              var name$1 = undefined;name$1 = m$7;temp$9 = [name$1, document.querySelector("#" + di$0 + " .repple-" + name$1)];acc$4.push(temp$9);
            }
          })(), acc$4));targets$1 = { aside: elements$2.aside };c$1 = Cards$0({ cards: config$0.cards, target: "aside" });bindings$1 = __amp__(__amp____colon__({ showCard: c$1.showCard.bind(c$1), dom: dom$0, Into: Into$0, Outputter: Outputter$0, ReloadAfterPromise: ReloadAfterPromise$0 }, (accum$10 = {}, accum$10.compile = function compile() {
            if (editor$0 && repl$2) {
              return repl$2.process(editor$0.cm.getValue(), false);
            } else {
              throw ErrorFactory(["compile"]).create("\"compile\" function only valid if there is an editor and a repl");
            }
          }, accum$10)), config$0.bindings || {});dynamic__minus__bindings$1 = __amp____colon__((accum$11 = {}, accum$11.$out = function $out() {
            return send(send(send(repl$2, "repple", true), "io", true), repl$2.repple.current);
          }, accum$11), __amp____colon__((accum$12 = {}, accum$12.$repl = function $repl() {
            return repl$2;
          }, accum$12), __amp____colon__((accum$13 = {}, accum$13.$editor = function $editor() {
            return editor$0;
          }, accum$13), (accum$14 = {}, accum$14.$repple = function $repple() {
            return repl$2;
          }, accum$14))));settings$3 = __amp__(config$0, { targets: targets$1, bindings: bindings$1, dynamicBindings: dynamic__minus__bindings$1 });if (elements$2.repl) {
            repl$2 = stdrepl$0(elements$2, settings$3);
          } else {
            repl$2 = null;
          }if (elements$2.editor) {
            editor$0 = stdeditor$0(elements$2, settings$3, repl$2);
          } else {
            editor$0 = null;
          }if (repl$2) {
            repl$2.process(config$0.code || "", false);
          }if (editor$0) {
            editor$0.cm.setValue(config$0.code);
          }focus$0 = function focus() {
            if (repl$2) {
              return repl$2.cm.focus();
            } else {
              if (editor$0) {
                return editor$0.cm.focus();
              }
            }
          };if (config$0.bodyFocus) {
            $targ$16 = function () {
              if (equal(document.getSelection().toString(), "")) {
                return focus$0();
              }
            };document.body.onclick = $targ$16;void 0;
          }if (config$0.focus) {
            focus$0();
          }$targ$15 = repl$2;global[config$0.variable] = $targ$15;if (repl$2) {
            repl$2.setenv();
          }colorize$0(config$0.lang, config$0.theme);rval$1 = { repl: repl$2, editor: editor$0 };m$6$0 = config$0.after;
          if (!(typeof m$6$0 === "function")) {
            context$2$0.next = 49;
            break;
          }

          f$2 = m$6$0;return context$2$0.abrupt("return", f$2(rval$1));

        case 49:
          if (!(typeof m$6$0 === "string")) {
            context$2$0.next = 54;
            break;
          }

          name$2 = m$6$0;return context$2$0.abrupt("return", send(global, name$2, true)(rval$1));

        case 54:
          return context$2$0.abrupt("return", rval$1);

        case 55:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  }));
};colorize$0 = function colorize(lang$0, theme$0) {
  var m$8 = undefined;var acc$5 = undefined;var temp$10 = undefined;acc$5 = [];temp$10 = null;m$8 = null;$7: for (var _iterator = document.querySelectorAll(".repple-paste")[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    (function () {
      m$8 = _step.value;
      var hl$0 = undefined;var $targ$17 = undefined;var elem$0 = undefined;elem$0 = m$8;hl$0 = [];codemirror$0.runMode(elem$0.textContent, lang$0, function (text$2, style$0) {
        return hl$0.push(style$0 ? ENode(["span", ".cm-" + style$0], {}, text$2) : ENode(["span"], {}, text$2));
      });$targ$17 = html$0(ENode(["span"], { "class": "cm-s-" + theme$0 }, hl$0));elem$0.innerHTML = $targ$17;temp$10 = void 0;acc$5.push(temp$10);
    })();
  }return acc$5;
};$targ$18 = fade__minus__in$0;exports.fadeIn = $targ$18;$targ$19 = Cards$0;exports.Cards = $targ$19;$targ$20 = Into$0;exports.Into = $targ$20;$targ$21 = make__minus__eval$0;exports.makeEval = $targ$21;$targ$22 = stdrepl$0;exports.stdrepl = $targ$22;$targ$23 = stdeditor$0;exports.stdeditor = $targ$23;$targ$24 = stdsetup$0;exports.stdsetup = $targ$24;$targ$25 = colorize$0;exports.colorize = $targ$25;void 0;
//# sourceMappingURL=common.js.map

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"codemirror":4,"codemirror/addon/runmode/runmode":3,"earlgrey-runtime/5":5,"earlgrey-runtime/std/dom":98,"earlgrey-runtime/std/html":99,"repple":587}],2:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$30 = undefined;var CodeMirror$0 = undefined;CodeMirror$0 = require("codemirror");CodeMirror$0.defineMode("earlgrey", function (config$0, parserConfig$0) {
  var accum$0 = undefined;var accum$1 = undefined;var accum$2 = undefined;var accum$3 = undefined;var re$0 = undefined;re$0 = { id: RegExp("(?:^[a-zA-Z$_](?:(?:[a-zA-Z$_0-9]|(?:-[a-zA-Z$_0-9]))*))", ""), numr: RegExp("(?:^((?:\\d+))[rR]((?:[A-Za-z0-9_]+))(?:(?:\\.((?:[A-Za-z0-9_]+)))?))", ""), num: RegExp("(?:^((?:[0-9_]+))(?:(?:\\.((?:\\d+)))?)(?:(?:[eE]((?:[+-]?)(?:[0-9_]+)))?))", ""), lowprio: RegExp("(?:(?:(?:(?:(?:(?:(?:(?:=|=>)|->)|%)|:)|with)|where)|each)(?:(?: +)|$))", ""), lowprio1: RegExp("(?:(?:(?:(?:(?:=|=>)|->)|%)|:)(?:(?: +)|$))", ""), lowprio2: RegExp("(?:(?:(?:with|where)|each)(?:(?: +)|$))", ""), op: RegExp("(?:^(?:[+\\-*/~\\^<>=%&|?!@#.:]+))", ""), op2_open: RegExp("(?:^[\\(\\[\\{])", ""), comma: RegExp("(?:^,)", ""), op2_close: RegExp("(?:^[\\}\\]\\)])", ""), op3: RegExp("(?:^(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:with|where)|when)|and)|not)|or)|in)|mod)|each)|as)|of)|is)(?:(?:[+\\-*/~\\^<>=%&|?!@#.:]+)|\\b))", ""), op4: RegExp("(?:^`((?:[A-Za-z0-9_$]+))`)", "") };return __amp____colon__((accum$0 = {}, accum$0.startState = function startState() {
    return { mode: "code", previous: null, sol: true, nest: [["", 0, 0, false]] };
  }, accum$0), __amp____colon__((accum$1 = {}, accum$1.token = function token(stream$0, state$0) {
    var $targ$1 = undefined;var o$0 = undefined;var a$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;var $targ$0 = undefined;var index$0 = undefined;var $targ$2 = undefined;var m$3$0 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var $targ$15 = undefined;var $targ$16 = undefined;var $targ$17 = undefined;var $targ$18 = undefined;var $targ$19 = undefined;var $$7604$0 = undefined;var $targ$20 = undefined;var ph$1$0 = undefined;var $targ$21 = undefined;var n$0 = undefined;var n$1 = undefined;var opchar$0 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var ph$0$0 = undefined;var d$0 = undefined;var $$7611$0 = undefined;var m$2$0 = undefined;var sf$0 = undefined;var rx$0 = undefined;var $targ$25 = undefined;var $targ$26 = undefined;var m$4$0 = undefined;var m$1$0 = undefined;var spaces$0 = undefined;var result$0 = undefined;if (stream$0.sol()) {
      if (stream$0.match(RegExp("===$", ""))) {
        return "sep";
      } else {
        $targ$0 = true;state$0.sol = $targ$0;index$0 = state$0.nest.length - 1;m$0$0 = send(send(state$0, "nest", true), index$0);if (Array.isArray(m$0$0) && (t0$0 = m$0$0.length, t0$0 === 4)) {
          o$0 = m$0$0[0];a$0 = m$0$0[1];m$0$0[2];m$0$0[3];$targ$1 = [o$0, a$0, stream$0.indentation(), false];state$0.nest[index$0] = $targ$1;void 0;
        } else {
          undefined;
        }
      }
    } else {
      $targ$2 = false;state$0.sol = $targ$2;void 0;
    }spaces$0 = stream$0.eatSpace();m$1$0 = state$0.mode;if (m$1$0 === "code") {
      m$2$0 = stream$0.peek();d$0 = m$2$0;if (__in__(m$2$0, ["\"", "'", "`"])) {
        stream$0.next();$targ$3 = "string";state$0.mode = $targ$3;m$3$0 = d$0;if (m$3$0 === "\"") {
          $targ$4 = "string";
        } else {
          if (m$3$0 === "'") {
            $targ$4 = "interpolated";
          } else {
            if (m$3$0 === "`") {
              $targ$4 = "quote";
            } else {
              $targ$4 = ___match_error(m$3$0, "\"`\"");
            }
          }
        }state$0.strtype = $targ$4;$targ$5 = d$0;state$0.finisher = $targ$5;result$0 = state$0.strtype;
      } else {
        if (stream$0.match(RegExp(";;", ""))) {
          stream$0.skipToEnd();$targ$6 = "comment";state$0.previous = $targ$6;result$0 = "comment";
        } else {
          if (stream$0.match(RegExp("\\.[A-Za-z0-9_$\\\\-]+", ""))) {
            $targ$7 = "id";state$0.previous = $targ$7;result$0 = "string";
          } else {
            if (stream$0.match(RegExp("@[A-Za-z0-9$\\\\-]+", ""))) {
              $targ$8 = "id";state$0.previous = $targ$8;result$0 = "attribute";
            } else {
              if (stream$0.match(RegExp("#[A-Za-z0-9$\\\\-]+", ""))) {
                $targ$9 = "id";state$0.previous = $targ$9;result$0 = "tag";
              } else {
                if (stream$0.match(RegExp("pass|else|return|break|continue|match", ""))) {
                  $targ$10 = "id";state$0.previous = $targ$10;result$0 = "keyword";
                } else {
                  if (stream$0.match(RegExp("true|false|null|undefined|this", ""))) {
                    $targ$11 = "id";state$0.previous = $targ$11;result$0 = "special";
                  } else {
                    if (stream$0.match(re$0.lowprio1)) {
                      $targ$12 = "lowprio";state$0.previous = $targ$12;result$0 = "operator";
                    } else {
                      if (stream$0.match(re$0.lowprio2)) {
                        $targ$13 = "lowprio";state$0.previous = $targ$13;result$0 = "wordop";
                      } else {
                        if (stream$0.match(re$0.op) || stream$0.match(re$0.op4)) {
                          $targ$14 = "op";state$0.previous = $targ$14;result$0 = "operator";
                        } else {
                          if (stream$0.match(re$0.op3)) {
                            $targ$15 = "op";state$0.previous = $targ$15;result$0 = "wordop";
                          } else {
                            ph$0$0 = m$2$0;if (stream$0.match(re$0.id)) {
                              ph$1$0 = ph$0$0;if (getChecker(RegExp("lowprio|comma", ""))(state$0.previous) || state$0.sol) {
                                if (stream$0.match(RegExp(" +(with|where|when|and|not|or|in|mod|each|as|of|is)( |$)", ""), false)) {
                                  $targ$16 = "id";state$0.previous = $targ$16;result$0 = "variable";
                                } else {
                                  if (stream$0.match(RegExp(" *:| +[A-Za-z0-9$\\[\\{\\(\\\"]", ""), false)) {
                                    $targ$17 = "id";state$0.previous = $targ$17;result$0 = "keyword";
                                  } else {
                                    if (stream$0.match(RegExp(" +[+\\-*/~^<>=%&|?!@#.:']+[A-Za-z0-9$\\[\\{\\(]", ""), false)) {
                                      $targ$18 = "id";state$0.previous = $targ$18;result$0 = "keyword";
                                    } else {
                                      $targ$19 = "id";state$0.previous = $targ$19;result$0 = "variable";
                                    }
                                  }
                                }
                              } else {
                                $targ$20 = "id";state$0.previous = $targ$20;result$0 = "variable";
                              }
                            } else {
                              if (stream$0.match(re$0.numr) || stream$0.match(re$0.num)) {
                                $targ$21 = "id";state$0.previous = $targ$21;result$0 = "number";
                              } else {
                                if (stream$0.match(re$0.op2_open, false)) {
                                  opchar$0 = stream$0.match(re$0.op2_open)[0];$targ$22 = "lowprio";state$0.previous = $targ$22;state$0.nest.push(stream$0.eol() ? (n$0 = send(send(state$0, "nest", true), state$0.nest.length - 1)[2], [opchar$0, n$0, n$0 + config$0.indentUnit, true]) : (n$1 = stream$0.column(), [opchar$0, n$1, n$1 + 1, true]));result$0 = "open";
                                } else {
                                  if (stream$0.match(re$0.comma)) {
                                    $targ$23 = "comma";state$0.previous = $targ$23;result$0 = "punctuation";
                                  } else {
                                    if (stream$0.match(re$0.op2_close)) {
                                      $targ$24 = "punct";state$0.previous = $targ$24;if (state$0.nest.length > 1) {
                                        state$0.nest.pop();
                                      }result$0 = "close";
                                    } else {
                                      stream$0.next();result$0 = null;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if (m$1$0 === "string") {
        sf$0 = state$0.finisher;rx$0 = new RegExp("(\\\\" + sf$0 + "|[^" + sf$0 + "])+");stream$0.match(rx$0);m$4$0 = stream$0.eat(state$0.finisher);if (m$4$0 === void 0) {
          result$0 = state$0.strtype;
        } else {
          $targ$25 = "code";state$0.mode = $targ$25;$targ$26 = "id";state$0.previous = $targ$26;result$0 = state$0.strtype;
        }
      } else {
        result$0 = ___match_error(m$1$0, ".string");
      }
    }return result$0;
  }, accum$1), __amp____colon__((accum$2 = {}, accum$2.indent = function indent(state$1, line$0) {
    var index$1 = undefined;var t0$1 = undefined;var t1$0 = undefined;var m$5$0 = undefined;var $targ$27 = undefined;var outr$0 = undefined;var inner$0 = undefined;var first$0 = undefined;var add$0 = undefined;index$1 = state$1.nest.length - 1;$targ$27 = send(send(state$1, "nest", true), index$1);t0$1 = $targ$27;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 4)) {
      t0$1[0];outr$0 = t0$1[1];inner$0 = t0$1[2];first$0 = t0$1[3];
    } else {
      ___match_error($targ$27, "{_, outr, inner, first}");
    }[outr$0, inner$0, first$0];if (!first$0 && (equal(state$1.previous, "lowprio") || equal(state$1.previous, "op"))) {
      add$0 = config$0.indentUnit;
    } else {
      add$0 = 0;
    }m$5$0 = line$0;if (getChecker(RegExp("(?:^[\\]\\}])", ""))(m$5$0)) {
      return outr$0 + add$0;
    } else {
      return inner$0 + add$0;
    }
  }, accum$2), __amp____colon__((accum$3 = {}, accum$3.blankLine = function blankLine(state$2) {
    var $targ$29 = undefined;var o$1 = undefined;var a$1 = undefined;var t0$2 = undefined;var m$6$0 = undefined;var $targ$28 = undefined;var index$2 = undefined;$targ$28 = true;state$2.sol = $targ$28;index$2 = state$2.nest.length - 1;m$6$0 = send(send(state$2, "nest", true), index$2);if (Array.isArray(m$6$0) && (t0$2 = m$6$0.length, t0$2 === 4)) {
      o$1 = m$6$0[0];a$1 = m$6$0[1];m$6$0[2];m$6$0[3];$targ$29 = [o$1, a$1, 0, false];state$2.nest[index$2] = $targ$29;void 0;
    } else {
      undefined;
    }return null;
  }, accum$3), { lineComment: ";;", electricInput: RegExp("(?:^(?: *)[\\]\\}\\)]$)", "") }))));
});$targ$30 = CodeMirror$0;exports.CodeMirror = $targ$30;void 0;
//# sourceMappingURL=earlmode.js.map

},{"codemirror":4,"earlgrey-runtime/5":5}],3:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.runMode = function(string, modespec, callback, options) {
  var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);

  if (callback.appendChild) {
    var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;
    var node = callback, col = 0;
    node.innerHTML = "";
    callback = function(text, style) {
      if (text == "\n") {
        // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.
        // Emitting a carriage return makes everything ok.
        node.appendChild(document.createTextNode(ie_lt9 ? '\r' : text));
        col = 0;
        return;
      }
      var content = "";
      // replace tabs
      for (var pos = 0;;) {
        var idx = text.indexOf("\t", pos);
        if (idx == -1) {
          content += text.slice(pos);
          col += text.length - pos;
          break;
        } else {
          col += idx - pos;
          content += text.slice(pos, idx);
          var size = tabSize - col % tabSize;
          col += size;
          for (var i = 0; i < size; ++i) content += " ";
          pos = idx + 1;
        }
      }

      if (style) {
        var sp = node.appendChild(document.createElement("span"));
        sp.className = "cm-" + style.replace(/ +/g, " cm-");
        sp.appendChild(document.createTextNode(content));
      } else {
        node.appendChild(document.createTextNode(content));
      }
    };
  }

  var lines = CodeMirror.splitLines(string), state = (options && options.state) || CodeMirror.startState(mode);
  for (var i = 0, e = lines.length; i < e; ++i) {
    if (i) callback("\n");
    var stream = new CodeMirror.StringStream(lines[i]);
    if (!stream.string && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      callback(stream.current(), style, i, stream.start, state);
      stream.start = stream.pos;
    }
  }
};

});

},{"../../lib/codemirror":4}],4:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    (this || window).CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) this.zeroWidthHack();
        this.checkedZeroWidth = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
    },
    zeroWidthHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed;
      this.disableVert = new Delayed;
    },
    enableZeroWidthBar: function(bar, delay) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // left corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
        if (elt != bar) bar.style.pointerEvents = "none";
        else delay.set(1000, maybeDisable);
      }
      delay.set(1000, maybeDisable);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    var total = measure.docHeight + cm.display.barHeight;
    cm.display.heightForcer.style.top = total + "px";
    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                      "px; width: " + dims.gutterTotalWidth + "px");
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = doc.splitLines(inserted), multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.length; i++)
            multiPaste.push(doc.splitLines(lastCopied[i]));
        }
      } else if (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, function(l) { return [l]; });
      }
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !paste) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) return;
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          indented = indentLine(cm, range.head.line, "smart");
      }
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        if (input.composing) input.composing.range.clear()
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput && !this.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        return false;

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) prevInput = "\u200b";
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, self.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;

        if (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText;
      input.wrapper.style.position = "absolute";
      te.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.position = "relative";
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function(val) {
      if (!val) this.reset();
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div);

      on(div, "paste", function(e) {
        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);
      })

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (cm.isReadOnly() || !input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && this.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) sel.addRange(rng);
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.lineDiv.lastChild;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (this.cm.isReadOnly())
        operation(this.cm, regChange)(this.cm)
      else if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.contentEditable = "false"
    },

    onKeyPress: function(e) {
      e.preventDefault();
      if (!this.cm.isReadOnly())
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    readOnlyChanged: function(val) {
      this.div.contentEditable = String(val != "nocursor")
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += lineSep;
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel, options);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) break;
            else {--i; continue;}
          }
        }
        if (!m.atomic) continue;

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff;
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) near = movePos(doc, near, -dir, line);
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            return skipAtomicInner(doc, near, pos, dir, mayClear);
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) far = movePos(doc, far, dir, line);
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
      else return null;
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
      else return null;
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range.head, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i].call(null);
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
    if (op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus()))
      ensureFocus(op.cm);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function(e){onDragStart(cm, e);},
      drop: operation(cm, onDrop),
      leave: function() {clearDragCursor(cm);}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != CodeMirror.Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      // #3261: make sure, that we're not starting a second selection
      if (cm.state.selectingText)
        cm.state.selectingText(e);
      else if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else cm.curOp.focus = activeElt();

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
        (cmp(contained.to(), start) > 0 || start.xRel < 0))
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display, startTime = +new Date;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date - 200 < startTime)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          return;

        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) return;
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return false
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return false
      } else ch = next;
      return true;
    }

    if (unit == "char") {
      moveOnce()
    } else if (unit == "column") {
      moveOnce(true)
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
    if (!cmp(pos, result)) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("lineSeparator", null, function(cm, val) {
    cm.doc.lineSep = val;
    if (!val) return;
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function(line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
    }
    cm.display.input.readOnlyChanged(val)
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = (css ? css + ";" : "") + m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.extend = false;

    if (typeof text == "string") text = this.splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || this.lineSeparator());
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;},

    splitLines: function(str) {
      if (this.lineSep) return str.split(this.lineSep);
      return splitLinesAuto(str);
    },
    lineSeparator: function() { return this.lineSep || "\n"; }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var noHandlers = []
  function getHandlers(emitter, type, copy) {
    var arr = emitter._handlers && emitter._handlers[type]
    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
    else return arr || noHandlers
  }

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var handlers = getHandlers(emitter, type, false)
      for (var i = 0; i < handlers.length; ++i)
        if (handlers[i] == f) { handlers.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type, true)
    if (!handlers.length) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type, false)
    if (!arr.length) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() {
    var activeElement = document.activeElement;
    while (activeElement && activeElement.root && activeElement.root.activeElement)
      activeElement = activeElement.root.activeElement;
    return activeElement;
  }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = CodeMirror.keyNames = {
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2)
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.11.0";

  return CodeMirror;
});

},{}],5:[function(require,module,exports){
(function (global){

if (!global._egruntime_installed) {
    global._egruntime_installed = 5;
    require("core-js/shim");
    require("regenerator/runtime");
    require("./lib");
}
else if (global._egruntime_installed == 6) {
    global._egruntime_installed = 5;
    require("core-js/shim");
    require("regenerator/runtime");
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib":6,"core-js/shim":95,"regenerator/runtime":97}],6:[function(require,module,exports){
(function (global){

"use strict";

var kaiser = require("kaiser/reg");

if (typeof(global) === "undefined")
    global = window;

// SYMBOLS

Symbol.check = "::check"
Symbol.project = "::project"
Symbol.projectNoExc = ":::project"
Symbol.clone = "::clone"
Symbol.send = "::send"
Symbol.contains = "::contains"
Symbol.repr = "::repr"
Symbol.equals = "::equals"
Symbol.requals = "::requals"
Symbol.errorTags = "::tags"


// EXTENSIONS TO STANDARD OBJECTS

String["::check"] = function (value) {
    return typeof(value) === "string";
};

String[":::project"] = function (value) {
    return [true, String(value)]
};

Number["::check"] = function (value) {
    return typeof(value) === "number";
};

Number[":::project"] = function (value) {
    return [true, parseFloat(value)]
};

Boolean["::check"] = function (value) {
    return typeof(value) === "boolean";
};

Boolean[":::project"] = function (value) {
    return [true, Boolean(value)]
};

Array["::check"] = function (value) {
    return this.isArray(value);
};

Array[":::project"] = function (value) {
    if (value instanceof Array)
        return [true, value]
    else
        return [true, [value]]
};


var _number_methods = {
    "::lightweight": function() {
        return true;
    },
    "::repr": function(_) {
        return simpleENode(".num", this);
    }
};

var _string_methods = {
    "::contains": function(x) {
        return this.includes(x);
    },
    "::lightweight": function() {
        return true;
    },
    "::repr": function(_) {
        return simpleENode(".str", this);
    }
};

var _boolean_methods = {
    "::lightweight": function() {
        return true;
    },
    "::repr": function(_) {
        return ENode([".bool", "." + String(this)], {}, [this]);
    }
};

var _object_methods = {
    "hasProperty": function (prop) {
        return prop in this;
    }
};

var _array_methods = {
    "::check": function (value) {
        if (value instanceof Array) {
            for (var i = 0; i < this.length; i++) {
                if (this[i] !== value[i])
                    return false;
            }
            return true;
        }
        else {
            return false;
        }
    },
    "::clone": function (value) {
        return mergeInplace(this.slice(0), this);
    },
    ":::project": function (value) {
        if (value instanceof Array) {
            for (var i = 0; i < this.length; i++) {
                if (this[i] !== value[i])
                    return [true, this.concat([value])];
            }
            return [true, value];
        }
        else {
            return [true, this.concat([value])];
        }
    },
    "::serialize_ast": function () {
        return ["array"].concat(this.map(_serialize_ast));
    },
    "::contains": function (b) {
        return this.indexOf(b) !== -1;
    },
    "::repr": function (repr) {
        return simpleENode(".array", this.map(function (x) {
            return repr(x);
        }));
    },
    "ejoin": function (sep) {
        return ENode([], {}, this.map(function (x) {
            return repr(x);
        })).join(sep);
    }
};

var _re_methods = {
    "::check": function (value) {
        if (typeof(value) === "string")
            return value.match(this) ? true : false;
        else
            return false;
    },
    ":::project": function (value) {
        if (typeof(value) === "string") {
            var m = value.match(this);
            if (m === null)
                return [false, null];
            else
                return [true, m];
        }
        else
            return [false, null];
    },
    "::lightweight": function() {
        return true;
    },
    "::repr": function(repr) {
        return simpleENode(".regexp", String(this).slice(1, -1));
    },
    "::contains": function(x) {
        return typeof(x) === "string" && this.test(x);
    }
};

var _function_methods = {
    "::lightweight": function() {
        return !this["::egclass"];
    },
    "::repr": function(repr) {
        if (this["::egclass"]) {
            return simpleENode(".class", [
                simpleENode(".name", this["::name"]),
                mktable(this.prototype, repr)
            ]);
        }
        else {
            return simpleENode(".function", this.name || "<anonymous>");
        }
    },
    "::send": function(args) {
        if (Array.isArray(args)) {
            var ins = args["::objinsert"];
            if (ins !== undefined) {
                var newargs = args.slice(0);
                newargs.splice(ins, ins, args);
                return this.apply(this, newargs);
            }
            else {
                return this.apply(this, args);
            }
        }
        else {
            return this(args);
        }
    }
};

[[Number, _number_methods],
 [String, _string_methods],
 [Boolean, _boolean_methods],
 [Array, _array_methods],
 [RegExp, _re_methods],
 [Function, _function_methods],
 [Object, _object_methods]].map(function (nm) {
     items(nm[1]).map(function (kv) {
         if (!nm[0].prototype[kv[0]])
             Object.defineProperty(nm[0].prototype, kv[0], {
                 enumerate: false,
                 value: kv[1],
                 writable: true
             });
     });
 });


// EG GLOBAL FUNCTIONS

// INTERNAL

function ___build_array(arrays) {
    return arrays.reduce(function (x, y) { return x.concat(y); }, []);
}
global["___build_array"] = ___build_array;

function ___hasprop(obj, key) {
    var t = typeof(obj);
    if (obj === null || obj === undefined)
        return false;
    else if (t === "string")
        return key in String.prototype;
    else if (t === "number")
        return key in Number.prototype;
    else if (t === "boolean")
        return key in Boolean.prototype;
    else if (t === "boolean")
        return key in Boolean.prototype;
    else if (t === "symbol")
        return key in Symbol.prototype;
    else if (key in obj || t === "function" && Array.isArray(key))
        return true;
    return false;
}
global["___hasprop"] = ___hasprop;

function ___serialize_ast(x) {
    if (typeof(x) === "object" && x !== null)
        return x["::serialize_ast"]();
    else
        return ["value", x];
}
global["___serialize_ast"] = ___serialize_ast;

function ___match_error(value, pattern_text) {
    var err = ErrorFactory("match").createFrom(
        ___match_error,
        (pattern_text ? "'" + pattern_text + "' c" : "C")
        + "ould not find a match for value '" + String(value) + "'",
        {value: value});
    throw err;
}
global["___match_error"] = ___match_error;

function ___extend(child, parent) {
    items(parent).forEach(function (kv) {
        child[kv[0]] = kv[1];
    });
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
    child["::super"] = parent.prototype;
    return child;
}
global["___extend"] = ___extend;



// USER FUNCTIONS


function send(obj, msg, called) {
    var t = typeof(msg);
    var result = null;

    if (t === "string" || t === "number" || t === "symbol") {
        result = obj[msg];
    }
    else if (msg instanceof range)
        result = obj.slice(msg.start, msg.end === undefined ? msg.end : msg.end + 1);
    else if (t === "object" && (obj instanceof Object && obj["::send"]))
        result = obj["::send"](msg);
    else if (msg && Object.getPrototypeOf(msg) === Symbol.prototype)
        result = obj[msg];
    else
        throw Error(obj + " cannot receive message '" + msg + "'");

    if (called && typeof(result) == "function")
        return result.bind(obj);
    else
        return result
}
global["send"] = send;

function getProperty(obj, prop, objname) {
    if (Object.hasProperty.call(obj, prop)) {
        return obj[prop];
    }
    else {
        throw ErrorFactory("no_property").createFrom(
            getProperty,
            "'" + (objname || obj.toString()) + "' does not have property '" + prop + "'"
        );
    }
}
global["getProperty"] = getProperty;


function object(pairs) {
    var rval = {};
    if (pairs.length === undefined)
        throw ErrorFactory("object").create(
            "Argument to 'object' must be an array of pairs.");
    for (var i = 0; i < pairs.length; i++) {
        var p = pairs[i];
        if (!p || !(p.length === 2))
            throw ErrorFactory("object").create(
                "Argument to 'object' must be an array of pairs.");
        rval[p[0]] = p[1];
    }
    return rval;
}
global["object"] = object;


global["keys"] = Object.keys;


function items(obj) {
    var rval = [];
    for (var k in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
            rval.push([k, obj[k]]);
        }
    }
    return rval;
}
global["items"] = items;


function enumerate(arr) {
    var results = [];
    for (var i = 0; i < arr.length; i++) {
        results.push([i, arr[i]]);
    }
    return results;
}
global["enumerate"] = enumerate;


function zip() {
    var r = [];
    for (var i = 0; i < arguments[0].length; i++) {
        var x = [];
        for (var j = 0; j < arguments.length; j++) {
            x.push(arguments[j][i]);
        }
        r.push(x);
    }
    return r;
}
global["zip"] = zip;


function product(a, b) {
    var results = [];
    for (var i = 0; i < a.length; i++) {
        for (var j = 0; j < b.length; j++) {
            results.push([a[i], b[j]]);
        }
    }
    return results;
}
global["product"] = product;


function neighbours(arr, n) {
    n = n || 2;
    var r = [];
    for (var i = 0; i <= arr.length - n; i++) {
        r.push(arr.slice(i, i + n));
    }
    return r;
}
global["neighbours"] = neighbours;


function predicate(f) {
    f["::check"] = f;
    return f;
}
global["predicate"] = predicate;


function equal(a, b) {
    if (a === b)
        return true;
    else if (typeof(a) === "number"
             || typeof(a) === "string"
             || typeof(a) === "boolean"
             || a === null || a === undefined)
        return false;
    else if (a instanceof Array) {
        if (!(b instanceof Array) || a.length !== b.length)
            return false;
        for (var i = 0; i < a.length; i++) {
            if (!equal(a[i], b[i]))
                return false;
        }
        return true;
    }
    else if (Object.getPrototypeOf(a) === null
             || (Object.getPrototypeOf(a) === Object.prototype
                 && b !== undefined && b !== null && typeof(b) === "object"
                 && (Object.getPrototypeOf(b) === null
                     || Object.getPrototypeOf(b) === Object.prototype))) {
        var ka = Object.keys(a);
        if (!equal(ka.sort(), Object.keys(b).sort()))
            return false;
        for (var key in a) {
            if (!equal(a[key], b[key]))
                return false;
        }
        return true;
    }
    else if (typeof(a) === "object" && a[Symbol.equals]) {
        return a[Symbol.equals](b);
    }
    else if (b && typeof(b) === "object" && b[Symbol.requals]) {
        return b[Symbol.requals](a);
    }
    else if (typeof(a) === "object" && a["::serialize"]) {
        if (b !== undefined && typeof(b) === "object" && b["::serialize"]) {
            return equal(a["::serialize"](), b["::serialize"]());
        }
    }
    else {
        return false;
    }
}
global["__equal____equal__"] = equal;
global["equal"] = equal;


function nequal(a, b) {
    return !equal(a, b);
}
global["__bang____equal__"] = nequal;
global["nequal"] = nequal;


function contains(a, b) {
    return a["::contains"](b);
}
global["__in__"] = function(a, b) { return contains(b, a); };
global["contains"] = contains;


function mktable(obj, repr) {
    var it = items(obj);
    var ch = [];
    for (var i = 0; i < it.length; i++) {
        var curr = it[i];
        ch.push(simpleENode(".assoc", [
            repr(curr[0]),
            repr(curr[1])
        ]));
    }
    return simpleENode(".object", ch);
}

function createRepr(state) {

    if (!state)
        state = {depth: 0, seen: new Map()};

    function repr(x) {

        function process(x) {
            if (x === null || x === undefined) {
                return simpleENode("." + String(x), String(x));
            }
            var prev = state.seen.get(x);
            if (prev && !(x["::lightweight"] && x["::lightweight"]())) {
                if (prev === true) {
                    var id = state.refid++;
                    state.seen.set(x, id);
                    return simpleENode(".reference", id);
                }
                else if (typeof(prev) === "number") {
                    return simpleENode(".reference", prev);
                }
                else if (prev.props._refid) {
                    return simpleENode(".reference", prev.props._refid);
                }
                else {
                    prev.props._refid = state.refid++;
                    return simpleENode(".reference", prev.props._refid);
                }
            }
            else {
                state.seen.set(x, true);
                var subrepr = createRepr(merge(state, {depth: state.depth + 1}));
                if (x["::repr"]) {
                    var rval = x["::repr"](subrepr);
                }
                else if (x.constructor && x.constructor["::egclass"]) {
                    var rval = simpleENode(".instance", [
                        simpleENode(".name", x.constructor["::name"]),
                        mktable(x, subrepr)
                    ]);
                }
                else if (Object.getPrototypeOf(x) === Object.prototype) {
                    var rval = mktable(x, subrepr);
                }
                else {
                    var rval = simpleENode(".unknown", String(x));
                }
                var ref = state.seen.get(x);
                if (typeof(ref) === "number")
                    rval.props._refid = ref;
                state.seen.set(x, rval);
                return rval;
            }
        }
        mergeInplace(process, state);
        process.repr = repr;

        if (state.wrap) {
            return state.wrap(x, process);
        }
        else {
            return process(x)
        }
    }
    mergeInplace(repr, state);
    repr.withState = function (newstate) {
        return createRepr(merge(state, newstate));
    }
    return repr;
}

function repr(x, wrap) {
    return repr.withState({wrap: wrap})(x);
}
repr.withState = repr.create = function (state) {
    state = merge({depth: 0, seen: new Map(), refid: 1}, state);
    return createRepr(state);
}

global["repr"] = repr;


function mergeInplace(dest, values) {
    for (var k in values) {
        if (values.hasOwnProperty(k))
            dest[k] = values[k];
    }
    return dest;
}
global["__amp____colon__"] = mergeInplace;


function merge(a, b) {
    var x = clone(a);
    return mergeInplace(x, b);
}
global["__amp__"] = merge;


function clone(a) {
    if (a === undefined || a === null
        || typeof(a) === "number"
        || typeof(a) === "string"
        || typeof(a) === "boolean")
        return a
    if (typeof(a) === "object" && a["::clone"])
        return a["::clone"]();
    if (Object.getPrototypeOf(a) === Object.prototype) {
        var dest = {};
        for (var key in a) {
            if (Object.prototype.hasOwnProperty.call(a, key))
                dest[key] = a[key];
        }
        return dest;
    }
    throw ErrorFactory("clone").create("Object cannot be cloned");
}
global["clone"] = clone;


function range(from, to) {
    if (!(this instanceof range))
        return new range(from, to)
    this.start = from
    this.end = to
}
range["::egclass"] = true;
range["::name"] = "range";
range.prototype[Symbol.iterator] = function () {
    var self = this;
    var current = self.start;
    return {
        next: function () {
            if (current >= self.end + 1)
                return {value: undefined, done: true}
            else {
                var rval = {value: current, done: false}
                current++;
                return rval;
            }
        }
    }
};
range.prototype.toArray = function () {
    var res = [];
    for (var i = this.start; i <= this.end; i++) {
        res.push(i);
    }
    return res;
};
range.prototype["::check"] = function (x) {
    return x >= this.start && x <= this.end;
};
range.prototype["::contains"] = function (x) {
    return x >= this.start && x <= this.end;
};

global["range"] = range;


function getChecker(type) {
    var f = type["::check"];
    if (f === undefined) {
        return function (value) {
            return value instanceof type;
        };
    }
    else {
        return function (value) {
            return f.call(type, value);
        };
    }
}
global["getChecker"] = getChecker;


function getProjector(type) {
    var f = type[":::project"];
    if (f === undefined) {
        f = type["::project"];
        if (f === undefined) {
            return function(value) {
                return [true, type(value)];
            };
        }
        else {
            return function(value) {
                try {
                    return [true, f.call(type, value)];
                }
                catch (_) {
                    return [false, null];
                }
            };
        }
    }
    else {
        return f.bind(type);
    }
}
global["getProjector"] = getProjector;



function consume(gen, n) {
    if (n === null || n === undefined)
        n = Infinity;
    if (!gen || !gen.next || n <= 0) {
        if (!Array.isArray(gen) && gen[Symbol.iterator]) {
            var res = [];
            var it = gen[Symbol.iterator]();
            var curr = it.next();
            var i = 0;
            for (var i = 0; !curr.done && i < n; i++) {
                res.push(curr.value);
                curr = it.next();
            }
            return res;
        }
        return gen;
    }
    var curr = gen.next();
    var results = [];
    var i = 0;
    while (!curr.done && i < n) {
        results.push(curr.value);
        curr = gen.next();
        i++;
    }
    return results;
}
global["consume"] = consume;
global["take"] = consume;


// ASYNC TOOLS

function promisify(fn, custom) {
    return function () {
        var args = [].slice.call(arguments);
        return new Promise(function (resolve, reject) {
            function callback(err, result) {
                if (custom) {
                    var self = {resolve: resolve, reject: reject};
                    return custom.apply(self, [].slice.call(arguments));
                }
                else {
                    if (err) { return reject(err); }
                    else { return resolve(result); }
                }
            }
            args.push(callback);
            return fn.apply(fn, args);
        });
    }
}
global["promisify"] = promisify;


// adapted from https://github.com/lukehoban/ecmascript-asyncawait
function spawn(genF, eager) {
    var self = this;
    var done = false;
    var value = null;
    var error = null;
    var prom = new Promise(function(resolve, reject) {
        var gen = genF.call(self);
        function step(nextF) {
            var next;
            try {
                next = nextF();
            } catch(e) {
                // finished with failure, reject the promise
                done = true;
                reject(error = e);
                return;
            }
            if(next.done) {
                // finished with success, resolve the promise
                done = true;
                resolve(value = next.value);
                return;
            } 
            // not finished, chain off the yielded promise and `step` again
            Promise.resolve(next.value).then(function(v) {
                step(function() { return gen.next(v); });      
            }, function(e) {
                step(function() { return gen.throw(e); });
            });
        }
        step(function() { return gen.next(undefined); });
    });
    if (eager && done) {
        // If the promise is already resolved by the time we get here,
        // we return the value directly
        if (error)
            throw error;
        return value;
    }
    else {
        return prom;
    }
}
global["spawn"] = spawn;



// ERROR FACTORIES

function ErrorFactory(tags) {
    if (!(this instanceof ErrorFactory))
        return new ErrorFactory(tags);
    this.tags = tags;
}
global["ErrorFactory"] = ErrorFactory;

ErrorFactory.prototype.createFrom = function(callee) {
    var e = this.create.apply(this, [].slice.call(arguments, 1));
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, callee);
    return e;
}

ErrorFactory.prototype.create = function(message) {
    var e = Error(message);
    e["::tags"] = this.tags;
    e.args = [].slice.call(arguments, 1);
    enumerate(e.args).forEach(function (iv) {
        e[iv[0]] = iv[1];
    });
    e.length = e.args.length;
    e.name = ["E"].concat(this.tags).join(".");
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, ErrorFactory.prototype.create);
    return e;
}

ErrorFactory.prototype["::check"] = function(e) {
    if (!e || !(e instanceof Error))
        return false
    var tags = e["::tags"] || [];
    for (var i = 0; i < this.tags.length; i++) {
        if (tags.indexOf(this.tags[i]) === -1)
            return false;
    }
    return true;
}


// NODE OBJECTS

function simpleENode(tag, children) {
    return ENode([tag], {}, children);
}

function ENode(tags, props, children) {
    if (!(this instanceof ENode))
        return new ENode(tags, props, children);
    if (!(tags instanceof Array)) { tags = [tags]; }
    if (!(children instanceof Array)) { children = [children]; }
    this.tags = tags;
    this.props = props;
    this.children = children;
}
ENode["::egclass"] = true;
ENode["::name"] = "ENode";
global["ENode"] = ENode;

ENode.fromObject = function (x) {
    if (x && typeof(x) === "object" && x.tags && x.props && x.children) {
        return ENode(x.tags, x.props, ENode.fromObject(x.children));
    }
    else if (Array.isArray(x)) {
        return x.map(ENode.fromObject);
    }
    else {
        return x;
    }
}

ENode.prototype["::check"] = function (n) {
    if (!(n instanceof ENode))
        return false;
    for (var i = 0; i < this.tags.length; i++) {
        if (n.tags.indexOf(this.tags[i]) === -1)
            return false;
    }    
    for (var i = 0; i < this.children.length; i++) {
        if (nequal(n.children[i], this.children[i]))
            return false;
    }
    for (var key in this.props) {
        if (nequal(n.props[key], this.props[key]))
            return false;
    }
    return true;
};

ENode.prototype[":::project"] = function (n) {
    if (this["::check"](n))
        return [true, [n.tags, n.props, n.children]]
    else
        return [false, null]
};

ENode.prototype["::repr"] = function (repr) {
    return this;
};

ENode.prototype.hasTag = function (tag) {
    return this.tags.indexOf(tag) !== -1;
};

ENode.prototype.concat = function (other) {
    return ENode([], {}, [this, other]);
};

ENode.prototype.join = function (sep) {
    if (sep === undefined)
        return this;
    var children = [];
    for (var i = 0; i < this.children.length; i++) {
        if (i > 0) children.push(sep);
        children.push(this.children[i]);
    }
    return ENode(this.tags, this.props, children);
};

ENode.prototype.toString = function () {
    // toString() ignores tags and props entirely
    return this.children.map(function (x) { return String(x); }).join("");
};


kaiser.register(ENode.prototype, {
    typeId: "earl-grey-runtime/ENode"
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"kaiser/reg":96}],7:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var $ = require('./$');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = $.toObject($this)
      , length = $.toLength(O.length)
      , index  = $.toIndex(fromIndex, length)
      , value;
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index;
    } return !IS_INCLUDES && -1;
  };
};
},{"./$":28}],8:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var $   = require('./$')
  , ctx = require('./$.ctx');
module.exports = function(TYPE){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that){
    var O      = Object($.assertDefined($this))
      , self   = $.ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = $.toLength(self.length)
      , index  = 0
      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./$":28,"./$.ctx":16}],9:[function(require,module,exports){
var $ = require('./$');
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
assert.def = $.assertDefined;
assert.fn = function(it){
  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
  return it;
};
assert.obj = function(it){
  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
assert.inst = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
module.exports = assert;
},{"./$":28}],10:[function(require,module,exports){
var $        = require('./$')
  , enumKeys = require('./$.enum-keys');
// 19.1.2.1 Object.assign(target, source, ...)
/* eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/* eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = enumKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
},{"./$":28,"./$.enum-keys":19}],11:[function(require,module,exports){
var $        = require('./$')
  , TAG      = require('./$.wks')('toStringTag')
  , toString = {}.toString;
function cof(it){
  return toString.call(it).slice(8, -1);
}
cof.classof = function(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
};
cof.set = function(it, tag, stat){
  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
};
module.exports = cof;
},{"./$":28,"./$.wks":46}],12:[function(require,module,exports){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , safe     = require('./$.uid').safe
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , step     = require('./$.iter').step
  , $has     = $.has
  , set      = $.set
  , isObject = $.isObject
  , hide     = $.hide
  , isExtensible = Object.isExtensible || isObject
  , ID       = safe('id')
  , O1       = safe('O1')
  , LAST     = safe('last')
  , FIRST    = safe('first')
  , ITER     = safe('iter')
  , SIZE     = $.DESC ? safe('size') : 'size'
  , id       = 0;

function fastKey(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
}

function getEntry(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that[O1][index];
  // frozen object case
  for(entry = that[FIRST]; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      assert.inst(that, C, NAME);
      set(that, O1, $.create(null));
      set(that, SIZE, 0);
      set(that, LAST, undefined);
      set(that, FIRST, undefined);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that[FIRST] = that[LAST] = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that[O1][entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that[FIRST] == entry)that[FIRST] = next;
          if(that[LAST] == entry)that[LAST] = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments[1], 3)
          , entry;
        while(entry = entry ? entry.n : this[FIRST]){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if($.DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return assert.def(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that[O1][index] = entry;
    } return that;
  },
  getEntry: getEntry,
  // add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  setIter: function(C, NAME, IS_MAP){
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
  }
};
},{"./$":28,"./$.assert":9,"./$.ctx":16,"./$.for-of":20,"./$.iter":27,"./$.iter-define":25,"./$.mix":30,"./$.uid":44}],13:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def')
  , forOf = require('./$.for-of');
module.exports = function(NAME){
  $def($def.P, NAME, {
    toJSON: function toJSON(){
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    }
  });
};
},{"./$.def":17,"./$.for-of":20}],14:[function(require,module,exports){
'use strict';
var $         = require('./$')
  , safe      = require('./$.uid').safe
  , assert    = require('./$.assert')
  , forOf     = require('./$.for-of')
  , $has      = $.has
  , isObject  = $.isObject
  , hide      = $.hide
  , isExtensible = Object.isExtensible || isObject
  , id        = 0
  , ID        = safe('id')
  , WEAK      = safe('weak')
  , LEAK      = safe('leak')
  , method    = require('./$.array-methods')
  , find      = method(5)
  , findIndex = method(6);
function findFrozen(store, key){
  return find(store.array, function(it){
    return it[0] === key;
  });
}
// fallback for frozen keys
function leakStore(that){
  return that[LEAK] || hide(that, LEAK, {
    array: [],
    get: function(key){
      var entry = findFrozen(this, key);
      if(entry)return entry[1];
    },
    has: function(key){
      return !!findFrozen(this, key);
    },
    set: function(key, value){
      var entry = findFrozen(this, key);
      if(entry)entry[1] = value;
      else this.array.push([key, value]);
    },
    'delete': function(key){
      var index = findIndex(this.array, function(it){
        return it[0] === key;
      });
      if(~index)this.array.splice(index, 1);
      return !!~index;
    }
  })[LEAK];
}

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      $.set(assert.inst(that, C, NAME), ID, id++);
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this)['delete'](key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        if(!isExtensible(key))return leakStore(this).has(key);
        return $has(key, WEAK) && $has(key[WEAK], this[ID]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    if(!isExtensible(assert.obj(key))){
      leakStore(that).set(key, value);
    } else {
      $has(key, WEAK) || hide(key, WEAK, {});
      key[WEAK][that[ID]] = value;
    } return that;
  },
  leakStore: leakStore,
  WEAK: WEAK,
  ID: ID
};
},{"./$":28,"./$.array-methods":8,"./$.assert":9,"./$.for-of":20,"./$.mix":30,"./$.uid":44}],15:[function(require,module,exports){
'use strict';
var $     = require('./$')
  , $def  = require('./$.def')
  , BUGGY = require('./$.iter').BUGGY
  , forOf = require('./$.for-of')
  , species = require('./$.species')
  , assertInstance = require('./$.assert').inst;

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = $.g[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  function fixMethod(KEY){
    var fn = proto[KEY];
    require('./$.redef')(proto, KEY,
      KEY == 'delete' ? function(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'has' ? function has(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'get' ? function get(a){ return fn.call(this, a === 0 ? 0 : a); }
      : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
      : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  }
  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    var inst  = new C
      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
      , buggyZero;
    // wrap for init collections from iterable
    if(!require('./$.iter-detect')(function(iter){ new C(iter); })){ // eslint-disable-line no-new
      C = wrapper(function(target, iterable){
        assertInstance(target, C, NAME);
        var that = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    IS_WEAK || inst.forEach(function(val, key){
      buggyZero = 1 / key === -Infinity;
    });
    // fix converting -0 key to +0
    if(buggyZero){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    // + fix .add & .set for chaining
    if(buggyZero || chain !== inst)fixMethod(ADDER);
  }

  require('./$.cof').set(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F * (C != Base), O);
  species(C);
  species($.core[NAME]); // for wrapper

  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

  return C;
};
},{"./$":28,"./$.assert":9,"./$.cof":11,"./$.def":17,"./$.for-of":20,"./$.iter":27,"./$.iter-detect":26,"./$.mix":30,"./$.redef":33,"./$.species":38}],16:[function(require,module,exports){
// Optional / simple context binding
var assertFunction = require('./$.assert').fn;
module.exports = function(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  } return function(/* ...args */){
      return fn.apply(that, arguments);
    };
};
},{"./$.assert":9}],17:[function(require,module,exports){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction
  , $redef     = require('./$.redef');
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
global.core = core;
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    if(type & $def.B && own)exp = ctx(out, global);
    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
    // extend global
    if(target && !own)$redef(target, key, out);
    // export
    if(exports[key] != out)$.hide(exports, key, exp);
    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;
  }
}
module.exports = $def;
},{"./$":28,"./$.redef":33}],18:[function(require,module,exports){
var $        = require('./$')
  , document = $.g.document
  , isObject = $.isObject
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$":28}],19:[function(require,module,exports){
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getDesc    = $.getDesc
    , getSymbols = $.getSymbols;
  if(getSymbols)$.each.call(getSymbols(it), function(key){
    if(getDesc(it, key).enumerable)keys.push(key);
  });
  return keys;
};
},{"./$":28}],20:[function(require,module,exports){
var ctx  = require('./$.ctx')
  , get  = require('./$.iter').get
  , call = require('./$.iter-call');
module.exports = function(iterable, entries, fn, that){
  var iterator = get(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done){
    if(call(iterator, f, step.value, entries) === false){
      return call.close(iterator);
    }
  }
};
},{"./$.ctx":16,"./$.iter":27,"./$.iter-call":24}],21:[function(require,module,exports){
module.exports = function($){
  $.FW   = true;
  $.path = $.g;
  return $;
};
},{}],22:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var $ = require('./$')
  , toString = {}.toString
  , getNames = $.getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

function getWindowNames(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
}

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames($.toObject(it));
};
},{"./$":28}],23:[function(require,module,exports){
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
};
},{}],24:[function(require,module,exports){
var assertObject = require('./$.assert').obj;
function close(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)assertObject(ret.call(iterator));
}
function call(iterator, fn, value, entries){
  try {
    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
  } catch(e){
    close(iterator);
    throw e;
  }
}
call.close = close;
module.exports = call;
},{"./$.assert":9}],25:[function(require,module,exports){
var $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , $               = require('./$')
  , cof             = require('./$.cof')
  , $iter           = require('./$.iter')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values'
  , Iterators       = $iter.Iterators;
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  $iter.create(Constructor, NAME, next);
  function createMethod(kind){
    function $$(that){
      return new Constructor(that, kind);
    }
    switch(kind){
      case KEYS: return function keys(){ return $$(this); };
      case VALUES: return function values(){ return $$(this); };
    } return function entries(){ return $$(this); };
  }
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = $.getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    cof.set(IteratorPrototype, TAG, true);
    // FF fix
    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
  }
  // Define iterator
  if($.FW || FORCE)$iter.set(proto, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = $.that;
  if(DEFAULT){
    methods = {
      keys:    IS_SET            ? _default : createMethod(KEYS),
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
  }
};
},{"./$":28,"./$.cof":11,"./$.def":17,"./$.iter":27,"./$.redef":33,"./$.wks":46}],26:[function(require,module,exports){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec){
  if(!SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":46}],27:[function(require,module,exports){
'use strict';
var $                 = require('./$')
  , cof               = require('./$.cof')
  , classof           = cof.classof
  , assert            = require('./$.assert')
  , assertObject      = assert.obj
  , SYMBOL_ITERATOR   = require('./$.wks')('iterator')
  , FF_ITERATOR       = '@@iterator'
  , Iterators         = require('./$.shared')('iterators')
  , IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, $.that);
function setIterator(O, value){
  $.hide(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
}

module.exports = {
  // Safari has buggy iterators w/o `next`
  BUGGY: 'keys' in [] && !('next' in [].keys()),
  Iterators: Iterators,
  step: function(done, value){
    return {value: value, done: !!done};
  },
  is: function(it){
    var O      = Object(it)
      , Symbol = $.g.Symbol;
    return (Symbol && Symbol.iterator || FF_ITERATOR) in O
      || SYMBOL_ITERATOR in O
      || $.has(Iterators, classof(O));
  },
  get: function(it){
    var Symbol = $.g.Symbol
      , getIter;
    if(it != undefined){
      getIter = it[Symbol && Symbol.iterator || FF_ITERATOR]
        || it[SYMBOL_ITERATOR]
        || Iterators[classof(it)];
    }
    assert($.isFunction(getIter), it, ' is not iterable!');
    return assertObject(getIter.call(it));
  },
  set: setIterator,
  create: function(Constructor, NAME, next, proto){
    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
    cof.set(Constructor, NAME + ' Iterator');
  }
};
},{"./$":28,"./$.assert":9,"./$.cof":11,"./$.shared":37,"./$.wks":46}],28:[function(require,module,exports){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value));
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  setDescs:   Object.defineProperties,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  assertDefined: assertDefined,
  // Dummy, fix for not array-like ES3 string in es5 module
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  each: [].forEach
});
/* eslint-disable no-undef */
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
},{"./$.fw":21}],29:[function(require,module,exports){
var $ = require('./$');
module.exports = function(object, el){
  var O      = $.toObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":28}],30:[function(require,module,exports){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
},{"./$.redef":33}],31:[function(require,module,exports){
var $            = require('./$')
  , assertObject = require('./$.assert').obj;
module.exports = function ownKeys(it){
  assertObject(it);
  var keys       = $.getNames(it)
    , getSymbols = $.getSymbols;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./$":28,"./$.assert":9}],32:[function(require,module,exports){
'use strict';
var $      = require('./$')
  , invoke = require('./$.invoke')
  , assertFunction = require('./$.assert').fn;
module.exports = function(/* ...pargs */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = $.path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !_length)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(_length > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./$":28,"./$.assert":9,"./$.invoke":23}],33:[function(require,module,exports){
var $   = require('./$')
  , tpl = String({}.hasOwnProperty)
  , SRC = require('./$.uid').safe('src')
  , _toString = Function.toString;

function $redef(O, key, val, safe){
  if($.isFunction(val)){
    var base = O[key];
    $.hide(val, SRC, base ? String(base) : tpl.replace(/hasOwnProperty/, String(key)));
    if(!('name' in val))val.name = key;
  }
  if(O === $.g){
    O[key] = val;
  } else {
    if(!safe)delete O[key];
    $.hide(O, key, val);
  }
}

// add fake Function#toString for correct work wrapped methods / constructors
// with methods similar to LoDash isNative
$redef(Function.prototype, 'toString', function toString(){
  return $.has(this, SRC) ? this[SRC] : _toString.call(this);
});

$.core.inspectSource = function(it){
  return _toString.call(it);
};

module.exports = $redef;
},{"./$":28,"./$.uid":44}],34:[function(require,module,exports){
'use strict';
module.exports = function(regExp, replace, isStatic){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  };
};
},{}],35:[function(require,module,exports){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],36:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var $      = require('./$')
  , assert = require('./$.assert');
function check(O, proto){
  assert.obj(O);
  assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
}
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line
    ? function(buggy, set){
        try {
          set = require('./$.ctx')(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
          set({}, []);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }()
    : undefined),
  check: check
};
},{"./$":28,"./$.assert":9,"./$.ctx":16}],37:[function(require,module,exports){
var $      = require('./$')
  , SHARED = '__core-js_shared__'
  , store  = $.g[SHARED] || ($.g[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$":28}],38:[function(require,module,exports){
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: $.that
  });
};
},{"./$":28,"./$.wks":46}],39:[function(require,module,exports){
// true  -> String#at
// false -> String#codePointAt
var $ = require('./$');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String($.assertDefined(that))
      , i = $.toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$":28}],40:[function(require,module,exports){
// http://wiki.ecmascript.org/doku.php?id=strawman:string_padding
var $      = require('./$')
  , repeat = require('./$.string-repeat');

module.exports = function(that, minLength, fillChar, left){
  // 1. Let O be CheckObjectCoercible(this value).
  // 2. Let S be ToString(O).
  var S = String($.assertDefined(that));
  // 4. If intMinLength is undefined, return S.
  if(minLength === undefined)return S;
  // 4. Let intMinLength be ToInteger(minLength).
  var intMinLength = $.toInteger(minLength);
  // 5. Let fillLen be the number of characters in S minus intMinLength.
  var fillLen = intMinLength - S.length;
  // 6. If fillLen < 0, then throw a RangeError exception.
  // 7. If fillLen is +∞, then throw a RangeError exception.
  if(fillLen < 0 || fillLen === Infinity){
    throw new RangeError('Cannot satisfy string length ' + minLength + ' for string: ' + S);
  }
  // 8. Let sFillStr be the string represented by fillStr.
  // 9. If sFillStr is undefined, let sFillStr be a space character.
  var sFillStr = fillChar === undefined ? ' ' : String(fillChar);
  // 10. Let sFillVal be a String made of sFillStr, repeated until fillLen is met.
  var sFillVal = repeat.call(sFillStr, Math.ceil(fillLen / sFillStr.length));
  // truncate if we overflowed
  if(sFillVal.length > fillLen)sFillVal = left
    ? sFillVal.slice(sFillVal.length - fillLen)
    : sFillVal.slice(0, fillLen);
  // 11. Return a string made from sFillVal, followed by S.
  // 11. Return a String made from S, followed by sFillVal.
  return left ? sFillVal.concat(S) : S.concat(sFillVal);
};
},{"./$":28,"./$.string-repeat":41}],41:[function(require,module,exports){
'use strict';
var $ = require('./$');

module.exports = function repeat(count){
  var str = String($.assertDefined(this))
    , res = ''
    , n   = $.toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./$":28}],42:[function(require,module,exports){
'use strict';
var $      = require('./$')
  , ctx    = require('./$.ctx')
  , cof    = require('./$.cof')
  , invoke = require('./$.invoke')
  , cel    = require('./$.dom-create')
  , global             = $.g
  , isFunction         = $.isFunction
  , html               = $.html
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
function run(){
  var id = +this;
  if($.has(queue, id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
}
function listner(event){
  run.call(event.data);
}
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!isFunction(setTask) || !isFunction(clearTask)){
  setTask = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(cof(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(global.addEventListener && isFunction(global.postMessage) && !global.importScripts){
    defer = function(id){
      global.postMessage(id, '*');
    };
    global.addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$":28,"./$.cof":11,"./$.ctx":16,"./$.dom-create":18,"./$.invoke":23}],43:[function(require,module,exports){
module.exports = function(exec){
  try {
    exec();
    return false;
  } catch(e){
    return true;
  }
};
},{}],44:[function(require,module,exports){
var sid = 0;
function uid(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
}
uid.safe = require('./$').g.Symbol || uid;
module.exports = uid;
},{"./$":28}],45:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./$.wks')('unscopables');
if(!(UNSCOPABLES in []))require('./$').hide(Array.prototype, UNSCOPABLES, {});
module.exports = function(key){
  [][UNSCOPABLES][key] = true;
};
},{"./$":28,"./$.wks":46}],46:[function(require,module,exports){
var global = require('./$').g
  , store  = require('./$.shared')('wks');
module.exports = function(name){
  return store[name] || (store[name] =
    global.Symbol && global.Symbol[name] || require('./$.uid').safe('Symbol.' + name));
};
},{"./$":28,"./$.shared":37,"./$.uid":44}],47:[function(require,module,exports){
var $                = require('./$')
  , cel              = require('./$.dom-create')
  , cof              = require('./$.cof')
  , $def             = require('./$.def')
  , invoke           = require('./$.invoke')
  , arrayMethod      = require('./$.array-methods')
  , IE_PROTO         = require('./$.uid').safe('__proto__')
  , assert           = require('./$.assert')
  , assertObject     = assert.obj
  , ObjectProto      = Object.prototype
  , html             = $.html
  , A                = []
  , _slice           = A.slice
  , _join            = A.join
  , classof          = cof.classof
  , has              = $.has
  , defineProperty   = $.setDesc
  , getOwnDescriptor = $.getDesc
  , defineProperties = $.setDescs
  , isFunction       = $.isFunction
  , isObject         = $.isObject
  , toObject         = $.toObject
  , toLength         = $.toLength
  , toIndex          = $.toIndex
  , IE8_DOM_DEFINE   = false
  , $indexOf         = require('./$.array-includes')(false)
  , $forEach         = arrayMethod(0)
  , $map             = arrayMethod(1)
  , $filter          = arrayMethod(2)
  , $some            = arrayMethod(3)
  , $every           = arrayMethod(4);

if(!$.DESC){
  try {
    IE8_DOM_DEFINE = defineProperty(cel('div'), 'x',
      {get: function(){ return 8; }}
    ).x == 8;
  } catch(e){ /* empty */ }
  $.setDesc = function(O, P, Attributes){
    if(IE8_DOM_DEFINE)try {
      return defineProperty(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)assertObject(O)[P] = Attributes.value;
    return O;
  };
  $.getDesc = function(O, P){
    if(IE8_DOM_DEFINE)try {
      return getOwnDescriptor(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return $.desc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
  };
  $.setDescs = defineProperties = function(O, Properties){
    assertObject(O);
    var keys   = $.getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);
    return O;
  };
}
$def($def.S + $def.F * !$.DESC, 'Object', {
  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $.getDesc,
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  defineProperty: $.setDesc,
  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  defineProperties: defineProperties
});

  // IE 8- don't enum bug keys
var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +
            'toLocaleString,toString,valueOf').split(',')
  // Additional keys for getOwnPropertyNames
  , keys2 = keys1.concat('length', 'prototype')
  , keysLen1 = keys1.length;

// Create object with `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = cel('iframe')
    , i      = keysLen1
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write('<script>document.F=Object</script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict.prototype[keys1[i]];
  return createDict();
};
function createGetKeys(names, length){
  return function(object){
    var O      = toObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(length > i)if(has(O, key = names[i++])){
      ~$indexOf(result, key) || result.push(key);
    }
    return result;
  };
}
function Empty(){}
$def($def.S, 'Object', {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  getPrototypeOf: $.getProto = $.getProto || function(O){
    O = Object(assert.def(O));
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(isFunction(O.constructor) && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  },
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  create: $.create = $.create || function(O, /*?*/Properties){
    var result;
    if(O !== null){
      Empty.prototype = assertObject(O);
      result = new Empty();
      Empty.prototype = null;
      // add "__proto__" for Object.getPrototypeOf shim
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : defineProperties(result, Properties);
  },
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false),
  // 19.1.2.17 / 15.2.3.8 Object.seal(O)
  seal: function seal(it){
    return it; // <- cap
  },
  // 19.1.2.5 / 15.2.3.9 Object.freeze(O)
  freeze: function freeze(it){
    return it; // <- cap
  },
  // 19.1.2.15 / 15.2.3.10 Object.preventExtensions(O)
  preventExtensions: function preventExtensions(it){
    return it; // <- cap
  },
  // 19.1.2.13 / 15.2.3.11 Object.isSealed(O)
  isSealed: function isSealed(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.12 / 15.2.3.12 Object.isFrozen(O)
  isFrozen: function isFrozen(it){
    return !isObject(it); // <- cap
  },
  // 19.1.2.11 / 15.2.3.13 Object.isExtensible(O)
  isExtensible: function isExtensible(it){
    return isObject(it); // <- cap
  }
});

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
$def($def.P, 'Function', {
  bind: function(that /*, args... */){
    var fn       = assert.fn(this)
      , partArgs = _slice.call(arguments, 1);
    function bound(/* args... */){
      var args   = partArgs.concat(_slice.call(arguments))
        , constr = this instanceof bound
        , ctx    = constr ? $.create(fn.prototype) : that
        , result = invoke(fn, args, ctx);
      return constr ? ctx : result;
    }
    if(fn.prototype)bound.prototype = fn.prototype;
    return bound;
  }
});

// Fix for not array-like ES3 string and DOM objects
if(!(0 in Object('z') && 'z'[0] == 'z')){
  $.ES5Object = function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
}

var buggySlice = true;
try {
  if(html)_slice.call(html);
  buggySlice = false;
} catch(e){ /* empty */ }

$def($def.P + $def.F * buggySlice, 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return _slice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

$def($def.P + $def.F * ($.ES5Object != Object), 'Array', {
  join: function join(){
    return _join.apply($.ES5Object(this), arguments);
  }
});

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
$def($def.S, 'Array', {
  isArray: function(arg){
    return cof(arg) == 'Array';
  }
});
function createArrayReduce(isRight){
  return function(callbackfn, memo){
    assert.fn(callbackfn);
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = isRight ? length - 1 : 0
      , i      = isRight ? -1 : 1;
    if(arguments.length < 2)for(;;){
      if(index in O){
        memo = O[index];
        index += i;
        break;
      }
      index += i;
      assert(isRight ? index >= 0 : length > index, 'Reduce of empty array with no initial value');
    }
    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){
      memo = callbackfn(memo, O[index], index, this);
    }
    return memo;
  };
}
$def($def.P, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: $.each = $.each || function forEach(callbackfn/*, that = undefined */){
    return $forEach(this, callbackfn, arguments[1]);
  },
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn/*, that = undefined */){
    return $map(this, callbackfn, arguments[1]);
  },
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn/*, that = undefined */){
    return $filter(this, callbackfn, arguments[1]);
  },
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn/*, that = undefined */){
    return $some(this, callbackfn, arguments[1]);
  },
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn/*, that = undefined */){
    return $every(this, callbackfn, arguments[1]);
  },
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: createArrayReduce(false),
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: createArrayReduce(true),
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(el /*, fromIndex = 0 */){
    return $indexOf(this, el, arguments[1]);
  },
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function(el, fromIndex /* = @[*-1] */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, $.toInteger(fromIndex));
    if(index < 0)index = toLength(length + index);
    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;
    return -1;
  }
});

// 21.1.3.25 / 15.5.4.20 String.prototype.trim()
$def($def.P, 'String', {trim: require('./$.replacer')(/^\s*([\s\S]*\S)?\s*$/, '$1')});

// 20.3.3.1 / 15.9.4.4 Date.now()
$def($def.S, 'Date', {now: function(){
  return +new Date;
}});

function lz(num){
  return num > 9 ? num : '0' + num;
}

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
// PhantomJS and old webkit had a broken Date implementation.
var date       = new Date(-5e13 - 1)
  , brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z'
      && require('./$.throws')(function(){ new Date(NaN).toISOString(); }));
$def($def.P + $def.F * brokenDate, 'Date', {toISOString: function(){
  if(!isFinite(this))throw RangeError('Invalid time value');
  var d = this
    , y = d.getUTCFullYear()
    , m = d.getUTCMilliseconds()
    , s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
}});

if(classof(function(){ return arguments; }()) == 'Object')cof.classof = function(it){
  var tag = classof(it);
  return tag == 'Object' && isFunction(it.callee) ? 'Arguments' : tag;
};
},{"./$":28,"./$.array-includes":7,"./$.array-methods":8,"./$.assert":9,"./$.cof":11,"./$.def":17,"./$.dom-create":18,"./$.invoke":23,"./$.replacer":34,"./$.throws":43,"./$.uid":44}],48:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  copyWithin: function copyWithin(target/* = 0 */, start /* = 0, end = @length */){
    var O     = Object($.assertDefined(this))
      , len   = $.toLength(O.length)
      , to    = toIndex(target, len)
      , from  = toIndex(start, len)
      , end   = arguments[2]
      , fin   = end === undefined ? len : toIndex(end, len)
      , count = Math.min(fin - from, len - to)
      , inc   = 1;
    if(from < to && to < from + count){
      inc  = -1;
      from = from + count - 1;
      to   = to   + count - 1;
    }
    while(count-- > 0){
      if(from in O)O[to] = O[from];
      else delete O[to];
      to   += inc;
      from += inc;
    } return O;
  }
});
require('./$.unscope')('copyWithin');
},{"./$":28,"./$.def":17,"./$.unscope":45}],49:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , $def    = require('./$.def')
  , toIndex = $.toIndex;
$def($def.P, 'Array', {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  fill: function fill(value /*, start = 0, end = @length */){
    var O      = Object($.assertDefined(this))
      , length = $.toLength(O.length)
      , index  = toIndex(arguments[1], length)
      , end    = arguments[2]
      , endPos = end === undefined ? length : toIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
  }
});
require('./$.unscope')('fill');
},{"./$":28,"./$.def":17,"./$.unscope":45}],50:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var KEY    = 'findIndex'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(6);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":8,"./$.def":17,"./$.unscope":45}],51:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var KEY    = 'find'
  , $def   = require('./$.def')
  , forced = true
  , $find  = require('./$.array-methods')(5);
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$def($def.P + $def.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments[1]);
  }
});
require('./$.unscope')(KEY);
},{"./$.array-methods":8,"./$.def":17,"./$.unscope":45}],52:[function(require,module,exports){
var $     = require('./$')
  , ctx   = require('./$.ctx')
  , $def  = require('./$.def')
  , $iter = require('./$.iter')
  , call  = require('./$.iter-call');
$def($def.S + $def.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = Object($.assertDefined(arrayLike))
      , mapfn   = arguments[1]
      , mapping = mapfn !== undefined
      , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
      , index   = 0
      , length, result, step, iterator;
    if($iter.is(O)){
      iterator = $iter.get(O);
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result   = new (typeof this == 'function' ? this : Array);
      for(; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, f, [step.value, index], true) : step.value;
      }
    } else {
      // strange IE quirks mode bug -> use typeof instead of isFunction
      result = new (typeof this == 'function' ? this : Array)(length = $.toLength(O.length));
      for(; length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});
},{"./$":28,"./$.ctx":16,"./$.def":17,"./$.iter":27,"./$.iter-call":24,"./$.iter-detect":26}],53:[function(require,module,exports){
var $          = require('./$')
  , setUnscope = require('./$.unscope')
  , ITER       = require('./$.uid').safe('iter')
  , $iter      = require('./$.iter')
  , step       = $iter.step
  , Iterators  = $iter.Iterators;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , kind  = iter.k
    , index = iter.i++;
  if(!O || index >= O.length){
    iter.o = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
},{"./$":28,"./$.iter":27,"./$.iter-define":25,"./$.uid":44,"./$.unscope":45}],54:[function(require,module,exports){
var $def = require('./$.def');
$def($def.S, 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , length = arguments.length
      // strange IE quirks mode bug -> use typeof instead of isFunction
      , result = new (typeof this == 'function' ? this : Array)(length);
    while(length > index)result[index] = arguments[index++];
    result.length = length;
    return result;
  }
});
},{"./$.def":17}],55:[function(require,module,exports){
require('./$.species')(Array);
},{"./$.species":38}],56:[function(require,module,exports){
var $             = require('./$')
  , HAS_INSTANCE  = require('./$.wks')('hasInstance')
  , FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(!$.isFunction(this) || !$.isObject(O))return false;
  if(!$.isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = $.getProto(O))if(this.prototype === O)return true;
  return false;
}});
},{"./$":28,"./$.wks":46}],57:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , NAME = 'name'
  , setDesc = $.setDesc
  , FunctionProto = Function.prototype;
// 19.2.4.2 name
NAME in FunctionProto || $.FW && $.DESC && setDesc(FunctionProto, NAME, {
  configurable: true,
  get: function(){
    var match = String(this).match(/^\s*function ([^ (]*)/)
      , name  = match ? match[1] : '';
    $.has(this, NAME) || setDesc(this, NAME, $.desc(5, name));
    return name;
  },
  set: function(value){
    $.has(this, NAME) || setDesc(this, NAME, $.desc(0, value));
  }
});
},{"./$":28}],58:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments[0]); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":15,"./$.collection-strong":12}],59:[function(require,module,exports){
var Infinity = 1 / 0
  , $def  = require('./$.def')
  , E     = Math.E
  , pow   = Math.pow
  , abs   = Math.abs
  , exp   = Math.exp
  , log   = Math.log
  , sqrt  = Math.sqrt
  , ceil  = Math.ceil
  , floor = Math.floor
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);
function roundTiesToEven(n){
  return n + 1 / EPSILON - 1 / EPSILON;
}

// 20.2.2.28 Math.sign(x)
function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
}
// 20.2.2.5 Math.asinh(x)
function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}
// 20.2.2.14 Math.expm1(x)
function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
}

$def($def.S, 'Math', {
  // 20.2.2.3 Math.acosh(x)
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
  },
  // 20.2.2.5 Math.asinh(x)
  asinh: asinh,
  // 20.2.2.7 Math.atanh(x)
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  },
  // 20.2.2.9 Math.cbrt(x)
  cbrt: function cbrt(x){
    return sign(x = +x) * pow(abs(x), 1 / 3);
  },
  // 20.2.2.11 Math.clz32(x)
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * Math.LOG2E) : 32;
  },
  // 20.2.2.12 Math.cosh(x)
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  },
  // 20.2.2.14 Math.expm1(x)
  expm1: expm1,
  // 20.2.2.16 Math.fround(x)
  fround: function fround(x){
    var $abs  = abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  },
  // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , len  = arguments.length
      , larg = 0
      , arg, div;
    while(i < len){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  },
  // 20.2.2.18 Math.imul(x, y)
  imul: function imul(x, y){
    var UInt16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UInt16 & xn
      , yl = UInt16 & yn;
    return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
  },
  // 20.2.2.20 Math.log1p(x)
  log1p: function log1p(x){
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
  },
  // 20.2.2.21 Math.log10(x)
  log10: function log10(x){
    return log(x) / Math.LN10;
  },
  // 20.2.2.22 Math.log2(x)
  log2: function log2(x){
    return log(x) / Math.LN2;
  },
  // 20.2.2.28 Math.sign(x)
  sign: sign,
  // 20.2.2.30 Math.sinh(x)
  sinh: function sinh(x){
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  },
  // 20.2.2.33 Math.tanh(x)
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  },
  // 20.2.2.34 Math.trunc(x)
  trunc: function trunc(it){
    return (it > 0 ? floor : ceil)(it);
  }
});
},{"./$.def":17}],60:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , isObject   = $.isObject
  , isFunction = $.isFunction
  , NUMBER     = 'Number'
  , $Number    = $.g[NUMBER]
  , Base       = $Number
  , proto      = $Number.prototype;
function toPrimitive(it){
  var fn, val;
  if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
  if(isFunction(fn = it.toString) && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to number");
}
function toNumber(it){
  if(isObject(it))it = toPrimitive(it);
  if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
    var binary = false;
    switch(it.charCodeAt(1)){
      case 66 : case 98  : binary = true;
      case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
    }
  } return +it;
}
if($.FW && !($Number('0o1') && $Number('0b1'))){
  $Number = function Number(it){
    return this instanceof $Number ? new Base(toNumber(it)) : toNumber(it);
  };
  $.each.call($.DESC ? $.getNames(Base) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES6 (in case, if modules with ES6 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), function(key){
      if($.has(Base, key) && !$.has($Number, key)){
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    }
  );
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./$.redef')($.g, NUMBER, $Number);
}
},{"./$":28,"./$.redef":33}],61:[function(require,module,exports){
var $     = require('./$')
  , $def  = require('./$.def')
  , abs   = Math.abs
  , floor = Math.floor
  , _isFinite = $.g.isFinite
  , MAX_SAFE_INTEGER = 0x1fffffffffffff; // pow(2, 53) - 1 == 9007199254740991;
function isInteger(it){
  return !$.isObject(it) && _isFinite(it) && floor(it) === it;
}
$def($def.S, 'Number', {
  // 20.1.2.1 Number.EPSILON
  EPSILON: Math.pow(2, -52),
  // 20.1.2.2 Number.isFinite(number)
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  },
  // 20.1.2.3 Number.isInteger(number)
  isInteger: isInteger,
  // 20.1.2.4 Number.isNaN(number)
  isNaN: function isNaN(number){
    return number != number;
  },
  // 20.1.2.5 Number.isSafeInteger(number)
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
  },
  // 20.1.2.6 Number.MAX_SAFE_INTEGER
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  // 20.1.2.10 Number.MIN_SAFE_INTEGER
  MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
  // 20.1.2.12 Number.parseFloat(string)
  parseFloat: parseFloat,
  // 20.1.2.13 Number.parseInt(string, radix)
  parseInt: parseInt
});
},{"./$":28,"./$.def":17}],62:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
},{"./$.assign":10,"./$.def":17}],63:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $def = require('./$.def');
$def($def.S, 'Object', {
  is: require('./$.same')
});
},{"./$.def":17,"./$.same":35}],64:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.def":17,"./$.set-proto":36}],65:[function(require,module,exports){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
$.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' +
  'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(',')
, function(KEY, ID){
  var fn     = ($.core.Object || {})[KEY] || Object[KEY]
    , forced = 0
    , method = {};
  method[KEY] = ID == 0 ? function freeze(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 1 ? function seal(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 2 ? function preventExtensions(it){
    return isObject(it) ? fn(it) : it;
  } : ID == 3 ? function isFrozen(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 4 ? function isSealed(it){
    return isObject(it) ? fn(it) : true;
  } : ID == 5 ? function isExtensible(it){
    return isObject(it) ? fn(it) : false;
  } : ID == 6 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : ID == 7 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : ID == 8 ? function keys(it){
    return fn(toObject(it));
  } : require('./$.get-names').get;
  try {
    fn('z');
  } catch(e){
    forced = 1;
  }
  $def($def.S + $def.F * forced, 'Object', method);
});
},{"./$":28,"./$.def":17,"./$.get-names":22}],66:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , tmp = {};
tmp[require('./$.wks')('toStringTag')] = 'z';
if(require('./$').FW && cof(tmp) != 'z'){
  require('./$.redef')(Object.prototype, 'toString', function toString(){
    return '[object ' + cof.classof(this) + ']';
  }, true);
}
},{"./$":28,"./$.cof":11,"./$.redef":33,"./$.wks":46}],67:[function(require,module,exports){
'use strict';
var $        = require('./$')
  , ctx      = require('./$.ctx')
  , cof      = require('./$.cof')
  , $def     = require('./$.def')
  , assert   = require('./$.assert')
  , forOf    = require('./$.for-of')
  , setProto = require('./$.set-proto').set
  , same     = require('./$.same')
  , species  = require('./$.species')
  , SPECIES  = require('./$.wks')('species')
  , RECORD   = require('./$.uid').safe('record')
  , PROMISE  = 'Promise'
  , global   = $.g
  , process  = global.process
  , isNode   = cof(process) == 'process'
  , asap     = process && process.nextTick || require('./$.task').set
  , P        = global[PROMISE]
  , isFunction     = $.isFunction
  , isObject       = $.isObject
  , assertFunction = assert.fn
  , assertObject   = assert.obj
  , Wrapper;

function testResolve(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
}

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = isFunction(P) && isFunction(P.resolve) && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && $.DESC){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
function isPromise(it){
  return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);
}
function sameConstructor(a, b){
  // library wrapper special case
  if(!$.FW && a === P && b === Wrapper)return true;
  return same(a, b);
}
function getConstructor(C){
  var S = assertObject(C)[SPECIES];
  return S != undefined ? S : C;
}
function isThenable(it){
  var then;
  if(isObject(it))then = it.then;
  return isFunction(then) ? then : false;
}
function notify(record){
  var chain = record.c;
  // strange IE + webpack dev server bug - use .call(global)
  if(chain.length)asap.call(global, function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    function run(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    }
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
  });
}
function isUnhandled(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
}
function $reject(value){
  var record = this
    , promise;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  setTimeout(function(){
    // strange IE + webpack dev server bug - use .call(global)
    asap.call(global, function(){
      if(isUnhandled(promise = record.p)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(global.console && console.error){
          console.error('Unhandled promise rejection', value);
        }
      }
      record.a = undefined;
    });
  }, 1);
  notify(record);
}
function $resolve(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      // strange IE + webpack dev server bug - use .call(global)
      asap.call(global, function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
}

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    assertFunction(executor);
    var record = {
      p: assert.inst(this, P, PROMISE),       // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false                                // <- handled rejection
    };
    $.hide(this, RECORD, record);
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var S = assertObject(assertObject(this).constructor)[SPECIES];
      var react = {
        ok:   isFunction(onFulfilled) ? onFulfilled : true,
        fail: isFunction(onRejected)  ? onRejected  : false
      };
      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){
        react.res = assertFunction(res);
        react.rej = assertFunction(rej);
      });
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
cof.set(P, PROMISE);
species(P);
species(Wrapper = $.core[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new (getConstructor(this))(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
},{"./$":28,"./$.assert":9,"./$.cof":11,"./$.ctx":16,"./$.def":17,"./$.for-of":20,"./$.iter-detect":26,"./$.mix":30,"./$.same":35,"./$.set-proto":36,"./$.species":38,"./$.task":42,"./$.uid":44,"./$.wks":46}],68:[function(require,module,exports){
var $         = require('./$')
  , $def      = require('./$.def')
  , setProto  = require('./$.set-proto')
  , $iter     = require('./$.iter')
  , ITERATOR  = require('./$.wks')('iterator')
  , ITER      = require('./$.uid').safe('iter')
  , step      = $iter.step
  , assert    = require('./$.assert')
  , isObject  = $.isObject
  , getProto  = $.getProto
  , $Reflect  = $.g.Reflect
  , _apply    = Function.apply
  , assertObject = assert.obj
  , _isExtensible = Object.isExtensible || isObject
  , _preventExtensions = Object.preventExtensions
  // IE TP has broken Reflect.enumerate
  , buggyEnumerate = !($Reflect && $Reflect.enumerate && ITERATOR in $Reflect.enumerate({}));

function Enumerate(iterated){
  $.set(this, ITER, {o: iterated, k: undefined, i: 0});
}
$iter.create(Enumerate, 'Object', function(){
  var iter = this[ITER]
    , keys = iter.k
    , key;
  if(keys == undefined){
    iter.k = keys = [];
    for(key in iter.o)keys.push(key);
  }
  do {
    if(iter.i >= keys.length)return step(1);
  } while(!((key = keys[iter.i++]) in iter.o));
  return step(0, key);
});

var reflect = {
  // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
  apply: function apply(target, thisArgument, argumentsList){
    return _apply.call(target, thisArgument, argumentsList);
  },
  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  construct: function construct(target, argumentsList /*, newTarget*/){
    var proto    = assert.fn(arguments.length < 3 ? target : arguments[2]).prototype
      , instance = $.create(isObject(proto) ? proto : Object.prototype)
      , result   = _apply.call(target, instance, argumentsList);
    return isObject(result) ? result : instance;
  },
  // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
  defineProperty: function defineProperty(target, propertyKey, attributes){
    assertObject(target);
    try {
      $.setDesc(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.4 Reflect.deleteProperty(target, propertyKey)
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = $.getDesc(assertObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  },
  // 26.1.6 Reflect.get(target, propertyKey [, receiver])
  get: function get(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = $.getDesc(assertObject(target), propertyKey), proto;
    if(desc)return $.has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getProto(target))
      ? get(proto, propertyKey, receiver)
      : undefined;
  },
  // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return $.getDesc(assertObject(target), propertyKey);
  },
  // 26.1.8 Reflect.getPrototypeOf(target)
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(assertObject(target));
  },
  // 26.1.9 Reflect.has(target, propertyKey)
  has: function has(target, propertyKey){
    return propertyKey in target;
  },
  // 26.1.10 Reflect.isExtensible(target)
  isExtensible: function isExtensible(target){
    return _isExtensible(assertObject(target));
  },
  // 26.1.11 Reflect.ownKeys(target)
  ownKeys: require('./$.own-keys'),
  // 26.1.12 Reflect.preventExtensions(target)
  preventExtensions: function preventExtensions(target){
    assertObject(target);
    try {
      if(_preventExtensions)_preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  },
  // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
  set: function set(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = $.getDesc(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getProto(target))){
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = $.desc(0);
    }
    if($.has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || $.desc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
};
// 26.1.14 Reflect.setPrototypeOf(target, proto)
if(setProto)reflect.setPrototypeOf = function setPrototypeOf(target, proto){
  setProto.check(target, proto);
  try {
    setProto.set(target, proto);
    return true;
  } catch(e){
    return false;
  }
};

$def($def.G, {Reflect: {}});

$def($def.S + $def.F * buggyEnumerate, 'Reflect', {
  // 26.1.5 Reflect.enumerate(target)
  enumerate: function enumerate(target){
    return new Enumerate(assertObject(target));
  }
});

$def($def.S, 'Reflect', reflect);
},{"./$":28,"./$.assert":9,"./$.def":17,"./$.iter":27,"./$.own-keys":31,"./$.set-proto":36,"./$.uid":44,"./$.wks":46}],69:[function(require,module,exports){
var $       = require('./$')
  , cof     = require('./$.cof')
  , $RegExp = $.g.RegExp
  , Base    = $RegExp
  , proto   = $RegExp.prototype
  , re      = /a/g
  // "new" creates a new object
  , CORRECT_NEW = new $RegExp(re) !== re
  // RegExp allows a regex with flags as the pattern
  , ALLOWS_RE_WITH_FLAGS = function(){
    try {
      return $RegExp(re, 'i') == '/a/i';
    } catch(e){ /* empty */ }
  }();
if($.FW && $.DESC){
  if(!CORRECT_NEW || !ALLOWS_RE_WITH_FLAGS){
    $RegExp = function RegExp(pattern, flags){
      var patternIsRegExp  = cof(pattern) == 'RegExp'
        , flagsIsUndefined = flags === undefined;
      if(!(this instanceof $RegExp) && patternIsRegExp && flagsIsUndefined)return pattern;
      return CORRECT_NEW
        ? new Base(patternIsRegExp && !flagsIsUndefined ? pattern.source : pattern, flags)
        : new Base(patternIsRegExp ? pattern.source : pattern
          , patternIsRegExp && flagsIsUndefined ? pattern.flags : flags);
    };
    $.each.call($.getNames(Base), function(key){
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function(){ return Base[key]; },
        set: function(it){ Base[key] = it; }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./$.redef')($.g, 'RegExp', $RegExp);
  }
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')$.setDesc(proto, 'flags', {
    configurable: true,
    get: require('./$.replacer')(/^.*\/(\w*)$/, '$1')
  });
}
require('./$.species')($RegExp);
},{"./$":28,"./$.cof":11,"./$.redef":33,"./$.replacer":34,"./$.species":38}],70:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments[0]); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":15,"./$.collection-strong":12}],71:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(false);
$def($def.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./$.def":17,"./$.string-at":39}],72:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def')
  , toLength = $.toLength;

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.endsWith(/./); }), 'String', {
  // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that = String($.assertDefined(this))
      , endPosition = arguments[1]
      , len = toLength(that.length)
      , end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    searchString += '';
    return that.slice(end - searchString.length, end) === searchString;
  }
});
},{"./$":28,"./$.cof":11,"./$.def":17,"./$.throws":43}],73:[function(require,module,exports){
var $def    = require('./$.def')
  , toIndex = require('./$').toIndex
  , fromCharCode = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res = []
      , len = arguments.length
      , i   = 0
      , code;
    while(len > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./$":28,"./$.def":17}],74:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.7 String.prototype.includes(searchString, position = 0)
  includes: function includes(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    return !!~String($.assertDefined(this)).indexOf(searchString, arguments[1]);
  }
});
},{"./$":28,"./$.cof":11,"./$.def":17}],75:[function(require,module,exports){
var set   = require('./$').set
  , $at   = require('./$.string-at')(true)
  , ITER  = require('./$.uid').safe('iter')
  , $iter = require('./$.iter')
  , step  = $iter.step;

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  set(this, ITER, {o: String(iterated), i: 0});
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var iter  = this[ITER]
    , O     = iter.o
    , index = iter.i
    , point;
  if(index >= O.length)return step(1);
  point = $at(O, index);
  iter.i += point.length;
  return step(0, point);
});
},{"./$":28,"./$.iter":27,"./$.iter-define":25,"./$.string-at":39,"./$.uid":44}],76:[function(require,module,exports){
var $    = require('./$')
  , $def = require('./$.def');

$def($def.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl = $.toObject(callSite.raw)
      , len = $.toLength(tpl.length)
      , sln = arguments.length
      , res = []
      , i   = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < sln)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./$":28,"./$.def":17}],77:[function(require,module,exports){
var $def = require('./$.def');

$def($def.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./$.string-repeat')
});
},{"./$.def":17,"./$.string-repeat":41}],78:[function(require,module,exports){
'use strict';
var $    = require('./$')
  , cof  = require('./$.cof')
  , $def = require('./$.def');

// should throw error on regex
$def($def.P + $def.F * !require('./$.throws')(function(){ 'q'.startsWith(/./); }), 'String', {
  // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
  startsWith: function startsWith(searchString /*, position = 0 */){
    if(cof(searchString) == 'RegExp')throw TypeError();
    var that  = String($.assertDefined(this))
      , index = $.toLength(Math.min(arguments[1], that.length));
    searchString += '';
    return that.slice(index, index + searchString.length) === searchString;
  }
});
},{"./$":28,"./$.cof":11,"./$.def":17,"./$.throws":43}],79:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $        = require('./$')
  , setTag   = require('./$.cof').set
  , uid      = require('./$.uid')
  , shared   = require('./$.shared')
  , $def     = require('./$.def')
  , $redef   = require('./$.redef')
  , keyOf    = require('./$.keyof')
  , enumKeys = require('./$.enum-keys')
  , assertObject = require('./$.assert').obj
  , ObjectProto = Object.prototype
  , DESC     = $.DESC
  , has      = $.has
  , $create  = $.create
  , getDesc  = $.getDesc
  , setDesc  = $.setDesc
  , desc     = $.desc
  , $names   = require('./$.get-names')
  , getNames = $names.get
  , toObject = $.toObject
  , $Symbol  = $.g.Symbol
  , setter   = false
  , TAG      = uid('tag')
  , HIDDEN   = uid('hidden')
  , _propertyIsEnumerable = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols = shared('symbols')
  , useNative = $.isFunction($Symbol);

var setSymbolDesc = DESC ? function(){ // fallback for old Android
  try {
    return $create(setDesc({}, HIDDEN, {
      get: function(){
        return setDesc(this, HIDDEN, {value: false})[HIDDEN];
      }
    }))[HIDDEN] || setDesc;
  } catch(e){
    return function(it, key, D){
      var protoDesc = getDesc(ObjectProto, key);
      if(protoDesc)delete ObjectProto[key];
      setDesc(it, key, D);
      if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
    };
  }
}() : setDesc;

function wrap(tag){
  var sym = AllSymbols[tag] = $.set($create($Symbol.prototype), TAG, tag);
  DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, desc(1, value));
    }
  });
  return sym;
}

function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, desc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = $create(D, {enumerable: desc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
}
function defineProperties(it, P){
  assertObject(it);
  var keys = enumKeys(P = toObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)defineProperty(it, key = keys[i++], P[key]);
  return it;
}
function create(it, P){
  return P === undefined ? $create(it) : defineProperties($create(it), P);
}
function propertyIsEnumerable(key){
  var E = _propertyIsEnumerable.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
}
function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
}
function getOwnPropertyNames(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
}
function getOwnPropertySymbols(it){
  var names  = getNames(toObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
}

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments[0]));
  };
  $redef($Symbol.prototype, 'toString', function(){
    return this[TAG];
  });

  $.create     = create;
  $.setDesc    = defineProperty;
  $.getDesc    = getOwnPropertyDescriptor;
  $.setDescs   = defineProperties;
  $.getNames   = $names.get = getOwnPropertyNames;
  $.getSymbols = getOwnPropertySymbols;

  if($.DESC && $.FW)$redef(ObjectProto, 'propertyIsEnumerable', propertyIsEnumerable, true);
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
    'species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), function(it){
    var sym = require('./$.wks')(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  }
);

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: getOwnPropertySymbols
});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag($.g.JSON, 'JSON', true);
},{"./$":28,"./$.assert":9,"./$.cof":11,"./$.def":17,"./$.enum-keys":19,"./$.get-names":22,"./$.keyof":29,"./$.redef":33,"./$.shared":37,"./$.uid":44,"./$.wks":46}],80:[function(require,module,exports){
'use strict';
var $         = require('./$')
  , weak      = require('./$.collection-weak')
  , leakStore = weak.leakStore
  , ID        = weak.ID
  , WEAK      = weak.WEAK
  , has       = $.has
  , isObject  = $.isObject
  , isExtensible = Object.isExtensible || isObject
  , tmp       = {};

// 23.3 WeakMap Objects
var $WeakMap = require('./$.collection')('WeakMap', function(get){
  return function WeakMap(){ return get(this, arguments[0]); };
}, {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      if(!isExtensible(key))return leakStore(this).get(key);
      if(has(key, WEAK))return key[WEAK][this[ID]];
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
}, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  $.each.call(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    require('./$.redef')(proto, key, function(a, b){
      // store frozen objects on leaky map
      if(isObject(a) && !isExtensible(a)){
        var result = leakStore(this)[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./$":28,"./$.collection":15,"./$.collection-weak":14,"./$.redef":33}],81:[function(require,module,exports){
'use strict';
var weak = require('./$.collection-weak');

// 23.4 WeakSet Objects
require('./$.collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments[0]); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./$.collection":15,"./$.collection-weak":14}],82:[function(require,module,exports){
'use strict';
var $def      = require('./$.def')
  , $includes = require('./$.array-includes')(true);
$def($def.P, 'Array', {
  // https://github.com/domenic/Array.prototype.includes
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments[1]);
  }
});
require('./$.unscope')('includes');
},{"./$.array-includes":7,"./$.def":17,"./$.unscope":45}],83:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Map');
},{"./$.collection-to-json":13}],84:[function(require,module,exports){
// https://gist.github.com/WebReflection/9353781
var $       = require('./$')
  , $def    = require('./$.def')
  , ownKeys = require('./$.own-keys');

$def($def.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O      = $.toObject(object)
      , result = {};
    $.each.call(ownKeys(O), function(key){
      $.setDesc(result, key, $.desc(0, $.getDesc(O, key)));
    });
    return result;
  }
});
},{"./$":28,"./$.def":17,"./$.own-keys":31}],85:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $    = require('./$')
  , $def = require('./$.def');
function createObjectToArray(isEntries){
  return function(object){
    var O      = $.toObject(object)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = Array(length)
      , key;
    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
    else while(length > i)result[i] = O[keys[i++]];
    return result;
  };
}
$def($def.S, 'Object', {
  values:  createObjectToArray(false),
  entries: createObjectToArray(true)
});
},{"./$":28,"./$.def":17}],86:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $def = require('./$.def');
$def($def.S, 'RegExp', {
  escape: require('./$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&', true)
});

},{"./$.def":17,"./$.replacer":34}],87:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
require('./$.collection-to-json')('Set');
},{"./$.collection-to-json":13}],88:[function(require,module,exports){
// https://github.com/mathiasbynens/String.prototype.at
'use strict';
var $def = require('./$.def')
  , $at  = require('./$.string-at')(true);
$def($def.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./$.def":17,"./$.string-at":39}],89:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  lpad: function lpad(n){
    return $pad(this, n, arguments[1], true);
  }
});
},{"./$.def":17,"./$.string-pad":40}],90:[function(require,module,exports){
'use strict';
var $def = require('./$.def')
  , $pad = require('./$.string-pad');
$def($def.P, 'String', {
  rpad: function rpad(n){
    return $pad(this, n, arguments[1], false);
  }
});
},{"./$.def":17,"./$.string-pad":40}],91:[function(require,module,exports){
// JavaScript 1.6 / Strawman array statics shim
var $       = require('./$')
  , $def    = require('./$.def')
  , $Array  = $.core.Array || Array
  , statics = {};
function setStatics(keys, length){
  $.each.call(keys.split(','), function(key){
    if(length == undefined && key in $Array)statics[key] = $Array[key];
    else if(key in [])statics[key] = require('./$.ctx')(Function.call, [][key], length);
  });
}
setStatics('pop,reverse,shift,keys,values,entries', 1);
setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
           'reduce,reduceRight,copyWithin,fill,turn');
$def($def.S, 'Array', statics);
},{"./$":28,"./$.ctx":16,"./$.def":17}],92:[function(require,module,exports){
require('./es6.array.iterator');
var $           = require('./$')
  , Iterators   = require('./$.iter').Iterators
  , ITERATOR    = require('./$.wks')('iterator')
  , ArrayValues = Iterators.Array
  , NL          = $.g.NodeList
  , HTC         = $.g.HTMLCollection
  , NLProto     = NL && NL.prototype
  , HTCProto    = HTC && HTC.prototype;
if($.FW){
  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);
  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);
}
Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;
},{"./$":28,"./$.iter":27,"./$.wks":46,"./es6.array.iterator":53}],93:[function(require,module,exports){
var $def  = require('./$.def')
  , $task = require('./$.task');
$def($def.G + $def.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./$.def":17,"./$.task":42}],94:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var $         = require('./$')
  , $def      = require('./$.def')
  , invoke    = require('./$.invoke')
  , partial   = require('./$.partial')
  , navigator = $.g.navigator
  , MSIE      = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
function wrap(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      $.isFunction(fn) ? fn : Function(fn)
    ), time);
  } : set;
}
$def($def.G + $def.B + $def.F * MSIE, {
  setTimeout:  wrap($.g.setTimeout),
  setInterval: wrap($.g.setInterval)
});
},{"./$":28,"./$.def":17,"./$.invoke":23,"./$.partial":32}],95:[function(require,module,exports){
require('./modules/es5');
require('./modules/es6.symbol');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.object.statics-accept-primitives');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.number.constructor');
require('./modules/es6.number.statics');
require('./modules/es6.math');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.iterator');
require('./modules/es6.array.species');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.regexp');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.reflect');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.lpad');
require('./modules/es7.string.rpad');
require('./modules/es7.regexp.escape');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.to-array');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/js.array.statics');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/$').core;

},{"./modules/$":28,"./modules/es5":47,"./modules/es6.array.copy-within":48,"./modules/es6.array.fill":49,"./modules/es6.array.find":51,"./modules/es6.array.find-index":50,"./modules/es6.array.from":52,"./modules/es6.array.iterator":53,"./modules/es6.array.of":54,"./modules/es6.array.species":55,"./modules/es6.function.has-instance":56,"./modules/es6.function.name":57,"./modules/es6.map":58,"./modules/es6.math":59,"./modules/es6.number.constructor":60,"./modules/es6.number.statics":61,"./modules/es6.object.assign":62,"./modules/es6.object.is":63,"./modules/es6.object.set-prototype-of":64,"./modules/es6.object.statics-accept-primitives":65,"./modules/es6.object.to-string":66,"./modules/es6.promise":67,"./modules/es6.reflect":68,"./modules/es6.regexp":69,"./modules/es6.set":70,"./modules/es6.string.code-point-at":71,"./modules/es6.string.ends-with":72,"./modules/es6.string.from-code-point":73,"./modules/es6.string.includes":74,"./modules/es6.string.iterator":75,"./modules/es6.string.raw":76,"./modules/es6.string.repeat":77,"./modules/es6.string.starts-with":78,"./modules/es6.symbol":79,"./modules/es6.weak-map":80,"./modules/es6.weak-set":81,"./modules/es7.array.includes":82,"./modules/es7.map.to-json":83,"./modules/es7.object.get-own-property-descriptors":84,"./modules/es7.object.to-array":85,"./modules/es7.regexp.escape":86,"./modules/es7.set.to-json":87,"./modules/es7.string.at":88,"./modules/es7.string.lpad":89,"./modules/es7.string.rpad":90,"./modules/js.array.statics":91,"./modules/web.dom.iterable":92,"./modules/web.immediate":93,"./modules/web.timers":94}],96:[function(require,module,exports){
(function (global){
var K = "@@KAISER";
var g = global;
if (!g[K]) {
    var w = [];
    k = {loaded: 0, waitingList: w};
    ["", "All", "Singleton", "Singletons", "Function", "Functions"].map(function (f) {
        var n = "register" + f;
        k[n] = function() {
            if (g[K].loaded) {
                g[K][n].apply(null, arguments);
            }
            else {
                w.push([n, [].slice.call(arguments)]);
            }
        };
     });
    g[K] = k;
}
module.exports = g[K];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],97:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(
      innerFn, self || null,
      new Context(tryLocsList || [])
    );

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument
        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
        : Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            return result;
          });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(function() {
          return invoke(method, arg);
        }) : new Promise(function(resolve) {
          resolve(invoke(method, arg));
        });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function(ignored){});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":707}],98:[function(require,module,exports){
(function (__filename){

var _util = require("../util");
var convertHTML = _util.convertHTML;
var normalize = _util.normalize;


function toDOM(tag, classes, attrs, children, raw) {

    if (tag === null) {
        if (children instanceof Element)
            return children;
        else
            return document.createTextNode(String(children));
    }
    
    if (tag == "top") tag = "";

    if (!tag && (equal(classes, []) && equal(attrs, {}))) {
        if (children.length == 1)
            return children[0];
        else {
            var node = document.createElement("div");
            children.forEach(function (x) {
                node.appendChild(x);
            });
            return node;
        }
    }

    tag = tag || "div";

    if (attrs.namespace)
        var node = document.createElementNS(attrs.namespace, tag);
    else
        var node = document.createElement(tag);

    if (attrs.id)
        node.id = attrs.id;

    if (classes.length > 0)
        node.className = classes.join(" ");

    if (raw) {
        node.innerHTML = raw;
    }

    items(attrs).forEach(function (kv) {
        if (kv[0].startsWith("on"))
            node[kv[0]] = kv[1];
        else
            node.setAttribute(kv[0], kv[1]);
    });

    children.forEach(function (c) {
        node.appendChild(c);
    });

    return node;
}


function DOM(enode, converter) {
    if (!converter)
        converter = toDOM;
    var res = convertHTML(enode, converter);
    if (Array.isArray(res))
        res = converter("top", [], {}, res, null);
    return res;
}

function DOMNode(tags, props, children) {
    if (!Array.isArray(children))
        children = [children];
    return toDOM.apply(null, normalize(tags, props, children));
}

function percentMacro(expr) {
    var DOMNode = this.deps.DOMNode;
    return ["multi",
            ["send", ["symbol", "="],
             ["data",
              ["send", ["symbol", "let"], ["symbol", "ENode"]],
              DOMNode]],
            ["send",
             ["symbol", "%"],
             ["data", expr[1], expr[2]]]]
}
percentMacro.__deps = {DOMNode: "ENode"};
percentMacro.__path = __filename;

module.exports = DOM;
DOM.DOM = DOM;
DOM.toDOM = toDOM;
DOM.ENode = DOMNode;
DOM["%"] = percentMacro;
DOM.normalize = normalize;

}).call(this,"/node_modules/earlgrey-runtime/std/dom.js")
},{"../util":100}],99:[function(require,module,exports){
(function (__filename){

var _util = require("../util");
var convertHTML = _util.convertHTML;
var normalize = _util.normalize;

function escapeHTML(s) {
    var repl = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
    }
    return s.replace(/[&<>]/g, function (x) { return repl[x]; });
}

function quotify(s) {
    return '"' + s.replace(/["\\]/g, function (x) { return "\\" + x; }) + '"';
}

var voidTags = [
    "area", "base", "br", "col", "command", "embed", "hr",
    "img", "input", "keygen", "link", "meta", "param", "source",
    "track", "wbr"
]

function toHTML(tag, classes, attrs, children, raw) {
    if (tag === null)
        return escapeHTML(String(children));

    var result = "";

    if (tag == "top") tag = "";

    if (!equal(classes, [])) {
        attrs["class"] = classes.join(" ");
    }
    if (!tag && (!equal(classes, []) || !equal(attrs, {}))) {
        tag = "div";
    }

    if (tag) result += "<" + tag;
    items(attrs).forEach(function (kv) {
        if (kv[1] === true) {
            result += " " + kv[0];
        }
        else if (kv[1] !== false) {
            result += " " + kv[0] + "=" + quotify(String(kv[1]));
        }
    });
    if (tag) result += ">";

    var closeTag = tag && voidTags.indexOf(tag) == -1;

    if (raw !== null) {
        result += raw;
        closeTag = !!tag;
    }
    else if (children.length > 0) {
        children.forEach(function (c) {
            result += c;
        });
        closeTag = !!tag;
    }

    if (closeTag)
        result += "</" + tag + ">"

    return result;
}

function HTML(enode, converter) {
    if (!converter)
        converter = toHTML;
    var res = convertHTML(enode, converter);
    if (Array.isArray(res))
        res = converter("top", [], {}, res, null);
    return res;
}

function HTMLNode(tags, props, children) {
    if (!Array.isArray(children))
        children = [children];
    return toHTML.apply(null, normalize(tags, props, children));
}

function percentMacro(expr) {
    var HTMLNode = this.deps.HTMLNode;
    return ["multi",
            ["send", ["symbol", "="],
             ["data",
              ["send", ["symbol", "let"], ["symbol", "ENode"]],
              HTMLNode]],
            ["send",
             ["symbol", "%"],
             ["data", expr[1], expr[2]]]]
}
percentMacro.__deps = {HTMLNode: "ENode"};
percentMacro.__path = __filename;

module.exports = HTML;
HTML.HTML = HTML;
HTML.toHTML = toHTML;
HTML.ENode = HTMLNode;
HTML["%"] = percentMacro;
HTML.normalize = normalize;

}).call(this,"/node_modules/earlgrey-runtime/std/html.js")
},{"../util":100}],100:[function(require,module,exports){

function normalize(tags, _attrs, _children) {

    var raw = null;
    var tag = "";
    var attrs = clone(_attrs);
    var classes = attrs["class"] ? [attrs["class"]] : [];
    delete attrs["class"];
    var children = [];

    tags.forEach(function (t) {
        if (t[0] === ".")
            classes.push(t.slice(1));
        else if (t[0] === "#")
            attrs.id = t.slice(1);
        else if (t === "raw")
            raw = true;
        else
            tag = t;
    });

    if (attrs.innerHTML) {
        raw = attrs.innerHTML;
        delete attrs.innerHTML;
    }

    if (raw) {
        raw = collapse(_children).map(function (x) { return String(x); }).join("");
    }
    else {
        children = collapse(_children);
    }

    return [tag, classes, attrs, children, raw];
}

exports.normalize = normalize

function collapse(x) {
    if (Array.isArray(x)) {
        var res = [];
        x.forEach(function (y) {
            if (Array.isArray(y))
                res = res.concat(y);
            else
                res.push(y);
        });
        return res;
    }
    else {
        return x;
    }
}

function convertHTML(x, create) {
    if (Array.isArray(x)) {
        return collapse(x.map(function (x) { return convertHTML(x, create); }));
    }
    else if (x instanceof ENode) {
        var norm = normalize(x.tags, x.props, x.children);
        norm[3] = norm[3].map(function (x) {
            return convertHTML(x, create)
        });
        return create.apply(x, norm);
    }
    else {
        return create.call(x, null, [], {}, x, null);
    }
}

exports.convertHTML = convertHTML


},{}],101:[function(require,module,exports){

module.exports = require("./lib5/earl-grey.js");

},{"./lib5/earl-grey.js":102}],102:[function(require,module,exports){
(function (process,global,Buffer){
"use strict";

require("earlgrey-runtime/5");var $targ$3 = undefined;var accum$0 = undefined;var $targ$4 = undefined;var accum$1 = undefined;var $targ$18 = undefined;var accum$2 = undefined;var $targ$19 = undefined;var accum$3 = undefined;var $targ$20 = undefined;var $targ$21 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var $targ$25 = undefined;var $targ$26 = undefined;var $targ$27 = undefined;var $targ$28 = undefined;var $0$0 = undefined;var Source$0 = undefined;var Location$0 = undefined;var highlight_locations$0 = undefined;var __lt____lt____colon__$0 = undefined;var $1$0 = undefined;var tokenize$0 = undefined;var $2$0 = undefined;var parse$0 = undefined;var $3$0 = undefined;var Translator$0 = undefined;var std$0 = undefined;var exp$0 = undefined;var opt$0 = undefined;var $7$0 = undefined;var Body$0 = undefined;var GenSym$0 = undefined;var vm$0 = undefined;var module$0 = undefined;var path$0 = undefined;var smap$0 = undefined;var SourceNode$0 = undefined;var $9$0 = undefined;var transfer$0 = undefined;var $10$0 = undefined;var version$0 = undefined;var $11$0 = undefined;var evaluator$0 = undefined;var es5Transform$0 = undefined;var globalizer$0 = undefined;var Pipeline$0 = undefined;var collapse$0 = undefined;var makeAnnotatedAST$0 = undefined;var toCodeAndSourceMap$0 = undefined;var Generator$0 = undefined;var compile$0 = undefined;$0$0 = require("./location");Source$0 = getProperty($0$0, "Source", "./location");Location$0 = getProperty($0$0, "Location", "./location");highlight_locations$0 = getProperty($0$0, "highlight_locations", "./location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "./location");$1$0 = require("./lex");tokenize$0 = getProperty($1$0, "tokenize", "./lex");$2$0 = require("./parse");parse$0 = getProperty($2$0, "parse", "./parse");$3$0 = require("./translate-js");Translator$0 = getProperty($3$0, "Translator", "./translate-js");std$0 = require("./stdenv");exp$0 = require("./expand");opt$0 = require("./opt");$7$0 = require("./util");Body$0 = getProperty($7$0, "Body", "./util");GenSym$0 = getProperty($7$0, "GenSym", "./util");vm$0 = require("vm");module$0 = require("module");path$0 = require("path");smap$0 = require("source-map");SourceNode$0 = getProperty(smap$0, "SourceNode", "smap");$9$0 = require("multi-stage-sourcemap");transfer$0 = getProperty($9$0, "transfer", "multi-stage-sourcemap");$10$0 = require("./version");version$0 = getProperty($10$0, "version", "./version");$11$0 = require("./evaluator");evaluator$0 = getProperty($11$0, "evaluator", "./evaluator");es5Transform$0 = function es5Transform() {
  var babel$0 = undefined;var x$0 = undefined;var opts$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 1 && t0$0 <= 2) {
    x$0 = m$0$0[0];if (1 >= t0$0) {
      opts$0 = null;
    } else {
      opts$0 = m$0$0[1];
    }babel$0 = require("babel");return babel$0.transform(x$0, opts$0);
  } else {
    return ___match_error(m$0$0, "{x, opts = null}");
  }
};globalizer$0 = GenSym$0("_$$_");Pipeline$0 = function Pipeline(temp$0$0) {
  var $targ$0 = undefined;var $targ$1 = undefined;var $targ$2 = undefined;var $it$0 = undefined;if (!getChecker(Pipeline$0)(this)) {
    $it$0 = Object.create(Pipeline$0.prototype);
  } else {
    $it$0 = this;
  }$it$0.opts = temp$0$0;$targ$0 = globalizer$0;$it$0.gensym = $targ$0;$targ$1 = std$0.make_expander($it$0);$it$0._expander = $targ$1;$targ$2 = $it$0._expander.mkenv();$it$0.env = $targ$2;return $it$0;
};Pipeline$0.prototype.parse = function parse(source$0) {
  var t$0 = undefined;var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;t$0 = tokenize$0(source$0);return parse$0(t$0);
};Pipeline$0.prototype.expand = function expand(ast$0) {
  var $it$2 = undefined;var self$1 = undefined;$it$2 = this;self$1 = this;return $it$2._expander.expand(["top"], exp$0.topscope, $it$2.env.mark(ast$0));
};Pipeline$0.prototype.translate = function translate(ast$1) {
  var r$0 = undefined;var res$0 = undefined;var globvar$0 = undefined;var tr$0 = undefined;var rval$0 = undefined;var prep$0 = undefined;var $it$3 = undefined;var self$2 = undefined;$it$3 = this;self$2 = this;res$0 = opt$0.hoist(ast$1);globvar$0 = $it$3.gensym("global");tr$0 = Translator$0(null, globvar$0);rval$0 = collapse$0(tr$0.translate(res$0, "expr"));prep$0 = tr$0.dump_store();r$0 = "\"use strict\";" + prep$0 + ";(" + rval$0 + ")";return { code: $it$3.opts.es5 ? es5Transform$0(r$0).code : r$0, globvar: globvar$0, global: Object.create(global), location: ast$1.location };
};Pipeline$0.prototype.evaluate = function evaluate(src$0) {
  var tmp$1 = undefined;var tmp$0 = undefined;var ev$0 = undefined;var url$0 = undefined;var $it$4 = undefined;var self$3 = undefined;$it$4 = this;self$3 = this;tmp$1 = send(src$0, "location", true);if (tmp$1 === undefined) {
    tmp$0 = undefined;
  } else {
    tmp$0 = send(tmp$1, "source", true);
  }if (tmp$0 === undefined) {
    url$0 = undefined;
  } else {
    url$0 = tmp$0.url;
  }ev$0 = evaluator$0({ globvar: src$0.globvar, global: src$0.global, filename: url$0 || "<eval>", showname: url$0 || "<eval>", cwd: url$0 });return ev$0(src$0.code);
};Pipeline$0.prototype.go = function go(x$1, temp$1$0, end$0) {
  var t0$1 = undefined;var start$0 = undefined;var ph$0$0 = undefined;var $it$5 = undefined;var self$4 = undefined;$it$5 = this;self$4 = this;t0$1 = temp$1$0;start$0 = t0$1;ph$0$0 = t0$1;if (start$0 === end$0 || start$0 === "eval") {
    return x$1;
  } else {
    if (ph$0$0 === "source") {
      return $it$5.go($it$5.parse(x$1), "parse", end$0);
    } else {
      if (ph$0$0 === "parse") {
        return $it$5.go($it$5.expand(x$1), "expand", end$0);
      } else {
        if (ph$0$0 === "expand") {
          return $it$5.go($it$5.translate(x$1), "translate", end$0);
        } else {
          if (ph$0$0 === "translate") {
            return $it$5.go($it$5.evaluate(x$1), "eval", end$0);
          } else {
            throw ErrorFactory(["pipeline"]).create("Unknown pipeline stage: " + start$0);
          }
        }
      }
    }
  }
};__amp____colon__(Pipeline$0, __amp____colon__(($targ$3 = "Pipeline", accum$0 = {}, accum$0["::name"] = $targ$3, accum$0), ($targ$4 = true, accum$1 = {}, accum$1["::egclass"] = $targ$4, accum$1)));collapse$0 = function collapse(temp$2$0) {
  var t0$2 = undefined;var acc$0 = undefined;var parts$0 = undefined;var t$1 = undefined;var s$1 = undefined;var tags$0 = undefined;var props$0 = undefined;var children$0 = undefined;var $$359$0 = undefined;var t0$3 = undefined;var node$0 = undefined;var ph$1$0 = undefined;t0$2 = temp$2$0;node$0 = t0$2;ph$1$0 = t0$2;t0$3 = ph$1$0;if (getChecker(ENode)(t0$3) && (___hasprop(t0$3, "tags") && (tags$0 = t0$3.tags, ___hasprop(t0$3, "props") && (props$0 = t0$3.props, ___hasprop(t0$3, "children"))))) {
    children$0 = t0$3.children;parts$0 = [];acc$0 = function acc(ph$2$0) {
      var m$1 = undefined;var acc$1 = undefined;var temp$3 = undefined;var n$0 = undefined;var xs$0$0 = undefined;var s$0 = undefined;var $$393$0 = undefined;var t0$4 = undefined;t0$4 = ph$2$0;if (typeof t0$4 === "string") {
        s$0 = t0$4;return parts$0.push(s$0);
      } else {
        if (Array.isArray(t0$4)) {
          xs$0$0 = t0$4;acc$1 = [];temp$3 = null;m$1 = null;$12: for (var _iterator = xs$0$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
            m$1 = _step.value;
            var x$2 = undefined;x$2 = m$1;temp$3 = acc$0(x$2);acc$1.push(temp$3);
          }return acc$1;
        } else {
          if (getChecker(ENode)(t0$4)) {
            n$0 = t0$4;return parts$0.push(collapse$0(n$0));
          } else {
            return ___match_error(ph$2$0, "ENode? n");
          }
        }
      }
    };acc$0(children$0);return parts$0.join("");
  } else {
    if (typeof t0$3 === "string") {
      s$1 = t0$3;return s$1;
    } else {
      t$1 = node$0;console.log(t$1);throw ErrorFactory(["invalid_translation_node"]).create(node$0);
    }
  }
};makeAnnotatedAST$0 = function makeAnnotatedAST(temp$4$0) {
  var t0$5 = undefined;var acc$2 = undefined;var t0$8 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var loc$0 = undefined;var $targ$5 = undefined;var l$0 = undefined;var c$0 = undefined;var src$1 = undefined;var rval$1 = undefined;var parts$1 = undefined;var t$2 = undefined;var s$3 = undefined;var tags$1 = undefined;var props$1 = undefined;var children$1 = undefined;var $$456$0 = undefined;var t0$6 = undefined;var node$1 = undefined;var ph$3$0 = undefined;t0$5 = temp$4$0;node$1 = t0$5;ph$3$0 = t0$5;t0$6 = ph$3$0;if (getChecker(ENode)(t0$6) && (___hasprop(t0$6, "tags") && (tags$1 = t0$6.tags, ___hasprop(t0$6, "props") && (props$1 = t0$6.props, ___hasprop(t0$6, "children"))))) {
    children$1 = t0$6.children;parts$1 = [];acc$2 = function acc(ph$4$0) {
      var m$2 = undefined;var acc$3 = undefined;var temp$5 = undefined;var n$1 = undefined;var xs$1$0 = undefined;var s$2 = undefined;var $$490$0 = undefined;var t0$7 = undefined;t0$7 = ph$4$0;if (typeof t0$7 === "string") {
        s$2 = t0$7;return parts$1.push(s$2);
      } else {
        if (Array.isArray(t0$7)) {
          xs$1$0 = t0$7;acc$3 = [];temp$5 = null;m$2 = null;$13: for (var _iterator = xs$1$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
            m$2 = _step.value;
            var x$3 = undefined;x$3 = m$2;temp$5 = acc$2(x$3);acc$3.push(temp$5);
          }return acc$3;
        } else {
          if (getChecker(ENode)(t0$7)) {
            n$1 = t0$7;return parts$1.push(makeAnnotatedAST$0(n$1));
          } else {
            return ___match_error(ph$4$0, "ENode? n");
          }
        }
      }
    };acc$2(children$1);if (props$1.origin && props$1.origin.location) {
      loc$0 = props$1.origin.location;$targ$5 = loc$0.linecol();t0$8 = $targ$5;if (Array.isArray(t0$8) && (t1$0 = t0$8.length, t1$0 === 2 && (t2$0 = t0$8[0], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 2)))) {
        l$0 = t2$0[0];c$0 = t2$0[1];t0$8[1];
      } else {
        ___match_error($targ$5, "{{var l, var c}, _}");
      }[l$0, c$0];src$1 = loc$0.source.url;rval$1 = new SourceNode$0(l$0, c$0, src$1 || "<unknown>", parts$1);return rval$1;
    } else {
      return parts$1;
    }
  } else {
    if (typeof t0$6 === "string") {
      s$3 = t0$6;return s$3;
    } else {
      t$2 = node$1;console.log(t$2);throw ErrorFactory(["invalid_translation_node"]).create(node$1);
    }
  }
};toCodeAndSourceMap$0 = function toCodeAndSourceMap(node$2, url$1) {
  var ast$2 = undefined;var obj$0 = undefined;ast$2 = makeAnnotatedAST$0(node$2);if (!getChecker(SourceNode$0)(ast$2)) {
    ast$2 = new SourceNode$0(1, 0, null, ast$2);ast$2;
  }obj$0 = ast$2.toStringWithSourceMap({ file: url$1 });return obj$0;
};Generator$0 = function Generator() {
  var $targ$12 = undefined;var m$4 = undefined;var $targ$13 = undefined;var m$5$0 = undefined;var $14$0 = undefined;var install$0 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var use__minus__es6$0 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var t0$9 = undefined;var m$3$0 = undefined;var $it$6 = undefined;if (!getChecker(Generator$0)(this)) {
    $it$6 = Object.create(Generator$0.prototype);
  } else {
    $it$6 = this;
  }m$3$0 = arguments;t0$9 = m$3$0.length;if (t0$9 >= 0 && t0$9 <= 1) {
    $it$6.opts = 0 >= t0$9 ? {} : m$3$0[0];if ($it$6.opts.runtime === undefined) {
      $targ$12 = "earlgrey-runtime";$it$6.opts.runtime = $targ$12;void 0;
    }$14$0 = require("./register");install$0 = getProperty($14$0, "install", "./register")($it$6.opts);$targ$6 = Translator$0(null, $it$6.opts.globvar);$it$6.tr = $targ$6;$targ$7 = std$0.stdenv.fork();$it$6.env = $targ$7;m$4 = null;$15: for (var _iterator = items($it$6.opts.parameters || {})[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$4 = _step.value;
      var k$0 = undefined;var v$0 = undefined;var t0$10 = undefined;var t1$1 = undefined;t0$10 = m$4;if (Array.isArray(t0$10) && (t1$1 = t0$10.length, t1$1 === 2)) {
        k$0 = t0$10[0];v$0 = t0$10[1];$it$6.env.setopt(exp$0.topscope, k$0, v$0);
      } else {
        ___match_error(m$4);
      }
    }$targ$8 = $it$6.opts.interactive;$it$6.interactive = $targ$8;if ($it$6.interactive) {
      $targ$13 = null;$it$6.opts.runtime = $targ$13;void 0;
    }$targ$9 = null;$it$6._eval = $targ$9;m$5$0 = process.title;if (m$5$0 === "node") {
      use__minus__es6$0 = parseInt(process.version.split(".")[0].slice(1)) >= 4;
    } else {
      if (m$5$0 === "iojs") {
        use__minus__es6$0 = true;
      } else {
        use__minus__es6$0 = false;
      }
    }$targ$10 = Pipeline$0(__amp__({ es5: !use__minus__es6$0 }, $it$6.opts));$it$6.pipeline = $targ$10;$targ$11 = std$0.make_expander($it$6.pipeline);$it$6.expander = $targ$11;void 0;
  } else {
    ___match_error(m$3$0, "{@opts = {=}}");
  }return $it$6;
};Generator$0.prototype.generateInteractive = function generateInteractive() {
  var t0$12 = undefined;var t1$2 = undefined;var t2$1 = undefined;var $targ$14 = undefined;var args$0 = undefined;var stmt$0 = undefined;var body$2 = undefined;var vars$0 = undefined;var body$1 = undefined;var t0$13 = undefined;var m$7$0 = undefined;var rt$1 = undefined;var rt$0 = undefined;var m$8$0 = undefined;var t$3 = undefined;var p$0 = undefined;var ex$0 = undefined;var wrap$0 = undefined;var result$0 = undefined;var source$1 = undefined;var opts$1 = undefined;var t0$11 = undefined;var m$6$0 = undefined;var $it$7 = undefined;var self$5 = undefined;$it$7 = this;self$5 = this;m$6$0 = arguments;t0$11 = m$6$0.length;if (t0$11 >= 1 && t0$11 <= 2) {
    source$1 = m$6$0[0];if (1 >= t0$11) {
      opts$1 = {};
    } else {
      opts$1 = m$6$0[1];
    }opts$1 = __amp__($it$7.opts, opts$1);t$3 = tokenize$0(source$1);p$0 = parse$0(t$3);if ($it$7.interactive) {
      $targ$14 = p$0;t0$12 = getProjector(Body$0)($targ$14);if (t0$12[0] && (t1$2 = t0$12[1], t2$1 = t1$2.length, t2$1 >= 0)) {
        args$0 = Array.prototype.slice.call(t1$2, 0);
      } else {
        ___match_error($targ$14, "Body! {*args}");
      }stmt$0 = ["interactive"].concat(args$0);
    } else {
      stmt$0 = ["multi", p$0];
    }ex$0 = $it$7.expander.expand(["top"], opts$1.scope || exp$0.topscope, $it$7.env.mark(stmt$0));wrap$0 = function wrap(body$0) {
      return ["send", ["variable", "spawn"], ["array", ["lambda", [], body$0, ["value", true]]]];
    };m$7$0 = ex$0;if (Array.isArray(m$7$0) && (t0$13 = m$7$0.length, t0$13 === 3 && m$7$0[0] === "scope")) {
      vars$0 = m$7$0[1];body$1 = m$7$0[2];ex$0 = ["scope", vars$0, wrap$0(body$1)];
    } else {
      body$2 = m$7$0;ex$0 = wrap$0(body$2);
    }ex$0 = opt$0.hoist(ex$0);result$0 = $it$7.tr.translate(ex$0, "stmt");result$0 = ENode(["splice"], {}, ["\n'use strict';", (m$8$0 = opts$1.runtime, m$8$0 === null ? "" : (rt$0 = m$8$0, opts$1.es5 ? "require('" + rt$0 + "/5');" : (rt$1 = m$8$0, "require('" + rt$1 + "/6');"))), result$0]);result$0 = collapse$0(result$0);if (opts$1.es5) {
      result$0 = es5Transform$0(result$0, {}).code;result$0;
    }return result$0;
  } else {
    return ___match_error(m$6$0, "{source, var opts = {=}}");
  }
};Generator$0.prototype.generate = function generate() {
  var t0$15 = undefined;var t1$3 = undefined;var t2$2 = undefined;var $targ$15 = undefined;var args$1 = undefined;var stmt$1 = undefined;var rt$3 = undefined;var rt$2 = undefined;var m$10$0 = undefined;var t0$16 = undefined;var $targ$16 = undefined;var code$0 = undefined;var map$0 = undefined;var newmap$0 = undefined;var parts$2 = undefined;var smname$0 = undefined;var m$11$0 = undefined;var t$4 = undefined;var p$1 = undefined;var ex$1 = undefined;var result$1 = undefined;var source$2 = undefined;var opts$2 = undefined;var t0$14 = undefined;var m$9$0 = undefined;var $it$8 = undefined;var self$6 = undefined;$it$8 = this;self$6 = this;m$9$0 = arguments;t0$14 = m$9$0.length;if (t0$14 >= 1 && t0$14 <= 2) {
    source$2 = m$9$0[0];if (1 >= t0$14) {
      opts$2 = {};
    } else {
      opts$2 = m$9$0[1];
    }opts$2 = __amp__($it$8.opts, opts$2);t$4 = tokenize$0(source$2);p$1 = parse$0(t$4);if ($it$8.interactive) {
      $targ$15 = p$1;t0$15 = getProjector(Body$0)($targ$15);if (t0$15[0] && (t1$3 = t0$15[1], t2$2 = t1$3.length, t2$2 >= 0)) {
        args$1 = Array.prototype.slice.call(t1$3, 0);
      } else {
        ___match_error($targ$15, "Body! {*args}");
      }stmt$1 = ["interactive"].concat(args$1);
    } else {
      stmt$1 = ["multi", p$1];
    }ex$1 = $it$8.expander.expand(["top"], opts$2.scope || exp$0.topscope, $it$8.env.mark(stmt$1));ex$1 = opt$0.hoist(ex$1);result$1 = $it$8.tr.translate(ex$1, "stmt");result$1 = ENode(["splice"], {}, ["\n'use strict';", (m$10$0 = opts$2.runtime, m$10$0 === null ? "" : (rt$2 = m$10$0, opts$2.es5 ? "require('" + rt$2 + "/5');" : (rt$3 = m$10$0, "require('" + rt$3 + "/6');"))), $it$8.tr.dump_store(), result$1]);if (!opts$2.sourceMap) {
      result$1 = collapse$0(result$1);if (opts$2.es5) {
        result$1 = es5Transform$0(result$1, {}).code;result$1;
      }return { code: result$1, map: null };
    } else {
      result$1 = toCodeAndSourceMap$0(result$1, source$2.url);if (opts$2.es5) {
        $targ$16 = es5Transform$0(result$1.code, { sourceMap: true });t0$16 = $targ$16;if (___hasprop(t0$16, "code") && (code$0 = t0$16.code, ___hasprop(t0$16, "map"))) {
          map$0 = t0$16.map;
        } else {
          ___match_error($targ$16, "{=> code, => map}");
        }[code$0, map$0];newmap$0 = transfer$0({ fromSourceMap: map$0, toSourceMap: result$1.map.toString() });result$1 = { code: code$0, map: newmap$0 };result$1;
      }m$11$0 = opts$2.sourceMap;if (m$11$0 === "inline") {
        return result$1.code + "\n/" + "/# sourceMappingURL=data:application/json;base64," + new Buffer(result$1.map.toString()).toString("base64") + ".map\n";
      } else {
        if (m$11$0 === "compute") {
          return result$1;
        } else {
          parts$2 = source$2.url.split("/");smname$0 = send(parts$2, parts$2.length - 1).replace(RegExp(".eg$", ""), ".js");result$1.code = result$1.code + ("\n/" + "/# sourceMappingURL=" + smname$0 + ".map\n");return result$1;
        }
      }
    }
  } else {
    return ___match_error(m$9$0, "{source, var opts = {=}}");
  }
};Generator$0.prototype.getEval = function getEval(file$0) {
  var $targ$17 = undefined;var $it$9 = undefined;var self$7 = undefined;$it$9 = this;self$7 = this;if (!$it$9._eval) {
    $targ$17 = evaluator$0({ globvar: $it$9.tr.globvar, global: null, filename: file$0, showname: file$0, cwd: file$0 });$it$9._eval = $targ$17;void 0;
  }return $it$9._eval;
};Generator$0.prototype.evaluate = function evaluate(source$3) {
  var $it$10 = undefined;var self$8 = undefined;$it$10 = this;self$8 = this;return $it$10.getEval(source$3.url)($it$10.generate(source$3, { runtime: null }).code);
};Generator$0.prototype.evaluateInteractive = function evaluateInteractive() {
  var source$4 = undefined;var opts$3 = undefined;var t0$17 = undefined;var m$12$0 = undefined;var $it$11 = undefined;var self$9 = undefined;$it$11 = this;self$9 = this;m$12$0 = arguments;t0$17 = m$12$0.length;if (t0$17 >= 1 && t0$17 <= 2) {
    source$4 = m$12$0[0];if (1 >= t0$17) {
      opts$3 = {};
    } else {
      opts$3 = m$12$0[1];
    }return $it$11.getEval(source$4.url)($it$11.generateInteractive(source$4, __amp__(opts$3, { runtime: null })));
  } else {
    return ___match_error(m$12$0, "{source, opts = {=}}");
  }
};__amp____colon__(Generator$0, __amp____colon__(($targ$18 = "Generator", accum$2 = {}, accum$2["::name"] = $targ$18, accum$2), ($targ$19 = true, accum$3 = {}, accum$3["::egclass"] = $targ$19, accum$3)));compile$0 = function compile() {
  var source$5 = undefined;var ph$6$0 = undefined;var options$0 = undefined;var t0$18 = undefined;var t1$4 = undefined;var m$13$0 = undefined;m$13$0 = arguments;t0$18 = m$13$0.length;if (t0$18 >= 1 && t0$18 <= 2) {
    t1$4 = m$13$0[0];source$5 = t1$4;ph$6$0 = t1$4;if (1 >= t0$18) {
      options$0 = {};
    } else {
      options$0 = m$13$0[1];
    }if (typeof ph$6$0 === "string") {
      return Generator$0(options$0).generate(Source$0(source$5, options$0.path || "<file>"));
    } else {
      if (getChecker(Source$0)(ph$6$0)) {
        return Generator$0(options$0).generate(source$5);
      } else {
        return ___match_error(ph$6$0, "Source? ");
      }
    }
  } else {
    return ___match_error(m$13$0, "{match source, options = {=}}");
  }
};$targ$20 = evaluator$0;exports.evaluator = $targ$20;$targ$21 = Source$0;exports.Source = $targ$21;$targ$22 = Location$0;exports.Location = $targ$22;$targ$23 = highlight_locations$0;exports.highlight_locations = $targ$23;$targ$24 = tokenize$0;exports.tokenize = $targ$24;$targ$25 = parse$0;exports.parse = $targ$25;$targ$26 = Generator$0;exports.Generator = $targ$26;$targ$27 = version$0;exports.version = $targ$27;$targ$28 = compile$0;exports.compile = $targ$28;void 0;
//# sourceMappingURL=earl-grey.js.map


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./evaluator":103,"./expand":104,"./lex":105,"./location":106,"./opt":119,"./parse":120,"./register":123,"./stdenv":124,"./translate-js":125,"./util":126,"./version":127,"_process":707,"babel":128,"buffer":699,"earlgrey-runtime/5":446,"module":697,"multi-stage-sourcemap":539,"path":706,"source-map":571,"vm":724}],103:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var module$0 = undefined;var path$0 = undefined;var vm$0 = undefined;var evaluator$0 = undefined;module$0 = require("module");path$0 = require("path");vm$0 = require("vm");evaluator$0 = function evaluator(options$0) {
  var g$0 = undefined;var m$1$0 = undefined;var gl$0 = undefined;var $targ$0 = undefined;var g$1 = undefined;var m$0$0 = undefined;var accum$0 = undefined;var paths$0 = undefined;var e_module$0 = undefined;var e_require$0 = undefined;var setup$0 = undefined;var __eval$0 = undefined;var req$0 = undefined;var glob$0 = undefined;req$0 = require;if (options$0.globvar) {
    m$0$0 = send(global, options$0.globvar);if (m$0$0 === void 0) {
      m$1$0 = options$0.global;if (m$1$0 === true) {
        gl$0 = global;
      } else {
        if (getChecker(Object)(m$1$0)) {
          g$0 = m$1$0;gl$0 = g$0;
        } else {
          gl$0 = Object.create(global);
        }
      }$targ$0 = gl$0;global[options$0.globvar] = $targ$0;glob$0 = gl$0;
    } else {
      g$1 = m$0$0;glob$0 = g$1;
    }
  } else {
    glob$0 = global;
  }if (module$0._nodeModulePaths) {
    if (options$0.cwd) {
      paths$0 = module$0._nodeModulePaths(options$0.cwd);
    } else {
      paths$0 = [];
    }e_module$0 = new module$0(options$0.showname);__amp____colon__(e_module$0, { filename: options$0.filename, paths: paths$0 });e_require$0 = function e_require(path$1) {
      return module$0._load(path$1, e_module$0, true);
    };__amp____colon__(e_require$0, __amp____colon__({ main: e_module$0 }, __amp____colon__((accum$0 = {}, accum$0.resolve = function resolve(path$2) {
      return module$0._resolveFileName(path$2, e_module$0);
    }, accum$0), { paths: paths$0, cache: req$0.cache })));setup$0 = { __filename: options$0.filename, __dirname: path$0.dirname(options$0.filename), module: e_module$0, require: e_require$0, exports: {} };__amp____colon__(glob$0, setup$0);return function (code$0) {
      var script$0 = undefined;var rval$0 = undefined;script$0 = vm$0.createScript(code$0, options$0.showname);rval$0 = script$0.runInThisContext();return rval$0;
    };
  } else {
    __eval$0 = eval;return function (code$1) {
      return __eval$0(code$1);
    };
  }
};$targ$1 = evaluator$0;exports.evaluator = $targ$1;void 0;
//# sourceMappingURL=evaluator.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"earlgrey-runtime/5":446,"module":697,"path":706,"vm":724}],104:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var accum$0 = undefined;var $targ$2 = undefined;var accum$1 = undefined;var $targ$14 = undefined;var accum$2 = undefined;var $targ$15 = undefined;var accum$3 = undefined;var $targ$17 = undefined;var accum$4 = undefined;var $targ$18 = undefined;var accum$5 = undefined;var $targ$33 = undefined;var accum$6 = undefined;var $targ$34 = undefined;var accum$7 = undefined;var $targ$35 = undefined;var $targ$36 = undefined;var $targ$37 = undefined;var $targ$38 = undefined;var $targ$39 = undefined;var $targ$40 = undefined;var $targ$41 = undefined;var $targ$42 = undefined;var $targ$43 = undefined;var $0$0 = undefined;var transferLocation$0 = undefined;var Source$0 = undefined;var util$0 = undefined;var classify$0 = undefined;var GenSym$0 = undefined;var gensym$0 = undefined;var camelCase$0 = undefined;var invCamelCase$0 = undefined;var $2$0 = undefined;var tokenize$0 = undefined;var $3$0 = undefined;var parse$0 = undefined;var __lt____lt____colon__$0 = undefined;var jsKeywords$0 = undefined;var Scope$0 = undefined;var Env$0 = undefined;var track_location$0 = undefined;var Info$0 = undefined;var Expander$0 = undefined;var topscope$0 = undefined;$0$0 = require("./location");transferLocation$0 = getProperty($0$0, "<<:", "./location");Source$0 = getProperty($0$0, "Source", "./location");util$0 = require("./util");classify$0 = getProperty(util$0, "classify", "util");GenSym$0 = getProperty(util$0, "GenSym", "util");gensym$0 = getProperty(util$0, "gensym", "util");camelCase$0 = getProperty(util$0, "camelCase", "util");invCamelCase$0 = getProperty(util$0, "invCamelCase", "util");$2$0 = require("./lex");tokenize$0 = getProperty($2$0, "tokenize", "./lex");$3$0 = require("./parse");parse$0 = getProperty($3$0, "parse", "./parse");__lt____lt____colon__$0 = function (a$0, b$0) {
  var $$1254$0 = undefined;var m$0$0 = undefined;transferLocation$0(a$0, b$0);m$0$0 = a$0;if (getChecker(Error)(m$0$0)) {
    return a$0;
  } else {
    if (b$0.name) {
      return __amp____colon__(a$0, { name: b$0.name });
    } else {
      return a$0;
    }
  }
};jsKeywords$0 = "abstract arguments boolean break byte\n              case catch char class const\n              continue debugger default delete do\n              double else enum eval export\n              extends false final finally float\n              for function goto if implements\n              import in instanceof int interface\n              let long native new null\n              package private protected public return\n              short static super switch synchronized\n              this throw throws transient true\n              try typeof var void volatile\n              while with yield".split(RegExp("[ \\n]+", ""));Scope$0 = function Scope() {
  var $targ$0 = undefined;var t0$0 = undefined;var m$1$0 = undefined;var $it$0 = undefined;if (!getChecker(Scope$0)(this)) {
    $it$0 = Object.create(Scope$0.prototype);
  } else {
    $it$0 = this;
  }m$1$0 = arguments;t0$0 = m$1$0.length;if (t0$0 >= 0 && t0$0 <= 3) {
    $it$0.parent = 0 >= t0$0 ? null : m$1$0[0];$it$0.name = 1 >= t0$0 ? gensym$0("scope") : m$1$0[1];$it$0.top = 2 >= t0$0 ? false : m$1$0[2];$targ$0 = {};$it$0.options = $targ$0;void 0;
  } else {
    ___match_error(m$1$0, "{@parent = null\n               @name = gensym{\"scope\"}\n               @top = false}");
  }return $it$0;
};Scope$0.prototype.fork = function fork() {
  var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;return Scope$0($it$1);
};Scope$0.prototype.toString = function toString() {
  var $it$2 = undefined;var self$1 = undefined;$it$2 = this;self$1 = this;return "Scope{" + $it$2.name + "}";
};__amp____colon__(Scope$0, __amp____colon__(($targ$1 = "Scope", accum$0 = {}, accum$0["::name"] = $targ$1, accum$0), ($targ$2 = true, accum$1 = {}, accum$1["::egclass"] = $targ$2, accum$1)));Env$0 = function Env() {
  var $targ$3 = undefined;var $targ$4 = undefined;var $it$3 = undefined;if (!getChecker(Env$0)(this)) {
    $it$3 = Object.create(Env$0.prototype);
  } else {
    $it$3 = this;
  }$targ$3 = {};$it$3.scopes = $targ$3;$targ$4 = {};$it$3.options = $targ$4;return $it$3;
};Env$0.prototype.list_bindings = function list_bindings(origin$0) {
  var values$0 = undefined;var scope$0 = undefined;var $it$4 = undefined;var self$2 = undefined;$it$4 = this;self$2 = this;values$0 = {};scope$0 = origin$0;$4: while (scope$0) {
    __amp____colon__(values$0, send(send($it$4, "scopes", true), scope$0.name));scope$0 = scope$0.parent;scope$0;
  }return values$0;
};Env$0.prototype.getopt = function getopt() {
  var scope_data$0 = undefined;var scope$1 = undefined;var name$0 = undefined;var level$0 = undefined;var t0$1 = undefined;var m$2$0 = undefined;var $it$5 = undefined;var self$3 = undefined;$it$5 = this;self$3 = this;m$2$0 = arguments;t0$1 = m$2$0.length;if (t0$1 >= 2 && t0$1 <= 3) {
    scope$1 = m$2$0[0];name$0 = m$2$0[1];if (2 >= t0$1) {
      level$0 = 0;
    } else {
      level$0 = m$2$0[2];
    }if (scope$1 === null) {
      return undefined;
    }scope_data$0 = send(send($it$5, "options", true), scope$1.name);if (scope_data$0 && Object.prototype.hasOwnProperty.call(scope_data$0, name$0)) {
      if (equal(level$0, 0)) {
        return send(scope_data$0, name$0);
      } else {
        return $it$5.getopt(scope$1.parent, name$0, level$0 - 1);
      }
    } else {
      return $it$5.getopt(scope$1.parent, name$0, level$0);
    }
  } else {
    return ___match_error(m$2$0, "{scope, name, level = 0}");
  }
};Env$0.prototype.setopt = function setopt(scope$2, name$1, value$0) {
  var $targ$6 = undefined;var t0$2 = undefined;var s$0 = undefined;var $targ$5 = undefined;var $it$6 = undefined;var self$4 = undefined;$it$6 = this;self$4 = this;if (!send(send($it$6, "options", true), scope$2.name)) {
    $targ$6 = {};$it$6.options[scope$2.name] = $targ$6;void 0;
  }s$0 = send(send($it$6, "options", true), scope$2.name);$targ$5 = value$0;t0$2 = $targ$5;s$0[name$1] = t0$2;s$0[camelCase$0(name$1)] = t0$2;s$0[invCamelCase$0(name$1)] = t0$2;return void 0;
};Env$0.prototype.resolve = function resolve() {
  var scope_data$1 = undefined;var scope$3 = undefined;var name$2 = undefined;var level$1 = undefined;var t0$3 = undefined;var m$3$0 = undefined;var $it$7 = undefined;var self$5 = undefined;$it$7 = this;self$5 = this;m$3$0 = arguments;t0$3 = m$3$0.length;if (t0$3 >= 2 && t0$3 <= 3) {
    scope$3 = m$3$0[0];name$2 = m$3$0[1];if (2 >= t0$3) {
      level$1 = 0;
    } else {
      level$1 = m$3$0[2];
    }if (scope$3 === null) {
      return undefined;
    }scope_data$1 = send(send($it$7, "scopes", true), scope$3.name);if (scope_data$1 && Object.prototype.hasOwnProperty.call(scope_data$1, name$2)) {
      if (equal(level$1, 0)) {
        return send(scope_data$1, name$2);
      } else {
        return $it$7.resolve(scope$3.parent, name$2, level$1 - 1);
      }
    } else {
      return $it$7.resolve(scope$3.parent, name$2, level$1);
    }
  } else {
    return ___match_error(m$3$0, "{scope, name, level = 0}");
  }
};Env$0.prototype.bind = function bind(scope$4, name$3, value$1) {
  var $targ$8 = undefined;var $targ$9 = undefined;var t0$4 = undefined;var s$1 = undefined;var $targ$7 = undefined;var $it$8 = undefined;var self$6 = undefined;$it$8 = this;self$6 = this;if (!send(send($it$8, "scopes", true), scope$4.name)) {
    $targ$8 = {};$it$8.scopes[scope$4.name] = $targ$8;void 0;
  }if (scope$4.top) {
    $targ$9 = true;value$1.top = $targ$9;void 0;
  }s$1 = send(send($it$8, "scopes", true), scope$4.name);$targ$7 = value$1;t0$4 = $targ$7;s$1[name$3] = t0$4;s$1[camelCase$0(name$3)] = t0$4;s$1[invCamelCase$0(name$3)] = t0$4;return void 0;
};Env$0.prototype.mark = function mark(expr$0) {
  var x$0 = undefined;var x$1 = undefined;var bridge$$1557$0 = undefined;var x$2 = undefined;var bridge$$1556$0 = undefined;var x$3 = undefined;var bridge$$1555$0 = undefined;var x$4 = undefined;var m$5 = undefined;var other$0 = undefined;var type$0 = undefined;var args$0 = undefined;var e$0 = undefined;var bridge$$1554$0 = undefined;var t0$5 = undefined;var m$4$0 = undefined;var $it$9 = undefined;var self$7 = undefined;$it$9 = this;self$7 = this;m$4$0 = expr$0;if (___hasprop(m$4$0, "env")) {
    e$0 = m$4$0.env;return expr$0;
  } else {
    bridge$$1554$0 = m$4$0;if ((bridge$$1555$0 = bridge$$1554$0, (bridge$$1556$0 = bridge$$1555$0, (bridge$$1557$0 = bridge$$1556$0, (x$0 = bridge$$1557$0, x$0 instanceof Array && x$0[0] === "symbol") || (x$1 = bridge$$1557$0, x$1 instanceof Array && x$1[0] === "value")) || (x$2 = bridge$$1556$0, x$2 instanceof Array && x$2[0] === "variable")) || (x$3 = bridge$$1555$0, x$3 instanceof Array && x$3[0] === "macro")) || (x$4 = bridge$$1554$0, x$4 instanceof Array && x$4[0] === "void")) {
      return __amp____colon__(expr$0, { env: $it$9 });
    } else {
      if (Array.isArray(m$4$0) && (t0$5 = m$4$0.length, t0$5 >= 1)) {
        type$0 = m$4$0[0];args$0 = Array.prototype.slice.call(m$4$0, 1);m$5 = null;$5: for (var _iterator = args$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          m$5 = _step.value;
          var arg$0 = undefined;arg$0 = m$5;$it$9.mark(arg$0);
        }return __amp____colon__(expr$0, { env: $it$9 });
      } else {
        other$0 = m$4$0;return other$0;
      }
    }
  }
};Env$0.prototype.fork = function fork() {
  var m$6 = undefined;var m$8 = undefined;var e$1 = undefined;var $it$10 = undefined;var self$8 = undefined;$it$10 = this;self$8 = this;e$1 = Env$0();m$6 = null;$6: for (var _iterator = items($it$10.scopes)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$6 = _step.value;
    var m$7 = undefined;var acc$0 = undefined;var temp$0 = undefined;var scope$5 = undefined;var bindings$0 = undefined;var t0$6 = undefined;var t1$0 = undefined;t0$6 = m$6;if (Array.isArray(t0$6) && (t1$0 = t0$6.length, t1$0 === 2)) {
      scope$5 = t0$6[0];bindings$0 = t0$6[1];acc$0 = [];temp$0 = null;m$7 = null;$8: for (var _iterator2 = items(bindings$0)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$7 = _step2.value;
        var $targ$11 = undefined;var $targ$10 = undefined;var k$0 = undefined;var v$0 = undefined;var t0$7 = undefined;var t1$1 = undefined;t0$7 = m$7;if (Array.isArray(t0$7) && (t1$1 = t0$7.length, t1$1 === 2)) {
          k$0 = t0$7[0];v$0 = t0$7[1];if (!send(send(e$1, "scopes", true), scope$5)) {
            $targ$11 = {};e$1.scopes[scope$5] = $targ$11;void 0;
          }$targ$10 = v$0;send(send(e$1, "scopes", true), scope$5)[k$0] = $targ$10;temp$0 = void 0;acc$0.push(temp$0);
        } else {
          ___match_error(m$7);
        }
      }acc$0;
    } else {
      ___match_error(m$6);
    }
  }m$8 = null;$7: for (var _iterator3 = items($it$10.options)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
    m$8 = _step3.value;
    var m$9 = undefined;var acc$1 = undefined;var temp$1 = undefined;var scope$6 = undefined;var bindings$1 = undefined;var t0$8 = undefined;var t1$2 = undefined;t0$8 = m$8;if (Array.isArray(t0$8) && (t1$2 = t0$8.length, t1$2 === 2)) {
      scope$6 = t0$8[0];bindings$1 = t0$8[1];acc$1 = [];temp$1 = null;m$9 = null;$9: for (var _iterator4 = items(bindings$1)[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
        m$9 = _step4.value;
        var $targ$13 = undefined;var $targ$12 = undefined;var k$1 = undefined;var v$1 = undefined;var t0$9 = undefined;var t1$3 = undefined;t0$9 = m$9;if (Array.isArray(t0$9) && (t1$3 = t0$9.length, t1$3 === 2)) {
          k$1 = t0$9[0];v$1 = t0$9[1];if (!send(send(e$1, "options", true), scope$6)) {
            $targ$13 = {};e$1.options[scope$6] = $targ$13;void 0;
          }$targ$12 = v$1;send(send(e$1, "options", true), scope$6)[k$1] = $targ$12;temp$1 = void 0;acc$1.push(temp$1);
        } else {
          ___match_error(m$9);
        }
      }acc$1;
    } else {
      ___match_error(m$8);
    }
  }return e$1;
};Env$0.prototype.toString = function toString() {
  var $it$11 = undefined;var self$9 = undefined;$it$11 = this;self$9 = this;return "Env{...}";
};__amp____colon__(Env$0, __amp____colon__(($targ$14 = "Env", accum$2 = {}, accum$2["::name"] = $targ$14, accum$2), ($targ$15 = true, accum$3 = {}, accum$3["::egclass"] = $targ$15, accum$3)));track_location$0 = function track_location(f$0) {
  var f2$0 = undefined;f2$0 = function f2(context$0, scope$7, expr$1) {
    var rval$1 = undefined;var other$1 = undefined;var v$2 = undefined;var t0$10 = undefined;var m$10$0 = undefined;var rval$0 = undefined;rval$1 = false;try {
      rval$1 = f$0(context$0, scope$7, expr$1);rval$1;
    } catch (excv$0) {
      var e$2 = undefined;e$2 = excv$0;__lt____lt____colon__$0(e$2, expr$1);throw e$2;rval$1;
    }rval$0 = rval$1;m$10$0 = rval$0;if (Array.isArray(m$10$0) && (t0$10 = m$10$0.length, t0$10 === 2 && m$10$0[0] === "bounce")) {
      v$2 = m$10$0[1];return f2$0(context$0, scope$7, __lt____lt____colon__$0(v$2, expr$1));
    } else {
      other$1 = m$10$0;return __lt____lt____colon__$0(other$1, expr$1);
    }
  };return f2$0;
};Info$0 = function Info(temp$2$0, temp$3$0, temp$4$0, temp$5$0, temp$6$0) {
  var $targ$16 = undefined;var $it$12 = undefined;if (!getChecker(Info$0)(this)) {
    $it$12 = Object.create(Info$0.prototype);
  } else {
    $it$12 = this;
  }$it$12.context = temp$2$0;$it$12.scope = temp$3$0;$it$12.form = temp$4$0;$it$12.arg = temp$5$0;$it$12.expander = temp$6$0;$targ$16 = $it$12.form.env;$it$12.env = $targ$16;return $it$12;
};Info$0.prototype.gettext = function gettext(ph$0$0) {
  var location$0 = undefined;var t0$11 = undefined;var $it$13 = undefined;var self$10 = undefined;$it$13 = this;self$10 = this;t0$11 = ph$0$0;if (___hasprop(t0$11, "location")) {
    location$0 = t0$11.location;return location$0.text();
  } else {
    return null;
  }
};Info$0.prototype.raw = function raw(x$5) {
  var $it$14 = undefined;var self$11 = undefined;$it$14 = this;self$11 = this;return $it$14.gettext(x$5);
};Info$0.prototype.with_scope = function with_scope(newscope$0) {
  var $it$15 = undefined;var self$12 = undefined;$it$15 = this;self$12 = this;return Info$0($it$15.context, newscope$0, $it$15.form, $it$15.arg, $it$15.expander);
};Info$0.prototype.gensym = function gensym(name$4) {
  var $it$16 = undefined;var self$13 = undefined;$it$16 = this;self$13 = this;return $it$16.expander.gensym(name$4 || "");
};Info$0.prototype.defer = function defer() {
  var $it$17 = undefined;var self$14 = undefined;$it$17 = this;self$14 = this;return ["nostep", $it$17.form];
};Info$0.prototype.mkenv = function mkenv() {
  var $it$18 = undefined;var self$15 = undefined;$it$18 = this;self$15 = this;return $it$18.expander.mkenv();
};Info$0.prototype.mark = function mark() {
  var m$12 = undefined;var acc$2 = undefined;var temp$7 = undefined;var xs$0 = undefined;var x$6 = undefined;var t0$13 = undefined;var t1$4 = undefined;var ph$2$0 = undefined;var t0$12 = undefined;var m$11$0 = undefined;var $it$19 = undefined;var self$16 = undefined;$it$19 = this;self$16 = this;m$11$0 = arguments;t0$12 = m$11$0.length;if (t0$12 >= 0) {
    ph$2$0 = Array.prototype.slice.call(m$11$0, 0);t0$13 = ph$2$0;t1$4 = t0$13.length;if (t1$4 === 1) {
      x$6 = t0$13[0];return $it$19.env.mark(x$6);
    } else {
      xs$0 = ph$2$0;acc$2 = [];temp$7 = null;m$12 = null;$10: for (var _iterator = xs$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$12 = _step.value;
        var x$7 = undefined;x$7 = m$12;temp$7 = $it$19.env.mark(x$7);acc$2.push(temp$7);
      }return acc$2;
    }
  } else {
    return ___match_error(m$11$0, "{*match}");
  }
};Info$0.prototype.step = function step(context$1, expr$2) {
  var $it$20 = undefined;var self$17 = undefined;$it$20 = this;self$17 = this;return $it$20.expander.step(context$1, $it$20.scope, expr$2);
};Info$0.prototype.step_all = function step_all(context$2, exprs$0) {
  var $it$21 = undefined;var self$18 = undefined;$it$21 = this;self$18 = this;return $it$21.expander.step_all(context$2, $it$21.scope, exprs$0);
};Info$0.prototype.expand = function expand(context$3, expr$3) {
  var $it$22 = undefined;var self$19 = undefined;$it$22 = this;self$19 = this;return $it$22.expander.expand(context$3, $it$22.scope, expr$3);
};Info$0.prototype.go = function go(x$8, start$0, end$0) {
  var $it$23 = undefined;var self$20 = undefined;$it$23 = this;self$20 = this;return $it$23.expander.pipeline.go(x$8, start$0, end$0);
};Info$0.prototype.getopt = function getopt(name$5) {
  var $it$24 = undefined;var self$21 = undefined;$it$24 = this;self$21 = this;return $it$24.env.getopt($it$24.scope, name$5);
};Info$0.prototype.setopt = function setopt(name$6, value$2) {
  var $it$25 = undefined;var self$22 = undefined;$it$25 = this;self$22 = this;return $it$25.env.setopt($it$25.scope, name$6, value$2);
};__amp____colon__(Info$0, __amp____colon__(($targ$17 = "Info", accum$4 = {}, accum$4["::name"] = $targ$17, accum$4), ($targ$18 = true, accum$5 = {}, accum$5["::egclass"] = $targ$18, accum$5)));Expander$0 = function Expander(temp$8$0, temp$9$0, temp$10$0) {
  var m$13 = undefined;var acc$3 = undefined;var temp$11 = undefined;var $targ$19 = undefined;var $it$26 = undefined;if (!getChecker(Expander$0)(this)) {
    $it$26 = Object.create(Expander$0.prototype);
  } else {
    $it$26 = this;
  }$it$26.stdenv = temp$8$0;$it$26.generic_nodes = temp$9$0;$it$26.pipeline = temp$10$0;$targ$19 = object((acc$3 = [], temp$11 = null, m$13 = null, (function () {
    $11: for (var _iterator = jsKeywords$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$13 = _step.value;
      var kw$0 = undefined;kw$0 = m$13;temp$11 = [kw$0, 0];acc$3.push(temp$11);
    }
  })(), acc$3));$it$26.nameusage = $targ$19;return $it$26;
};Expander$0.prototype.gensym = function gensym(temp$12$0) {
  var t0$14 = undefined;var idx$0 = undefined;var $targ$20 = undefined;var $$2227$0 = undefined;var bridge$$2224$0 = undefined;var name$7 = undefined;var ph$3$0 = undefined;var $it$27 = undefined;var self$23 = undefined;$it$27 = this;self$23 = this;t0$14 = temp$12$0;name$7 = t0$14;ph$3$0 = t0$14;bridge$$2224$0 = ph$3$0;if (bridge$$2224$0 === void 0 || bridge$$2224$0 === null) {
    return $it$27.gensym("");
  } else {
    if (Object.prototype.hasOwnProperty.call($it$27.nameusage, name$7)) {
      idx$0 = $it$27.nameusage[name$7] = send(send($it$27, "nameusage", true), name$7) + 1;return name$7 + "$" + String(idx$0);
    } else {
      $targ$20 = 0;$it$27.nameusage[name$7] = $targ$20;return name$7 + "$0";
    }
  }
};Expander$0.prototype.mkenv = function mkenv() {
  var e$3 = undefined;var $targ$21 = undefined;var $it$28 = undefined;var self$24 = undefined;$it$28 = this;self$24 = this;e$3 = Env$0();$targ$21 = $it$28.stdenv.scopes.top;e$3.scopes.top = $targ$21;return e$3;
};Expander$0.prototype.run_macro = function run_macro(m$14, context$4, scope$8, form$0, arg$1) {
  var rval$3 = undefined;var rval$4 = undefined;var info$0 = undefined;var rval$2 = undefined;var $it$29 = undefined;var self$25 = undefined;$it$29 = this;self$25 = this;info$0 = Info$0(context$4, scope$8, form$0, arg$1, $it$29);rval$3 = false;try {
    rval$3 = m$14(context$4, info$0, form$0, arg$1);rval$3;
  } catch (excv$1) {
    (function () {
      var t0$16 = undefined;var t1$6 = undefined;var t2$1 = undefined;var bridge$$2362$0 = undefined;var msg$0 = undefined;var msg$2 = undefined;var find$0 = undefined;var err$0 = undefined;var other$2 = undefined;var m$15$0 = undefined;var $targ$22 = undefined;var name$8 = undefined;var e$4 = undefined;var e$5 = undefined;var value$3 = undefined;var t0$15 = undefined;var t1$5 = undefined;var t2$0 = undefined;var t3$0 = undefined;t0$15 = excv$1;if (getChecker(ErrorFactory(["match"]))(t0$15) && (___hasprop(t0$15, "args") && (t1$5 = t0$15.args, Array.isArray(t1$5) && (t2$0 = t1$5.length, t2$0 === 1 && (t3$0 = t1$5[0], ___hasprop(t3$0, "value")))))) {
        value$3 = t3$0.value;$targ$22 = form$0;bridge$$2362$0 = $targ$22;if (Array.isArray(bridge$$2362$0) && (t0$16 = bridge$$2362$0.length, t0$16 === 3 && (bridge$$2362$0[0] === "send" && (t1$6 = bridge$$2362$0[1], Array.isArray(t1$6) && (t2$1 = t1$6.length, t2$1 === 2 && (t1$6[0] === "symbol" && (name$8 = t1$6[1], bridge$$2362$0[2], true)))))) || (name$8 = "<unknown>", true)) {} else {
          ___match_error($targ$22, "#send{#symbol{name}, _} or name is \"<unknown>\"");
        }m$15$0 = value$3;if (m$15$0 === context$4) {
          msg$0 = ENode([], {}, ["The macro cannot be found in context {", context$4, "}."]).toString();e$4 = ErrorFactory(["syntax", "context"]).create(msg$0, { context: context$4, form: form$0 });
        } else {
          other$2 = m$15$0;find$0 = function find(temp$13$0) {
            var t0$17 = undefined;var msg$1 = undefined;var m$16 = undefined;var other$3 = undefined;var type$1 = undefined;var xs$1 = undefined;var t0$18 = undefined;var t1$7 = undefined;var arg$2 = undefined;var ph$4$0 = undefined;t0$17 = temp$13$0;arg$2 = t0$17;ph$4$0 = t0$17;if (ph$4$0 === value$3) {
              msg$1 = ENode([], {}, ["The macro `", name$8, "` expected something different. You should bug the macro/language implementer to improve their error messages."]).toString();return ErrorFactory(["syntax", "argument"]).create(msg$1, { context: context$4, argument: arg$2, form: form$0 });
            } else {
              t0$18 = ph$4$0;t1$7 = t0$18.length;if (t1$7 >= 1) {
                type$1 = t0$18[0];xs$1 = Array.prototype.slice.call(t0$18, 1);m$16 = null;$12: for (var _iterator = xs$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                  m$16 = _step.value;
                  var x$9 = undefined;var t0$19 = undefined;t0$19 = getProjector(find$0)(m$16);if (t0$19[0]) {
                    x$9 = t0$19[1];if (x$9) {
                      return x$9;
                    }
                  } else {
                    ___match_error(m$16);
                  }
                }return false;
              } else {
                other$3 = ph$4$0;return false;
              }
            }
          };err$0 = find$0(arg$1);if (err$0) {
            e$4 = err$0;
          } else {
            msg$2 = ENode([], {}, ["An error occurred in the `", name$8, "` macro. You should bug the macro/language implementer to fix this."]).toString();e$4 = ErrorFactory(["syntax", "failure"]).create(msg$2, { form: form$0, value: value$3 });
          }
        }throw e$4;rval$3;
      } else {
        e$5 = excv$1;throw e$5;rval$3;
      }
    })();
  }rval$2 = rval$3;rval$4 = false;try {
    rval$4 = $it$29.mkenv().mark(rval$2);rval$4;
  } catch (excv$2) {
    var t$0 = undefined;var e$6 = undefined;e$6 = excv$2;t$0 = rval$2;console.log(t$0);throw ErrorFactory(["syntax", "macro"]).create("Macro returned a bad node", { form: form$0 });rval$4;
  }return rval$4;
};Expander$0.prototype.step = function step(context$5, scope$9, expr$4) {
  var t0$26 = undefined;var $targ$23 = undefined;var helper$0 = undefined;var $it$30 = undefined;var self$26 = undefined;$it$30 = this;self$26 = this;$targ$23 = function (context$6, scope$10, temp$14$0) {
    var t0$20 = undefined;var other$4 = undefined;var env$1 = undefined;var m$18$0 = undefined;var other$5 = undefined;var t0$23 = undefined;var m$20$0 = undefined;var other$6 = undefined;var m$19 = undefined;var t0$22 = undefined;var m$17$0 = undefined;var env$0 = undefined;var other$7 = undefined;var t0$24 = undefined;var m$22$0 = undefined;var other$8 = undefined;var m$24 = undefined;var t0$25 = undefined;var m$23$0 = undefined;var t$1 = undefined;var p$0 = undefined;var other$9 = undefined;var x$10 = undefined;var code$0 = undefined;var url$0 = undefined;var f$1 = undefined;var arg$3 = undefined;var m$21 = undefined;var s$2 = undefined;var $$2539$0 = undefined;var $$2540$0 = undefined;var $$2541$0 = undefined;var t0$21 = undefined;var t1$8 = undefined;var expr$5 = undefined;var ph$5$0 = undefined;t0$20 = temp$14$0;expr$5 = t0$20;ph$5$0 = t0$20;t0$21 = ph$5$0;t1$8 = t0$21.length;if (($$2541$0 = t1$8 === 2) && t0$21[0] === "symbol") {
      s$2 = t0$21[1];m$18$0 = expr$5;if (___hasprop(m$18$0, "env")) {
        env$1 = m$18$0.env;env$0 = expr$5.env;
      } else {
        other$4 = m$18$0;throw ErrorFactory(["syntax", "no_env"]).create("No environment was found to resolve '" + s$2 + "'", { symbol: expr$5 });
      }m$17$0 = env$0.resolve(scope$10, s$2, expr$5.level || 0);if (Array.isArray(m$17$0) && (t0$22 = m$17$0.length, t0$22 === 2 && m$17$0[0] === "macro")) {
        m$19 = m$17$0[1];m$20$0 = context$6;if (Array.isArray(m$20$0) && (t0$23 = m$20$0.length, t0$23 === 2 && (m$20$0[0] === "expr" && m$20$0[1] === "head"))) {
          return ["macro", m$19];
        } else {
          other$5 = m$20$0;return ["bounce", $it$30.run_macro(m$19, context$6, scope$10, expr$5, __lt____lt____colon__$0(["void"], expr$5))];
        }
      } else {
        other$6 = m$17$0;return expr$5;
      }
    } else {
      if ($$2541$0 && t0$21[0] === "macro") {
        m$21 = t0$21[1];m$22$0 = context$6;if (Array.isArray(m$22$0) && (t0$24 = m$22$0.length, t0$24 === 2 && (m$22$0[0] === "expr" && m$22$0[1] === "head"))) {
          return expr$5;
        } else {
          other$7 = m$22$0;return ["bounce", $it$30.run_macro(m$21, context$6, scope$10, expr$5, __lt____lt____colon__$0(["void"], expr$5))];
        }
      } else {
        if (t1$8 === 3 && t0$21[0] === "send") {
          f$1 = t0$21[1];arg$3 = t0$21[2];m$23$0 = helper$0(["expr", "head"], scope$10, f$1);if (Array.isArray(m$23$0) && (t0$25 = m$23$0.length, t0$25 === 2 && m$23$0[0] === "macro")) {
            m$24 = m$23$0[1];return ["bounce", $it$30.run_macro(m$24, context$6, scope$10, expr$5, arg$3)];
          } else {
            other$8 = m$23$0;return expr$5;
          }
        } else {
          if (t1$8 >= 2 && t1$8 <= 3 && t0$21[0] === "parse") {
            code$0 = t0$21[1];if (2 >= t1$8) {
              url$0 = null;
            } else {
              url$0 = t0$21[2];
            }t$1 = tokenize$0(Source$0(code$0, url$0));p$0 = parse$0(t$1);return ["bounce", helper$0(context$6, scope$10, expr$5.env.mark(p$0))];
          } else {
            if (t1$8 === 2 && t0$21[0] === "nostep") {
              x$10 = t0$21[1];return x$10;
            } else {
              other$9 = ph$5$0;return expr$5;
            }
          }
        }
      }
    }
  };t0$26 = getProjector(track_location$0)($targ$23);if (t0$26[0]) {
    helper$0 = t0$26[1];
  } else {
    ___match_error($targ$23, "track_location! helper{context, scope, match expr}");
  }return helper$0(context$5, scope$9, expr$4);
};Expander$0.prototype.step_all = function step_all(context$7, scope$11, temp$15$0) {
  var t0$27 = undefined;var t1$9 = undefined;var pre$0 = undefined;var bulk$0 = undefined;var post$0 = undefined;var stmts$0 = undefined;var $it$31 = undefined;var self$27 = undefined;$it$31 = this;self$27 = this;t0$27 = temp$15$0;if (Array.isArray(t0$27) && (t1$9 = t0$27.length, t1$9 >= 0)) {
    stmts$0 = Array.prototype.slice.call(t0$27, 0);
  } else {
    ___match_error(temp$15$0);
  }pre$0 = [];bulk$0 = [];post$0 = [];$13: while (stmts$0.length) {
    var m$27 = undefined;var acc$4 = undefined;var temp$16 = undefined;var e$7 = undefined;var x$11 = undefined;var m$26 = undefined;var stmt$1 = undefined;var stmt$0 = undefined;var prepend$0 = undefined;var $$2739$0 = undefined;var $$2740$0 = undefined;var $$2741$0 = undefined;var t0$28 = undefined;var m$25$0 = undefined;var current$0 = undefined;current$0 = stmts$0.shift();m$25$0 = $it$31.step(context$7, scope$11, current$0);if (($$2739$0 = Array.isArray(m$25$0)) && (t0$28 = m$25$0.length, t0$28 >= 1 && m$25$0[0] === "splice")) {
      prepend$0 = Array.prototype.slice.call(m$25$0, 1);stmts$0 = prepend$0.concat(stmts$0);stmts$0;
    } else {
      if ($$2739$0 && (($$2741$0 = t0$28 === 2) && m$25$0[0] === "float")) {
        stmt$0 = m$25$0[1];pre$0 = pre$0.concat($it$31.step_all(context$7, scope$11, [stmt$0]));
      } else {
        if ($$2741$0 && m$25$0[0] === "sink") {
          stmt$1 = m$25$0[1];post$0 = post$0.concat($it$31.step_all(context$7, scope$11, [stmt$1]));
        } else {
          if ($$2741$0 && m$25$0[0] === "restmacro") {
            m$26 = m$25$0[1];e$7 = $it$31.mkenv();acc$4 = [];temp$16 = null;m$27 = null;$14: for (var _iterator = m$26(stmts$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$27 = _step.value;
              var stmt$2 = undefined;stmt$2 = m$27;temp$16 = e$7.mark(stmt$2);acc$4.push(temp$16);
            }stmts$0 = acc$4;stmts$0;
          } else {
            x$11 = m$25$0;bulk$0.push(x$11);
          }
        }
      }
    }
  }return pre$0.concat(bulk$0).concat(post$0);
};Expander$0.prototype.expand = function expand(context$8, scope$12, expr$6) {
  var t0$49 = undefined;var $targ$24 = undefined;var helper$1 = undefined;var $it$32 = undefined;var self$28 = undefined;$it$32 = this;self$28 = this;$targ$24 = function (context$9, scope$13, expr$7) {
    var t0$30 = undefined;var v$3 = undefined;var resolved$0 = undefined;var m$29$0 = undefined;var $targ$25 = undefined;var env$2 = undefined;var m$30 = undefined;var acc$5 = undefined;var temp$17 = undefined;var newargs$0 = undefined;var m$31 = undefined;var acc$6 = undefined;var temp$18 = undefined;var newargs$1 = undefined;var t0$32 = undefined;var newscope$1 = undefined;var $targ$26 = undefined;var env$3 = undefined;var m$32 = undefined;var acc$7 = undefined;var temp$19 = undefined;var t0$38 = undefined;var newscope$2 = undefined;var stepscope$0 = undefined;var changes$0 = undefined;var $targ$27 = undefined;var newargs$2 = undefined;var vars$0 = undefined;var exp$0 = undefined;var m$38 = undefined;var f$3 = undefined;var f$4 = undefined;var other$14 = undefined;var t0$43 = undefined;var m$39$0 = undefined;var obj$0 = undefined;var arr$0 = undefined;var arr_parts$0 = undefined;var obj_parts$0 = undefined;var index$0 = undefined;var objindex$0 = undefined;var new_arr_part$0 = undefined;var decl_obj$0 = undefined;var new_obj_part$0 = undefined;var is_obj$0 = undefined;var r$0 = undefined;var x$14 = undefined;var msg$5 = undefined;var $targ$32 = undefined;var otherwise$0 = undefined;var m$41 = undefined;var t0$44 = undefined;var m$40$0 = undefined;var t$2 = undefined;var orig$0 = undefined;var m$42 = undefined;var acc$10 = undefined;var temp$22 = undefined;var newscope$3 = undefined;var s$9 = undefined;var newscope$4 = undefined;var name$9 = undefined;var t0$47 = undefined;var m$43 = undefined;var acc$11 = undefined;var temp$23 = undefined;var m$44 = undefined;var acc$12 = undefined;var temp$24 = undefined;var tokens$0 = undefined;var msg$6 = undefined;var other$16 = undefined;var c$0 = undefined;var ops$0 = undefined;var args$8 = undefined;var type$2 = undefined;var args$7 = undefined;var x$17 = undefined;var tag$0 = undefined;var body$2 = undefined;var ph$6$0 = undefined;var x$16 = undefined;var bindings$2 = undefined;var body$1 = undefined;var generator$0 = undefined;var target$0 = undefined;var value$9 = undefined;var args$6 = undefined;var args$5 = undefined;var args$4 = undefined;var args$3 = undefined;var variable$0 = undefined;var s$4 = undefined;var value$4 = undefined;var body$0 = undefined;var args$2 = undefined;var args$1 = undefined;var f$2 = undefined;var arg$4 = undefined;var s$3 = undefined;var $$2852$0 = undefined;var $$2853$0 = undefined;var $$2854$0 = undefined;var t0$29 = undefined;var t1$10 = undefined;var t2$2 = undefined;var m$28$0 = undefined;expr$7 = $it$32.step(context$9, scope$13, expr$7);m$28$0 = expr$7;if (($$2852$0 = Array.isArray(m$28$0)) && (t0$29 = m$28$0.length, ($$2854$0 = t0$29 === 2) && m$28$0[0] === "symbol")) {
      s$3 = m$28$0[1];$targ$25 = expr$7;t0$30 = $targ$25;if (___hasprop(t0$30, "env")) {
        env$2 = t0$30.env;
      } else {
        ___match_error($targ$25, "{=> env}");
      }m$29$0 = env$2.resolve(scope$13, s$3, expr$7.level || 0);if (m$29$0 === void 0) {
        throw ErrorFactory(["syntax", "undeclared"]).create("Undeclared variable: " + s$3, { node: expr$7 });
      } else {
        resolved$0 = m$29$0;v$3 = __amp____colon__(clone(resolved$0), { location: expr$7.location, top: resolved$0.top, origin: resolved$0 });return ["bounce", v$3];
      }
    } else {
      if ($$2854$0 && m$28$0[0] === "value") {
        m$28$0[1];return expr$7;
      } else {
        if ($$2854$0 && m$28$0[0] === "variable") {
          m$28$0[1];return expr$7;
        } else {
          if ($$2852$0 && (t0$29 === 1 && m$28$0[0] === "void")) {
            return expr$7;
          } else {
            if ($$2852$0 && (t0$29 === 3 && m$28$0[0] === "send")) {
              f$2 = m$28$0[1];arg$4 = m$28$0[2];return ["send", helper$1(["expr", "head"], scope$13, f$2), helper$1(["expr", "tail"], scope$13, arg$4)];
            } else {
              if ($$2852$0 && (($$2854$0 = t0$29 >= 1) && m$28$0[0] === "array")) {
                args$1 = Array.prototype.slice.call(m$28$0, 1);acc$5 = [];temp$17 = null;m$30 = null;$15: for (var _iterator = $it$32.step_all(["expr", "array"], scope$13, args$1)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                  m$30 = _step.value;
                  var arg$5 = undefined;arg$5 = m$30;temp$17 = helper$1(["expr", "expr"], scope$13, arg$5);acc$5.push(temp$17);
                }newargs$0 = acc$5;return ["array"].concat(newargs$0);
              } else {
                if ($$2854$0 && m$28$0[0] === "object") {
                  args$2 = Array.prototype.slice.call(m$28$0, 1);acc$6 = [];temp$18 = null;m$31 = null;$16: for (var _iterator2 = $it$32.step_all(["expr", "object"], scope$13, args$2)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                    m$31 = _step2.value;
                    var k$2 = undefined;var v$4 = undefined;var t0$31 = undefined;var t1$11 = undefined;t0$31 = m$31;if (Array.isArray(t0$31) && (t1$11 = t0$31.length, t1$11 === 3 && t0$31[0] === "array")) {
                      k$2 = t0$31[1];v$4 = t0$31[2];temp$18 = ["array", helper$1(["expr", "expr"], scope$13, k$2), helper$1(["expr", "expr"], scope$13, v$4)];acc$6.push(temp$18);
                    } else {
                      ___match_error(m$31);
                    }
                  }newargs$1 = acc$6;return ["object"].concat(newargs$1);
                } else {
                  if ($$2852$0 && (t0$29 === 4 && (m$28$0[0] === "bind" && (t1$10 = m$28$0[1], variable$0 = t1$10, Array.isArray(t1$10) && (t2$2 = t1$10.length, t2$2 === 2 && t1$10[0] === "symbol"))))) {
                    s$4 = t1$10[1];value$4 = m$28$0[2];body$0 = m$28$0[3];newscope$1 = Scope$0(scope$13);$targ$26 = variable$0;t0$32 = $targ$26;if (___hasprop(t0$32, "env")) {
                      env$3 = t0$32.env;
                    } else {
                      ___match_error($targ$26, "{=> env}");
                    }env$3.bind(newscope$1, s$4, value$4);return helper$1(context$9, newscope$1, body$0);
                  } else {
                    if ($$2852$0 && (($$2854$0 = t0$29 >= 1) && m$28$0[0] === "splice")) {
                      args$3 = Array.prototype.slice.call(m$28$0, 1);return ["bounce", __amp____colon__(["multi"].concat(args$3), { override_scope: true })];
                    } else {
                      if ($$2854$0 && m$28$0[0] === "interactive") {
                        args$4 = Array.prototype.slice.call(m$28$0, 1);return ["bounce", __amp____colon__(["multi"].concat(args$4), { override_scope: true, all_mutable: true })];
                      } else {
                        if ($$2854$0 && m$28$0[0] === "multi") {
                          args$5 = Array.prototype.slice.call(m$28$0, 1);if (expr$7.override_scope) {
                            newscope$2 = scope$13;
                          } else {
                            newscope$2 = Scope$0(scope$13);
                          }if (expr$7.nonrecursive) {
                            stepscope$0 = scope$13;
                          } else {
                            stepscope$0 = newscope$2;
                          }changes$0 = false;$targ$27 = classify$0("newargs", "vars", (acc$7 = [], temp$19 = null, m$32 = null, (function () {
                            $17: for (var _iterator3 = $it$32.step_all(["expr", "multi"], stepscope$0, args$5)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                              m$32 = _step3.value;
                              var t0$34 = undefined;var $targ$28 = undefined;var env$4 = undefined;var t0$35 = undefined;var $targ$29 = undefined;var env$5 = undefined;var t0$36 = undefined;var v$5 = undefined;var $targ$30 = undefined;var env$6 = undefined;var t0$37 = undefined;var $targ$31 = undefined;var env$7 = undefined;var other$10 = undefined;var s$7 = undefined;var variable$3 = undefined;var v$6 = undefined;var value$8 = undefined;var variable$2 = undefined;var s$6 = undefined;var value$7 = undefined;var variable$1 = undefined;var s$5 = undefined;var value$6 = undefined;var opt$0 = undefined;var value$5 = undefined;var $$3049$0 = undefined;var $$3050$0 = undefined;var $$3051$0 = undefined;var $$3052$0 = undefined;var $$3053$0 = undefined;var $$3054$0 = undefined;var t0$33 = undefined;var t1$12 = undefined;var t2$3 = undefined;var t3$1 = undefined;t0$33 = m$32;if (($$3050$0 = Array.isArray(t0$33)) && (t1$12 = t0$33.length, ($$3052$0 = t1$12 === 3) && t0$33[0] === "option")) {
                                opt$0 = t0$33[1];value$5 = t0$33[2];$targ$28 = expr$7;t0$34 = $targ$28;if (___hasprop(t0$34, "env")) {
                                  env$4 = t0$34.env;
                                } else {
                                  ___match_error($targ$28, "{=> env}");
                                }env$4.setopt(newscope$2, opt$0, value$5);changes$0 = true;temp$19 = ["ignore"];acc$7.push(temp$19);
                              } else {
                                if ($$3052$0 && (t0$33[0] === "declare_raw" && (t2$3 = t0$33[1], variable$1 = t2$3, Array.isArray(t2$3) && (t3$1 = t2$3.length, t3$1 === 2 && t2$3[0] === "symbol")))) {
                                  s$5 = t2$3[1];value$6 = t0$33[2];$targ$29 = variable$1;t0$35 = $targ$29;if (___hasprop(t0$35, "env")) {
                                    env$5 = t0$35.env;
                                  } else {
                                    ___match_error($targ$29, "{=> env}");
                                  }env$5.bind(newscope$2, s$5, value$6);changes$0 = true;temp$19 = ["ignore"];acc$7.push(temp$19);
                                } else {
                                  if ($$3050$0 && (($$3052$0 = t1$12 >= 2 && t1$12 <= 3) && (($$3053$0 = t0$33[0] === "declare") && (t2$3 = t0$33[1], variable$2 = t2$3, Array.isArray(t2$3) && (t3$1 = t2$3.length, t3$1 === 2 && t2$3[0] === "symbol"))))) {
                                    s$6 = t2$3[1];if (2 >= t1$12) {
                                      value$7 = null;
                                    } else {
                                      value$7 = t0$33[2];
                                    }$targ$30 = variable$2;t0$36 = $targ$30;if (___hasprop(t0$36, "env")) {
                                      env$6 = t0$36.env;
                                    } else {
                                      ___match_error($targ$30, "{=> env}");
                                    }if (variable$2.use_previous && env$6.resolve(newscope$2, s$6, variable$2.level || 0)) {
                                      temp$19 = ["splice"];
                                    } else {
                                      v$5 = __lt____lt____colon__$0(["variable", $it$32.gensym(s$6)], variable$2);__amp____colon__(v$5, { mutable: expr$7.all_mutable || variable$2.mutable });__amp____colon__(v$5, { top: variable$2.top });env$6.bind(newscope$2, s$6, v$5);changes$0 = true;if (value$7) {
                                        temp$19 = ["splice", ["newargs", ["assign", v$5, value$7]], ["vars", v$5]];
                                      } else {
                                        temp$19 = ["vars", v$5];
                                      }
                                    }acc$7.push(temp$19);
                                  } else {
                                    if ($$3053$0 && (v$6 = t2$3, Array.isArray(t2$3) && (t3$1 = t2$3.length, t3$1 === 2 && t2$3[0] === "variable"))) {
                                      t2$3[1];if (2 >= t1$12) {
                                        value$8 = null;
                                      } else {
                                        value$8 = t0$33[2];
                                      }changes$0 = true;if (value$8) {
                                        temp$19 = ["splice", ["newargs", ["assign", v$6, value$8]], ["vars", v$6]];
                                      } else {
                                        temp$19 = ["vars", v$6];
                                      }acc$7.push(temp$19);
                                    } else {
                                      if ($$3050$0 && (t1$12 === 2 && (t0$33[0] === "undeclare" && (t2$3 = t0$33[1], Array.isArray(t2$3) && (t3$1 = t2$3.length, t3$1 === 2 && t2$3[0] === "symbol"))))) {
                                        s$7 = t2$3[1];variable$3 = t2$3;$targ$31 = variable$3;t0$37 = $targ$31;if (___hasprop(t0$37, "env")) {
                                          env$7 = t0$37.env;
                                        } else {
                                          ___match_error($targ$31, "{=> env}");
                                        }env$7.bind(newscope$2, s$7, undefined);changes$0 = true;temp$19 = ["ignore"];acc$7.push(temp$19);
                                      } else {
                                        other$10 = m$32;temp$19 = ["newargs", other$10];acc$7.push(temp$19);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          })(), acc$7));t0$38 = $targ$27;if (___hasprop(t0$38, "newargs") && (newargs$2 = t0$38.newargs, ___hasprop(t0$38, "vars"))) {
                            vars$0 = t0$38.vars;
                          } else {
                            ___match_error($targ$27, "{=> newargs, => vars}");
                          }[newargs$2, vars$0];exp$0 = function exp(s$8) {
                            var m$33 = undefined;var acc$8 = undefined;var temp$20 = undefined;var m$34 = undefined;var acc$9 = undefined;var temp$21 = undefined;var stepped$0 = undefined;acc$8 = [];temp$20 = null;m$33 = null;$19: for (var _iterator3 = enumerate(newargs$2)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                              m$33 = _step3.value;
                              var e$8 = undefined;var i$0 = undefined;var arg$6 = undefined;var t0$39 = undefined;var t1$13 = undefined;t0$39 = m$33;if (Array.isArray(t0$39) && (t1$13 = t0$39.length, t1$13 === 2)) {
                                i$0 = t0$39[0];arg$6 = t0$39[1];if (i$0 === newargs$2.length - 1) {
                                  e$8 = "expr";
                                } else {
                                  e$8 = "ignore";
                                }temp$20 = $it$32.step(["expr", e$8], s$8, arg$6);acc$8.push(temp$20);
                              } else {
                                ___match_error(m$33);
                              }
                            }stepped$0 = acc$8;acc$9 = [];temp$21 = null;m$34 = null;$18: for (var _iterator4 = stepped$0[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                              m$34 = _step4.value;
                              var arg$7 = undefined;arg$7 = m$34;temp$21 = helper$1(["expr", "expr"], s$8, arg$7);acc$9.push(temp$21);
                            }return acc$9;
                          };if (changes$0) {
                            return ["scope", vars$0, ["multi"].concat(exp$0(newscope$2))];
                          } else {
                            return ["multi"].concat(exp$0(scope$13));
                          }
                        } else {
                          if ($$2854$0 && m$28$0[0] === "data") {
                            args$6 = Array.prototype.slice.call(m$28$0, 1);obj$0 = ["object"];arr$0 = ["array"];arr_parts$0 = [];obj_parts$0 = [];index$0 = 0;objindex$0 = null;new_arr_part$0 = function new_arr_part() {
                              var other$11 = undefined;var t0$40 = undefined;var m$35$0 = undefined;m$35$0 = arr$0;if (Array.isArray(m$35$0) && (t0$40 = m$35$0.length, t0$40 === 1 && m$35$0[0] === "array")) {
                                return false;
                              } else {
                                other$11 = m$35$0;arr_parts$0.push(arr$0);arr$0 = ["array"];return arr$0;
                              }
                            };decl_obj$0 = function decl_obj() {
                              var msg$3 = undefined;var msg$4 = undefined;var m$36$0 = undefined;m$36$0 = objindex$0;if (equal(index$0, null)) {
                                msg$3 = "Object fields cannot be declared after *rest arguments.";throw ErrorFactory(["syntax", "illegal_object"]).create(msg$3, { node: expr$7 });
                              } else {
                                if (equal(m$36$0, null)) {
                                  objindex$0 = index$0;return objindex$0;
                                } else {
                                  if (equal(m$36$0, index$0)) {
                                    return undefined;
                                  } else {
                                    msg$4 = "Cannot declare object fields at multiple indexes.";throw ErrorFactory(["syntax", "illegal_object"]).create(msg$4, { node: expr$7 });
                                  }
                                }
                              }
                            };new_obj_part$0 = function new_obj_part() {
                              var other$12 = undefined;var t0$41 = undefined;var m$37$0 = undefined;m$37$0 = obj$0;if (Array.isArray(m$37$0) && (t0$41 = m$37$0.length, t0$41 === 1 && m$37$0[0] === "object")) {
                                return false;
                              } else {
                                other$12 = m$37$0;obj_parts$0.push(obj$0);obj$0 = ["object"];return obj$0;
                              }
                            };m$38 = null;$20: for (var _iterator3 = $it$32.step_all(["expr", "data"], scope$13, args$6)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                              m$38 = _step3.value;
                              var other$13 = undefined;var expr$9 = undefined;var expr$8 = undefined;var k$3 = undefined;var v$7 = undefined;var $$3343$0 = undefined;var $$3344$0 = undefined;var $$3345$0 = undefined;var $$3346$0 = undefined;var t0$42 = undefined;var t1$14 = undefined;t0$42 = m$38;if (($$3344$0 = Array.isArray(t0$42)) && (t1$14 = t0$42.length, t1$14 === 1 && t0$42[0] === "assoc")) {
                                decl_obj$0();
                              } else {
                                if ($$3344$0 && (t1$14 === 3 && t0$42[0] === "assoc")) {
                                  k$3 = t0$42[1];v$7 = t0$42[2];decl_obj$0();obj$0.push(["array", k$3, v$7]);
                                } else {
                                  if ($$3344$0 && (($$3346$0 = t1$14 === 2) && t0$42[0] === "dynsplice")) {
                                    expr$8 = t0$42[1];index$0 = null;new_arr_part$0();arr_parts$0.push(expr$8);
                                  } else {
                                    if ($$3346$0 && t0$42[0] === "objsplice") {
                                      expr$9 = t0$42[1];decl_obj$0();new_obj_part$0();obj_parts$0.push(expr$9);
                                    } else {
                                      other$13 = m$38;if (nequal(index$0, null)) {
                                        index$0 = index$0 + 1;
                                      }arr$0.push(other$13);
                                    }
                                  }
                                }
                              }
                            }new_arr_part$0();is_obj$0 = nequal(objindex$0, null);if (is_obj$0 && nequal(arr_parts$0, [])) {
                              obj$0.push(["array", ["value", "::objinsert"], ["value", objindex$0]]);
                            }new_obj_part$0();f$3 = function f(x$12, rest$0) {
                              return ["send", ["symbol", "&:"], ["data", x$12, rest$0]];
                            };obj$0 = util$0.construct(obj_parts$0, f$3, ["object"]);f$4 = function f(x$13, rest$1) {
                              return ["send", ["send", rest$1, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "concat"]]]], ["data", x$13]];
                            };arr$0 = util$0.construct(arr_parts$0.reverse(), f$4, ["array"]);m$39$0 = arr_parts$0;if (Array.isArray(m$39$0) && (t0$43 = m$39$0.length, t0$43 === 0 && is_obj$0)) {
                              r$0 = obj$0;
                            } else {
                              if (is_obj$0) {
                                r$0 = ["send", ["symbol", "&:"], ["data", arr$0, obj$0]];
                              } else {
                                other$14 = m$39$0;r$0 = arr$0;
                              }
                            }return helper$1(context$9, scope$13, $it$32.mkenv().mark(r$0));
                          } else {
                            if ($$2852$0 && (t0$29 === 3 && m$28$0[0] === "assign")) {
                              target$0 = m$28$0[1];value$9 = m$28$0[2];t$2 = helper$1(["expr", "expr"], scope$13, target$0);orig$0 = t$2.origin || {};m$40$0 = t$2;if ((x$14 = m$40$0, x$14 instanceof Array && x$14[0] === "variable") && (!t$2.mutable && orig$0.assigned && orig$0.assigned.group_id !== target$0.group_id)) {
                                msg$5 = ["Variable was declared as read-only. Declare it as", "mutable at the origin with `var` (if you have access", "to the declaration) or declare a new variable with", "`let` or `var` or remove the original binding with", "`delete`"].join(" ");throw ErrorFactory(["syntax"]).create(msg$5, { variable: target$0, loc: t$2.assigned });
                              } else {
                                if (Array.isArray(m$40$0) && (t0$44 = m$40$0.length, t0$44 === 2 && m$40$0[0] === "macro")) {
                                  m$41 = m$40$0[1];["bounce", m$41(["assign"], scope$13, expr$7, value$9)];
                                } else {
                                  otherwise$0 = m$40$0;$targ$32 = target$0;orig$0.assigned = $targ$32;void 0;
                                }
                              }return ["assign", t$2, helper$1(["expr", "expr"], scope$13, value$9)];
                            } else {
                              if ($$2852$0 && (t0$29 === 4 && m$28$0[0] === "lambda")) {
                                bindings$2 = m$28$0[1];body$1 = m$28$0[2];generator$0 = m$28$0[3];newscope$3 = Scope$0(scope$13);return ["lambda", (acc$10 = [], temp$22 = null, m$42 = null, (function () {
                                  $21: for (var _iterator4 = bindings$2[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                    m$42 = _step4.value;
                                    var v$8 = undefined;var x$15 = undefined;var other$15 = undefined;var v$9 = undefined;var b$1 = undefined;var env$8 = undefined;var $$3619$0 = undefined;var t0$46 = undefined;var t1$15 = undefined;var binding$0 = undefined;var ph$7$0 = undefined;var t0$45 = undefined;t0$45 = m$42;binding$0 = t0$45;ph$7$0 = t0$45;t0$46 = ph$7$0;if (Array.isArray(t0$46) && (t1$15 = t0$46.length, t1$15 === 2 && (t0$46[0] === "symbol" && (b$1 = t0$46[1], ___hasprop(t0$46, "env"))))) {
                                      env$8 = t0$46.env;v$8 = __lt____lt____colon__$0(["variable", $it$32.gensym(b$1)], binding$0);__amp____colon__(v$8, { mutable: binding$0.mutable, group_id: binding$0.group_id, assigned: v$8 });env$8.bind(newscope$3, b$1, v$8);temp$22 = v$8;
                                    } else {
                                      if ((x$15 = t0$46, x$15 instanceof Array && x$15[0] === "variable")) {
                                        v$9 = t0$46;temp$22 = v$9;
                                      } else {
                                        other$15 = ph$7$0;throw ErrorFactory(["syntax", "lambda", "binding"]).create("Not a valid binding.", { node: other$15 });
                                      }
                                    }acc$10.push(temp$22);
                                  }
                                })(), acc$10), helper$1(["expr", "expr"], newscope$3, body$1), generator$0];
                              } else {
                                if ($$2852$0 && (($$2854$0 = t0$29 === 3) && m$28$0[0] === "use")) {
                                  ph$6$0 = m$28$0[1];x$16 = m$28$0[2];t0$47 = ph$6$0;if (typeof t0$47 === "string") {
                                    name$9 = t0$47;s$9 = scope$13;$22: while (s$9) {
                                      if (s$9.name.slice(0, name$9.length + 1) === name$9 + "/") {
                                        break $22;
                                      } else {
                                        s$9 = s$9.parent;s$9;
                                      }
                                    }if (s$9) {
                                      return helper$1(context$9, s$9, x$16);
                                    } else {
                                      throw ErrorFactory(["syntax", "noscope"]).create("Could not find a scope tagged: " + name$9);
                                    }
                                  } else {
                                    newscope$4 = ph$6$0;return helper$1(context$9, newscope$4, x$16);
                                  }
                                } else {
                                  if ($$2854$0 && (m$28$0[0] === "tagscope" && (t1$10 = m$28$0[1], typeof t1$10 === "string"))) {
                                    tag$0 = t1$10;body$2 = m$28$0[2];return helper$1(context$9, Scope$0(scope$13, $it$32.gensym(tag$0 + "/")), body$2);
                                  } else {
                                    if ($$2852$0 && (t0$29 === 2 && m$28$0[0] === "final")) {
                                      x$17 = m$28$0[1];return x$17;
                                    } else {
                                      if ($$2852$0 && (t0$29 >= 1 && (type$2 = m$28$0[0], args$7 = Array.prototype.slice.call(m$28$0, 1), $it$32.generic_nodes.indexOf(type$2) !== -1))) {
                                        return [type$2].concat((acc$11 = [], temp$23 = null, m$43 = null, (function () {
                                          $23: for (var _iterator4 = args$7[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                            m$43 = _step4.value;
                                            var arg$8 = undefined;arg$8 = m$43;temp$23 = helper$1(["expr", "expr"], scope$13, arg$8);acc$11.push(temp$23);
                                          }
                                        })(), acc$11));
                                      } else {
                                        if ($$2852$0 && (t0$29 >= 2 && m$28$0[0] === "mismix")) {
                                          ops$0 = m$28$0[1];args$8 = Array.prototype.slice.call(m$28$0, 2);tokens$0 = object((acc$12 = [], temp$24 = null, m$44 = null, (function () {
                                            $24: for (var _iterator4 = enumerate(ops$0)[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                              m$44 = _step4.value;
                                              var i$1 = undefined;var op$0 = undefined;var t0$48 = undefined;var t1$16 = undefined;t0$48 = m$44;if (Array.isArray(t0$48) && (t1$16 = t0$48.length, t1$16 === 2)) {
                                                i$1 = t0$48[0];op$0 = t0$48[1];temp$24 = ["token" + String(i$1 + 1), op$0];acc$12.push(temp$24);
                                              } else {
                                                ___match_error(m$44);
                                              }
                                            }
                                          })(), acc$12));msg$6 = "These operators or brackets cannot be mixed together.";throw ErrorFactory(["syntax", "mismatch"]).create(msg$6, tokens$0);
                                        } else {
                                          if ($$2852$0 && (t0$29 === 2 && m$28$0[0] === "char")) {
                                            c$0 = m$28$0[1];throw ErrorFactory(["syntax", "illegal_character"]).create("An illegal character was found: " + c$0, { node: expr$7 });
                                          } else {
                                            other$16 = m$28$0;throw ErrorFactory(["syntax", "illegal_node"]).create("An illegal node was found: " + other$16, { node: other$16, context: context$9 });
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };t0$49 = getProjector(track_location$0)($targ$24);if (t0$49[0]) {
    helper$1 = t0$49[1];
  } else {
    ___match_error($targ$24, "track_location! helper{context, scope, var expr}");
  }return helper$1(context$8, scope$12, expr$6);
};__amp____colon__(Expander$0, __amp____colon__(($targ$33 = "Expander", accum$6 = {}, accum$6["::name"] = $targ$33, accum$6), ($targ$34 = true, accum$7 = {}, accum$7["::egclass"] = $targ$34, accum$7)));topscope$0 = Scope$0(null, "top", true);$targ$35 = Env$0;exports.Env = $targ$35;$targ$36 = Scope$0;exports.Scope = $targ$36;$targ$37 = Info$0;exports.Info = $targ$37;$targ$38 = track_location$0;exports.track_location = $targ$38;$targ$39 = Expander$0;exports.Expander = $targ$39;$targ$40 = GenSym$0;exports.GenSym = $targ$40;$targ$41 = gensym$0;exports.gensym = $targ$41;$targ$42 = topscope$0;exports.topscope = $targ$42;$targ$43 = jsKeywords$0;exports.jsKeywords = $targ$43;void 0;
//# sourceMappingURL=expand.js.map


},{"./lex":105,"./location":106,"./parse":120,"./util":126,"earlgrey-runtime/5":446}],105:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var id$0 = undefined;var id_f$0 = undefined;var numr$0 = undefined;var numr_f$0 = undefined;var num$0 = undefined;var num_f$0 = undefined;var quasi$0 = undefined;var quasi2$0 = undefined;var quasi_f$0 = undefined;var quaint$0 = undefined;var quaint2$0 = undefined;var quaint_f$0 = undefined;var str$0 = undefined;var str2$0 = undefined;var str_f$0 = undefined;var op$0 = undefined;var op2$0 = undefined;var op3$0 = undefined;var op_f$0 = undefined;var indent$0 = undefined;var indent_f$0 = undefined;var indent2$0 = undefined;var indent2_f$0 = undefined;var cmnt$0 = undefined;var hashbang$0 = undefined;var cmnt_f$0 = undefined;var op4$0 = undefined;var ign$0 = undefined;var ign_f$0 = undefined;var unkn$0 = undefined;var unkn_f$0 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var $0$0 = undefined;var Location$0 = undefined;var __lt____lt____colon__$0 = undefined;var unescape$0 = undefined;var special_ops$0 = undefined;var regexps$0 = undefined;var ws_re$0 = undefined;var eol_re$0 = undefined;var produce$0 = undefined;var indent_tracker$0 = undefined;var process_indent$0 = undefined;var disambiguate_fixity$0 = undefined;var alternate_operators$0 = undefined;var fill_locations$0 = undefined;var tokenize$0 = undefined;$0$0 = require("./location");Location$0 = getProperty($0$0, "Location", "./location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "./location");unescape$0 = function unescape(s$0) {
  var rx$0 = undefined;var f$0 = undefined;var repl$0 = undefined;repl$0 = { b: String.fromCharCode(8), f: String.fromCharCode(12), n: "\n", r: String.fromCharCode(13), t: String.fromCharCode(9) };rx$0 = RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\.", "g");f$0 = function f(ph$0$0) {
    var chr$0 = undefined;var digits$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;var t2$0 = undefined;t0$0 = getProjector(RegExp("^(?:\\\\u|\\\\x)(.*)", ""))(ph$0$0);if (t0$0[0] && (t1$0 = t0$0[1], t2$0 = t1$0.length, t2$0 === 2)) {
      t1$0[0];digits$0 = t1$0[1];return String.fromCharCode(parseInt(digits$0, 16));
    } else {
      t0$0 = getProjector(RegExp("^.(.)", ""))(ph$0$0);if (t0$0[0] && (t1$0 = t0$0[1], t2$0 = t1$0.length, t2$0 === 2)) {
        t1$0[0];chr$0 = t1$0[1];return send(repl$0, chr$0) || chr$0;
      } else {
        return ___match_error(ph$0$0, "R\"^.(.)\"! {_, chr}");
      }
    }
  };return s$0.replace(rx$0, f$0);
};special_ops$0 = { "(": "PFX", "[": "PFX", "{": "PFX", ")": "SFX", "]": "SFX", "}": "SFX", ",": "IFX", ";": "IFX", ".": "PFX", not: "PFX", "??": "SFX" };id$0 = RegExp("(?:^(?:[a-zA-Z$_]|(?:\\\\_.))(?:(?:(?:[a-zA-Z$_0-9]|(?:\\\\_.))|(?:-[a-zA-Z$_0-9]))*))", "");id_f$0 = function id_f(m$0) {
  return ["ID", m$0[0].replace(RegExp("\\\\_(.)", "g"), function (temp$0$0, x$0) {
    return x$0;
  })];
};numr$0 = RegExp("(?:^((?:\\d+))[rR]((?:[A-Za-z0-9_]+))(?:(?:\\.((?:[A-Za-z0-9_]+)))?))", "");numr_f$0 = function numr_f(m$1) {
  var t0$1 = undefined;var t1$1 = undefined;var frac$1 = undefined;var $targ$0 = undefined;var radix$0 = undefined;var intp$0 = undefined;var frac$0 = undefined;var value$0 = undefined;$targ$0 = m$1;t0$1 = $targ$0;if (Array.isArray(t0$1) && (t1$1 = t0$1.length, t1$1 === 4)) {
    t0$1[0];radix$0 = t0$1[1];intp$0 = t0$1[2];frac$0 = t0$1[3];
  } else {
    ___match_error($targ$0, "{_, radix, intp, frac}");
  }[radix$0, intp$0, frac$0];value$0 = parseInt(intp$0.replace(RegExp("_", "g"), ""), radix$0);if (frac$0) {
    frac$1 = frac$0.replace(RegExp("_", "g"), "");value$0 = value$0 + parseInt(frac$0, radix$0) / Math.pow(radix$0, frac$0.length);value$0;
  }return ["NUM", value$0];
};num$0 = RegExp("(?:^((?:[0-9_]+))(?:(?:\\.((?:\\d+)))?)(?:(?:[eE]((?:[+-]?)(?:[0-9_]+)))?))", "");num_f$0 = function num_f(m$2) {
  return ["NUM", parseFloat(m$2[0].replace(RegExp("_", "g"), ""))];
};quasi$0 = RegExp("(?:^`((?:(?:(?:\\\\.)|[^`])*))`)", "");quasi2$0 = RegExp("^[`]{3,}((?:[\\\\.]|[^`]|``?[^`])*)[`]{3,}", "");quasi_f$0 = function quasi_f(m$3) {
  return ["QUASI", m$3[1]];
};quaint$0 = RegExp("(?:^'((?:(?:(?:\\\\.)|[^'])*))')", "");quaint2$0 = RegExp("^[']{3,}((?:[\\\\.]|[^']|''?[^'])*)[']{3,}", "");quaint_f$0 = function quaint_f(m$4) {
  return ["QUAINT", m$4[1]];
};str$0 = RegExp("(?:^\"((?:(?:(?:\\\\.)|[^\"])*))\")", "");str2$0 = RegExp("^[\\\"]{3,}((?:[\\\\.]|[^\\\"]|\\\"\\\"?[^\\\"])*)[\\\"]{3,}", "");str_f$0 = function str_f(m$5) {
  return ["STR", unescape$0(m$5[1])];
};op$0 = RegExp("(?:^(?:[+\\-*/~\\^<>=%&|?!@#:]+))", "");op2$0 = RegExp("(?:^(?:[\\(\\[\\{\\}\\]\\),]|(?:\\.+)))", "");op3$0 = RegExp("(?:^(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:with|where)|when)|and)|not)|or)|in)|mod)|each)|as)|of)|is)(?:(?:[+*/~\\^<>=%&|?!@#.:]+)|\\b)(?!-))", "");op_f$0 = function op_f(m$6, column$0) {
  var fixity$0 = undefined;var otherwise$0 = undefined;var $$4140$0 = undefined;var m$7$0 = undefined;var op$1 = undefined;op$1 = m$6[1] || m$6[0];m$7$0 = null;if (op$1 === "|") {
    return ["INDENT", column$0 - 1];
  } else {
    if (send(special_ops$0, op$1)) {
      fixity$0 = send(special_ops$0, op$1);return ["OP", fixity$0, op$1];
    } else {
      otherwise$0 = m$7$0;return ["OP", "?FX", op$1];
    }
  }
};indent$0 = RegExp("(?:^(?:(?:\n(?: *);;(?:[^\n]*))*)(?:(?:\n((?: *)))+))", "");indent_f$0 = function indent_f(m$8) {
  var ilen$0 = undefined;ilen$0 = m$8[1].length;return ["INDENT", ilen$0];
};indent2$0 = RegExp("(?:^\\\\\\\\)", "");indent2_f$0 = function indent2_f(m$9, column$1) {
  return ["INDENT", column$1 - 2];
};cmnt$0 = RegExp("(?:^;;(?:[^\n]*))", "");hashbang$0 = RegExp("(?:^#!(?:[^\n]*))", "");cmnt_f$0 = function cmnt_f(m$10) {
  return ["IGNORE"];
};op4$0 = RegExp("(?:^;)", "");ign$0 = RegExp("\r", "");ign_f$0 = function ign_f(m$11) {
  return ["IGNORE"];
};unkn$0 = RegExp("(?:^(?:(?:.|\n)|\r))", "");unkn_f$0 = function unkn_f(m$12) {
  return ["ILLEGAL", m$12[0]];
};regexps$0 = [[op3$0, op_f$0], [id$0, id_f$0], [numr$0, numr_f$0], [num$0, num_f$0], [str2$0, str_f$0], [str$0, str_f$0], [quasi2$0, quasi_f$0], [quasi$0, quasi_f$0], [quaint2$0, quaint_f$0], [quaint$0, quaint_f$0], [hashbang$0, cmnt_f$0], [op$0, op_f$0], [op2$0, op_f$0], [indent$0, indent_f$0], [indent2$0, indent2_f$0], [cmnt$0, cmnt_f$0], [op4$0, op_f$0], [ign$0, ign_f$0], [unkn$0, unkn_f$0]];ws_re$0 = RegExp("(?:^(?: *)(?:(?:\n(?: *)\\\\ (?: *))*))", "");eol_re$0 = RegExp("(?:^(?: *)(?:\r?)(?:\n|$))", "");produce$0 = function produce(src$0) {
  var text$0 = undefined;var results$0 = undefined;var wsb$0 = undefined;var pos$0 = undefined;var column$2 = undefined;text$0 = src$0.text;results$0 = [];wsb$0 = text$0.match(ws_re$0)[0].length;text$0 = text$0.slice(wsb$0);pos$0 = wsb$0;column$2 = 0;$1: while (text$0) {
    var i$0 = undefined;i$0 = 0;$2: for (null; i$0 < regexps$0.length; ++i$0) {
      var t0$2 = undefined;var t1$2 = undefined;var splits$0 = undefined;var skip$0 = undefined;var endpos$0 = undefined;var wsa$0 = undefined;var eol$0 = undefined;var bwsb$0 = undefined;var bwsa$0 = undefined;var token$0 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$1 = undefined;var re$0 = undefined;var fn$0 = undefined;var m$13 = undefined;$targ$1 = send(regexps$0, i$0);t0$2 = $targ$1;if (Array.isArray(t0$2) && (t1$2 = t0$2.length, t1$2 === 2)) {
        re$0 = t0$2[0];fn$0 = t0$2[1];
      } else {
        ___match_error($targ$1, "{re, fn}");
      }[re$0, fn$0];m$13 = text$0.match(re$0);if (m$13) {
        skip$0 = m$13[0].length;endpos$0 = pos$0 + skip$0;splits$0 = m$13[0].split("\n");if (splits$0.length > 1) {
          column$2 = send(splits$0, splits$0.length - 1).length;
        } else {
          column$2 = column$2 + skip$0;
        }text$0 = text$0.slice(skip$0);wsa$0 = text$0.match(ws_re$0)[0].length;eol$0 = text$0.match(eol_re$0) && true;bwsb$0 = wsb$0 > 0;if (eol$0) {
          bwsa$0 = bwsb$0;
        } else {
          bwsa$0 = wsa$0 > 0;
        }token$0 = fn$0(m$13, column$2);$targ$2 = bwsb$0;token$0.wsb = $targ$2;$targ$3 = bwsa$0;token$0.wsa = $targ$3;$targ$4 = Location$0(src$0, pos$0, endpos$0);token$0.location = $targ$4;results$0.push(token$0);text$0 = text$0.slice(wsa$0);column$2 = column$2 + wsa$0;wsb$0 = wsa$0;pos$0 = endpos$0 + wsa$0;break $2;
      }
    }
  }return results$0;
};indent_tracker$0 = function indent_tracker() {
  var curr$0 = undefined;var stack$0 = undefined;var stacks$0 = undefined;curr$0 = 0;stack$0 = [];stacks$0 = [stack$0];return function (temp$1$0) {
    var t0$3 = undefined;var rval$0 = undefined;var m$14 = undefined;var acc$0 = undefined;var temp$2 = undefined;var rval$1 = undefined;var x$1 = undefined;var m$15 = undefined;var acc$1 = undefined;var temp$3 = undefined;var other$0 = undefined;var fixity$2 = undefined;var fixity$1 = undefined;var stuff$0 = undefined;var new_indent$0 = undefined;var ph$2$0 = undefined;var $$4376$0 = undefined;var $$4377$0 = undefined;var $$4378$0 = undefined;var $$4379$0 = undefined;var t0$4 = undefined;var t1$3 = undefined;var t2$1 = undefined;var bridge$$4371$0 = undefined;var bridge$$4373$0 = undefined;var token$1 = undefined;var ph$1$0 = undefined;t0$3 = temp$1$0;token$1 = t0$3;ph$1$0 = t0$3;t0$4 = ph$1$0;t1$3 = t0$4.length;if (t1$3 === 2 && t0$4[0] === "INDENT") {
      t2$1 = t0$4[1];new_indent$0 = t2$1;ph$2$0 = t2$1;if (curr$0 === false) {
        curr$0 = new_indent$0;return [__amp__(["OP", "IFX", ";"], { wsb: true, wsa: true })];
      } else {
        if (ph$2$0 > curr$0) {
          stack$0.push(curr$0);curr$0 = new_indent$0;return [__amp__(["OP", "PFX", "["], { wsb: true, wsa: true })];
        } else {
          if (ph$2$0 === curr$0) {
            return [__amp__(["OP", "IFX", ";"], { wsb: true, wsa: true })];
          } else {
            if (ph$2$0 < curr$0) {
              rval$0 = [];$3: while (stack$0.length > 0 && new_indent$0 < curr$0) {
                curr$0 = stack$0.pop();rval$0.push(__amp__(["OP", "SFX", "]"], { wsb: true, wsa: true }));
              }rval$0.push(__amp__(["OP", "IFX", ";"], { wsb: true, wsa: true }));return rval$0;
            } else {
              return ___match_error(ph$2$0, "[< curr]");
            }
          }
        }
      }
    } else {
      if (t1$3 >= 1 && t0$4[0] === "ID") {
        stuff$0 = Array.prototype.slice.call(t0$4, 1);return [token$1];
      } else {
        if (($$4378$0 = t1$3 === 3) && (($$4379$0 = t0$4[0] === "OP") && (fixity$1 = t0$4[1], bridge$$4371$0 = t0$4[2], bridge$$4371$0 === "[" || bridge$$4371$0 === "{"))) {
          stack$0.push(curr$0);stacks$0.push(stack$0);stack$0 = [];curr$0 = false;return [token$1];
        } else {
          if ($$4379$0 && (fixity$2 = t0$4[1], bridge$$4373$0 = t0$4[2], bridge$$4373$0 === "]" || bridge$$4373$0 === "}")) {
            acc$0 = [];temp$2 = null;m$14 = null;$4: for (var _iterator = stack$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$14 = _step.value;
              temp$2 = __amp__(["OP", "SFX", "]"], { wsb: true, wsa: true });acc$0.push(temp$2);
            }rval$1 = acc$0;stack$0 = stacks$0.pop();curr$0 = stack$0.pop();rval$1.push(token$1);return rval$1;
          } else {
            if ((x$1 = ph$1$0, x$1 instanceof Array && x$1[0] === "EOF")) {
              acc$1 = [];temp$3 = null;m$15 = null;$5: for (var _iterator2 = stack$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                m$15 = _step2.value;
                temp$3 = __amp__(["OP", "SFX", "]"], { wsb: true, wsa: true });acc$1.push(temp$3);
              }return acc$1;
            } else {
              other$0 = ph$1$0;return [token$1];
            }
          }
        }
      }
    }
  };
};process_indent$0 = function process_indent(stream$0) {
  var m$16 = undefined;var tracker$0 = undefined;var results$1 = undefined;tracker$0 = indent_tracker$0();results$1 = [];m$16 = null;$6: for (var _iterator = stream$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$16 = _step.value;
    var token$2 = undefined;token$2 = m$16;results$1 = results$1.concat(tracker$0(token$2));
  }return results$1.concat(tracker$0(["EOF"]));
};disambiguate_fixity$0 = function disambiguate_fixity(stream$1) {
  var m$23 = undefined;var __lt____lt____lt____colon__$0 = undefined;var collapse_operators$0 = undefined;var buffer$0 = undefined;var pfx$0 = undefined;var collapse$0 = undefined;var results$2 = undefined;__lt____lt____lt____colon__$0 = function (a$0, b$0) {
    var $targ$5 = undefined;var $targ$6 = undefined;$targ$5 = b$0.wsb;a$0.wsb = $targ$5;$targ$6 = b$0.wsa;a$0.wsa = $targ$6;return __lt____lt____colon__$0(a$0, b$0);
  };collapse_operators$0 = function collapse_operators() {
    var msg$0 = undefined;var longer$0 = undefined;var token$3 = undefined;var fixity$3 = undefined;var name$0 = undefined;var t0$7 = undefined;var t1$5 = undefined;var t2$2 = undefined;var m$18$0 = undefined;var m$19 = undefined;var acc$2 = undefined;var temp$4 = undefined;var m$20 = undefined;var acc$3 = undefined;var temp$5 = undefined;var t0$10 = undefined;var t1$8 = undefined;var t2$3 = undefined;var t3$0 = undefined;var t0$12 = undefined;var t0$13 = undefined;var t0$14 = undefined;var t0$15 = undefined;var t1$9 = undefined;var t2$4 = undefined;var bridge$$4860$0 = undefined;var m$22$0 = undefined;var t$0 = undefined;var results$3 = undefined;var $$4785$0 = undefined;var $$4786$0 = undefined;var $$4787$0 = undefined;var bridge$$4782$0 = undefined;var t0$11 = undefined;var m$21$0 = undefined;var $targ$7 = undefined;var first$0 = undefined;var fixity$4 = undefined;var name$3 = undefined;var rest$0 = undefined;var n$0 = undefined;var $$4625$0 = undefined;var $$4626$0 = undefined;var $$4627$0 = undefined;var t0$6 = undefined;var t1$4 = undefined;var buffer$1 = undefined;var ph$6$0 = undefined;var t0$5 = undefined;var m$17$0 = undefined;m$17$0 = arguments;t0$5 = m$17$0.length;if (t0$5 >= 1) {
      buffer$1 = m$17$0[0];ph$6$0 = Array.prototype.slice.call(m$17$0, 1);n$0 = buffer$1.length;if (!buffer$1.length) {
        return [];
      } else {
        t0$6 = ph$6$0;t1$4 = t0$6.length;if (($$4627$0 = t1$4 === 2) && ((t0$6[0] ? true : false) && (t0$6[1] ? true : false))) {
          m$18$0 = buffer$1;if (Array.isArray(m$18$0) && (t0$7 = m$18$0.length, t0$7 === 1 && (t1$5 = m$18$0[0], token$3 = t1$5, Array.isArray(t1$5) && (t2$2 = t1$5.length, t2$2 === 3 && t1$5[0] === "OP")))) {
            fixity$3 = t1$5[1];name$0 = t1$5[2];return [__lt____lt____lt____colon__$0(["ID", name$0], token$3)];
          } else {
            longer$0 = m$18$0;msg$0 = "Too many consecutive operators were found here.";throw ErrorFactory(["syntax", "nullary"]).create(msg$0, { operators: buffer$1 });
          }
        } else {
          if ($$4627$0 && (t0$6[0] ? true : false)) {
            t0$6[1];acc$2 = [];temp$4 = null;m$19 = null;$8: for (var _iterator = buffer$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$19 = _step.value;
              var token$4 = undefined;var name$1 = undefined;var t0$8 = undefined;var t1$6 = undefined;t0$8 = m$19;token$4 = t0$8;if (Array.isArray(t0$8) && (t1$6 = t0$8.length, t1$6 === 3 && t0$8[0] === "OP")) {
                t0$8[1];name$1 = t0$8[2];temp$4 = __lt____lt____lt____colon__$0(["OP", "PFX", name$1], token$4);acc$2.push(temp$4);
              } else {
                ___match_error(m$19);
              }
            }return acc$2;
          } else {
            if ($$4627$0 && (t0$6[0], t0$6[1] ? true : false)) {
              acc$3 = [];temp$5 = null;m$20 = null;$9: for (var _iterator2 = buffer$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                m$20 = _step2.value;
                var token$5 = undefined;var name$2 = undefined;var t0$9 = undefined;var t1$7 = undefined;t0$9 = m$20;token$5 = t0$9;if (Array.isArray(t0$9) && (t1$7 = t0$9.length, t1$7 === 3 && t0$9[0] === "OP")) {
                  t0$9[1];name$2 = t0$9[2];temp$5 = __lt____lt____lt____colon__$0(["OP", "SFX", name$2], token$5);acc$3.push(temp$5);
                } else {
                  ___match_error(m$20);
                }
              }return acc$3;
            } else {
              $targ$7 = buffer$1;t0$10 = $targ$7;if (Array.isArray(t0$10) && (t1$8 = t0$10.length, t1$8 >= 1 && (t2$3 = t0$10[0], first$0 = t2$3, Array.isArray(t2$3) && (t3$0 = t2$3.length, t3$0 === 3 && t2$3[0] === "OP")))) {
                fixity$4 = t2$3[1];name$3 = t2$3[2];rest$0 = Array.prototype.slice.call(t0$10, 1);
              } else {
                ___match_error($targ$7, "{first and #OP{fixity, name}, *rest}");
              }[first$0, fixity$4, name$3, rest$0];m$21$0 = [first$0.wsb, first$0.wsa];bridge$$4782$0 = m$21$0;if (Array.isArray(bridge$$4782$0) && (t0$12 = bridge$$4782$0.length, t0$12 === 2 && (!bridge$$4782$0[0] && !bridge$$4782$0[1])) || Array.isArray(bridge$$4782$0) && (t0$13 = bridge$$4782$0.length, t0$13 === 2 && ((bridge$$4782$0[0] ? true : false) && (bridge$$4782$0[1] ? true : false)))) {
                return [__lt____lt____lt____colon__$0(["OP", "IFX", name$3], first$0)].concat(collapse_operators$0(rest$0, true, false));
              } else {
                if (($$4785$0 = Array.isArray(m$21$0)) && (t0$11 = m$21$0.length, ($$4787$0 = t0$11 === 2) && (m$21$0[0] ? true : false))) {
                  m$21$0[1];return [__lt____lt____lt____colon__$0(["OP", "PFX", name$3], first$0)].concat(collapse_operators$0(rest$0, true, false));
                } else {
                  if ($$4787$0 && (m$21$0[0], m$21$0[1] ? true : false)) {
                    results$3 = collapse_operators$0(rest$0, false, false);m$22$0 = results$3;bridge$$4860$0 = m$22$0;if (Array.isArray(bridge$$4860$0) && (t0$14 = bridge$$4860$0.length, t0$14 === 0) || Array.isArray(bridge$$4860$0) && (t0$15 = bridge$$4860$0.length, t0$15 >= 1 && (t1$9 = bridge$$4860$0[0], Array.isArray(t1$9) && (t2$4 = t1$9.length, t2$4 >= 2 && (t1$9[0] === "OP" && (t1$9[1] === "PFX" && (Array.prototype.slice.call(t1$9, 2), Array.prototype.slice.call(bridge$$4860$0, 1), true))))))) {
                      t$0 = ["OP", "IFX", name$3];
                    } else {
                      t$0 = ["OP", "SFX", name$3];
                    }return [__lt____lt____lt____colon__$0(t$0, first$0)].concat(results$3);
                  } else {
                    return ___match_error(m$21$0, "{_, true?}");
                  }
                }
              }
            }
          }
        }
      }
    } else {
      return ___match_error(m$17$0, "{buffer, *match}");
    }
  };buffer$0 = [];pfx$0 = true;collapse$0 = function collapse(sfx$0) {
    var rval$2 = undefined;rval$2 = collapse_operators$0(buffer$0, pfx$0, sfx$0);buffer$0 = [];return rval$2;
  };results$2 = [];m$23 = null;$7: for (var _iterator = stream$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$23 = _step.value;
    var other$1 = undefined;var ph$4$0 = undefined;var name$4 = undefined;var t0$17 = undefined;var t1$10 = undefined;var token$6 = undefined;var ph$3$0 = undefined;var t0$16 = undefined;t0$16 = m$23;token$6 = t0$16;ph$3$0 = t0$16;t0$17 = ph$3$0;if (Array.isArray(t0$17) && (t1$10 = t0$17.length, t1$10 === 3 && t0$17[0] === "OP")) {
      ph$4$0 = t0$17[1];name$4 = t0$17[2];if (ph$4$0 === "?FX") {
        buffer$0.push(token$6);
      } else {
        if (ph$4$0 === "IFX") {
          results$2 = results$2.concat(collapse$0(true));results$2.push(token$6);pfx$0 = true;pfx$0;
        } else {
          if (ph$4$0 === "PFX") {
            results$2 = results$2.concat(collapse$0(false));results$2.push(token$6);pfx$0 = true;pfx$0;
          } else {
            if (ph$4$0 === "SFX") {
              results$2 = results$2.concat(collapse$0(true));results$2.push(token$6);pfx$0 = false;pfx$0;
            } else {
              ___match_error(ph$4$0);
            }
          }
        }
      }
    } else {
      other$1 = ph$3$0;results$2 = results$2.concat(collapse$0(false));results$2.push(token$6);pfx$0 = false;pfx$0;
    }
  }return results$2.concat(collapse$0(true));
};alternate_operators$0 = function alternate_operators(stream$2) {
  var m$24 = undefined;var W$0 = undefined;var last_op$0 = undefined;var results$4 = undefined;W$0 = function W(x$2) {
    if (x$2) {
      return "wide";
    } else {
      return "short";
    }
  };last_op$0 = true;results$4 = [];m$24 = null;$10: for (var _iterator = stream$2[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$24 = _step.value;
    var x$3 = undefined;var m$25$0 = undefined;var token$8 = undefined;var fixity$5 = undefined;var name$5 = undefined;var t0$19 = undefined;var t1$11 = undefined;var token$7 = undefined;var ph$7$0 = undefined;var t0$18 = undefined;t0$18 = m$24;token$7 = t0$18;ph$7$0 = t0$18;if ((x$3 = ph$7$0, x$3 instanceof Array && x$3[0] === "IGNORE")) {
      null;
    } else {
      t0$19 = ph$7$0;if (Array.isArray(t0$19) && (t1$11 = t0$19.length, t1$11 === 3 && t0$19[0] === "OP")) {
        fixity$5 = t0$19[1];name$5 = t0$19[2];if (last_op$0) {
          results$4.push(["VOID"]);
        }m$25$0 = fixity$5;if (m$25$0 === "IFX") {
          results$4.push(__lt____lt____colon__$0(["IFX", W$0(token$7.wsa || token$7.wsb), name$5], token$7));last_op$0 = true;last_op$0;
        } else {
          if (m$25$0 === "PFX") {
            if (!last_op$0) {
              results$4.push(["IFX", W$0(token$7.wsb), "WHITE"], ["VOID"]);
            }results$4.push(__lt____lt____colon__$0(["PFX", W$0(token$7.wsa), name$5], token$7));last_op$0 = true;last_op$0;
          } else {
            if (m$25$0 === "SFX") {
              results$4.push(__lt____lt____colon__$0(["SFX", W$0(token$7.wsb), name$5], token$7), ["VOID"]);last_op$0 = false;last_op$0;
            } else {
              ___match_error(m$25$0, ".SFX");
            }
          }
        }
      } else {
        token$8 = ph$7$0;if (!last_op$0) {
          results$4.push(["IFX", W$0(token$8.wsb), "WHITE"]);
        }results$4.push(token$8);last_op$0 = false;last_op$0;
      }
    }
  }if (last_op$0) {
    results$4.push(["VOID"]);
  }return results$4;
};fill_locations$0 = function fill_locations(source$0, stream$3) {
  var m$27 = undefined;var to_fill$0 = undefined;var start$0 = undefined;var fill$0 = undefined;to_fill$0 = [];start$0 = 0;fill$0 = function fill(end$0) {
    var m$26 = undefined;var first$1 = undefined;first$1 = true;m$26 = null;$12: for (var _iterator = to_fill$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$26 = _step.value;
      var s$1 = undefined;var $targ$8 = undefined;var token$9 = undefined;token$9 = m$26;if (first$1) {
        first$1 = false;s$1 = start$0;
      } else {
        s$1 = end$0;
      }$targ$8 = Location$0(source$0, s$1, end$0);token$9.location = $targ$8;void 0;
    }to_fill$0 = [];return to_fill$0;
  };m$27 = null;$11: for (var _iterator = stream$3[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$27 = _step.value;
    var other$2 = undefined;var location$0 = undefined;var t0$20 = undefined;t0$20 = m$27;if (___hasprop(t0$20, "location") && (location$0 = t0$20.location, location$0)) {
      fill$0(location$0.start);start$0 = location$0.end;start$0;
    } else {
      other$2 = m$27;to_fill$0.push(other$2);
    }
  }fill$0(source$0.text.length);return stream$3;
};tokenize$0 = function tokenize(src$1) {
  var __at___$4 = undefined;var __at___$3 = undefined;var __at___$2 = undefined;var __at___$1 = undefined;var __at___$0 = undefined;__at___$0 = src$1;__at___$1 = produce$0(__at___$0);__at___$2 = process_indent$0(__at___$1);__at___$3 = disambiguate_fixity$0(__at___$2);__at___$4 = alternate_operators$0(__at___$3);return fill_locations$0(src$1, __at___$4);
};$targ$9 = tokenize$0;exports.tokenize = $targ$9;$targ$10 = process_indent$0;exports.process_indent = $targ$10;$targ$11 = disambiguate_fixity$0;exports.disambiguate_fixity = $targ$11;$targ$12 = alternate_operators$0;exports.alternate_operators = $targ$12;$targ$13 = fill_locations$0;exports.fill_locations = $targ$13;$targ$14 = unescape$0;exports.unescape = $targ$14;void 0;
//# sourceMappingURL=lex.js.map


},{"./location":106,"earlgrey-runtime/5":446}],106:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $0$0 = undefined;var binsearch$0 = undefined;var $1$0 = undefined;var __lt____gt__$0 = undefined;var _repr$0 = undefined;var fs$0 = undefined;var opg$0 = undefined;var Source$0 = undefined;var Location$0 = undefined;var $2$0 = undefined;var highlight$0 = undefined;var highlight_locations$0 = undefined;var merge_locations$0 = undefined;var repr$0 = undefined;var __lt____lt____colon__$0 = undefined;var __plus____plus____colon__$0 = undefined;var format_error$0 = undefined;var display_error$0 = undefined;$0$0 = require("./util");binsearch$0 = getProperty($0$0, "binsearch", "./util");$1$0 = require("./pp");__lt____gt__$0 = getProperty($1$0, "<>", "./pp");_repr$0 = getProperty($1$0, "repr", "./pp");fs$0 = require("fs");opg$0 = require("opg");Source$0 = getProperty(opg$0, "Source", "opg");Location$0 = getProperty(opg$0, "Location", "opg");$2$0 = require("opg/lib/highlight");highlight$0 = getProperty($2$0, "highlight", "opg/lib/highlight");highlight_locations$0 = getProperty($2$0, "highlightLocations", "opg/lib/highlight");merge_locations$0 = getProperty($2$0, "mergeLocations", "opg/lib/highlight");repr$0 = _repr$0;__lt____lt____colon__$0 = function (x$0, y$0) {
  var $targ$1 = undefined;var $targ$2 = undefined;var $targ$0 = undefined;if (!getChecker(Location$0)(x$0.location)) {
    if (!y$0 || getChecker(Location$0)(y$0)) {
      $targ$0 = y$0;
    } else {
      $targ$0 = y$0.location;
    }x$0.location = $targ$0;if (y$0.called) {
      $targ$1 = y$0.called;x$0.called = $targ$1;void 0;
    }if (y$0.name) {
      $targ$2 = y$0.name;x$0.name = $targ$2;void 0;
    }
  }return x$0;
};__plus____plus____colon__$0 = function (x$1, y$1) {
  var rval$0 = undefined;var x2$0 = undefined;var y2$0 = undefined;if (!x$1 || getChecker(Location$0)(x$1)) {
    x2$0 = x$1;
  } else {
    x2$0 = x$1.location;
  }if (!y$1 || getChecker(Location$0)(y$1)) {
    y2$0 = y$1;
  } else {
    y2$0 = y$1.location;
  }rval$0 = false;try {
    rval$0 = merge_locations$0([x2$0, y2$0]);rval$0;
  } catch (excv$0) {
    var e$0 = undefined;e$0 = excv$0;rval$0 = undefined;rval$0;
  }return rval$0;
};format_error$0 = function format_error() {
  var m$1 = undefined;var acc$0 = undefined;var temp$0 = undefined;var hls$0 = undefined;var locs$0 = undefined;var rval$1 = undefined;var loc$1 = undefined;var data$0 = undefined;var other$0 = undefined;var url$0 = undefined;var start$0 = undefined;var end$0 = undefined;var loc$0 = undefined;var args$0 = undefined;var fmt_args$0 = undefined;var $$5372$0 = undefined;var $$5373$0 = undefined;var $$5374$0 = undefined;var t0$1 = undefined;var t1$1 = undefined;var t2$0 = undefined;var e$1 = undefined;var ph$1$0 = undefined;var context$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 1 && t0$0 <= 2) {
    t1$0 = m$0$0[0];e$1 = t1$0;ph$1$0 = t1$0;if (1 >= t0$0) {
      context$0 = 0;
    } else {
      context$0 = m$0$0[1];
    }fmt_args$0 = function fmt_args(e$2) {
      if (e$2.args && e$2.args.length) {
        return ENode([".error_args"], {}, repr$0(e$2.args));
      } else {
        return "";
      }
    };t0$1 = ph$1$0;if (getChecker(ErrorFactory(["syntax"]))(t0$1) && (___hasprop(t0$1, "args") && (t1$1 = t0$1.args, Array.isArray(t1$1) && (t2$0 = t1$1.length, t2$0 === 1)))) {
      args$0 = t1$1[0];hls$0 = ["hl1", "hl2", "hl3", "hl4"];acc$0 = [];temp$0 = null;m$1 = null;$3: for (var _iterator = enumerate(items(args$0))[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$1 = _step.value;
        var i$0 = undefined;var key$0 = undefined;var arg$0 = undefined;var t0$2 = undefined;var t1$2 = undefined;var t2$1 = undefined;var t3$0 = undefined;t0$2 = m$1;if (Array.isArray(t0$2) && (t1$2 = t0$2.length, t1$2 === 2 && (i$0 = t0$2[0], t2$1 = t0$2[1], Array.isArray(t2$1) && (t3$0 = t2$1.length, t3$0 === 2 && (key$0 = t2$1[0], arg$0 = t2$1[1], arg$0 && arg$0.location))))) {
          temp$0 = [arg$0.location, send(hls$0, i$0 % 4)];acc$0.push(temp$0);
        } else {
          false;
        }
      }locs$0 = acc$0;return ENode(["div"], {}, [ENode([".error"], {}, [ENode([".error_type"], {}, e$1.name), ENode([".error_message"], {}, e$1.message)]), ENode([".error_args", ".syntax"], {}, repr$0(args$0)), highlight_locations$0(locs$0, context$0)]);
    } else {
      if (($$5373$0 = ___hasprop(t0$1, "location")) && (t1$1 = t0$1.location, getChecker(Location$0)(t1$1))) {
        loc$0 = t1$1;return ENode(["div"], {}, [ENode([".error"], {}, [ENode([".error_type"], {}, e$1.name), ENode([".error_message"], {}, e$1.message)]), fmt_args$0(e$1), highlight_locations$0([[loc$0, "hl1"]], context$0), ENode([".traceback"], {}, e$1.stack || "")]);
      } else {
        if ($$5373$0 && (Array.isArray(t1$1) && (t2$0 = t1$1.length, t2$0 === 4 && t1$1[0] === "location"))) {
          url$0 = t1$1[1];start$0 = t1$1[2];end$0 = t1$1[3];rval$1 = false;try {
            rval$1 = fs$0.readFileSync(url$0, "utf8");rval$1;
          } catch (excv$1) {
            var e$3 = undefined;e$3 = excv$1;rval$1 = null;rval$1;
          }data$0 = rval$1;if (data$0) {
            loc$1 = Location$0(Source$0(data$0, url$0), start$0, end$0);return ENode(["div"], {}, [ENode([".error"], {}, [ENode([".error_type"], {}, e$1.name), ENode([".error_message"], {}, e$1.message)]), fmt_args$0(e$1), highlight_locations$0([[loc$1, "hl1"]], context$0), ENode([".traceback"], {}, ENode([], {}, e$1.stack || ""))]);
          } else {
            return ENode(["div"], {}, [ENode([".error"], {}, [ENode([".error_type"], {}, e$1.name), ENode([".error_message"], {}, e$1.message)]), fmt_args$0(e$1), ENode([".traceback"], {}, ENode([], {}, e$1.stack || e$1))]);
          }
        } else {
          other$0 = ph$1$0;return ENode(["div"], {}, [ENode([".error"], {}, [ENode([".error_type"], {}, e$1.name), ENode([".error_message"], {}, e$1.message)]), fmt_args$0(e$1), ENode([".traceback"], {}, ENode([], {}, e$1.stack))]);
        }
      }
    }
  } else {
    return ___match_error(m$0$0, "{match e, context = 0}");
  }
};display_error$0 = function display_error(e$4) {
  return __lt____gt__$0(null, format_error$0(e$4));
};$targ$3 = Source$0;exports.Source = $targ$3;$targ$4 = Location$0;exports.Location = $targ$4;$targ$5 = highlight$0;exports.highlight = $targ$5;$targ$6 = highlight_locations$0;exports.highlight_locations = $targ$6;$targ$7 = merge_locations$0;exports.merge_locations = $targ$7;$targ$8 = __lt____lt____colon__$0;exports["<<:"] = $targ$8;$targ$9 = __plus____plus____colon__$0;exports["++:"] = $targ$9;$targ$10 = format_error$0;exports.format_error = $targ$10;$targ$11 = display_error$0;exports.display_error = $targ$11;void 0;
//# sourceMappingURL=location.js.map


},{"./pp":122,"./util":126,"earlgrey-runtime/5":446,"fs":697,"opg":553,"opg/lib/highlight":552}],107:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var expr_mac$0 = undefined;var expr_mac2$0 = undefined;var AssignmentHandler$0 = undefined;$0$0 = require("./helpers");expr_mac$0 = getProperty($0$0, "expr_mac", "./helpers");expr_mac2$0 = getProperty($0$0, "expr_mac2", "./helpers");AssignmentHandler$0 = getProperty($0$0, "AssignmentHandler", "./helpers");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var t0$3 = undefined;var t0$7 = undefined;var t0$13 = undefined;var t0$20 = undefined;var t0$21 = undefined;var t0$28 = undefined;var $targ$2 = undefined;var yield_mac$0 = undefined;var $targ$3 = undefined;var await_mac$0 = undefined;var $targ$4 = undefined;var gen_mac$0 = undefined;var $targ$5 = undefined;var async_mac$0 = undefined;var $targ$6 = undefined;var eager_await_mac$0 = undefined;var $targ$7 = undefined;var eager_async_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};$targ$2 = function (ph$0$0, temp$0$0, form$0, arg$0) {
    var x$0 = undefined;var subp$0 = undefined;var w$0 = undefined;var t0$0 = undefined;var t0$1 = undefined;var arg$2 = undefined;var arg$1 = undefined;var t0$2 = undefined;var t1$0 = undefined;var t2$0 = undefined;var m$0$0 = undefined;var otherwise$0 = undefined;var bridge$$1318$0 = undefined;if ((x$0 = ph$0$0, x$0 instanceof Array && x$0[0] === "pattern")) {
      if (equal(arg$0, ["void"])) {
        subp$0 = null;
      } else {
        subp$0 = arg$0;
      }w$0 = function w(ph$1) {
        return ["send", ["symbol", "yield"], ph$1];
      };return ["special", AssignmentHandler$0(subp$0, w$0)];
    } else {
      bridge$$1318$0 = ph$0$0;if (Array.isArray(bridge$$1318$0) && (t0$0 = bridge$$1318$0.length, t0$0 === 2 && (bridge$$1318$0[0] === "expr" && bridge$$1318$0[1] === "expr")) || Array.isArray(bridge$$1318$0) && (t0$1 = bridge$$1318$0.length, t0$1 === 2 && (bridge$$1318$0[0] === "expr" && bridge$$1318$0[1] === "head"))) {
        m$0$0 = arg$0;if (Array.isArray(m$0$0) && (t0$2 = m$0$0.length, t0$2 === 3 && (m$0$0[0] === "send" && (t1$0 = m$0$0[1], Array.isArray(t1$0) && (t2$0 = t1$0.length, t2$0 === 2 && (t1$0[0] === "symbol" && t1$0[1] === "all")))))) {
          arg$1 = m$0$0[2];return ["js_yield", arg$1, ["value", true]];
        } else {
          arg$2 = m$0$0;return ["js_yield", arg$2, ["value", false]];
        }
      } else {
        otherwise$0 = ph$0$0;return ["nostep", form$0];
      }
    }
  };t0$3 = getProjector(mac$0("yield"))($targ$2);if (t0$3[0]) {
    yield_mac$0 = t0$3[1];
  } else {
    ___match_error($targ$2, "mac{\"yield\"}! yield_mac{match, _, form, arg}");
  }$targ$3 = function (ph$2$0, temp$1$0, form$1, arg$3) {
    var x$1 = undefined;var subp$1 = undefined;var w$1 = undefined;var t0$4 = undefined;var t0$5 = undefined;var arg$6 = undefined;var arg$5 = undefined;var arg$4 = undefined;var $$1459$0 = undefined;var $$1460$0 = undefined;var $$1461$0 = undefined;var $$1462$0 = undefined;var $$1463$0 = undefined;var $$1464$0 = undefined;var $$1465$0 = undefined;var $$1466$0 = undefined;var $$1467$0 = undefined;var t0$6 = undefined;var t1$1 = undefined;var t2$1 = undefined;var m$1$0 = undefined;var otherwise$1 = undefined;var bridge$$1408$0 = undefined;if ((x$1 = ph$2$0, x$1 instanceof Array && x$1[0] === "pattern")) {
      if (equal(arg$3, ["void"])) {
        subp$1 = null;
      } else {
        subp$1 = arg$3;
      }w$1 = function w(ph$3) {
        return ["send", ["symbol", "await"], ph$3];
      };return ["special", AssignmentHandler$0(subp$1, w$1)];
    } else {
      bridge$$1408$0 = ph$2$0;if (Array.isArray(bridge$$1408$0) && (t0$4 = bridge$$1408$0.length, t0$4 === 2 && (bridge$$1408$0[0] === "expr" && bridge$$1408$0[1] === "expr")) || Array.isArray(bridge$$1408$0) && (t0$5 = bridge$$1408$0.length, t0$5 === 2 && (bridge$$1408$0[0] === "expr" && bridge$$1408$0[1] === "head"))) {
        m$1$0 = arg$3;if (($$1459$0 = Array.isArray(m$1$0)) && (t0$6 = m$1$0.length, ($$1461$0 = t0$6 === 3) && (($$1462$0 = m$1$0[0] === "send") && (t1$1 = m$1$0[1], ($$1464$0 = Array.isArray(t1$1)) && (t2$1 = t1$1.length, ($$1466$0 = t2$1 === 2) && (($$1467$0 = t1$1[0] === "symbol") && t1$1[1] === "all")))))) {
          arg$4 = m$1$0[2];return ["js_yield", ["send", ["send", ["symbol", "Promise"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "all"]]]], ["data", arg$4]], ["value", false]];
        } else {
          if ($$1467$0 && t1$1[1] === "any") {
            arg$5 = m$1$0[2];return ["js_yield", ["send", ["send", ["symbol", "Promise"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "race"]]]], ["data", arg$5]], ["value", false]];
          } else {
            arg$6 = m$1$0;return ["js_yield", arg$6, ["value", false]];
          }
        }
      } else {
        otherwise$1 = ph$2$0;return ["nostep", form$1];
      }
    }
  };t0$7 = getProjector(mac$0("await"))($targ$3);if (t0$7[0]) {
    await_mac$0 = t0$7[1];
  } else {
    ___match_error($targ$3, "mac{\"await\"}! await_mac{match, _, form, arg}");
  }$targ$4 = function (ph$4$0, info$0, form$2, expr$0) {
    var x$2 = undefined;var mac$1 = undefined;var t0$11 = undefined;var t1$5 = undefined;var t2$5 = undefined;var t3$3 = undefined;var t4$2 = undefined;var t5$2 = undefined;var t6$1 = undefined;var t0$12 = undefined;var t1$6 = undefined;var t2$6 = undefined;var t3$4 = undefined;var t4$3 = undefined;var arg$10 = undefined;var pre$1 = undefined;var body$3 = undefined;var post$1 = undefined;var arg$9 = undefined;var body$2 = undefined;var bridge$$1513$0 = undefined;var t0$10 = undefined;var t1$4 = undefined;var t2$4 = undefined;var t3$2 = undefined;var t4$1 = undefined;var t5$1 = undefined;var t6$0 = undefined;var t7$0 = undefined;var ph$5$0 = undefined;if (equal(expr$0, ["void"])) {
      return ["nostep", form$2];
    } else {
      if ((x$2 = ph$4$0, x$2 instanceof Array && x$2[0] === "pattern")) {
        mac$1 = function mac() {
          var arg$8 = undefined;var pre$0 = undefined;var body$1 = undefined;var post$0 = undefined;var arg$7 = undefined;var body$0 = undefined;var env$0 = undefined;var x$3 = undefined;var $$1542$0 = undefined;var $$1543$0 = undefined;var $$1544$0 = undefined;var $$1545$0 = undefined;var $$1546$0 = undefined;var $$1547$0 = undefined;var $$1548$0 = undefined;var $$1549$0 = undefined;var $$1550$0 = undefined;var t0$9 = undefined;var t1$3 = undefined;var t2$3 = undefined;var t3$1 = undefined;var t4$0 = undefined;var t5$0 = undefined;var e$0 = undefined;var ph$7$0 = undefined;var blah$0 = undefined;var t0$8 = undefined;var t1$2 = undefined;var t2$2 = undefined;var t3$0 = undefined;var m$2$0 = undefined;m$2$0 = arguments;t0$8 = m$2$0.length;if (t0$8 >= 1 && (blah$0 = Array.prototype.slice.call(m$2$0, 0, -1), t1$2 = m$2$0[t0$8 - 1], Array.isArray(t1$2) && (t2$2 = t1$2.length, t2$2 === 2 && t1$2[0] === "data"))) {
            t3$0 = t1$2[1];e$0 = t3$0;ph$7$0 = t3$0;t0$9 = ph$7$0;t1$3 = t0$9.length;if (($$1544$0 = t1$3 === 3) && t0$9[0] === "use") {
              env$0 = t0$9[1];x$3 = t0$9[2];return ["use", env$0, mac$1.call(this, ["data", x$3])];
            } else {
              if ($$1544$0 && (($$1545$0 = t0$9[0] === "send") && (t2$3 = t0$9[1], ($$1547$0 = Array.isArray(t2$3)) && (t3$1 = t2$3.length, ($$1549$0 = t3$1 === 2) && (($$1550$0 = t2$3[0] === "symbol") && (t2$3[1] === "->" && (t4$0 = t0$9[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && t4$0[0] === "data")))))))) {
                arg$7 = t4$0[1];body$0 = t4$0[2];return ["send", ["symbol", "*->"], ["data", arg$7, body$0]];
              } else {
                if ($$1550$0 && (t2$3[1] === "_lambda" && (t4$0 = t0$9[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 6 && t4$0[0] === "data")))) {
                  arg$8 = t4$0[1];pre$0 = t4$0[2];body$1 = t4$0[3];post$0 = t4$0[4];t4$0[5];return ["send", ["symbol", "_lambda"], ["data", arg$8, pre$0, body$1, post$0, ["value", true]]];
                } else {
                  throw ErrorFactory(["syntax", "gen"]).create("gen must decorate a function", { node: e$0 });
                }
              }
            }
          } else {
            return ___match_error(m$2$0, "{*blah, #data{match e}}");
          }
        };return ["project", ["macro", mac$1], expr$0, true];
      } else {
        ph$5$0 = expr$0;bridge$$1513$0 = ph$5$0;if (Array.isArray(bridge$$1513$0) && (t0$11 = bridge$$1513$0.length, t0$11 === 2 && (bridge$$1513$0[0] === "data" && (t1$5 = bridge$$1513$0[1], Array.isArray(t1$5) && (t2$5 = t1$5.length, t2$5 === 3 && (t1$5[0] === "send" && (t3$3 = t1$5[1], Array.isArray(t3$3) && (t4$2 = t3$3.length, t4$2 === 2 && (t3$3[0] === "symbol" && (t3$3[1] === "->" && (t5$2 = t1$5[2], Array.isArray(t5$2) && (t6$1 = t5$2.length, t6$1 === 3 && (t5$2[0] === "data" && (arg$9 = t5$2[1], body$2 = t5$2[2], true))))))))))))) || Array.isArray(bridge$$1513$0) && (t0$12 = bridge$$1513$0.length, t0$12 === 3 && (bridge$$1513$0[0] === "send" && (t1$6 = bridge$$1513$0[1], Array.isArray(t1$6) && (t2$6 = t1$6.length, t2$6 === 2 && (t1$6[0] === "symbol" && (t1$6[1] === "->" && (t3$4 = bridge$$1513$0[2], Array.isArray(t3$4) && (t4$3 = t3$4.length, t4$3 === 3 && (t3$4[0] === "data" && (arg$9 = t3$4[1], body$2 = t3$4[2], true))))))))))) {
          return ["send", ["symbol", "*->"], ["data", arg$9, body$2]];
        } else {
          t0$10 = ph$5$0;t1$4 = t0$10.length;if (t1$4 === 2 && (t0$10[0] === "data" && (t2$4 = t0$10[1], Array.isArray(t2$4) && (t3$2 = t2$4.length, t3$2 === 3 && (t2$4[0] === "send" && (t4$1 = t2$4[1], Array.isArray(t4$1) && (t5$1 = t4$1.length, t5$1 === 2 && (t4$1[0] === "symbol" && (t4$1[1] === "_lambda" && (t6$0 = t2$4[2], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 6 && t6$0[0] === "data"))))))))))) {
            arg$10 = t6$0[1];pre$1 = t6$0[2];body$3 = t6$0[3];post$1 = t6$0[4];t6$0[5];return ["send", ["symbol", "_lambda"], ["data", arg$10, pre$1, body$3, post$1, ["value", true]]];
          } else {
            throw ErrorFactory(["syntax", "gen"]).create("gen must be applied on a function", { expr: expr$0 });
          }
        }
      }
    }
  };t0$13 = getProjector(mac$0("gen"))($targ$4);if (t0$13[0]) {
    gen_mac$0 = t0$13[1];
  } else {
    ___match_error($targ$4, "mac{\"gen\"}! gen_mac{match, info, form, expr}");
  }$targ$5 = function (ph$8$0, info$1, form$3, expr$1) {
    var x$4 = undefined;var mac$2 = undefined;var t0$17 = undefined;var t1$10 = undefined;var t2$10 = undefined;var t3$8 = undefined;var t4$6 = undefined;var t5$5 = undefined;var t6$3 = undefined;var t0$18 = undefined;var t1$11 = undefined;var t2$11 = undefined;var t3$9 = undefined;var t4$7 = undefined;var t0$19 = undefined;var x$6 = undefined;var arg$14 = undefined;var pre$3 = undefined;var body$7 = undefined;var post$3 = undefined;var arg$13 = undefined;var body$6 = undefined;var bridge$$1767$0 = undefined;var t0$16 = undefined;var t1$9 = undefined;var t2$9 = undefined;var t3$7 = undefined;var t4$5 = undefined;var t5$4 = undefined;var t6$2 = undefined;var t7$1 = undefined;var bridge$$1770$0 = undefined;var ph$9$0 = undefined;if (equal(expr$1, ["void"])) {
      return ["nostep", form$3];
    } else {
      if ((x$4 = ph$8$0, x$4 instanceof Array && x$4[0] === "pattern")) {
        mac$2 = function mac() {
          var arg$12 = undefined;var pre$2 = undefined;var body$5 = undefined;var post$2 = undefined;var arg$11 = undefined;var body$4 = undefined;var env$1 = undefined;var x$5 = undefined;var $$1797$0 = undefined;var $$1798$0 = undefined;var $$1799$0 = undefined;var $$1800$0 = undefined;var $$1801$0 = undefined;var $$1802$0 = undefined;var $$1803$0 = undefined;var $$1804$0 = undefined;var $$1805$0 = undefined;var t0$15 = undefined;var t1$8 = undefined;var t2$8 = undefined;var t3$6 = undefined;var t4$4 = undefined;var t5$3 = undefined;var e$1 = undefined;var ph$11$0 = undefined;var blah$1 = undefined;var t0$14 = undefined;var t1$7 = undefined;var t2$7 = undefined;var t3$5 = undefined;var m$3$0 = undefined;m$3$0 = arguments;t0$14 = m$3$0.length;if (t0$14 >= 1 && (blah$1 = Array.prototype.slice.call(m$3$0, 0, -1), t1$7 = m$3$0[t0$14 - 1], Array.isArray(t1$7) && (t2$7 = t1$7.length, t2$7 === 2 && t1$7[0] === "data"))) {
            t3$5 = t1$7[1];e$1 = t3$5;ph$11$0 = t3$5;t0$15 = ph$11$0;t1$8 = t0$15.length;if (($$1799$0 = t1$8 === 3) && t0$15[0] === "use") {
              env$1 = t0$15[1];x$5 = t0$15[2];return ["use", env$1, mac$2.call(this, ["data", x$5])];
            } else {
              if ($$1799$0 && (($$1800$0 = t0$15[0] === "send") && (t2$8 = t0$15[1], ($$1802$0 = Array.isArray(t2$8)) && (t3$6 = t2$8.length, ($$1804$0 = t3$6 === 2) && (($$1805$0 = t2$8[0] === "symbol") && (t2$8[1] === "->" && (t4$4 = t0$15[2], Array.isArray(t4$4) && (t5$3 = t4$4.length, t5$3 === 3 && t4$4[0] === "data")))))))) {
                arg$11 = t4$4[1];body$4 = t4$4[2];return ["send", ["symbol", "->"], ["data", arg$11, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], body$4]]]]]];
              } else {
                if ($$1805$0 && (t2$8[1] === "_lambda" && (t4$4 = t0$15[2], Array.isArray(t4$4) && (t5$3 = t4$4.length, t5$3 === 6 && t4$4[0] === "data")))) {
                  arg$12 = t4$4[1];pre$2 = t4$4[2];body$5 = t4$4[3];post$2 = t4$4[4];t4$4[5];return ["send", ["symbol", "_lambda"], ["data", arg$12, pre$2, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], body$5]]]], post$2, ["value", false]]];
                } else {
                  throw ErrorFactory(["syntax", "async"]).create("async must decorate a function", { node: e$1 });
                }
              }
            }
          } else {
            return ___match_error(m$3$0, "{*blah, #data{match e}}");
          }
        };return ["project", ["macro", mac$2], expr$1, true];
      } else {
        ph$9$0 = expr$1;bridge$$1767$0 = ph$9$0;if (Array.isArray(bridge$$1767$0) && (t0$17 = bridge$$1767$0.length, t0$17 === 2 && (bridge$$1767$0[0] === "data" && (t1$10 = bridge$$1767$0[1], Array.isArray(t1$10) && (t2$10 = t1$10.length, t2$10 === 3 && (t1$10[0] === "send" && (t3$8 = t1$10[1], Array.isArray(t3$8) && (t4$6 = t3$8.length, t4$6 === 2 && (t3$8[0] === "symbol" && (t3$8[1] === "->" && (t5$5 = t1$10[2], Array.isArray(t5$5) && (t6$3 = t5$5.length, t6$3 === 3 && (t5$5[0] === "data" && (arg$13 = t5$5[1], body$6 = t5$5[2], true))))))))))))) || Array.isArray(bridge$$1767$0) && (t0$18 = bridge$$1767$0.length, t0$18 === 3 && (bridge$$1767$0[0] === "send" && (t1$11 = bridge$$1767$0[1], Array.isArray(t1$11) && (t2$11 = t1$11.length, t2$11 === 2 && (t1$11[0] === "symbol" && (t1$11[1] === "->" && (t3$9 = bridge$$1767$0[2], Array.isArray(t3$9) && (t4$7 = t3$9.length, t4$7 === 3 && (t3$9[0] === "data" && (arg$13 = t3$9[1], body$6 = t3$9[2], true))))))))))) {
          return ["send", ["symbol", "->"], ["data", arg$13, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], body$6]]]]]];
        } else {
          t0$16 = ph$9$0;t1$9 = t0$16.length;if (t1$9 === 2 && (t0$16[0] === "data" && (t2$9 = t0$16[1], Array.isArray(t2$9) && (t3$7 = t2$9.length, t3$7 === 3 && (t2$9[0] === "send" && (t4$5 = t2$9[1], Array.isArray(t4$5) && (t5$4 = t4$5.length, t5$4 === 2 && (t4$5[0] === "symbol" && (t4$5[1] === "_lambda" && (t6$2 = t2$9[2], Array.isArray(t6$2) && (t7$1 = t6$2.length, t7$1 === 6 && t6$2[0] === "data"))))))))))) {
            arg$14 = t6$2[1];pre$3 = t6$2[2];body$7 = t6$2[3];post$3 = t6$2[4];t6$2[5];return ["send", ["symbol", "_lambda"], ["data", arg$14, pre$3, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], body$7]]]], post$3, ["value", false]]];
          } else {
            bridge$$1770$0 = ph$9$0;if (Array.isArray(bridge$$1770$0) && (t0$19 = bridge$$1770$0.length, t0$19 === 2 && (bridge$$1770$0[0] === "data" && (x$6 = bridge$$1770$0[1], true))) || (x$6 = bridge$$1770$0, true)) {
              return ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], ["multi", ["send", ["symbol", "try"], ["data", ["send", ["symbol", "await"], x$6]]], ["send", ["symbol", "catch"], ["data", ["symbol", "e"], ["send", ["send", ["symbol", "console"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "error"]]]], ["data", ["send", ["symbol", "e"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "stack"]]]]]]]]]]]]];
            } else {
              return ___match_error(ph$9$0, "`{^x}` or x");
            }
          }
        }
      }
    }
  };t0$20 = getProjector(mac$0("async"))($targ$5);if (t0$20[0]) {
    async_mac$0 = t0$20[1];
  } else {
    ___match_error($targ$5, "mac{\"async\"}! async_mac{match, info, form, expr}");
  }$targ$6 = function (ctx$0, temp$2$0, form$4, expr$2) {
    return ["send", ["symbol", "match"], ["data", expr$2, ["multi", ["send", ["symbol", "->"], ["data", ["send", ["symbol", "?"], ["data", ["symbol", "Promise"], ["symbol", "p"]]], ["send", ["symbol", "await"], ["symbol", "p"]]]], ["send", ["symbol", "->"], ["data", ["symbol", "x"], ["symbol", "x"]]]]]];
  };t0$21 = getProjector(mac$0("eager-await"))($targ$6);if (t0$21[0]) {
    eager_await_mac$0 = t0$21[1];
  } else {
    ___match_error($targ$6, "mac{\"eager-await\"}! eager_await_mac{ctx, _, form, expr}");
  }$targ$7 = function (ph$12$0, info$2, form$5, expr$3) {
    var x$7 = undefined;var mac$3 = undefined;var t0$25 = undefined;var t1$15 = undefined;var t2$15 = undefined;var t3$13 = undefined;var t4$10 = undefined;var t5$8 = undefined;var t6$5 = undefined;var t0$26 = undefined;var t1$16 = undefined;var t2$16 = undefined;var t3$14 = undefined;var t4$11 = undefined;var t0$27 = undefined;var x$9 = undefined;var arg$18 = undefined;var pre$5 = undefined;var body$12 = undefined;var post$5 = undefined;var arg$17 = undefined;var body$11 = undefined;var bridge$$2051$0 = undefined;var t0$24 = undefined;var t1$14 = undefined;var t2$14 = undefined;var t3$12 = undefined;var t4$9 = undefined;var t5$7 = undefined;var t6$4 = undefined;var t7$2 = undefined;var bridge$$2054$0 = undefined;var ph$13$0 = undefined;var aw$0 = undefined;var wrap$0 = undefined;aw$0 = info$2.mark(["symbol", "await"]);wrap$0 = function wrap(body$8) {
      return ["multi", ["send", ["symbol", "inline-macro"], ["data", ["send", aw$0, ["data", ["symbol", "expr"]]], ["send", ["symbol", "`"], ["value", "eager-await ^expr"]]]], body$8];
    };if (equal(expr$3, ["void"])) {
      return ["nostep", form$5];
    } else {
      if ((x$7 = ph$12$0, x$7 instanceof Array && x$7[0] === "pattern")) {
        mac$3 = function mac() {
          var arg$16 = undefined;var pre$4 = undefined;var body$10 = undefined;var post$4 = undefined;var arg$15 = undefined;var body$9 = undefined;var env$2 = undefined;var x$8 = undefined;var $$2093$0 = undefined;var $$2094$0 = undefined;var $$2095$0 = undefined;var $$2096$0 = undefined;var $$2097$0 = undefined;var $$2098$0 = undefined;var $$2099$0 = undefined;var $$2100$0 = undefined;var $$2101$0 = undefined;var t0$23 = undefined;var t1$13 = undefined;var t2$13 = undefined;var t3$11 = undefined;var t4$8 = undefined;var t5$6 = undefined;var e$2 = undefined;var ph$15$0 = undefined;var blah$2 = undefined;var t0$22 = undefined;var t1$12 = undefined;var t2$12 = undefined;var t3$10 = undefined;var m$4$0 = undefined;m$4$0 = arguments;t0$22 = m$4$0.length;if (t0$22 >= 1 && (blah$2 = Array.prototype.slice.call(m$4$0, 0, -1), t1$12 = m$4$0[t0$22 - 1], Array.isArray(t1$12) && (t2$12 = t1$12.length, t2$12 === 2 && t1$12[0] === "data"))) {
            t3$10 = t1$12[1];e$2 = t3$10;ph$15$0 = t3$10;t0$23 = ph$15$0;t1$13 = t0$23.length;if (($$2095$0 = t1$13 === 3) && t0$23[0] === "use") {
              env$2 = t0$23[1];x$8 = t0$23[2];return ["use", env$2, mac$3.call(this, ["data", x$8])];
            } else {
              if ($$2095$0 && (($$2096$0 = t0$23[0] === "send") && (t2$13 = t0$23[1], ($$2098$0 = Array.isArray(t2$13)) && (t3$11 = t2$13.length, ($$2100$0 = t3$11 === 2) && (($$2101$0 = t2$13[0] === "symbol") && (t2$13[1] === "->" && (t4$8 = t0$23[2], Array.isArray(t4$8) && (t5$6 = t4$8.length, t5$6 === 3 && t4$8[0] === "data")))))))) {
                arg$15 = t4$8[1];body$9 = t4$8[2];return ["send", ["symbol", "->"], ["data", arg$15, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], wrap$0(body$9)]], ["symbol", "true"]]]]];
              } else {
                if ($$2101$0 && (t2$13[1] === "_lambda" && (t4$8 = t0$23[2], Array.isArray(t4$8) && (t5$6 = t4$8.length, t5$6 === 6 && t4$8[0] === "data")))) {
                  arg$16 = t4$8[1];pre$4 = t4$8[2];body$10 = t4$8[3];post$4 = t4$8[4];t4$8[5];return ["send", ["symbol", "_lambda"], ["data", arg$16, pre$4, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], wrap$0(body$10)]], ["symbol", "true"]]], post$4, ["value", false]]];
                } else {
                  throw ErrorFactory(["syntax", "async"]).create("async must decorate a function", { node: e$2 });
                }
              }
            }
          } else {
            return ___match_error(m$4$0, "{*blah, #data{match e}}");
          }
        };return ["project", ["macro", mac$3], expr$3, true];
      } else {
        ph$13$0 = expr$3;bridge$$2051$0 = ph$13$0;if (Array.isArray(bridge$$2051$0) && (t0$25 = bridge$$2051$0.length, t0$25 === 2 && (bridge$$2051$0[0] === "data" && (t1$15 = bridge$$2051$0[1], Array.isArray(t1$15) && (t2$15 = t1$15.length, t2$15 === 3 && (t1$15[0] === "send" && (t3$13 = t1$15[1], Array.isArray(t3$13) && (t4$10 = t3$13.length, t4$10 === 2 && (t3$13[0] === "symbol" && (t3$13[1] === "->" && (t5$8 = t1$15[2], Array.isArray(t5$8) && (t6$5 = t5$8.length, t6$5 === 3 && (t5$8[0] === "data" && (arg$17 = t5$8[1], body$11 = t5$8[2], true))))))))))))) || Array.isArray(bridge$$2051$0) && (t0$26 = bridge$$2051$0.length, t0$26 === 3 && (bridge$$2051$0[0] === "send" && (t1$16 = bridge$$2051$0[1], Array.isArray(t1$16) && (t2$16 = t1$16.length, t2$16 === 2 && (t1$16[0] === "symbol" && (t1$16[1] === "->" && (t3$14 = bridge$$2051$0[2], Array.isArray(t3$14) && (t4$11 = t3$14.length, t4$11 === 3 && (t3$14[0] === "data" && (arg$17 = t3$14[1], body$11 = t3$14[2], true))))))))))) {
          return ["send", ["symbol", "->"], ["data", arg$17, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], wrap$0(body$11)]], ["symbol", "true"]]]]];
        } else {
          t0$24 = ph$13$0;t1$14 = t0$24.length;if (t1$14 === 2 && (t0$24[0] === "data" && (t2$14 = t0$24[1], Array.isArray(t2$14) && (t3$12 = t2$14.length, t3$12 === 3 && (t2$14[0] === "send" && (t4$9 = t2$14[1], Array.isArray(t4$9) && (t5$7 = t4$9.length, t5$7 === 2 && (t4$9[0] === "symbol" && (t4$9[1] === "_lambda" && (t6$4 = t2$14[2], Array.isArray(t6$4) && (t7$2 = t6$4.length, t7$2 === 6 && t6$4[0] === "data"))))))))))) {
            arg$18 = t6$4[1];pre$5 = t6$4[2];body$12 = t6$4[3];post$5 = t6$4[4];t6$4[5];return ["send", ["symbol", "_lambda"], ["data", arg$18, pre$5, ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], wrap$0(body$12)]], ["symbol", "true"]]], post$5, ["value", false]]];
          } else {
            bridge$$2054$0 = ph$13$0;if (Array.isArray(bridge$$2054$0) && (t0$27 = bridge$$2054$0.length, t0$27 === 2 && (bridge$$2054$0[0] === "data" && (x$9 = bridge$$2054$0[1], true))) || (x$9 = bridge$$2054$0, true)) {
              return ["send", ["send", ["symbol", "spawn"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", ["symbol", "this"], ["send", ["symbol", "*->"], ["data", ["data"], ["multi", ["send", ["symbol", "try"], ["data", ["send", ["symbol", "await"], x$9]]], ["send", ["symbol", "catch"], ["data", ["symbol", "e"], ["send", ["send", ["symbol", "console"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "error"]]]], ["data", ["send", ["symbol", "e"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "stack"]]]]]]]]]]], ["symbol", "true"]]];
            } else {
              return ___match_error(ph$13$0, "`{^x}` or x");
            }
          }
        }
      }
    }
  };t0$28 = getProjector(mac$0("eager-async"))($targ$7);if (t0$28[0]) {
    eager_async_mac$0 = t0$28[1];
  } else {
    ___match_error($targ$7, "mac{\"eager-async\"}! eager_async_mac{match, info, form, expr}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=async.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":110,"earlgrey-runtime/5":446}],108:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var protected_value$0 = undefined;var value_mac$0 = undefined;$0$0 = require("./helpers");protected_value$0 = getProperty($0$0, "protected_value", "./helpers");value_mac$0 = getProperty($0$0, "value_mac", "./helpers");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0, bind$0) {
  var m$0 = undefined;var m$1 = undefined;var chk$0 = undefined;var $targ$2 = undefined;var accum$0 = undefined;var chk$1 = undefined;var $targ$3 = undefined;var accum$1 = undefined;var chk$2 = undefined;var $targ$4 = undefined;var accum$2 = undefined;var chk$3 = undefined;var $targ$5 = undefined;var accum$3 = undefined;var chk$4 = undefined;var proj$0 = undefined;var $targ$6 = undefined;var accum$4 = undefined;var chk$5 = undefined;var proj$1 = undefined;var $targ$7 = undefined;var accum$5 = undefined;var chk$6 = undefined;var proj$2 = undefined;var $targ$8 = undefined;var accum$6 = undefined;var chk$7 = undefined;var proj$3 = undefined;var $targ$9 = undefined;var accum$7 = undefined;var chk$8 = undefined;var $targ$10 = undefined;var accum$8 = undefined;var m$2 = undefined;var acc$0 = undefined;var temp$0 = undefined;var kv$0 = undefined;var global_variables$0 = undefined;var keywords$0 = undefined;var exports$0 = undefined;exports$0 = {};global_variables$0 = ["+", "-", "*", "/", "mod", "&+", "|+", "^+", "and", "or", "not", "===", "!==", "<", ">", "<=", ">=", "<<", ">>", ">>>", "in", "instanceof", "--", "++", "typeof", "Array", "Object", "Symbol", "RegExp", "Function", "Date", "parseInt", "parseFloat", "Math", "Infinity", "Error", "TypeError", "ReferenceError", "console", "process", "eval", "setTimeout", "clearTimeout", "setInterval", "clearInterval", "___js_fetch", "___node", "arguments", "this", "module", "exports", "send", "object", "keys", "items", "enumerate", "zip", "product", "neighbours", "range", "predicate", "==", "!=", "equal", "nequal", "&", "&:", "clone", "dir", "getProjector", "getChecker", "ErrorFactory", "ENode", "repr", "getProperty", "___build_array", "___hasprop", "___extend", "___match_error", "___serialize_ast", "JSON", "Set", "Map", "consume", "Promise", "promisify", "spawn", "Buffer", "global", "__dirname", "__filename"];m$0 = null;$1: for (var _iterator = global_variables$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$0 = _step.value;
    var gvar$0 = undefined;gvar$0 = m$0;bind$0(gvar$0, __amp__(["variable", gvar$0], { mutable: false, assigned: true }));
  }keywords$0 = { "true": protected_value$0("true", true), "false": protected_value$0("false", false), "null": protected_value$0("null", null), undefined: protected_value$0("undefined", undefined), pass: ["variable", "undefined"] };m$1 = null;$2: for (var _iterator2 = items(keywords$0)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    m$1 = _step2.value;
    var gvar$1 = undefined;var v$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$1;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
      gvar$1 = t0$0[0];v$0 = t0$0[1];bind$0(gvar$1, v$0);
    } else {
      ___match_error(m$1);
    }
  }kv$0 = __amp____colon__(($targ$2 = (chk$0 = function chk(x$0) {
    return ["send", ["symbol", "==="], ["data", x$0, ["value", null]]];
  }, value_mac$0("null", chk$0)), accum$0 = {}, accum$0["null"] = $targ$2, accum$0), __amp____colon__(($targ$3 = (chk$1 = function chk(x$1) {
    return ["send", ["symbol", "==="], ["data", x$1, ["value", undefined]]];
  }, value_mac$0("undefined", chk$1)), accum$1 = {}, accum$1.undefined = $targ$3, accum$1), __amp____colon__(($targ$4 = (chk$2 = function chk(x$2) {
    return ["send", ["symbol", "if"], ["data", x$2, ["symbol", "true"], ["symbol", "false"]]];
  }, value_mac$0("true", chk$2)), accum$2 = {}, accum$2["true"] = $targ$4, accum$2), __amp____colon__(($targ$5 = (chk$3 = function chk(x$3) {
    return ["send", ["symbol", "not"], ["data", ["void"], x$3]];
  }, value_mac$0("false", chk$3)), accum$3 = {}, accum$3["false"] = $targ$5, accum$3), __amp____colon__(($targ$6 = (chk$4 = function chk(x$4) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$4]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "string"]]]]];
  }, proj$0 = function proj(x$5) {
    return ["data", ["symbol", "true"], ["send", ["symbol", "String"], ["data", x$5]]];
  }, value_mac$0("String", chk$4, proj$0)), accum$4 = {}, accum$4.String = $targ$6, accum$4), __amp____colon__(($targ$7 = (chk$5 = function chk(x$6) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$6]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "number"]]]]];
  }, proj$1 = function proj(x$7) {
    return ["data", ["symbol", "true"], ["send", ["symbol", "parseFloat"], ["data", x$7]]];
  }, value_mac$0("Number", chk$5, proj$1)), accum$5 = {}, accum$5.Number = $targ$7, accum$5), __amp____colon__(($targ$8 = (chk$6 = function chk(x$8) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$8]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "boolean"]]]]];
  }, proj$2 = function proj(x$9) {
    return ["data", ["symbol", "true"], ["send", ["symbol", "Boolean"], ["data", x$9]]];
  }, value_mac$0("Boolean", chk$6, proj$2)), accum$6 = {}, accum$6.Boolean = $targ$8, accum$6), __amp____colon__(($targ$9 = (chk$7 = function chk(x$10) {
    return ["send", ["send", ["symbol", "Array"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "isArray"]]]], ["data", x$10]];
  }, proj$3 = function proj(x$11) {
    return ["data", ["symbol", "true"], ["multi", ["send", ["symbol", "="], ["data", ["symbol", "t"], x$11]], ["send", ["symbol", "if"], ["data", ["send", ["send", ["symbol", "Array"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "isArray"]]]], ["data", ["symbol", "t"]]], ["symbol", "t"], ["data", ["symbol", "t"]]]]]];
  }, value_mac$0("Array", chk$7, proj$3)), accum$7 = {}, accum$7.Array = $targ$9, accum$7), ($targ$10 = (chk$8 = function chk(x$12) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$12]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "function"]]]]];
  }, value_mac$0("Function", chk$8)), accum$8 = {}, accum$8.Function = $targ$10, accum$8)))))))));acc$0 = [];temp$0 = null;m$2 = null;$3: for (var _iterator3 = items(kv$0)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
    m$2 = _step3.value;
    var k$0 = undefined;var v$1 = undefined;var t0$1 = undefined;var t1$1 = undefined;t0$1 = m$2;if (Array.isArray(t0$1) && (t1$1 = t0$1.length, t1$1 === 2)) {
      k$0 = t0$1[0];v$1 = t0$1[1];temp$0 = mac$0(k$0)(v$1);acc$0.push(temp$0);
    } else {
      ___match_error(m$2);
    }
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=consts.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":110,"earlgrey-runtime/5":446}],109:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var camelCase$0 = undefined;var $1$0 = undefined;var __lt____lt____colon__$0 = undefined;var $2$0 = undefined;var expr_mac$0 = undefined;var pattern_handlers$0 = undefined;var ctx_mac$0 = undefined;var named_statement_matcher$0 = undefined;var flatmacro$0 = undefined;var match_error$0 = undefined;var Body$0 = undefined;var AssignmentHandler$0 = undefined;var $3$0 = undefined;var PatternCompiler$0 = undefined;var parse_clauses$0 = undefined;$0$0 = require("../util");camelCase$0 = getProperty($0$0, "camelCase", "../util");$1$0 = require("../location");__lt____lt____colon__$0 = getProperty($1$0, "<<:", "../location");$2$0 = require("./helpers");expr_mac$0 = getProperty($2$0, "expr_mac", "./helpers");pattern_handlers$0 = getProperty($2$0, "pattern_handlers", "./helpers");ctx_mac$0 = getProperty($2$0, "ctx_mac", "./helpers");named_statement_matcher$0 = getProperty($2$0, "named_statement_matcher", "./helpers");flatmacro$0 = getProperty($2$0, "flatmacro", "./helpers");match_error$0 = getProperty($2$0, "match_error", "./helpers");Body$0 = getProperty($2$0, "Body", "./helpers");AssignmentHandler$0 = getProperty($2$0, "AssignmentHandler", "./helpers");$3$0 = require("../pattern");PatternCompiler$0 = getProperty($3$0, "PatternCompiler", "../pattern");parse_clauses$0 = getProperty($3$0, "parse_clauses", "../pattern");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var t0$0 = undefined;var t0$1 = undefined;var t0$4 = undefined;var t0$7 = undefined;var t1$4 = undefined;var t0$9 = undefined;var t0$11 = undefined;var t0$14 = undefined;var t0$16 = undefined;var t0$24 = undefined;var t0$29 = undefined;var t0$39 = undefined;var t0$41 = undefined;var t0$44 = undefined;var t0$47 = undefined;var _catch$0 = undefined;var _finally$0 = undefined;var t0$55 = undefined;var t0$58 = undefined;var t0$59 = undefined;var t1$33 = undefined;var t0$60 = undefined;var t0$63 = undefined;var t0$64 = undefined;var t1$34 = undefined;var t0$67 = undefined;var t0$69 = undefined;var t0$74 = undefined;var t0$76 = undefined;var $targ$2 = undefined;var var_mac$0 = undefined;var $targ$3 = undefined;var setvar_mac$0 = undefined;var $targ$4 = undefined;var let_mac$0 = undefined;var $targ$5 = undefined;var letrec_mac$0 = undefined;var $targ$6 = undefined;var where_mac$0 = undefined;var $targ$7 = undefined;var rawsym_mac$0 = undefined;var $targ$8 = undefined;var dot_mac$0 = undefined;var $targ$9 = undefined;var as_mac$0 = undefined;var $targ$10 = undefined;var equal_mac$0 = undefined;var $targ$11 = undefined;var fat_arrow_mac$0 = undefined;var $targ$12 = undefined;var _lambda_mac$0 = undefined;var $targ$13 = undefined;var genarrow_mac$0 = undefined;var $targ$14 = undefined;var metharrow_mac$0 = undefined;var $targ$15 = undefined;var arrow_mac$0 = undefined;var try_pattern$0 = undefined;var $targ$16 = undefined;var try_mac$0 = undefined;var $targ$17 = undefined;var tryop_mac$0 = undefined;var $targ$18 = undefined;var throw_mac$0 = undefined;var $targ$19 = undefined;var exprvalue_mac$0 = undefined;var $targ$20 = undefined;var return_mac$0 = undefined;var $targ$21 = undefined;var new_mac$0 = undefined;var $targ$22 = undefined;var delete_mac$0 = undefined;var $targ$23 = undefined;var splice_mac$0 = undefined;var $targ$24 = undefined;var hash_mac$0 = undefined;var $targ$25 = undefined;var placeholder_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};$targ$2 = function (temp$0$0, temp$1$0, form$0, argument$0) {
    var x$0 = undefined;if ((x$0 = temp$0$0, x$0 instanceof Array && x$0[0] === "pattern")) {} else {
      ___match_error(temp$0$0);
    }return ["mode", "var", argument$0];
  };t0$0 = getProjector(mac$0("var"))($targ$2);if (t0$0[0]) {
    var_mac$0 = t0$0[1];
  } else {
    ___match_error($targ$2, "mac{\"var\"}! var_mac{#pattern, _, form, argument}");
  }$targ$3 = function (temp$2$0, temp$3$0, form$1, argument$1) {
    var x$1 = undefined;if ((x$1 = temp$2$0, x$1 instanceof Array && x$1[0] === "pattern")) {} else {
      ___match_error(temp$2$0);
    }return ["mode", "set", argument$1];
  };t0$1 = getProjector(mac$0("set-var"))($targ$3);if (t0$1[0]) {
    setvar_mac$0 = t0$1[1];
  } else {
    ___match_error($targ$3, "mac{\"set-var\"}! setvar_mac{#pattern, _, form, argument}");
  }$targ$4 = function (ph$0$0, temp$4$0, form$2, argument$2) {
    var x$2 = undefined;var construct$0 = undefined;var bindings$0 = undefined;var body$0 = undefined;var t0$2 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var m$0$0 = undefined;var other$0 = undefined;if ((x$2 = ph$0$0, x$2 instanceof Array && x$2[0] === "pattern")) {
      return ["mode", "let", argument$2];
    } else {
      other$0 = ph$0$0;m$0$0 = argument$2;if (Array.isArray(m$0$0) && (t0$2 = m$0$0.length, t0$2 === 3 && (m$0$0[0] === "data" && (t1$0 = getProjector(Body$0)(m$0$0[1]), t1$0[0] && (t2$0 = t1$0[1], t3$0 = t2$0.length, t3$0 >= 0))))) {
        bindings$0 = Array.prototype.slice.call(t2$0, 0);body$0 = m$0$0[2];construct$0 = function construct(ph$1$0) {
          var bind$0 = undefined;var val$0 = undefined;var xs$0 = undefined;var $$7121$0 = undefined;var $$7122$0 = undefined;var t0$3 = undefined;var t1$1 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;t0$3 = ph$1$0;t1$1 = t0$3.length;if (t1$1 === 0) {
            return body$0;
          } else {
            if (t1$1 >= 1 && (t2$1 = t0$3[0], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 3 && (t2$1[0] === "send" && (t4$0 = t2$1[1], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 2 && (t4$0[0] === "symbol" && (t4$0[1] === "=" && (t6$0 = t2$1[2], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 3 && t6$0[0] === "data")))))))))) {
              bind$0 = t6$0[1];val$0 = t6$0[2];xs$0 = Array.prototype.slice.call(t0$3, 1);return __amp__(["multi", ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], bind$0], val$0]], construct$0(xs$0)], { nonrecursive: true });
            } else {
              return ___match_error(ph$1$0, "{`^bind = ^val`, *xs}");
            }
          }
        };return construct$0(bindings$0);
      } else {
        return ___match_error(m$0$0, "#data{Body! {*bindings}, body}");
      }
    }
  };t0$4 = getProjector(mac$0("let"))($targ$4);if (t0$4[0]) {
    let_mac$0 = t0$4[1];
  } else {
    ___match_error($targ$4, "mac{\"let\"}! let_mac{match, _, form, argument}");
  }$targ$5 = function (temp$5$0, form$3, temp$6$0) {
    var t0$5 = undefined;var t1$2 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$1 = undefined;var m$1 = undefined;var acc$0 = undefined;var temp$7 = undefined;var let_bindings$0 = undefined;var bindings$1 = undefined;var body$1 = undefined;t0$5 = temp$6$0;if (Array.isArray(t0$5) && (t1$2 = t0$5.length, t1$2 === 3 && (t0$5[0] === "data" && (t2$2 = getProjector(Body$0)(t0$5[1]), t2$2[0] && (t3$2 = t2$2[1], t4$1 = t3$2.length, t4$1 >= 0))))) {
      bindings$1 = Array.prototype.slice.call(t3$2, 0);body$1 = t0$5[2];
    } else {
      ___match_error(temp$6$0);
    }acc$0 = [];temp$7 = null;m$1 = null;$4: for (var _iterator = bindings$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$1 = _step.value;
      var b$0 = undefined;var v$0 = undefined;var t0$6 = undefined;var t1$3 = undefined;var t2$3 = undefined;var t3$3 = undefined;var t4$2 = undefined;var t5$1 = undefined;t0$6 = m$1;if (Array.isArray(t0$6) && (t1$3 = t0$6.length, t1$3 === 3 && (t0$6[0] === "send" && (t2$3 = t0$6[1], Array.isArray(t2$3) && (t3$3 = t2$3.length, t3$3 === 2 && (t2$3[0] === "symbol" && (t2$3[1] === "=" && (t4$2 = t0$6[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 === 3 && t4$2[0] === "data"))))))))) {
        b$0 = t4$2[1];v$0 = t4$2[2];temp$7 = ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], b$0], v$0]];acc$0.push(temp$7);
      } else {
        ___match_error(m$1);
      }
    }let_bindings$0 = acc$0;return ["multi"].concat(let_bindings$0).concat([body$1]);
  };t0$7 = getProjector(expr_mac$0)($targ$5);if (t0$7[0] && (t1$4 = getProjector(mac$0("letrec"))(t0$7[1]), t1$4[0])) {
    letrec_mac$0 = t1$4[1];
  } else {
    ___match_error($targ$5, "expr_mac! mac{\"letrec\"}! letrec_mac{_, form, #data{Body! {*bindings}, body}}");
  }$targ$6 = function (context$0, temp$8$0, form$4, temp$9$0) {
    var t0$8 = undefined;var t1$5 = undefined;var body$2 = undefined;var bindings$2 = undefined;t0$8 = temp$9$0;if (Array.isArray(t0$8) && (t1$5 = t0$8.length, t1$5 === 3 && t0$8[0] === "data")) {
      body$2 = t0$8[1];bindings$2 = t0$8[2];
    } else {
      ___match_error(temp$9$0);
    }return ["send", ["symbol", "letrec"], ["data", bindings$2, body$2]];
  };t0$9 = getProjector(mac$0("where"))($targ$6);if (t0$9[0]) {
    where_mac$0 = t0$9[1];
  } else {
    ___match_error($targ$6, "mac{\"where\"}! where_mac{context, _, form, #data{body, bindings}}");
  }$targ$7 = function (context$1, info$0, form$5, temp$10$0) {
    var t0$10 = undefined;var t1$6 = undefined;var t2$4 = undefined;var t3$4 = undefined;var sym$0 = undefined;var name$0 = undefined;t0$10 = temp$10$0;if (Array.isArray(t0$10) && (t1$6 = t0$10.length, t1$6 === 2 && (t0$10[0] === "data" && (t2$4 = t0$10[1], sym$0 = t2$4, Array.isArray(t2$4) && (t3$4 = t2$4.length, t3$4 === 2 && t2$4[0] === "symbol"))))) {
      name$0 = t2$4[1];
    } else {
      ___match_error(temp$10$0);
    }return sym$0.env.mark(["raw-symbol", name$0]);
  };t0$11 = getProjector(mac$0("raw-symbol"))($targ$7);if (t0$11[0]) {
    rawsym_mac$0 = t0$11[1];
  } else {
    ___match_error($targ$7, "mac{\"raw-symbol\"}! rawsym_mac{context, info, form, #data{sym and #symbol{name}}}");
  }$targ$8 = function (context$2, temp$11$0, form$6, temp$12$0) {
    var t0$12 = undefined;var t1$7 = undefined;var t2$5 = undefined;var t3$5 = undefined;var f$0 = undefined;var expr$0 = undefined;t0$12 = temp$12$0;if (Array.isArray(t0$12) && (t1$7 = t0$12.length, t1$7 === 3 && (t0$12[0] === "data" && (t2$5 = t0$12[1], Array.isArray(t2$5) && (t3$5 = t2$5.length, t3$5 === 1 && t2$5[0] === "void"))))) {
      expr$0 = t0$12[2];
    } else {
      ___match_error(temp$12$0);
    }f$0 = function f(ph$2$0) {
      var m$2 = undefined;var acc$1 = undefined;var temp$13 = undefined;var other$1 = undefined;var args$0 = undefined;var x$3 = undefined;var $$7391$0 = undefined;var $$7392$0 = undefined;var t0$13 = undefined;var t1$8 = undefined;var t2$6 = undefined;t0$13 = ph$2$0;t1$8 = t0$13.length;if (t1$8 === 2 && (t0$13[0] === "symbol" && (t2$6 = getProjector(camelCase$0)(t0$13[1]), t2$6[0]))) {
        x$3 = t2$6[1];return ["value", x$3];
      } else {
        if (t1$8 >= 1 && t0$13[0] === "data") {
          args$0 = Array.prototype.slice.call(t0$13, 1);return ["data"].concat((acc$1 = [], temp$13 = null, m$2 = null, (function () {
            $5: for (var _iterator = args$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$2 = _step.value;
              var arg$0 = undefined;arg$0 = m$2;temp$13 = f$0(arg$0);acc$1.push(temp$13);
            }
          })(), acc$1));
        } else {
          other$1 = ph$2$0;throw ErrorFactory(["syntax", "dot"]).create("Argument to '.' must be a symbol or an array", { argument: other$1 });
        }
      }
    };return f$0(expr$0);
  };t0$14 = getProjector(mac$0("."))($targ$8);if (t0$14[0]) {
    dot_mac$0 = t0$14[1];
  } else {
    ___match_error($targ$8, "mac{\".\"}! dot_mac{context, _, form, #data{#void{}, expr}}");
  }$targ$9 = function (ctx$0, info$1, form$7, temp$14$0) {
    var t0$15 = undefined;var t1$9 = undefined;var rhs$0 = undefined;var lhs$0 = undefined;t0$15 = temp$14$0;if (Array.isArray(t0$15) && (t1$9 = t0$15.length, t1$9 === 3 && t0$15[0] === "data")) {
      rhs$0 = t0$15[1];lhs$0 = t0$15[2];
    } else {
      ___match_error(temp$14$0);
    }return ["send", ["symbol", "="], ["data", lhs$0, rhs$0]];
  };t0$16 = getProjector(mac$0("as"))($targ$9);if (t0$16[0]) {
    as_mac$0 = t0$16[1];
  } else {
    ___match_error($targ$9, "mac{\"as\"}! as_mac{ctx, info, form, #data{rhs, lhs}}");
  }$targ$10 = function (ph$3$0, info$2, form$8, expr$1) {
    var x$4 = undefined;var t0$18 = undefined;var t1$11 = undefined;var $targ$26 = undefined;var lhs$1 = undefined;var rhs$1 = undefined;var t0$20 = undefined;var t1$13 = undefined;var t2$8 = undefined;var t3$6 = undefined;var t4$3 = undefined;var t0$21 = undefined;var t1$14 = undefined;var t2$9 = undefined;var t3$7 = undefined;var t4$4 = undefined;var opt$0 = undefined;var rhs2$0 = undefined;var lhs$2 = undefined;var rhs$3 = undefined;var s$1 = undefined;var rhs$2 = undefined;var x$5 = undefined;var s$0 = undefined;var $$7522$0 = undefined;var $$7523$0 = undefined;var $$7524$0 = undefined;var $$7525$0 = undefined;var t0$19 = undefined;var bridge$$7519$0 = undefined;var t1$12 = undefined;var t2$7 = undefined;var m$3$0 = undefined;var opt$1 = undefined;var rhs2$1 = undefined;var vs$0 = undefined;var v$1 = undefined;var $$7679$0 = undefined;var $$7680$0 = undefined;var t0$23 = undefined;var m$5$0 = undefined;var expr$2 = undefined;var pc$0 = undefined;var assignment$0 = undefined;var rval$0 = undefined;var lhs$3 = undefined;var rhs$4 = undefined;var t0$22 = undefined;var m$4$0 = undefined;var other$2 = undefined;var t0$17 = undefined;var t1$10 = undefined;if ((x$4 = ph$3$0, x$4 instanceof Array && x$4[0] === "pattern")) {
      $targ$26 = expr$1;t0$18 = $targ$26;if (Array.isArray(t0$18) && (t1$11 = t0$18.length, t1$11 === 3 && t0$18[0] === "data")) {
        lhs$1 = t0$18[1];rhs$1 = t0$18[2];
      } else {
        ___match_error($targ$26, "#data{lhs, rhs}");
      }[lhs$1, rhs$1];return ["default", lhs$1, rhs$1];
    } else {
      t0$17 = ph$3$0;t1$10 = t0$17.length;if (t1$10 === 2 && (t0$17[0] === "expr" && t0$17[1] === "data")) {
        m$3$0 = expr$1;if (Array.isArray(m$3$0) && (t0$19 = m$3$0.length, t0$19 === 1 && m$3$0[0] === "void")) {
          return ["assoc"];
        } else {
          bridge$$7519$0 = m$3$0;if (Array.isArray(bridge$$7519$0) && (t0$20 = bridge$$7519$0.length, t0$20 === 3 && (bridge$$7519$0[0] === "data" && (t1$13 = bridge$$7519$0[1], x$5 = t1$13, Array.isArray(t1$13) && (t2$8 = t1$13.length, t2$8 === 2 && (t1$13[0] === "symbol" && (s$0 = t1$13[1], t3$6 = bridge$$7519$0[2], Array.isArray(t3$6) && (t4$3 = t3$6.length, t4$3 === 1 && t3$6[0] === "void"))))))) || Array.isArray(bridge$$7519$0) && (t0$21 = bridge$$7519$0.length, t0$21 === 3 && (bridge$$7519$0[0] === "data" && (t1$14 = bridge$$7519$0[1], Array.isArray(t1$14) && (t2$9 = t1$14.length, t2$9 === 1 && (t1$14[0] === "void" && (t3$7 = bridge$$7519$0[2], x$5 = t3$7, Array.isArray(t3$7) && (t4$4 = t3$7.length, t4$4 === 2 && (t3$7[0] === "symbol" && (s$0 = t3$7[1], true)))))))))) {
            return ["assoc", ["value", camelCase$0(s$0)], x$5];
          } else {
            if (($$7522$0 = Array.isArray(m$3$0)) && (t0$19 = m$3$0.length, ($$7524$0 = t0$19 === 3) && (($$7525$0 = m$3$0[0] === "data") && (t1$12 = m$3$0[1], Array.isArray(t1$12) && (t2$7 = t1$12.length, t2$7 === 2 && t1$12[0] === "symbol"))))) {
              s$1 = t1$12[1];rhs$2 = m$3$0[2];return ["assoc", ["value", camelCase$0(s$1)], rhs$2];
            } else {
              if ($$7525$0) {
                lhs$2 = m$3$0[1];rhs$3 = m$3$0[2];return ["objsplice", ["multi", (opt$0 = pattern_handlers$0.build_object, rhs2$0 = __lt____lt____colon__$0(["use", info$2.scope, rhs$3], rhs$3), PatternCompiler$0(lhs$2, info$2, opt$0).extract_from_rhs(rhs2$0))]];
              } else {
                return ___match_error(m$3$0, "#data{lhs, rhs}");
              }
            }
          }
        }
      } else {
        other$2 = ph$3$0;m$4$0 = expr$1;if (Array.isArray(m$4$0) && (t0$22 = m$4$0.length, t0$22 === 3 && m$4$0[0] === "data")) {
          lhs$3 = m$4$0[1];rhs$4 = m$4$0[2];opt$1 = pattern_handlers$0.declare_variables;pc$0 = PatternCompiler$0(lhs$3, info$2, opt$1);rhs2$1 = __lt____lt____colon__$0(["use", info$2.scope, rhs$4], rhs$4);assignment$0 = pc$0.extract_from_rhs(rhs2$1);m$5$0 = pc$0.vars;if (($$7679$0 = Array.isArray(m$5$0)) && (t0$23 = m$5$0.length, t0$23 === 0)) {
            rval$0 = ["value", undefined];
          } else {
            if ($$7679$0 && t0$23 === 1) {
              v$1 = m$5$0[0];rval$0 = v$1;
            } else {
              vs$0 = m$5$0;rval$0 = ["data"].concat(vs$0);
            }
          }expr$2 = ["splice", assignment$0, rval$0];return pc$0.wrapAssignment(expr$2);
        } else {
          return ___match_error(m$4$0, "#data{lhs, rhs}");
        }
      }
    }
  };t0$24 = getProjector(mac$0("="))($targ$10);if (t0$24[0]) {
    equal_mac$0 = t0$24[1];
  } else {
    ___match_error($targ$10, "mac{\"=\"}! equal_mac{match, info, form, expr}");
  }$targ$11 = function (ph$4$0, temp$15$0, temp$16$0, temp$17$0) {
    var t0$25 = undefined;var t0$26 = undefined;var t1$15 = undefined;var x$6 = undefined;var x$7 = undefined;var rhs$6 = undefined;var t0$27 = undefined;var m$6$0 = undefined;var x$8 = undefined;var t0$28 = undefined;var t1$16 = undefined;var t2$10 = undefined;var $targ$27 = undefined;var stmts$0 = undefined;var other$3 = undefined;var env$0 = undefined;var lhs$4 = undefined;var rhs$5 = undefined;t0$25 = temp$15$0;if (___hasprop(t0$25, "env")) {
      env$0 = t0$25.env;
    } else {
      ___match_error(temp$15$0);
    }t0$26 = temp$17$0;if (Array.isArray(t0$26) && (t1$15 = t0$26.length, t1$15 === 3 && t0$26[0] === "data")) {
      lhs$4 = t0$26[1];rhs$5 = t0$26[2];
    } else {
      ___match_error(temp$17$0);
    }if ((x$6 = ph$4$0, x$6 instanceof Array && x$6[0] === "pattern")) {
      m$6$0 = [lhs$4, rhs$5];if (Array.isArray(m$6$0) && (t0$27 = m$6$0.length, t0$27 === 2 && (x$7 = m$6$0[0], x$7 instanceof Array && x$7[0] === "void"))) {
        rhs$6 = m$6$0[1];return ["assoc", rhs$6];
      } else {
        return ["assoc", lhs$4, rhs$5];
      }
    } else {
      if ((x$8 = ph$4$0, x$8 instanceof Array && x$8[0] === "test")) {
        $targ$27 = rhs$5;t0$28 = getProjector(Body$0)($targ$27);if (t0$28[0] && (t1$16 = t0$28[1], t2$10 = t1$16.length, t2$10 >= 0)) {
          stmts$0 = Array.prototype.slice.call(t1$16, 0);
        } else {
          ___match_error($targ$27, "Body! {*stmts}");
        }return ["blocktest", lhs$4, stmts$0];
      } else {
        other$3 = ph$4$0;return ["assoc", lhs$4, rhs$5];
      }
    }
  };t0$29 = getProjector(mac$0("=>"))($targ$11);if (t0$29[0]) {
    fat_arrow_mac$0 = t0$29[1];
  } else {
    ___match_error($targ$11, "mac{\"=>\"}! fat_arrow_mac{match, {=> env}, _, #data{lhs, rhs}}");
  }$targ$12 = function (context$3, info$3, form$9, ph$5$0) {
    var t0$31 = undefined;var t0$32 = undefined;var bridge$$7823$0 = undefined;var t0$33 = undefined;var bridge$$7822$0 = undefined;var accum$0 = undefined;var m$8 = undefined;var acc$2 = undefined;var temp$18 = undefined;var decls$0 = undefined;var newargs$0 = undefined;var _body$0 = undefined;var x$9 = undefined;var body2$1 = undefined;var newp$0 = undefined;var body2$2 = undefined;var a$0 = undefined;var pc2$1 = undefined;var body2$3 = undefined;var a$1 = undefined;var other$5 = undefined;var fw$1 = undefined;var bw$0 = undefined;var defaults$0 = undefined;var rest$0 = undefined;var objp$1 = undefined;var i$0 = undefined;var objp$0 = undefined;var fw$0 = undefined;var t0$34 = undefined;var t1$18 = undefined;var t2$11 = undefined;var t3$8 = undefined;var t4$5 = undefined;var m$7$0 = undefined;var wrap$0 = undefined;var pc$1 = undefined;var cpattern$0 = undefined;var arg$1 = undefined;var args$1 = undefined;var pre$0 = undefined;var body$3 = undefined;var post$0 = undefined;var generator$0 = undefined;var t0$30 = undefined;var t1$17 = undefined;var bridge$$7821$0 = undefined;t0$30 = ph$5$0;t1$17 = t0$30.length;if (t1$17 >= 5 && t1$17 <= 6 && (t0$30[0] === "data" && (bridge$$7821$0 = t0$30[1], (bridge$$7822$0 = bridge$$7821$0, (bridge$$7823$0 = bridge$$7822$0, (arg$1 = bridge$$7823$0, Array.isArray(bridge$$7823$0) && (t0$31 = bridge$$7823$0.length, t0$31 >= 1 && (bridge$$7823$0[0] === "data" && (args$1 = Array.prototype.slice.call(bridge$$7823$0, 1), true)))) || Array.isArray(bridge$$7823$0) && (t0$32 = bridge$$7823$0.length, t0$32 >= 1 && (bridge$$7823$0[0] === "multi" && (args$1 = Array.prototype.slice.call(bridge$$7823$0, 1), arg$1 = ["data"].concat(args$1), true)))) || Array.isArray(bridge$$7822$0) && (t0$33 = bridge$$7822$0.length, t0$33 === 1 && (bridge$$7822$0[0] === "void" && (args$1 = [], arg$1 = ["data"], true)))) || (arg$1 = ["data", arg$1], args$1 = [arg$1], true)))) {
      pre$0 = t0$30[2];body$3 = t0$30[3];post$0 = t0$30[4];if (5 >= t1$17) {
        generator$0 = ["value", false];
      } else {
        generator$0 = t0$30[5];
      }wrap$0 = function wrap(body2$0) {
        var body3$0 = undefined;if (equal(post$0, ["value", null])) {
          body3$0 = body2$0;
        } else {
          body3$0 = ["multi", body2$0, post$0];
        }if (equal(pre$0, ["value", null])) {
          return body3$0;
        } else {
          return ["multi", pre$0, body3$0];
        }
      };pc$1 = PatternCompiler$0(arg$1, info$3, __amp__(pattern_handlers$0.declare_variables, __amp____colon__({ indexable: true, allow_nested: true }, __amp____colon__((accum$0 = {}, accum$0.fallback = function fallback(target$0, pattern$0) {
        return match_error$0(target$0, pattern$0);
      }, accum$0), { tags: { declare_mode: "let" }, insert_object_argument: true }))));cpattern$0 = pc$1.compile();m$7$0 = cpattern$0;if (Array.isArray(m$7$0) && (t0$34 = m$7$0.length, t0$34 === 5 && (m$7$0[0] === "array_pattern" && (fw$0 = m$7$0[1], t1$18 = m$7$0[2], Array.isArray(t1$18) && (t2$11 = t1$18.length, t2$11 === 0 && (t3$8 = m$7$0[3], Array.isArray(t3$8) && (t4$5 = t3$8.length, t4$5 === 0 && m$7$0[4] === void 0))))))) {
        decls$0 = [];acc$2 = [];temp$18 = null;m$8 = null;$6: for (var _iterator = zip(fw$0, args$1)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          m$8 = _step.value;
          var t0$37 = undefined;var t0$38 = undefined;var bridge$$8037$0 = undefined;var m$9$0 = undefined;var newv$0 = undefined;var pc2$0 = undefined;var other$4 = undefined;var expr$3 = undefined;var v$2 = undefined;var t0$36 = undefined;var t1$20 = undefined;var t2$12 = undefined;var bridge$$7962$0 = undefined;var ph$6$0 = undefined;var arg$2 = undefined;var t0$35 = undefined;var t1$19 = undefined;t0$35 = m$8;if (Array.isArray(t0$35) && (t1$19 = t0$35.length, t1$19 === 2)) {
            ph$6$0 = t0$35[0];arg$2 = t0$35[1];t0$36 = ph$6$0;if (Array.isArray(t0$36) && (t1$20 = t0$36.length, t1$20 === 2 && (t0$36[0] === "assign" && (t2$12 = t0$36[1], expr$3 = t2$12, bridge$$7962$0 = t2$12, (Array.isArray(bridge$$7962$0) && (t0$37 = bridge$$7962$0.length, t0$37 === 2 && (bridge$$7962$0[0] === "symbol" && (v$2 = bridge$$7962$0[1], true))) || Array.isArray(bridge$$7962$0) && (t0$38 = bridge$$7962$0.length, t0$38 === 2 && (bridge$$7962$0[0] === "variable" && (v$2 = bridge$$7962$0[1], true)))) && nequal(expr$3.declare_mode, "set"))))) {
              m$9$0 = expr$3.declare_mode;if (m$9$0 === "let") {
                temp$18 = __amp____colon__(expr$3, { mutable: false });
              } else {
                if (m$9$0 === "var") {
                  temp$18 = __amp____colon__(expr$3, { mutable: true });
                } else {
                  bridge$$8037$0 = m$9$0;if (bridge$$8037$0 === "unqualified" || bridge$$8037$0 === void 0) {
                    temp$18 = __amp____colon__(expr$3, { mutable: false });
                  } else {
                    temp$18 = ___match_error(m$9$0, ".unqualified or undefined? ");
                  }
                }
              }
            } else {
              other$4 = ph$6$0;newv$0 = __amp__(["symbol", info$3.gensym("temp")], { env: info$3.mkenv(), location: arg$2.location });pc2$0 = pc$1.fork(other$4);decls$0.push(pc2$0.extract_from_rhs(newv$0));temp$18 = newv$0;
            }acc$2.push(temp$18);
          } else {
            ___match_error(m$8);
          }
        }newargs$0 = acc$2;_body$0 = pc$1.wrapBody(body$3);return ["lambda", newargs$0, wrap$0(["multi"].concat(decls$0).concat([_body$0])), generator$0];
      } else {
        objp$0 = m$7$0;if ((x$9 = m$7$0, x$9 instanceof Array && x$9[0] === "object_pattern")) {
          body2$1 = ["send", ["symbol", "match"], ["data", ["send", ["symbol", "arguments"], ["value", 0]], ["send", ["symbol", "->"], ["data", arg$1, body$3]]]];return ["lambda", [], wrap$0(body2$1), generator$0];
        } else {
          if (Array.isArray(m$7$0) && (t0$34 = m$7$0.length, t0$34 === 3 && (m$7$0[0] === "all" && (t1$18 = m$7$0[1], Array.isArray(t1$18) && (t2$11 = t1$18.length, t2$11 === 5 && (t1$18[0] === "array_pattern" && (fw$1 = t1$18[1], bw$0 = t1$18[2], defaults$0 = t1$18[3], rest$0 = t1$18[4], objp$1 = m$7$0[2], ___hasprop(m$7$0, "insertion_index")))))))) {
            i$0 = m$7$0.insertion_index;a$0 = __lt____lt____colon__$0(["symbol", "arguments"], arg$1);fw$1.splice(i$0, 0, objp$1);newp$0 = ["array_pattern", fw$1, bw$0, defaults$0, rest$0];pc2$1 = pc$1.fork(newp$0);body2$2 = ["multi", pc2$1.extract_from_rhs(a$0), pc$1.wrapBody(body$3)];return ["lambda", [], wrap$0(body2$2), generator$0];
          } else {
            other$5 = m$7$0;a$1 = __lt____lt____colon__$0(["symbol", "arguments"], arg$1);body2$3 = ["send", ["send", ["symbol", "match"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "indexable"]]]], ["data", a$1, ["send", ["symbol", "->"], ["data", arg$1, body$3]]]];return ["lambda", [], wrap$0(body2$3), generator$0];
          }
        }
      }
    } else {
      return ___match_error(ph$5$0, "#data{[arg and #data{*args}\n          \\ or #multi{*args} and arg is #data{*args}\n          \\ or #void{} and args is {} and arg is #data{}\n          \\ or arg is #data{arg} and args is {arg}]\n         pre, body, post, generator = #value{false}}");
    }
  };t0$39 = getProjector(mac$0("_lambda"))($targ$12);if (t0$39[0]) {
    _lambda_mac$0 = t0$39[1];
  } else {
    ___match_error($targ$12, "mac{\"_lambda\"}! _lambda_mac{context, info, form, match}");
  }$targ$13 = function (ctx$1, temp$19$0, form$10, ph$7$0) {
    var other$6 = undefined;var args$2 = undefined;var body$4 = undefined;var t0$40 = undefined;var t1$21 = undefined;t0$40 = ph$7$0;t1$21 = t0$40.length;if (t1$21 === 3 && t0$40[0] === "data") {
      args$2 = t0$40[1];body$4 = t0$40[2];return ["send", ["symbol", "_lambda"], ["data", args$2, ["value", null], body$4, ["value", null], ["value", true]]];
    } else {
      other$6 = ph$7$0;throw ErrorFactory(["syntax", "lambda"]).create("Bad lambda syntax", { node: other$6 });
    }
  };t0$41 = getProjector(mac$0("*->"))($targ$13);if (t0$41[0]) {
    genarrow_mac$0 = t0$41[1];
  } else {
    ___match_error($targ$13, "mac{\"*->\"}! genarrow_mac{ctx, _, form, match}");
  }$targ$14 = function (ctx$2, info$4, form$11, temp$20$0) {
    var t0$42 = undefined;var t1$22 = undefined;var t0$43 = undefined;var t1$23 = undefined;var $targ$28 = undefined;var at$0 = undefined;var self$0 = undefined;var args$3 = undefined;var body$5 = undefined;t0$42 = temp$20$0;if (Array.isArray(t0$42) && (t1$22 = t0$42.length, t1$22 === 3 && t0$42[0] === "data")) {
      args$3 = t0$42[1];body$5 = t0$42[2];
    } else {
      ___match_error(temp$20$0);
    }$targ$28 = info$4.mark(["symbol", "@"], ["symbol", "self"]);t0$43 = $targ$28;if (Array.isArray(t0$43) && (t1$23 = t0$43.length, t1$23 === 2)) {
      at$0 = t0$43[0];self$0 = t0$43[1];
    } else {
      ___match_error($targ$28, "{at, self}");
    }[at$0, self$0];return ["send", ["symbol", "_lambda"], ["data", args$3, ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], ["send", ["symbol", "and"], ["data", at$0, self$0]]], ["symbol", "this"]]], body$5, ["value", null]]];
  };t0$44 = getProjector(mac$0("@->"))($targ$14);if (t0$44[0]) {
    metharrow_mac$0 = t0$44[1];
  } else {
    ___match_error($targ$14, "mac{\"@->\"}! metharrow_mac{ctx, info, form, #data{args, body}}");
  }$targ$15 = function (ph$8$0, temp$21$0, form$12, expr$4) {
    var x$10 = undefined;var t0$45 = undefined;var t1$24 = undefined;var $targ$29 = undefined;var lhs$5 = undefined;var rhs$7 = undefined;var other$8 = undefined;var args$4 = undefined;var body$6 = undefined;var t0$46 = undefined;var m$10$0 = undefined;var other$7 = undefined;if ((x$10 = ph$8$0, x$10 instanceof Array && x$10[0] === "clause")) {
      $targ$29 = expr$4;t0$45 = $targ$29;if (Array.isArray(t0$45) && (t1$24 = t0$45.length, t1$24 === 3 && t0$45[0] === "data")) {
        lhs$5 = t0$45[1];rhs$7 = t0$45[2];
      } else {
        ___match_error($targ$29, "#data{lhs, rhs}");
      }[lhs$5, rhs$7];return ["clause", lhs$5, rhs$7];
    } else {
      other$7 = ph$8$0;m$10$0 = expr$4;if (Array.isArray(m$10$0) && (t0$46 = m$10$0.length, t0$46 === 3 && m$10$0[0] === "data")) {
        args$4 = m$10$0[1];body$6 = m$10$0[2];return ["send", ["symbol", "_lambda"], ["data", args$4, ["value", null], body$6, ["value", null]]];
      } else {
        other$8 = m$10$0;throw ErrorFactory(["syntax", "lambda"]).create("Bad lambda syntax", { node: other$8 });
      }
    }
  };t0$47 = getProjector(mac$0("->"))($targ$15);if (t0$47[0]) {
    arrow_mac$0 = t0$47[1];
  } else {
    ___match_error($targ$15, "mac{\"->\"}! arrow_mac{match, _, form, expr}");
  }_catch$0 = named_statement_matcher$0("catch");_finally$0 = named_statement_matcher$0("finally");try_pattern$0 = ["seq", ["multiple", _catch$0], ["multiple", _finally$0, 0, 1]];$targ$16 = function (temp$22$0, info$5, form$13, temp$23$0) {
    var t0$48 = undefined;var t1$25 = undefined;var t0$49 = undefined;var t1$26 = undefined;var body$7 = undefined;t0$48 = temp$22$0;if (Array.isArray(t0$48) && (t1$25 = t0$48.length, t1$25 === 2 && (t0$48[0] === "expr" && t0$48[1] === "multi"))) {} else {
      ___match_error(temp$22$0);
    }t0$49 = temp$23$0;if (Array.isArray(t0$49) && (t1$26 = t0$49.length, t1$26 === 2 && t0$49[0] === "data")) {
      body$7 = t0$49[1];
    } else {
      ___match_error(temp$23$0);
    }return flatmacro$0(try_pattern$0, function (temp$24$0) {
      var t0$50 = undefined;var t1$27 = undefined;var t2$13 = undefined;var t3$9 = undefined;var t4$6 = undefined;var t5$2 = undefined;var m$11 = undefined;var m$12 = undefined;var t0$54 = undefined;var $targ$30 = undefined;var m$13 = undefined;var env$1 = undefined;var clauses$0 = undefined;var finally$1 = undefined;var make_ebody$0 = undefined;var catches$0 = undefined;var finallies$0 = undefined;t0$50 = temp$24$0;if (Array.isArray(t0$50) && (t1$27 = t0$50.length, t1$27 === 3 && (t0$50[0] === "seq" && (t2$13 = t0$50[1], Array.isArray(t2$13) && (t3$9 = t2$13.length, t3$9 >= 1 && (t2$13[0] === "multiple" && (catches$0 = Array.prototype.slice.call(t2$13, 1), t4$6 = t0$50[2], Array.isArray(t4$6) && (t5$2 = t4$6.length, t5$2 >= 1 && t4$6[0] === "multiple")))))))) {
        finallies$0 = Array.prototype.slice.call(t4$6, 1);
      } else {
        ___match_error(temp$24$0);
      }env$1 = info$5.mkenv();clauses$0 = [];finally$1 = ["void"];m$11 = null;$7: for (var _iterator = catches$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$11 = _step.value;
        var p$0 = undefined;var body$8 = undefined;var t0$51 = undefined;var t1$28 = undefined;var t2$14 = undefined;var t3$10 = undefined;var t4$7 = undefined;var t5$3 = undefined;t0$51 = m$11;if (Array.isArray(t0$51) && (t1$28 = t0$51.length, t1$28 === 3 && (t0$51[0] === "send" && (t2$14 = t0$51[1], Array.isArray(t2$14) && (t3$10 = t2$14.length, t3$10 === 2 && (t2$14[0] === "symbol" && (t2$14[1] === "catch" && (t4$7 = t0$51[2], Array.isArray(t4$7) && (t5$3 = t4$7.length, t5$3 === 3 && t4$7[0] === "data"))))))))) {
          p$0 = t4$7[1];body$8 = t4$7[2];clauses$0.push(env$1.mark(["send", ["symbol", "->"], ["data", p$0, body$8]]));
        } else {
          ___match_error(m$11);
        }
      }m$12 = null;$8: for (var _iterator2 = finallies$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$12 = _step2.value;
        var body$9 = undefined;var t0$52 = undefined;var t1$29 = undefined;var t2$15 = undefined;var t3$11 = undefined;var t4$8 = undefined;var t5$4 = undefined;t0$52 = m$12;if (Array.isArray(t0$52) && (t1$29 = t0$52.length, t1$29 === 3 && (t0$52[0] === "send" && (t2$15 = t0$52[1], Array.isArray(t2$15) && (t3$11 = t2$15.length, t3$11 === 2 && (t2$15[0] === "symbol" && (t2$15[1] === "finally" && (t4$8 = t0$52[2], Array.isArray(t4$8) && (t5$4 = t4$8.length, t5$4 === 2 && t4$8[0] === "data"))))))))) {
          body$9 = t4$8[1];finally$1 = body$9;finally$1;
        } else {
          ___match_error(m$12);
        }
      }clauses$0.push(env$1.mark(["send", ["symbol", "->"], ["data", ["symbol", "e"], ["send", ["symbol", "throw"], ["symbol", "e"]]]]));make_ebody$0 = function make_ebody(wrap$1) {
        return parse_clauses$0(info$5, ["symbol", "excv"], clauses$0, { wrap: wrap$1 });
      };$targ$30 = function (ph$9$0, e$0) {
        var trystmt$0 = undefined;var $$8479$0 = undefined;var $$8480$0 = undefined;var $$8481$0 = undefined;var $$8482$0 = undefined;var t0$53 = undefined;var t1$30 = undefined;t0$53 = ph$9$0;t1$30 = t0$53.length;if (($$8481$0 = t1$30 === 2) && (($$8482$0 = t0$53[0] === "expr") && t0$53[1] === "multi")) {
          return ["nostep", this.form];
        } else {
          if ($$8482$0 && t0$53[1] === "ignore") {
            return ["js_try", body$7, ["send", ["symbol", "->"], ["data", ["data", ["symbol", "excv"]], make_ebody$0(function (x$11) {
              return x$11;
            })]], finally$1];
          } else {
            if ($$8482$0 && t0$53[1] === "expr") {
              trystmt$0 = ["js_try", ["send", ["symbol", "="], ["data", ["send", ["symbol", "set-var"], ["symbol", "rval"]], body$7]], ["send", ["symbol", "->"], ["data", ["data", ["symbol", "excv"]], make_ebody$0(function (x$12) {
                return ["send", ["symbol", "="], ["data", ["send", ["symbol", "set-var"], ["symbol", "rval"]], x$12]];
              })]], finally$1];return ["multi", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "rval"]], ["symbol", "false"]]], trystmt$0, ["symbol", "rval"]];
            } else {
              return ___match_error(ph$9$0, "#expr{.expr}");
            }
          }
        }
      };t0$54 = getProjector(ctx_mac$0)($targ$30);if (t0$54[0]) {
        m$13 = t0$54[1];
      } else {
        ___match_error($targ$30);
      }return ["macro", m$13];
    });
  };t0$55 = getProjector(mac$0("try"))($targ$16);if (t0$55[0]) {
    try_mac$0 = t0$55[1];
  } else {
    ___match_error($targ$16, "mac{\"try\"}! try_mac{#expr{.multi}, info, form, #data{body}}");
  }$targ$17 = function (ph$10$0, info$6, form$14, temp$25$0) {
    var t0$56 = undefined;var t1$31 = undefined;var t2$16 = undefined;var t3$12 = undefined;var t4$9 = undefined;var parsed_clauses$0 = undefined;var parsed_clauses$1 = undefined;var trystmt$1 = undefined;var other$9 = undefined;var $$8537$0 = undefined;var $$8538$0 = undefined;var $$8539$0 = undefined;var $$8540$0 = undefined;var t0$57 = undefined;var t1$32 = undefined;var expr$5 = undefined;var clauses$1 = undefined;t0$56 = temp$25$0;if (Array.isArray(t0$56) && (t1$31 = t0$56.length, t1$31 === 3 && (t0$56[0] === "data" && (expr$5 = t0$56[1], t2$16 = getProjector(Body$0)(t0$56[2]), t2$16[0] && (t3$12 = t2$16[1], t4$9 = t3$12.length, t4$9 >= 0))))) {
      clauses$1 = Array.prototype.slice.call(t3$12, 0);
    } else {
      ___match_error(temp$25$0);
    }t0$57 = ph$10$0;t1$32 = t0$57.length;if (($$8539$0 = t1$32 === 2) && (($$8540$0 = t0$57[0] === "expr") && t0$57[1] === "multi")) {
      return ["nostep", form$14];
    } else {
      if ($$8540$0 && t0$57[1] === "ignore") {
        clauses$1.push(info$6.mkenv().mark(["send", ["symbol", "->"], ["data", ["symbol", "e"], ["send", ["symbol", "throw"], ["symbol", "e"]]]]));parsed_clauses$0 = parse_clauses$0(info$6, ["symbol", "excv"], clauses$1, { wrap: function (x$13) {
            return x$13;
          } });return ["js_try", expr$5, ["send", ["symbol", "->"], ["data", ["data", ["symbol", "excv"]], parsed_clauses$0]], ["void"]];
      } else {
        other$9 = ph$10$0;clauses$1.push(info$6.mkenv().mark(["send", ["symbol", "->"], ["data", ["symbol", "e"], ["send", ["symbol", "throw"], ["symbol", "e"]]]]));parsed_clauses$1 = parse_clauses$0(info$6, ["symbol", "excv"], clauses$1, { wrap: function (x$14) {
            return ["send", ["symbol", "="], ["data", ["send", ["symbol", "set-var"], ["symbol", "rval"]], x$14]];
          } });trystmt$1 = ["js_try", ["send", ["symbol", "="], ["data", ["send", ["symbol", "set-var"], ["symbol", "rval"]], expr$5]], ["send", ["symbol", "->"], ["data", ["data", ["symbol", "excv"]], parsed_clauses$1]], ["void"]];return ["send", ["symbol", "let"], ["data", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "rval"]], ["symbol", "false"]]], ["multi", trystmt$1, ["symbol", "rval"]]]];
      }
    }
  };t0$58 = getProjector(mac$0("!!"))($targ$17);if (t0$58[0]) {
    tryop_mac$0 = t0$58[1];
  } else {
    ___match_error($targ$17, "mac{\"!!\"}! tryop_mac{match, info, form, #data{expr, Body! {*clauses}}}");
  }$targ$18 = function (temp$26$0, form$15, arg$3) {
    return ["js_throw", arg$3];
  };t0$59 = getProjector(expr_mac$0)($targ$18);if (t0$59[0] && (t1$33 = getProjector(mac$0("throw"))(t0$59[1]), t1$33[0])) {
    throw_mac$0 = t1$33[1];
  } else {
    ___match_error($targ$18, "expr_mac! mac{\"throw\"}! throw_mac{_, form, arg}");
  }$targ$19 = function (ph$11$0, temp$27$0, form$16, arg$4) {
    var x$15 = undefined;var subp$0 = undefined;var w$0 = undefined;if ((x$15 = ph$11$0, x$15 instanceof Array && x$15[0] === "pattern")) {
      if (equal(arg$4, ["void"])) {
        subp$0 = null;
      } else {
        subp$0 = arg$4;
      }w$0 = function w(ph$12) {
        return ph$12;
      };return ["special", AssignmentHandler$0(subp$0, w$0)];
    } else {
      return ___match_error(ph$11$0, "#pattern");
    }
  };t0$60 = getProjector(mac$0("expr-value"))($targ$19);if (t0$60[0]) {
    exprvalue_mac$0 = t0$60[1];
  } else {
    ___match_error($targ$19, "mac{\"expr-value\"}! exprvalue_mac{match, _, form, arg}");
  }$targ$20 = function (ph$13$0, temp$28$0, form$17, arg$5) {
    var x$16 = undefined;var subp$1 = undefined;var w$1 = undefined;var t0$61 = undefined;var t0$62 = undefined;var otherwise$0 = undefined;var bridge$$8679$0 = undefined;if ((x$16 = ph$13$0, x$16 instanceof Array && x$16[0] === "pattern")) {
      if (equal(arg$5, ["void"])) {
        subp$1 = null;
      } else {
        subp$1 = arg$5;
      }w$1 = function w(ph$14) {
        return ["send", ["symbol", "return"], ph$14];
      };return ["special", AssignmentHandler$0(subp$1, w$1)];
    } else {
      bridge$$8679$0 = ph$13$0;if (Array.isArray(bridge$$8679$0) && (t0$61 = bridge$$8679$0.length, t0$61 === 2 && (bridge$$8679$0[0] === "expr" && bridge$$8679$0[1] === "expr")) || Array.isArray(bridge$$8679$0) && (t0$62 = bridge$$8679$0.length, t0$62 === 2 && (bridge$$8679$0[0] === "expr" && bridge$$8679$0[1] === "head"))) {
        return ["js_return", arg$5];
      } else {
        otherwise$0 = ph$13$0;return ["nostep", form$17];
      }
    }
  };t0$63 = getProjector(mac$0("return"))($targ$20);if (t0$63[0]) {
    return_mac$0 = t0$63[1];
  } else {
    ___match_error($targ$20, "mac{\"return\"}! return_mac{match, _, form, arg}");
  }$targ$21 = function (temp$29$0, form$18, arg$6) {
    return ["js_new", arg$6];
  };t0$64 = getProjector(expr_mac$0)($targ$21);if (t0$64[0] && (t1$34 = getProjector(mac$0("new"))(t0$64[1]), t1$34[0])) {
    new_mac$0 = t1$34[1];
  } else {
    ___match_error($targ$21, "expr_mac! mac{\"new\"}! new_mac{_, form, arg}");
  }$targ$22 = function (context$4, temp$30$0, form$19, temp$31$0) {
    var t0$65 = undefined;var other$10 = undefined;var s$2 = undefined;var t0$66 = undefined;var t1$35 = undefined;var arg$7 = undefined;var ph$15$0 = undefined;t0$65 = temp$31$0;arg$7 = t0$65;ph$15$0 = t0$65;t0$66 = ph$15$0;t1$35 = t0$66.length;if (t1$35 === 2 && t0$66[0] === "symbol") {
      s$2 = t0$66[1];return ["undeclare", arg$7];
    } else {
      other$10 = ph$15$0;return ["js_delete", other$10];
    }
  };t0$67 = getProjector(mac$0("delete"))($targ$22);if (t0$67[0]) {
    delete_mac$0 = t0$67[1];
  } else {
    ___match_error($targ$22, "mac{\"delete\"}! delete_mac{context, _, form, match arg}");
  }$targ$23 = function (context$5, temp$32$0, form$20, temp$33$0) {
    var t0$68 = undefined;var t1$36 = undefined;var t2$17 = undefined;var t3$13 = undefined;var t4$10 = undefined;var stmts$1 = undefined;t0$68 = temp$33$0;if (Array.isArray(t0$68) && (t1$36 = t0$68.length, t1$36 === 2 && (t0$68[0] === "data" && (t2$17 = getProjector(Body$0)(t0$68[1]), t2$17[0] && (t3$13 = t2$17[1], t4$10 = t3$13.length, t4$10 >= 0))))) {
      stmts$1 = Array.prototype.slice.call(t3$13, 0);
    } else {
      ___match_error(temp$33$0);
    }return ["splice"].concat(stmts$1);
  };t0$69 = getProjector(mac$0("splice"))($targ$23);if (t0$69[0]) {
    splice_mac$0 = t0$69[1];
  } else {
    ___match_error($targ$23, "mac{\"splice\"}! splice_mac{context, _, form, #data{Body! {*stmts}}}");
  }$targ$24 = function (context$6, temp$34$0, form$21, temp$35$0) {
    var t0$70 = undefined;var t1$37 = undefined;var t2$18 = undefined;var t3$14 = undefined;var t4$11 = undefined;var t5$5 = undefined;var f$1 = undefined;var tag$0 = undefined;t0$70 = temp$35$0;if (Array.isArray(t0$70) && (t1$37 = t0$70.length, t1$37 === 3 && (t0$70[0] === "data" && (t2$18 = t0$70[1], Array.isArray(t2$18) && (t3$14 = t2$18.length, t3$14 === 1 && (t2$18[0] === "void" && (t4$11 = t0$70[2], Array.isArray(t4$11) && (t5$5 = t4$11.length, t5$5 === 2 && t4$11[0] === "symbol")))))))) {
      tag$0 = t4$11[1];
    } else {
      ___match_error(temp$35$0);
    }tag$0 = ["value", tag$0];f$1 = function f(ph$16$0, temp$36$0, form$22, expr$6) {
      var x$17 = undefined;var other$11 = undefined;var subp$2 = undefined;var $$8909$0 = undefined;var $$8910$0 = undefined;var t0$72 = undefined;var m$14$0 = undefined;var checker_mac$0 = undefined;var x$18 = undefined;var x$19 = undefined;var other$12 = undefined;var args$5 = undefined;var $$8974$0 = undefined;var $$8975$0 = undefined;var t0$73 = undefined;var m$15$0 = undefined;if ((x$17 = ph$16$0, x$17 instanceof Array && x$17[0] === "pattern")) {
        checker_mac$0 = ["macro", function (context$7, temp$37$0, form$23, temp$38$0) {
          var t0$71 = undefined;var t1$38 = undefined;var expr$7 = undefined;t0$71 = temp$38$0;if (Array.isArray(t0$71) && (t1$38 = t0$71.length, t1$38 === 2 && t0$71[0] === "data")) {
            expr$7 = t0$71[1];
          } else {
            ___match_error(temp$38$0);
          }return ["send", ["symbol", "let"], ["data", ["send", ["symbol", "="], ["data", ["symbol", "x"], expr$7]], ["send", ["symbol", "and"], ["data", ["send", ["symbol", "instanceof"], ["data", ["symbol", "x"], ["symbol", "Array"]]], ["send", ["symbol", "==="], ["data", ["send", ["symbol", "x"], ["value", 0]], tag$0]]]]]];
        }];m$14$0 = expr$6;if (($$8909$0 = Array.isArray(m$14$0)) && (t0$72 = m$14$0.length, t0$72 >= 1 && m$14$0[0] === "data")) {
          subp$2 = Array.prototype.slice.call(m$14$0, 1);return ["data", tag$0].concat(subp$2);
        } else {
          if ($$8909$0 && (t0$72 === 1 && m$14$0[0] === "void")) {
            return ["check", checker_mac$0, ["ignore"]];
          } else {
            other$11 = m$14$0;return ["check", checker_mac$0, expr$6];
          }
        }
      } else {
        if ((x$18 = ph$16$0, x$18 instanceof Array && x$18[0] === "check")) {
          return ["send", ["symbol", "getChecker"], ["data", ["data", tag$0]]];
        } else {
          if ((x$19 = ph$16$0, x$19 instanceof Array && x$19[0] === "project")) {
            return ["send", ["symbol", "getProjector"], ["data", ["data", tag$0]]];
          } else {
            m$15$0 = expr$6;if (($$8974$0 = Array.isArray(m$15$0)) && (t0$73 = m$15$0.length, t0$73 === 1 && m$15$0[0] === "void")) {
              return ["data", tag$0];
            } else {
              if ($$8974$0 && (t0$73 >= 1 && m$15$0[0] === "data")) {
                args$5 = Array.prototype.slice.call(m$15$0, 1);return ["data", tag$0].concat(args$5);
              } else {
                other$12 = m$15$0;return ["send", ["data", tag$0], other$12];
              }
            }
          }
        }
      }
    };return ["macro", f$1];
  };t0$74 = getProjector(mac$0("#"))($targ$24);if (t0$74[0]) {
    hash_mac$0 = t0$74[1];
  } else {
    ___match_error($targ$24, "mac{\"#\"}! hash_mac{context, _, form, #data{#void{}, #symbol{var tag}}}");
  }$targ$25 = function (temp$39$0, temp$40$0, form$24, temp$41$0) {
    var x$20 = undefined;var t0$75 = undefined;var t1$39 = undefined;if ((x$20 = temp$39$0, x$20 instanceof Array && x$20[0] === "pattern")) {} else {
      ___match_error(temp$39$0);
    }t0$75 = temp$41$0;if (Array.isArray(t0$75) && (t1$39 = t0$75.length, t1$39 === 1 && t0$75[0] === "void")) {} else {
      ___match_error(temp$41$0);
    }return ["ignore"];
  };t0$76 = getProjector(mac$0("_"))($targ$25);if (t0$76[0]) {
    placeholder_mac$0 = t0$76[1];
  } else {
    ___match_error($targ$25, "mac{\"_\"}! placeholder_mac{#pattern, _, form, #void{}}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=core.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../location":106,"../pattern":121,"../util":126,"./helpers":110,"earlgrey-runtime/5":446}],110:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var accum$1 = undefined;var accum$2 = undefined;var accum$3 = undefined;var accum$4 = undefined;var accum$5 = undefined;var accum$6 = undefined;var accum$7 = undefined;var accum$8 = undefined;var $targ$12 = undefined;var accum$9 = undefined;var $targ$13 = undefined;var accum$10 = undefined;var $targ$14 = undefined;var $targ$15 = undefined;var $targ$16 = undefined;var $targ$17 = undefined;var $targ$18 = undefined;var $targ$19 = undefined;var $targ$20 = undefined;var $targ$21 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var $targ$25 = undefined;var $targ$26 = undefined;var $targ$27 = undefined;var $targ$28 = undefined;var $targ$29 = undefined;var $targ$30 = undefined;var $targ$31 = undefined;var $targ$32 = undefined;var $targ$33 = undefined;var $targ$34 = undefined;var $targ$35 = undefined;var $targ$36 = undefined;var $targ$37 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var $1$0 = undefined;var Scope$0 = undefined;var $2$0 = undefined;var parse_clauses$0 = undefined;var PatternCompiler$0 = undefined;var $3$0 = undefined;var Body$0 = undefined;var camelCase$0 = undefined;var mac1$0 = undefined;var embed_location$0 = undefined;var error_embed_location$0 = undefined;var match_error$0 = undefined;var drop_ctx$0 = undefined;var expr_mac$0 = undefined;var expr_mac2$0 = undefined;var ctx_mac$0 = undefined;var _default_proj$0 = undefined;var value_mac$0 = undefined;var overridable$0 = undefined;var protected_value$0 = undefined;var var_operator$0 = undefined;var accum_flags$0 = undefined;var build_loop$0 = undefined;var partial_pattern$0 = undefined;var make_assigner$0 = undefined;var disregard_specials$0 = undefined;var pattern_handlers$0 = undefined;var named_statement_matcher$0 = undefined;var grab_statements$0 = undefined;var flatmacro$0 = undefined;var AssignmentHandler$0 = undefined;var qqstruct$0 = undefined;var qq$0 = undefined;var multimacro$0 = undefined;var inject__minus__tools$0 = undefined;$0$0 = require("../location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "../location");$1$0 = require("../expand");Scope$0 = getProperty($1$0, "Scope", "../expand");$2$0 = require("../pattern");parse_clauses$0 = getProperty($2$0, "parse_clauses", "../pattern");PatternCompiler$0 = getProperty($2$0, "PatternCompiler", "../pattern");$3$0 = require("../util");Body$0 = getProperty($3$0, "Body", "../util");camelCase$0 = getProperty($3$0, "camelCase", "../util");mac1$0 = getProperty($3$0, "mac1", "../util");if (typeof Infinity === "undefined") {
  $targ$0 = undefined;global.Infinity = $targ$0;void 0;
}embed_location$0 = function embed_location(ph$0$0) {
  var other$0 = undefined;var url$0 = undefined;var start$0 = undefined;var end$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;var t2$0 = undefined;t0$0 = ph$0$0;if (___hasprop(t0$0, "location") && (t1$0 = t0$0.location, ___hasprop(t1$0, "source") && (t2$0 = t1$0.source, ___hasprop(t2$0, "url") && (url$0 = t2$0.url, ___hasprop(t1$0, "start") && (start$0 = t1$0.start, ___hasprop(t1$0, "end")))))) {
    end$0 = t1$0.end;return ["send", ["send", ["symbol", "#"], ["data", ["void"], ["symbol", "location"]]], ["data", ["value", url$0], ["value", start$0], ["value", end$0]]];
  } else {
    other$0 = ph$0$0;return ["send", ["send", ["symbol", "#"], ["data", ["void"], ["symbol", "location"]]], ["data", ["symbol", "null"], ["value", 0], ["value", 0]]];
  }
};error_embed_location$0 = function error_embed_location(error$0, target$0) {
  return ["send", ["symbol", "throw"], ["send", ["symbol", "&:"], ["data", error$0, ["data", ["send", ["symbol", "="], ["data", ["symbol", "location"], embed_location$0(target$0)]]]]]];
};match_error$0 = function match_error() {
  var location$0 = undefined;var t0$2 = undefined;var t1$1 = undefined;var target$1 = undefined;var ph$2$0 = undefined;var t0$1 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$1 = m$0$0.length;if (t0$1 >= 1 && t0$1 <= 2) {
    target$1 = m$0$0[0];if (1 >= t0$1) {
      ph$2$0 = null;
    } else {
      ph$2$0 = m$0$0[1];
    }t0$2 = ph$2$0;if (___hasprop(t0$2, "location") && (t1$1 = t0$2.location, t1$1 ? true : false)) {
      location$0 = t1$1;return __lt____lt____colon__$0(["send", ["symbol", "___match_error"], ["data", target$1, ["value", location$0.text()]]], target$1);
    } else {
      return __lt____lt____colon__$0(["send", ["symbol", "___match_error"], ["data", target$1]], target$1);
    }
  } else {
    return ___match_error(m$0$0, "{target, match = null}");
  }
};drop_ctx$0 = function drop_ctx(f$0) {
  return function (context$0, info$0, form$0, arg$0) {
    var rval$0 = undefined;rval$0 = false;try {
      rval$0 = f$0(context$0, info$0, form$0, arg$0);rval$0;
    } catch (excv$0) {
      var t0$4 = undefined;var e$0 = undefined;var t0$3 = undefined;var t1$2 = undefined;var t2$1 = undefined;var t3$0 = undefined;var t4$0 = undefined;t0$3 = excv$0;if (getChecker(ErrorFactory(["match"]))(t0$3) && (___hasprop(t0$3, "args") && (t1$2 = t0$3.args, Array.isArray(t1$2) && (t2$1 = t1$2.length, t2$1 === 1 && (t3$0 = t1$2[0], ___hasprop(t3$0, "value") && (t4$0 = t3$0.value, t4$0 === context$0 && !(Array.isArray(t4$0) && (t0$4 = t4$0.length, t0$4 === 2 && (t4$0[0] === "expr" && t4$0[1] === "expr"))))))))) {
        rval$0 = ["nostep", form$0];rval$0;
      } else {
        e$0 = excv$0;throw e$0;rval$0;
      }
    }return rval$0;
  };
};expr_mac$0 = function expr_mac(f$1) {
  return function (ph$3$0, info$1, form$1, arg$1) {
    var t0$5 = undefined;var t0$6 = undefined;var otherwise$0 = undefined;var bridge$$232$0 = undefined;bridge$$232$0 = ph$3$0;if (Array.isArray(bridge$$232$0) && (t0$5 = bridge$$232$0.length, t0$5 === 2 && (bridge$$232$0[0] === "expr" && bridge$$232$0[1] === "expr")) || Array.isArray(bridge$$232$0) && (t0$6 = bridge$$232$0.length, t0$6 === 2 && (bridge$$232$0[0] === "expr" && bridge$$232$0[1] === "head"))) {
      return f$1(info$1, form$1, arg$1);
    } else {
      otherwise$0 = ph$3$0;return ["nostep", form$1];
    }
  };
};expr_mac2$0 = function expr_mac2(mac$0) {
  return function (ph$4$0, info$2, f$2, e$1) {
    var x$0 = undefined;var mac3$0 = undefined;var f$4 = undefined;var x$3 = undefined;var ph$5$0 = undefined;var t0$7 = undefined;var t1$3 = undefined;t0$7 = ph$4$0;t1$3 = t0$7.length;if (t1$3 === 2 && t0$7[0] === "project") {
      ph$5$0 = t0$7[1];if ((x$0 = ph$5$0, x$0 instanceof Array && x$0[0] === "pattern")) {
        mac3$0 = function mac3(c$0, info$3, f$3, temp$0$0) {
          var t0$8 = undefined;var t1$4 = undefined;var x$2 = undefined;var env$0 = undefined;var x$1 = undefined;var t0$9 = undefined;var t1$5 = undefined;var ph$6$0 = undefined;t0$8 = temp$0$0;if (Array.isArray(t0$8) && (t1$4 = t0$8.length, t1$4 === 2 && t0$8[0] === "data")) {
            ph$6$0 = t0$8[1];
          } else {
            ___match_error(temp$0$0);
          }t0$9 = ph$6$0;t1$5 = t0$9.length;if (t1$5 === 3 && t0$9[0] === "use") {
            env$0 = t0$9[1];x$1 = t0$9[2];return ["use", env$0, mac$0.call(info$3, __lt____lt____colon__$0(["data", x$1], e$1))];
          } else {
            x$2 = ph$6$0;return mac$0.call(info$3, __lt____lt____colon__$0(["data", x$2], x$2));
          }
        };return ["unconditional", ["macro", mac3$0]];
      } else {
        f$4 = function f(_ctx$0, _info$0, _form$0, _e$0) {
          return ["data", ["value", true], mac$0.call(_info$0, _e$0)];
        };return ["nostep", ["macro", f$4]];
      }
    } else {
      if ((x$3 = ph$4$0, x$3 instanceof Array && x$3[0] === "expr")) {
        return mac$0.call(info$2, e$1);
      } else {
        return ___match_error(ph$4$0, "#expr");
      }
    }
  };
};ctx_mac$0 = function ctx_mac(mac$1) {
  return function (ctx$0, info$4, f$5, e$2) {
    return mac$1.call(info$4, ctx$0, e$2);
  };
};_default_proj$0 = function _default_proj(name$0) {
  return function (x$4) {
    return ["send", ["symbol", "throw"], ["send", ["send", ["symbol", "E"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "project"]]]], ["data", ["send", ["symbol", "+"], ["data", ["send", ["symbol", "+"], ["data", ["value", "Cannot project a value with '"], ["value", name$0]]], ["value", "!'"]]]]]];
  };
};value_mac$0 = function value_mac() {
  var name$1 = undefined;var chk$0 = undefined;var proj$0 = undefined;var t0$10 = undefined;var m$1$0 = undefined;m$1$0 = arguments;t0$10 = m$1$0.length;if (t0$10 >= 2 && t0$10 <= 3) {
    name$1 = m$1$0[0];chk$0 = m$1$0[1];if (2 >= t0$10) {
      proj$0 = _default_proj$0(name$1);
    } else {
      proj$0 = m$1$0[2];
    }return function (temp$1$0, temp$2$0, form$2, arg$2) {
      var t0$11 = undefined;var x$5 = undefined;var m$2 = undefined;var x$7 = undefined;var m$4 = undefined;var x$9 = undefined;var m$6$0 = undefined;var ctx$2 = undefined;var ctx$1 = undefined;var ph$7$0 = undefined;t0$11 = temp$1$0;ctx$1 = t0$11;ph$7$0 = t0$11;if ((x$5 = ph$7$0, x$5 instanceof Array && x$5[0] === "check")) {
        m$2 = function m() {
          var x$6 = undefined;var $$426$0 = undefined;var $$427$0 = undefined;var t0$13 = undefined;var t1$6 = undefined;var ph$9$0 = undefined;var t0$12 = undefined;var m$3$0 = undefined;m$3$0 = arguments;t0$12 = m$3$0.length;if (t0$12 >= 1) {
            Array.prototype.slice.call(m$3$0, 0, -1);ph$9$0 = m$3$0[t0$12 - 1];t0$13 = ph$9$0;t1$6 = t0$13.length;if (t1$6 === 1 && t0$13[0] === "void") {
              return ["variable", name$1];
            } else {
              if (t1$6 === 2 && t0$13[0] === "data") {
                x$6 = t0$13[1];return chk$0(x$6);
              } else {
                return ___match_error(ph$9$0, "#data{x}");
              }
            }
          } else {
            return ___match_error(m$3$0, "{*, match}");
          }
        };return ["nostep", ["macro", m$2]];
      } else {
        if ((x$7 = ph$7$0, x$7 instanceof Array && x$7[0] === "project")) {
          m$4 = function m() {
            var x$8 = undefined;var $$480$0 = undefined;var $$481$0 = undefined;var t0$15 = undefined;var t1$7 = undefined;var ph$11$0 = undefined;var t0$14 = undefined;var m$5$0 = undefined;m$5$0 = arguments;t0$14 = m$5$0.length;if (t0$14 >= 1) {
              Array.prototype.slice.call(m$5$0, 0, -1);ph$11$0 = m$5$0[t0$14 - 1];t0$15 = ph$11$0;t1$7 = t0$15.length;if (t1$7 === 1 && t0$15[0] === "void") {
                return ["variable", name$1];
              } else {
                if (t1$7 === 2 && t0$15[0] === "data") {
                  x$8 = t0$15[1];return proj$0(x$8);
                } else {
                  return ___match_error(ph$11$0, "#data{x}");
                }
              }
            } else {
              return ___match_error(m$5$0, "{*, match}");
            }
          };return ["nostep", ["macro", m$4]];
        } else {
          ctx$2 = ph$7$0;m$6$0 = arg$2;if ((x$9 = m$6$0, x$9 instanceof Array && x$9[0] === "void")) {
            return ["variable", name$1];
          } else {
            return ["send", ["variable", name$1], arg$2];
          }
        }
      }
    };
  } else {
    return ___match_error(m$1$0, "{name, chk, proj = _default_proj{name}}");
  }
};overridable$0 = function overridable(f$6) {
  return function (temp$3$0, info$5, form$3, arg$3) {
    var t0$16 = undefined;var x$10 = undefined;var other$1 = undefined;var t0$17 = undefined;var t1$8 = undefined;var context$1 = undefined;var ph$12$0 = undefined;t0$16 = temp$3$0;context$1 = t0$16;ph$12$0 = t0$16;if ((x$10 = ph$12$0, x$10 instanceof Array && x$10[0] === "pattern")) {
      return ["nostep", form$3];
    } else {
      t0$17 = ph$12$0;t1$8 = t0$17.length;if (t1$8 === 2 && (t0$17[0] === "expr" && t0$17[1] === "multi")) {
        return ["nostep", form$3];
      } else {
        other$1 = ph$12$0;return f$6(context$1, info$5, form$3, arg$3);
      }
    }
  };
};protected_value$0 = function protected_value(name$2, value$0) {
  return function (ph$13$0, temp$4$0, form$4, arg$4) {
    var x$11 = undefined;var other$3 = undefined;var t0$18 = undefined;var m$7$0 = undefined;var other$2 = undefined;if ((x$11 = ph$13$0, x$11 instanceof Array && x$11[0] === "pattern")) {
      throw ErrorFactory(["syntax", "pattern"]).create("'" + name$2 + "' is not a valid pattern and cannot be redeclared");
    } else {
      other$2 = ph$13$0;m$7$0 = arg$4;if (Array.isArray(m$7$0) && (t0$18 = m$7$0.length, t0$18 === 1 && m$7$0[0] === "void")) {
        return ["value", value$0];
      } else {
        other$3 = m$7$0;return ["send", ["value", value$0], arg$4];
      }
    }
  };
};var_operator$0 = function var_operator(name$3) {
  return function (ph$14$0, temp$5$0, form$5, expr$0) {
    var t0$19 = undefined;var x$12 = undefined;var x$13 = undefined;var sym$0 = undefined;var x$14 = undefined;var t0$21 = undefined;var m$9$0 = undefined;var x$15 = undefined;var t0$24 = undefined;var t1$11 = undefined;var $targ$1 = undefined;var args$0 = undefined;var s$0 = undefined;var $$689$0 = undefined;var $$690$0 = undefined;var t0$23 = undefined;var t1$10 = undefined;var expr$1 = undefined;var ph$15$0 = undefined;var $$692$0 = undefined;var $$693$0 = undefined;var t0$22 = undefined;var t1$9 = undefined;var m$8$0 = undefined;var sym$1 = undefined;var bridge$$635$0 = undefined;var t0$20 = undefined;var env$1 = undefined;t0$19 = temp$5$0;if (___hasprop(t0$19, "env")) {
      env$1 = t0$19.env;
    } else {
      ___match_error(temp$5$0);
    }bridge$$635$0 = ph$14$0;if ((x$12 = bridge$$635$0, x$12 instanceof Array && x$12[0] === "check") || (x$13 = bridge$$635$0, x$13 instanceof Array && x$13[0] === "project")) {
      return ["nostep", form$5];
    } else {
      t0$20 = ph$14$0;if (___hasprop(t0$20, "fromop") && !t0$20.fromop) {
        sym$0 = __amp__(["symbol", name$3], { env: env$1 });return ["send", __lt____lt____colon__$0(sym$0, expr$0), expr$0];
      } else {
        sym$1 = __lt____lt____colon__$0(__amp__(["symbol", name$3], { env: env$1 }), (m$9$0 = form$5, Array.isArray(m$9$0) && (t0$21 = m$9$0.length, t0$21 === 3 && m$9$0[0] === "send") ? (x$14 = m$9$0[1], m$9$0[2], x$14) : form$5));m$8$0 = expr$0;if (($$692$0 = Array.isArray(m$8$0)) && (t0$22 = m$8$0.length, t0$22 === 1 && m$8$0[0] === "void")) {
          return sym$1;
        } else {
          if ($$692$0 && (t0$22 === 3 && (m$8$0[0] === "data" && (x$15 = m$8$0[1], x$15 instanceof Array && x$15[0] === "void")))) {
            t1$9 = m$8$0[2];expr$1 = t1$9;ph$15$0 = t1$9;t0$23 = ph$15$0;if (($$690$0 = ___hasprop(t0$23, "brackets")) && t0$23.brackets === "[]") {
              return ["send", sym$1, expr$1];
            } else {
              if ($$690$0 && t0$23.brackets === "()") {
                $targ$1 = getProjector(["multi"])(expr$1)[1];t0$24 = $targ$1;if (Array.isArray(t0$24) && (t1$11 = t0$24.length, t1$11 >= 1 && t0$24[0] === "multi")) {
                  args$0 = Array.prototype.slice.call(t0$24, 1);
                } else {
                  ___match_error($targ$1, "#multi{*args}");
                }return ["send", sym$1, ["data"].concat(args$0)];
              } else {
                if (Array.isArray(t0$23) && (t1$10 = t0$23.length, t1$10 === 2 && t0$23[0] === "symbol")) {
                  s$0 = t0$23[1];return ["send", sym$1, ["value", camelCase$0(s$0)]];
                } else {
                  return ["send", sym$1, expr$1];
                }
              }
            }
          } else {
            return ["send", sym$1, expr$0];
          }
        }
      }
    }
  };
};accum_flags$0 = function accum_flags() {
  var make$0 = undefined;var mac$2 = undefined;var also_values$0 = undefined;var t0$25 = undefined;var m$10$0 = undefined;m$10$0 = arguments;t0$25 = m$10$0.length;if (t0$25 >= 1 && t0$25 <= 2) {
    mac$2 = m$10$0[0];if (1 >= t0$25) {
      also_values$0 = true;
    } else {
      also_values$0 = m$10$0[1];
    }make$0 = function make(flags$0) {
      return function (context$2, info$6, form$6, ph$16$0) {
        var other$4 = undefined;var flag$1 = undefined;var flag$0 = undefined;var $$813$0 = undefined;var t0$26 = undefined;var t1$12 = undefined;var t2$2 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t9$0 = undefined;t0$26 = ph$16$0;if (Array.isArray(t0$26) && (t1$12 = t0$26.length, t1$12 === 2 && (t0$26[0] === "value" && (flag$0 = t0$26[1], also_values$0)))) {
          return ["macro", make$0(flags$0.concat([flag$0]))];
        } else {
          t1$12 = t0$26.length;if (t1$12 === 3 && (t0$26[0] === "send" && (t2$2 = t0$26[1], Array.isArray(t2$2) && (t3$1 = t2$2.length, t3$1 === 2 && (t2$2[0] === "symbol" && (t2$2[1] === "." && (t4$1 = t0$26[2], Array.isArray(t4$1) && (t5$0 = t4$1.length, t5$0 === 3 && (t4$1[0] === "data" && (t6$0 = t4$1[1], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 1 && (t6$0[0] === "void" && (t8$0 = t4$1[2], Array.isArray(t8$0) && (t9$0 = t8$0.length, t9$0 === 2 && t8$0[0] === "symbol")))))))))))))) {
            flag$1 = t8$0[1];return ["macro", make$0(flags$0.concat([flag$1]))];
          } else {
            other$4 = ph$16$0;return mac$2(context$2, info$6, form$6, other$4, flags$0);
          }
        }
      };
    };return make$0([]);
  } else {
    return ___match_error(m$10$0, "{mac, also_values = true}");
  }
};build_loop$0 = function build_loop(info$7, env$2, form$7, li$0, clauses$0, wrap$0, pre$0, post$0, opt$0) {
  var t0$27 = undefined;var t0$28 = undefined;var accum$0 = undefined;var lbl$0 = undefined;var freshenv$0 = undefined;var i$0 = undefined;var len$0 = undefined;var $targ$2 = undefined;var first_mac$0 = undefined;var $targ$3 = undefined;var last_mac$0 = undefined;var newscope$0 = undefined;var m$11 = undefined;if (env$2) {
    lbl$0 = __amp__(["value", info$7.gensym()], { env: env$2 });
  } else {
    lbl$0 = ["value", info$7.gensym()];
  }freshenv$0 = info$7.expander.mkenv();i$0 = __amp__(["symbol", "i"], { env: freshenv$0 });len$0 = __amp__(["symbol", "len"], { env: freshenv$0 });$targ$2 = function (temp$6$0, temp$7$0, form$8, subp$0) {
    var x$16 = undefined;if ((x$16 = temp$6$0, x$16 instanceof Array && x$16[0] === "pattern")) {} else {
      ___match_error(temp$6$0);
    }return ["test", ["send", ["symbol", "==="], ["data", i$0, ["value", 0]]], subp$0];
  };t0$27 = getProjector(drop_ctx$0)($targ$2);if (t0$27[0]) {
    first_mac$0 = t0$27[1];
  } else {
    ___match_error($targ$2, "drop_ctx! first_mac{#pattern, _, form, subp}");
  }$targ$3 = function (temp$8$0, temp$9$0, form$9, subp$1) {
    var x$17 = undefined;if ((x$17 = temp$8$0, x$17 instanceof Array && x$17[0] === "pattern")) {} else {
      ___match_error(temp$8$0);
    }return ["test", ["send", ["symbol", "==="], ["data", i$0, ["send", ["symbol", "-"], ["data", len$0, ["value", 1]]]]], subp$1];
  };t0$28 = getProjector(drop_ctx$0)($targ$3);if (t0$28[0]) {
    last_mac$0 = t0$28[1];
  } else {
    ___match_error($targ$3, "drop_ctx! last_mac{#pattern, _, form, subp}");
  }newscope$0 = Scope$0(info$7.scope);env$2.bind(newscope$0, "first", ["macro", first_mac$0]);env$2.bind(newscope$0, "last", ["macro", last_mac$0]);m$11 = __lt____lt____colon__$0(["symbol", "m"], form$7);if (opt$0.forof) {
    return ["multi", pre$0, ["send", ["send", ["symbol", "for"], lbl$0], ["data", ["send", ["symbol", "of"], ["data", m$11, li$0]], parse_clauses$0(info$7.with_scope(newscope$0), m$11, clauses$0, __amp__(opt$0, { wrap: wrap$0 }))]], post$0];
  } else {
    return ["multi", pre$0, ["send", ["symbol", "let"], ["data", ["multi", ["send", ["symbol", "="], ["data", ["symbol", "temp"], li$0]], ["send", ["symbol", "="], ["data", len$0, ["send", ["symbol", "temp"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "length"]]]]]]], ["send", ["send", ["symbol", "for"], lbl$0], ["data", ["multi", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], i$0], ["value", 0]]], ["send", ["symbol", "<"], ["data", i$0, len$0]], ["send", ["symbol", "++"], ["data", i$0, ["void"]]]], ["multi", ["send", ["symbol", "="], ["data", m$11, ["send", ["symbol", "___js_fetch"], ["data", ["symbol", "temp"], i$0]]]], parse_clauses$0(info$7.with_scope(newscope$0), m$11, clauses$0, __amp__(opt$0, (accum$0 = {}, accum$0.wrap = function wrap(x$18) {
      return wrap$0(x$18, i$0);
    }, accum$0)))]]]]], post$0];
  }
};partial_pattern$0 = function partial_pattern(operator$0) {
  var x$19 = undefined;var m$12$0 = undefined;var op$0 = undefined;m$12$0 = operator$0;if ((x$19 = m$12$0, x$19 instanceof Array && x$19[0] === "symbol")) {
    op$0 = operator$0;
  } else {
    if (typeof m$12$0 === "string") {
      op$0 = ["variable", operator$0];
    } else {
      op$0 = ___match_error(m$12$0, "String? ");
    }
  }return function (context$3, temp$10$0, form$10, expr$2) {
    var x$20 = undefined;var subp2$0 = undefined;var m$14 = undefined;var other$5 = undefined;var subp$2 = undefined;var val$0 = undefined;var $$1009$0 = undefined;var $$1010$0 = undefined;var $$1011$0 = undefined;var t0$29 = undefined;var t1$13 = undefined;var t2$3 = undefined;var m$13$0 = undefined;m$13$0 = [context$3, expr$2];if (($$1009$0 = Array.isArray(m$13$0)) && (t0$29 = m$13$0.length, ($$1011$0 = t0$29 === 2) && ((x$20 = m$13$0[0], x$20 instanceof Array && x$20[0] === "pattern") && (t1$13 = m$13$0[1], Array.isArray(t1$13) && (t2$3 = t1$13.length, t2$3 === 3 && t1$13[0] === "data"))))) {
      subp$2 = t1$13[1];val$0 = t1$13[2];if (equal(subp$2, ["void"])) {
        subp2$0 = ["ignore"];
      } else {
        subp2$0 = subp$2;
      }m$14 = mac1$0(function (x$21) {
        return ["send", op$0, ["data", x$21, val$0]];
      });return ["check", m$14, subp2$0];
    } else {
      if ($$1011$0 && (m$13$0[0], t1$13 = m$13$0[1], Array.isArray(t1$13) && (t2$3 = t1$13.length, t2$3 === 1 && t1$13[0] === "void"))) {
        return op$0;
      } else {
        other$5 = m$13$0;return ["send", op$0, expr$2];
      }
    }
  };
};make_assigner$0 = function make_assigner(op$1) {
  return function (context$4, temp$11$0, form$11, temp$12$0) {
    var t0$30 = undefined;var t1$14 = undefined;var a$0 = undefined;var b$0 = undefined;t0$30 = temp$12$0;if (Array.isArray(t0$30) && (t1$14 = t0$30.length, t1$14 === 3 && t0$30[0] === "data")) {
      a$0 = t0$30[1];b$0 = t0$30[2];
    } else {
      ___match_error(temp$12$0);
    }return ["assign", a$0, ["send", ["symbol", op$1], ["data", a$0, b$0]]];
  };
};disregard_specials$0 = function disregard_specials(temp$13$0, value$1) {
  var t0$31 = undefined;var t1$15 = undefined;var kind$0 = undefined;var expr$3 = undefined;t0$31 = temp$13$0;if (Array.isArray(t0$31) && (t1$15 = t0$31.length, t1$15 === 2 && t0$31[0] === "special")) {
    kind$0 = t0$31[1];expr$3 = t0$31;
  } else {
    ___match_error(temp$13$0);
  }throw ErrorFactory(["syntax", "pattern", "special"]).create("Special token cannot be used here", { special: expr$3 });
};pattern_handlers$0 = { declare_variables: __amp____colon__({ allow_nested: true, allow_arguments: true, special: disregard_specials$0 }, __amp____colon__((accum$1 = {}, accum$1.assign = function assign(temp$14$0, value$2) {
    var t0$32 = undefined;var v$1 = undefined;var name$4 = undefined;var t0$33 = undefined;var t1$16 = undefined;var v$0 = undefined;var ph$17$0 = undefined;t0$32 = temp$14$0;v$0 = t0$32;ph$17$0 = t0$32;t0$33 = ph$17$0;t1$16 = t0$33.length;if (t1$16 === 2 && t0$33[0] === "symbol") {
      name$4 = t0$33[1];return ["do", __lt____lt____colon__$0(["assign", v$0, __amp____colon__(value$2, { name: camelCase$0(name$4) })], v$0)];
    } else {
      v$1 = ph$17$0;return ["do", __lt____lt____colon__$0(["assign", v$1, value$2], v$1)];
    }
  }, accum$1), __amp____colon__({ tags: { declare_mode: "unqualified" } }, __amp____colon__((accum$2 = {}, accum$2.declare = function declare(temp$15$0, vars$0) {
    var m$15 = undefined;var acc$0 = undefined;var temp$16 = undefined;acc$0 = [];temp$16 = null;m$15 = null;$4: for (var _iterator = vars$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$15 = _step.value;
      var m$16$0 = undefined;var v$2 = undefined;v$2 = m$15;m$16$0 = v$2.declare_mode;if (m$16$0 === "set") {
        temp$16 = ["splice"];
      } else {
        if (m$16$0 === "let") {
          temp$16 = ["declare", __amp__(v$2, { mutable: false })];
        } else {
          if (m$16$0 === "var") {
            temp$16 = ["declare", __amp__(v$2, { mutable: true })];
          } else {
            if (m$16$0 === "unqualified") {
              temp$16 = ["declare", __amp__(v$2, { mutable: false, use_previous: true })];
            } else {
              temp$16 = ___match_error(m$16$0, ".unqualified");
            }
          }
        }
      }acc$0.push(temp$16);
    }return acc$0;
  }, accum$2), __amp____colon__((accum$3 = {}, accum$3.success = function success(temp$17$0) {
    return ["multi"];
  }, accum$3), __amp____colon__((accum$4 = {}, accum$4.failure = function failure(target$2, pattern$0) {
    return match_error$0(target$2, pattern$0);
  }, accum$4), { wrapOrder: 0 })))))), build_object: __amp____colon__({ strings_as_variables: true, allow_nested: true, allow_arguments: true, special: disregard_specials$0 }, __amp____colon__((accum$5 = {}, accum$5.assign = function assign(temp$18$0, value$3, temp$19$0) {
    var t0$34 = undefined;var name$5 = undefined;var t0$35 = undefined;var t1$17 = undefined;var t2$4 = undefined;var v$3 = undefined;var ph$18$0 = undefined;t0$34 = temp$18$0;v$3 = t0$34;ph$18$0 = t0$34;t0$35 = ph$18$0;t1$17 = t0$35.length;if (t1$17 === 2 && (t0$35[0] === "symbol" && (t2$4 = getProjector(camelCase$0)(t0$35[1]), t2$4[0]))) {
      name$5 = t2$4[1];return ["do", __lt____lt____colon__$0(["assign", ["send", ["symbol", "accum"], ["value", name$5]], value$3], v$3)];
    } else {
      return ["do", __lt____lt____colon__$0(["assign", ["send", ["symbol", "accum"], v$3], value$3], v$3)];
    }
  }, accum$5), __amp____colon__((accum$6 = {}, accum$6.declare = function declare(temp$20$0, vars$1) {
    return [["declare", ["symbol", "accum"], ["data", ["symbol", "="]]]];
  }, accum$6), __amp____colon__((accum$7 = {}, accum$7.success = function success(temp$21$0) {
    return ["symbol", "accum"];
  }, accum$7), __amp____colon__((accum$8 = {}, accum$8.failure = function failure(target$3, pattern$1) {
    return match_error$0(target$3, pattern$1);
  }, accum$8), { wrapOrder: 0 }))))) };named_statement_matcher$0 = function named_statement_matcher(name$6) {
  var t0$37 = undefined;var $targ$4 = undefined;var p$0 = undefined;var $targ$5 = undefined;$targ$4 = function (ph$19$0) {
    var t0$36 = undefined;var t1$18 = undefined;var t2$5 = undefined;var t3$2 = undefined;t0$36 = ph$19$0;t1$18 = t0$36.length;if (t1$18 === 3 && (t0$36[0] === "send" && (t2$5 = t0$36[1], Array.isArray(t2$5) && (t3$2 = t2$5.length, t3$2 === 2 && (t2$5[0] === "symbol" && t2$5[1] === name$6))))) {
      t0$36[2];return true;
    } else {
      return false;
    }
  };t0$37 = getProjector(predicate)($targ$4);if (t0$37[0]) {
    p$0 = t0$37[1];
  } else {
    ___match_error($targ$4, "predicate! p{match}");
  }$targ$5 = function () {
    return name$6;
  };p$0.toString = $targ$5;return p$0;
};grab_statements$0 = function grab_statements() {
  var stmt$0 = undefined;var rest$0 = undefined;var t0$40 = undefined;var t1$21 = undefined;var m$18$0 = undefined;var m$19 = undefined;var n$0 = undefined;var bridge$$1464$0 = undefined;var m$22$0 = undefined;var matches$0 = undefined;var rest$2 = undefined;var t0$43 = undefined;var t1$23 = undefined;var t0$44 = undefined;var t1$24 = undefined;var $targ$7 = undefined;var one$0 = undefined;var rest1$0 = undefined;var $targ$8 = undefined;var two$0 = undefined;var rest2$0 = undefined;var pattern$4 = undefined;var others$0 = undefined;var pattern$3 = undefined;var min$0 = undefined;var max$0 = undefined;var err$0 = undefined;var opts$0 = undefined;var pattern$2 = undefined;var $$1358$0 = undefined;var $$1359$0 = undefined;var t0$39 = undefined;var t1$20 = undefined;var descr$0 = undefined;var ph$21$0 = undefined;var all$0 = undefined;var transform$0 = undefined;var t0$38 = undefined;var t1$19 = undefined;var m$17$0 = undefined;m$17$0 = arguments;t0$38 = m$17$0.length;if (t0$38 >= 2 && t0$38 <= 3) {
    t1$19 = m$17$0[0];descr$0 = t1$19;ph$21$0 = t1$19;all$0 = m$17$0[1];if (2 >= t0$38) {
      transform$0 = function (x$22) {
        return x$22;
      };
    } else {
      transform$0 = m$17$0[2];
    }t0$39 = ph$21$0;if (typeof t0$39 === "function") {
      pattern$2 = t0$39;m$18$0 = all$0;if (Array.isArray(m$18$0) && (t0$40 = m$18$0.length, t0$40 >= 1 && (t1$21 = m$18$0[0], getChecker(pattern$2)(t1$21)))) {
        stmt$0 = t1$21;rest$0 = Array.prototype.slice.call(m$18$0, 1);return [transform$0(stmt$0), rest$0];
      } else {
        return [null, all$0];
      }
    } else {
      t1$20 = t0$39.length;if (t1$20 >= 1 && t0$39[0] === "any") {
        opts$0 = Array.prototype.slice.call(t0$39, 1);m$19 = null;$5: for (var _iterator = opts$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          m$19 = _step.value;
          var m$21 = undefined;var rest$1 = undefined;var $$1434$0 = undefined;var $$1435$0 = undefined;var $$1436$0 = undefined;var t0$41 = undefined;var m$20$0 = undefined;var opt$1 = undefined;opt$1 = m$19;m$20$0 = grab_statements$0(opt$1, all$0, transform$0);if (($$1434$0 = Array.isArray(m$20$0)) && (t0$41 = m$20$0.length, ($$1436$0 = t0$41 === 2) && m$20$0[0] === null)) {
            m$20$0[1];undefined;
          } else {
            if ($$1436$0) {
              m$21 = m$20$0[0];rest$1 = m$20$0[1];return [m$21, rest$1];
            } else {
              ___match_error(m$20$0, "{m, rest}");
            }
          }
        }return [null, all$0];
      } else {
        if (t1$20 >= 2 && t1$20 <= 5 && t0$39[0] === "multiple") {
          pattern$3 = t0$39[1];if (2 >= t1$20) {
            min$0 = 0;
          } else {
            min$0 = t0$39[2];
          }if (3 >= t1$20) {
            max$0 = Infinity;
          } else {
            max$0 = t0$39[3];
          }if (4 >= t1$20) {
            err$0 = true;
          } else {
            err$0 = t0$39[4];
          }matches$0 = [];rest$2 = all$0;$6: while (true) {
            var t0$42 = undefined;var t1$22 = undefined;var $targ$6 = undefined;var _matches$0 = undefined;$targ$6 = grab_statements$0(pattern$3, rest$2, transform$0);t0$42 = $targ$6;if (Array.isArray(t0$42) && (t1$22 = t0$42.length, t1$22 === 2)) {
              _matches$0 = t0$42[0];rest$2 = t0$42[1];
            } else {
              ___match_error($targ$6, "{_matches, rest}");
            }[_matches$0, rest$2];if (equal(_matches$0, null)) {
              break $6;
            }matches$0.push(_matches$0);if (equal(rest$2, [])) {
              break $6;
            }
          }m$22$0 = matches$0.length;n$0 = m$22$0;bridge$$1464$0 = m$22$0;if (bridge$$1464$0 < min$0 || bridge$$1464$0 > max$0) {
            if (err$0) {
              throw ErrorFactory(["syntax", "wrong_multiplicity"]).create(n$0 + " instances of the pattern '" + pattern$3 + "' were found." + " between " + min$0 + " and " + max$0 + " were expected.", { pattern: pattern$3, matches: matches$0 });
            }return [["multiple"], all$0];
          } else {
            return [["multiple"].concat(matches$0), rest$2];
          }
        } else {
          if (t1$20 === 1 && t0$39[0] === "seq") {
            return [["seq"], all$0];
          } else {
            if (t1$20 >= 2 && t0$39[0] === "seq") {
              pattern$4 = t0$39[1];others$0 = Array.prototype.slice.call(t0$39, 2);$targ$7 = grab_statements$0(pattern$4, all$0, transform$0);t0$43 = $targ$7;if (Array.isArray(t0$43) && (t1$23 = t0$43.length, t1$23 === 2)) {
                one$0 = t0$43[0];rest1$0 = t0$43[1];
              } else {
                ___match_error($targ$7, "{one, rest1}");
              }[one$0, rest1$0];if (one$0 === null) {
                return [null, all$0];
              }$targ$8 = grab_statements$0(["seq"].concat(others$0), rest1$0, transform$0);t0$44 = $targ$8;if (Array.isArray(t0$44) && (t1$24 = t0$44.length, t1$24 === 2)) {
                two$0 = t0$44[0];rest2$0 = t0$44[1];
              } else {
                ___match_error($targ$8, "{two, rest2}");
              }[two$0, rest2$0];if (two$0 === null) {
                return [null, all$0];
              }return [["seq", one$0].concat(two$0.slice(1)), rest2$0];
            } else {
              throw ErrorFactory(["unknown_pattern"]).create(descr$0);
            }
          }
        }
      }
    }
  } else {
    return ___match_error(m$17$0, "{match descr, all, transform = {x} -> x}");
  }
};flatmacro$0 = function flatmacro(pattern$5, assemble$0) {
  return ["restmacro", function (stmts$0) {
    var t0$45 = undefined;var t1$25 = undefined;var $targ$9 = undefined;var result$0 = undefined;var rest$3 = undefined;$targ$9 = grab_statements$0(pattern$5, stmts$0);t0$45 = $targ$9;if (Array.isArray(t0$45) && (t1$25 = t0$45.length, t1$25 === 2)) {
      result$0 = t0$45[0];rest$3 = t0$45[1];
    } else {
      ___match_error($targ$9, "{result, rest}");
    }[result$0, rest$3];return [assemble$0(result$0)].concat(rest$3);
  }];
};AssignmentHandler$0 = function AssignmentHandler(temp$22$0, temp$23$0) {
  var $targ$10 = undefined;var $it$0 = undefined;if (!getChecker(AssignmentHandler$0)(this)) {
    $it$0 = Object.create(AssignmentHandler$0.prototype);
  } else {
    $it$0 = this;
  }$it$0.subp = temp$22$0;$it$0.wrapPlaceholder = temp$23$0;$targ$10 = 1;$it$0.wrapAssignmentOrder = $targ$10;return $it$0;
};AssignmentHandler$0.prototype.expand = function expand(info$8) {
  var $targ$11 = undefined;var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;$targ$11 = info$8.env.mark(["symbol", info$8.gensym("$get")]);$it$1.placeholder = $targ$11;if ($it$1.subp) {
    return ["all", $it$1.subp, $it$1.placeholder];
  } else {
    return $it$1.placeholder;
  }
};AssignmentHandler$0.prototype.wrapAssignment = function wrapAssignment(expr$4, info$9, opt$2) {
  var $it$2 = undefined;var self$1 = undefined;$it$2 = this;self$1 = this;return ["splice", expr$4, $it$2.wrapPlaceholder($it$2.placeholder)];
};__amp____colon__(AssignmentHandler$0, __amp____colon__(($targ$12 = "AssignmentHandler", accum$9 = {}, accum$9["::name"] = $targ$12, accum$9), ($targ$13 = true, accum$10 = {}, accum$10["::egclass"] = $targ$13, accum$10)));qqstruct$0 = function qqstruct(name$7, args$1) {
  return ["data", ["value", name$7]].concat(args$1);
};qq$0 = function qq() {
  var m$24 = undefined;var acc$1 = undefined;var temp$24 = undefined;var m$25 = undefined;var acc$2 = undefined;var temp$25 = undefined;var m$26 = undefined;var acc$3 = undefined;var temp$26 = undefined;var res$0 = undefined;var name$8 = undefined;var args$3 = undefined;var ops$0 = undefined;var args$2 = undefined;var insert$2 = undefined;var insert$1 = undefined;var insert$0 = undefined;var v$4 = undefined;var s$2 = undefined;var s$1 = undefined;var $$1659$0 = undefined;var $$1660$0 = undefined;var $$1661$0 = undefined;var $$1662$0 = undefined;var $$1663$0 = undefined;var $$1664$0 = undefined;var $$1665$0 = undefined;var $$1666$0 = undefined;var $$1667$0 = undefined;var t0$47 = undefined;var t1$27 = undefined;var t2$6 = undefined;var t3$3 = undefined;var t4$2 = undefined;var t5$1 = undefined;var t6$1 = undefined;var t7$1 = undefined;var expr$5 = undefined;var ph$23$0 = undefined;var annotate$0 = undefined;var t0$46 = undefined;var t1$26 = undefined;var m$23$0 = undefined;m$23$0 = arguments;t0$46 = m$23$0.length;if (t0$46 >= 1 && t0$46 <= 2) {
    t1$26 = m$23$0[0];expr$5 = t1$26;ph$23$0 = t1$26;if (1 >= t0$46) {
      annotate$0 = false;
    } else {
      annotate$0 = m$23$0[1];
    }t0$47 = ph$23$0;t1$27 = t0$47.length;if (($$1661$0 = t1$27 === 2) && t0$47[0] === "symbol") {
      s$1 = t0$47[1];return qqstruct$0("symbol", [["value", s$1]]);
    } else {
      if ($$1661$0 && t0$47[0] === "char") {
        s$2 = t0$47[1];return qqstruct$0("char", [["value", s$2]]);
      } else {
        if (t1$27 === 1 && t0$47[0] === "void") {
          return qqstruct$0("void", []);
        } else {
          if (t1$27 === 2 && t0$47[0] === "value") {
            v$4 = t0$47[1];return qqstruct$0("value", [expr$5]);
          } else {
            if (($$1661$0 = t1$27 === 3) && (($$1662$0 = t0$47[0] === "send") && (t2$6 = t0$47[1], ($$1664$0 = Array.isArray(t2$6)) && (t3$3 = t2$6.length, ($$1666$0 = t3$3 === 2) && (($$1667$0 = t2$6[0] === "symbol") && (t2$6[1] === "^" && (t4$2 = t0$47[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 === 3 && (t4$2[0] === "data" && (t6$1 = t4$2[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && t6$1[0] === "void"))))))))))) {
              insert$0 = t4$2[2];return insert$0;
            } else {
              if ($$1667$0 && (t2$6[1] === "^=" && (t4$2 = t0$47[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 === 3 && (t4$2[0] === "data" && (t6$1 = t4$2[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && t6$1[0] === "void"))))))) {
                insert$1 = t4$2[2];return qqstruct$0("value", [insert$1]);
              } else {
                if ($$1667$0 && (t2$6[1] === "^*" && (t4$2 = t0$47[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 === 3 && (t4$2[0] === "data" && (t6$1 = t4$2[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && t6$1[0] === "void"))))))) {
                  insert$2 = t4$2[2];return ["send", ["symbol", "*"], ["data", ["void"], insert$2]];
                } else {
                  if (t1$27 >= 2 && t0$47[0] === "mismix") {
                    ops$0 = t0$47[1];args$2 = Array.prototype.slice.call(t0$47, 2);return qqstruct$0("mismix", [["data"].concat((acc$1 = [], temp$24 = null, m$24 = null, (function () {
                      $7: for (var _iterator = ops$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                        m$24 = _step.value;
                        var op$2 = undefined;op$2 = m$24;temp$24 = qq$0(op$2, annotate$0);acc$1.push(temp$24);
                      }
                    })(), acc$1))].concat((acc$2 = [], temp$25 = null, m$25 = null, (function () {
                      $8: for (var _iterator = args$2[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                        m$25 = _step.value;
                        var arg$5 = undefined;arg$5 = m$25;temp$25 = qq$0(arg$5, annotate$0);acc$2.push(temp$25);
                      }
                    })(), acc$2)));
                  } else {
                    if (t1$27 >= 1) {
                      name$8 = t0$47[0];args$3 = Array.prototype.slice.call(t0$47, 1);res$0 = qqstruct$0(name$8, (acc$3 = [], temp$26 = null, m$26 = null, (function () {
                        $9: for (var _iterator = args$3[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                          m$26 = _step.value;
                          var arg$6 = undefined;arg$6 = m$26;temp$26 = qq$0(arg$6, annotate$0);acc$3.push(temp$26);
                        }
                      })(), acc$3));if (annotate$0 && expr$5.fromop) {
                        return ["send", ["symbol", "&"], ["data", res$0, ["data", ["send", ["symbol", "="], ["data", ["symbol", "fromop"], ["symbol", "true"]]]]]];
                      } else {
                        return res$0;
                      }
                    } else {
                      return ___match_error(ph$23$0, "{name, *args}");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    return ___match_error(m$23$0, "{match expr, annotate = false}");
  }
};multimacro$0 = function multimacro(cases$0) {
  return function (temp$27$0, info$10, form$12, temp$28$0) {
    var t0$48 = undefined;var t0$49 = undefined;var x$24 = undefined;var x$25 = undefined;var x$26 = undefined;var x$27 = undefined;var ph$26$0 = undefined;var ph$25$0 = undefined;var fallbacks$0 = undefined;var ex$0 = undefined;var projector$0 = undefined;var $$1891$0 = undefined;var $$1892$0 = undefined;var $$1893$0 = undefined;var t0$50 = undefined;var t1$28 = undefined;var context$5 = undefined;var ph$24$0 = undefined;var expr$6 = undefined;var topexpr$0 = undefined;t0$48 = temp$27$0;context$5 = t0$48;ph$24$0 = t0$48;t0$49 = temp$28$0;expr$6 = t0$49;topexpr$0 = t0$49;fallbacks$0 = { check: null, clause: null, decorate: "project", expr: null, project: "expr" };ex$0 = function ex() {
      var case$1 = undefined;var info$11 = undefined;var expr$7 = undefined;var orig$0 = undefined;var t0$51 = undefined;var m$27$0 = undefined;m$27$0 = arguments;t0$51 = m$27$0.length;if (t0$51 >= 3 && t0$51 <= 4) {
        case$1 = m$27$0[0];info$11 = m$27$0[1];expr$7 = m$27$0[2];if (3 >= t0$51) {
          orig$0 = case$1;
        } else {
          orig$0 = m$27$0[3];
        }if (send(cases$0, case$1)) {
          return send(cases$0, case$1).call(info$11, expr$7);
        } else {
          if (send(fallbacks$0, case$1)) {
            return ex$0(send(fallbacks$0, case$1), info$11, expr$7, orig$0);
          } else {
            throw send(send(ErrorFactory(["syntax", "nomacro"]), "create", true), __amp____colon__([ENode([], {}, ["No macro for context: '", orig$0, "'"]).toString()], { expr: topexpr$0, "::objinsert": 1 }));
          }
        }
      } else {
        return ___match_error(m$27$0, "{case, info, expr, orig = case}");
      }
    };projector$0 = function projector(case$2) {
      var mac$3 = undefined;mac$3 = function mac(ctx$3, info$12, form$13, temp$29$0) {
        var t0$52 = undefined;var t1$29 = undefined;var t2$7 = undefined;var env$3 = undefined;var x$23 = undefined;var t0$53 = undefined;var t1$30 = undefined;var e$3 = undefined;var ph$27$0 = undefined;t0$52 = temp$29$0;if (Array.isArray(t0$52) && (t1$29 = t0$52.length, t1$29 === 2 && t0$52[0] === "data")) {
          t2$7 = t0$52[1];e$3 = t2$7;ph$27$0 = t2$7;
        } else {
          ___match_error(temp$29$0);
        }t0$53 = ph$27$0;t1$30 = t0$53.length;if (t1$30 === 3 && t0$53[0] === "use") {
          env$3 = t0$53[1];x$23 = t0$53[2];return ["use", env$3, ex$0(case$2, info$12, x$23)];
        } else {
          return ex$0(case$2, info$12, e$3);
        }
      };return ["macro", mac$3];
    };if ((x$24 = ph$24$0, x$24 instanceof Array && x$24[0] === "clause")) {
      return ex$0("clause", info$10, expr$6);
    } else {
      if ((x$25 = ph$24$0, x$25 instanceof Array && x$25[0] === "pattern")) {
        if (cases$0.pattern) {
          return ex$0("pattern", info$10, expr$6);
        } else {
          return ["project", projector$0("decorate"), expr$6, true];
        }
      } else {
        t0$50 = ph$24$0;t1$28 = t0$50.length;if (($$1893$0 = t1$28 === 2) && t0$50[0] === "check") {
          ph$25$0 = t0$50[1];if ((x$26 = ph$25$0, x$26 instanceof Array && x$26[0] === "pattern")) {
            return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "x"]], ["send", projector$0("check"), ["data", ["symbol", "x"]]]]];
          } else {
            return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "x"]], ["send", projector$0("check"), ["data", ["symbol", "x"]]]]];
          }
        } else {
          if ($$1893$0 && t0$50[0] === "project") {
            ph$26$0 = t0$50[1];if ((x$27 = ph$26$0, x$27 instanceof Array && x$27[0] === "pattern")) {
              return ["unconditional", projector$0("project")];
            } else {
              return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "x"]], ["data", ["symbol", "true"], ["send", projector$0("project"), ["data", ["symbol", "x"]]]]]];
            }
          } else {
            return ex$0("expr", info$10, expr$6);
          }
        }
      }
    }
  };
};inject__minus__tools$0 = function injectTools(info$13) {
  var accum$11 = undefined;return __amp____colon__(info$13, __amp____colon__({ PatternCompiler: PatternCompiler$0, pattern_handlers: pattern_handlers$0, camelCase: camelCase$0 }, __amp____colon__((accum$11 = {}, accum$11.multimacro = function multimacro(cases$1) {
    return multimacro$0(cases$1)(info$13.context, info$13, info$13.form, info$13.arg);
  }, accum$11), { transfer: __lt____lt____colon__$0 })));
};$targ$14 = embed_location$0;exports.embed_location = $targ$14;$targ$15 = error_embed_location$0;exports.error_embed_location = $targ$15;$targ$16 = match_error$0;exports.match_error = $targ$16;$targ$17 = drop_ctx$0;exports.drop_ctx = $targ$17;$targ$18 = expr_mac$0;exports.expr_mac = $targ$18;$targ$19 = expr_mac2$0;exports.expr_mac2 = $targ$19;$targ$20 = ctx_mac$0;exports.ctx_mac = $targ$20;$targ$21 = value_mac$0;exports.value_mac = $targ$21;$targ$22 = overridable$0;exports.overridable = $targ$22;$targ$23 = protected_value$0;exports.protected_value = $targ$23;$targ$24 = var_operator$0;exports.var_operator = $targ$24;$targ$25 = accum_flags$0;exports.accum_flags = $targ$25;$targ$26 = build_loop$0;exports.build_loop = $targ$26;$targ$27 = partial_pattern$0;exports.partial_pattern = $targ$27;$targ$28 = make_assigner$0;exports.make_assigner = $targ$28;$targ$29 = pattern_handlers$0;exports.pattern_handlers = $targ$29;$targ$30 = Body$0;exports.Body = $targ$30;$targ$31 = named_statement_matcher$0;exports.named_statement_matcher = $targ$31;$targ$32 = grab_statements$0;exports.grab_statements = $targ$32;$targ$33 = flatmacro$0;exports.flatmacro = $targ$33;$targ$34 = AssignmentHandler$0;exports.AssignmentHandler = $targ$34;$targ$35 = qq$0;exports.qq = $targ$35;$targ$36 = multimacro$0;exports.multimacro = $targ$36;$targ$37 = inject__minus__tools$0;exports.injectTools = $targ$37;void 0;
//# sourceMappingURL=helpers.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../expand":104,"../location":106,"../pattern":121,"../util":126,"earlgrey-runtime/5":446}],111:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var $1$0 = undefined;var accum_flags$0 = undefined;var match_error$0 = undefined;var Body$0 = undefined;var named_statement_matcher$0 = undefined;var flatmacro$0 = undefined;var $2$0 = undefined;var parse_clauses$0 = undefined;var util$0 = undefined;$0$0 = require("../location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "../location");$1$0 = require("./helpers");accum_flags$0 = getProperty($1$0, "accum_flags", "./helpers");match_error$0 = getProperty($1$0, "match_error", "./helpers");Body$0 = getProperty($1$0, "Body", "./helpers");named_statement_matcher$0 = getProperty($1$0, "named_statement_matcher", "./helpers");flatmacro$0 = getProperty($1$0, "flatmacro", "./helpers");$2$0 = require("../pattern");parse_clauses$0 = getProperty($2$0, "parse_clauses", "../pattern");util$0 = require("../util");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var $targ$13 = undefined;var accum$0 = undefined;var $targ$14 = undefined;var accum$1 = undefined;var t0$3 = undefined;var t1$2 = undefined;var _elif$0 = undefined;var _else$0 = undefined;var t0$10 = undefined;var t0$11 = undefined;var t0$13 = undefined;var t0$15 = undefined;var t0$17 = undefined;var t0$20 = undefined;var t0$24 = undefined;var t0$28 = undefined;var MatchHandler$0 = undefined;var $targ$2 = undefined;var match_mac$0 = undefined;var if_pattern$0 = undefined;var $targ$3 = undefined;var if_mac$0 = undefined;var $targ$4 = undefined;var else_mac$0 = undefined;var $targ$5 = undefined;var not_mac$0 = undefined;var $targ$6 = undefined;var and_mac$0 = undefined;var $targ$7 = undefined;var or_mac$0 = undefined;var $targ$8 = undefined;var when_mac$0 = undefined;var $targ$9 = undefined;var check_mac$0 = undefined;var $targ$10 = undefined;var project_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};MatchHandler$0 = function MatchHandler() {
    var $targ$11 = undefined;var __at___$0 = undefined;if (!getChecker(MatchHandler$0)(this)) {
      __at___$0 = Object.create(MatchHandler$0.prototype);
    } else {
      __at___$0 = this;
    }$targ$11 = 1;__at___$0.wrapOrder = $targ$11;return __at___$0;
  };MatchHandler$0.prototype.expand = function expand(info$0) {
    var $targ$12 = undefined;var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;$targ$12 = info$0.env.mark(["symbol", info$0.gensym("ph")]);__at___$1.placeholder = $targ$12;return __lt____lt____colon__$0(__at___$1.placeholder, __at___$1.location);
  };MatchHandler$0.prototype.wrap = function wrap(expr$0, info$1, opt$0) {
    var __at___$2 = undefined;var self$1 = undefined;__at___$2 = this;self$1 = this;return parse_clauses$0(info$1, __at___$2.placeholder, Body$0(expr$0), __amp__(opt$0, { wrap: null }));
  };__amp____colon__(MatchHandler$0, __amp____colon__(($targ$13 = "MatchHandler", accum$0 = {}, accum$0["::name"] = $targ$13, accum$0), ($targ$14 = true, accum$1 = {}, accum$1["::egclass"] = $targ$14, accum$1)));$targ$2 = function (ph$0$0, info$2, form$0, expr$1, flags$0) {
    var x$0 = undefined;var other$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;var v$0 = undefined;var b$1 = undefined;var b$0 = undefined;var $$11362$0 = undefined;var $$11363$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var m$1$0 = undefined;var t0$2 = undefined;var t1$1 = undefined;var accum$2 = undefined;var mbody$0 = undefined;var opt$1 = undefined;var to_match$0 = undefined;var $targ$15 = undefined;var value$0 = undefined;var body$0 = undefined;var other$1 = undefined;if ((x$0 = ph$0$0, x$0 instanceof Array && x$0[0] === "pattern")) {
      m$0$0 = expr$1;if (Array.isArray(m$0$0) && (t0$0 = m$0$0.length, t0$0 === 1 && m$0$0[0] === "void")) {
        return __lt____lt____colon__$0(["special", __lt____lt____colon__$0(MatchHandler$0(), form$0)], form$0);
      } else {
        other$0 = m$0$0;return ["all", __lt____lt____colon__$0(other$0, expr$1), __lt____lt____colon__$0(["special", __lt____lt____colon__$0(MatchHandler$0(), form$0)], form$0)];
      }
    } else {
      other$1 = ph$0$0;opt$1 = util$0.mkset(flags$0);to_match$0 = __amp__(["symbol", info$2.gensym("m")], { single_assignment: true });m$1$0 = expr$1;if (($$11362$0 = Array.isArray(m$1$0)) && (t0$1 = m$1$0.length, t0$1 === 2 && (m$1$0[0] === "data" && (t1$0 = getProjector(Body$0)(m$1$0[1]), t1$0[0] && (t2$0 = t1$0[1], t3$0 = t2$0.length, t3$0 >= 0))))) {
        b$0 = Array.prototype.slice.call(t2$0, 0);$targ$15 = [["value", null], b$0];
      } else {
        if ($$11362$0 && (t0$1 === 3 && (m$1$0[0] === "data" && (v$0 = m$1$0[1], t1$0 = getProjector(Body$0)(m$1$0[2]), t1$0[0] && (t2$0 = t1$0[1], t3$0 = t2$0.length, t3$0 >= 0))))) {
          b$1 = Array.prototype.slice.call(t2$0, 0);$targ$15 = [v$0, b$1];
        } else {
          $targ$15 = ___match_error(m$1$0, "#data{v, Body! {*b}}");
        }
      }t0$2 = $targ$15;if (Array.isArray(t0$2) && (t1$1 = t0$2.length, t1$1 === 2)) {
        value$0 = t0$2[0];body$0 = t0$2[1];
      } else {
        ___match_error($targ$15, "{value, body}");
      }[value$0, body$0];__lt____lt____colon__$0(to_match$0, value$0);mbody$0 = parse_clauses$0(info$2, to_match$0, body$0, __amp__(opt$1, __amp____colon__((accum$2 = {}, accum$2.fallback = function fallback(target$0, pattern$0) {
        return match_error$0(target$0, pattern$0);
      }, accum$2), { wrap: null })));return ["send", ["symbol", "let"], ["data", ["send", ["symbol", "="], ["data", to_match$0, value$0]], mbody$0]];
    }
  };t0$3 = getProjector(accum_flags$0)($targ$2);if (t0$3[0] && (t1$2 = getProjector(mac$0("match"))(t0$3[1]), t1$2[0])) {
    match_mac$0 = t1$2[1];
  } else {
    ___match_error($targ$2, "accum_flags! mac{\"match\"}! match_mac{match, info, form, expr, flags}");
  }_elif$0 = named_statement_matcher$0("elif");_else$0 = named_statement_matcher$0("else");if_pattern$0 = ["seq", ["multiple", _elif$0], ["multiple", _else$0, 0, 1]];$targ$3 = function (ctx$0, temp$0$0, form$1, ph$1$0) {
    var t0$6 = undefined;var m$2$0 = undefined;var body$1 = undefined;var a$2 = undefined;var b$3 = undefined;var a$1 = undefined;var $$11471$0 = undefined;var $$11472$0 = undefined;var t0$5 = undefined;var t1$4 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$1 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t9$0 = undefined;var t10$0 = undefined;var t11$0 = undefined;var t12$0 = undefined;var t13$0 = undefined;var test$1 = undefined;var ph$2$0 = undefined;var test$0 = undefined;var a$0 = undefined;var b$2 = undefined;var $$11473$0 = undefined;var $$11474$0 = undefined;var t0$4 = undefined;var t1$3 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$0 = undefined;t0$4 = ph$1$0;t1$3 = t0$4.length;if (t1$3 === 4 && t0$4[0] === "data") {
      test$0 = t0$4[1];a$0 = t0$4[2];b$2 = t0$4[3];return ["if", test$0, a$0, b$2];
    } else {
      if (t1$3 === 3 && (t0$4[0] === "data" && (test$1 = t0$4[1], t2$1 = getProjector(["multi"])(t0$4[2]), t2$1[0] && (t3$1 = t2$1[1], t4$0 = t3$1.length, t4$0 >= 1 && t3$1[0] === "multi")))) {
        ph$2$0 = Array.prototype.slice.call(t3$1, 1);t0$5 = ph$2$0;t1$4 = t0$5.length;if (t1$4 === 1 && (t2$2 = t0$5[0], Array.isArray(t2$2) && (t3$2 = t2$2.length, t3$2 === 3 && (t2$2[0] === "send" && (t4$1 = t2$2[1], Array.isArray(t4$1) && (t5$0 = t4$1.length, t5$0 === 2 && (t4$1[0] === "symbol" && (t4$1[1] === "then" && (t6$0 = t2$2[2], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 2 && t6$0[0] === "data")))))))))) {
          a$1 = t6$0[1];return ["if", test$1, a$1, ["value", undefined]];
        } else {
          if (t1$4 === 2 && (t2$2 = t0$5[0], Array.isArray(t2$2) && (t3$2 = t2$2.length, t3$2 === 3 && (t2$2[0] === "send" && (t4$1 = t2$2[1], Array.isArray(t4$1) && (t5$0 = t4$1.length, t5$0 === 2 && (t4$1[0] === "symbol" && (t4$1[1] === "then" && (t6$0 = t2$2[2], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 2 && (t6$0[0] === "data" && (a$2 = t6$0[1], t8$0 = t0$5[1], Array.isArray(t8$0) && (t9$0 = t8$0.length, t9$0 === 3 && (t8$0[0] === "send" && (t10$0 = t8$0[1], Array.isArray(t10$0) && (t11$0 = t10$0.length, t11$0 === 2 && (t10$0[0] === "symbol" && (t10$0[1] === "else" && (t12$0 = t8$0[2], Array.isArray(t12$0) && (t13$0 = t12$0.length, t13$0 === 2 && t12$0[0] === "data")))))))))))))))))))) {
            b$3 = t12$0[1];return ["if", test$1, a$2, b$3];
          } else {
            body$1 = ph$2$0;m$2$0 = ctx$0;if (Array.isArray(m$2$0) && (t0$6 = m$2$0.length, t0$6 === 2 && (m$2$0[0] === "expr" && m$2$0[1] === "multi"))) {
              return flatmacro$0(if_pattern$0, function (temp$1$0) {
                var t0$7 = undefined;var t1$5 = undefined;var t2$3 = undefined;var t3$3 = undefined;var t4$2 = undefined;var t5$1 = undefined;var m$3 = undefined;var m$4 = undefined;var rval$0 = undefined;var elifs$0 = undefined;var elses$0 = undefined;t0$7 = temp$1$0;if (Array.isArray(t0$7) && (t1$5 = t0$7.length, t1$5 === 3 && (t0$7[0] === "seq" && (t2$3 = t0$7[1], Array.isArray(t2$3) && (t3$3 = t2$3.length, t3$3 >= 1 && (t2$3[0] === "multiple" && (elifs$0 = Array.prototype.slice.call(t2$3, 1), t4$2 = t0$7[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 >= 1 && t4$2[0] === "multiple")))))))) {
                  elses$0 = Array.prototype.slice.call(t4$2, 1);
                } else {
                  ___match_error(temp$1$0);
                }rval$0 = ["value", undefined];m$3 = null;$4: for (var _iterator = elses$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                  m$3 = _step.value;
                  var body$2 = undefined;var t0$8 = undefined;var t1$6 = undefined;var t2$4 = undefined;var t3$4 = undefined;var t4$3 = undefined;var t5$2 = undefined;t0$8 = m$3;if (Array.isArray(t0$8) && (t1$6 = t0$8.length, t1$6 === 3 && (t0$8[0] === "send" && (t2$4 = t0$8[1], Array.isArray(t2$4) && (t3$4 = t2$4.length, t3$4 === 2 && (t2$4[0] === "symbol" && (t2$4[1] === "else" && (t4$3 = t0$8[2], Array.isArray(t4$3) && (t5$2 = t4$3.length, t5$2 === 2 && t4$3[0] === "data"))))))))) {
                    body$2 = t4$3[1];rval$0 = body$2;rval$0;
                  } else {
                    ___match_error(m$3);
                  }
                }m$4 = null;$5: for (var _iterator2 = elifs$0.reverse()[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                  m$4 = _step2.value;
                  var cond$0 = undefined;var body$3 = undefined;var t0$9 = undefined;var t1$7 = undefined;var t2$5 = undefined;var t3$5 = undefined;var t4$4 = undefined;var t5$3 = undefined;t0$9 = m$4;if (Array.isArray(t0$9) && (t1$7 = t0$9.length, t1$7 === 3 && (t0$9[0] === "send" && (t2$5 = t0$9[1], Array.isArray(t2$5) && (t3$5 = t2$5.length, t3$5 === 2 && (t2$5[0] === "symbol" && (t2$5[1] === "elif" && (t4$4 = t0$9[2], Array.isArray(t4$4) && (t5$3 = t4$4.length, t5$3 === 3 && t4$4[0] === "data"))))))))) {
                    cond$0 = t4$4[1];body$3 = t4$4[2];rval$0 = ["if", cond$0, body$3, rval$0];rval$0;
                  } else {
                    ___match_error(m$4);
                  }
                }return ["if", test$1, ["multi"].concat(body$1), rval$0];
              });
            } else {
              return ["if", test$1, ["multi"].concat(body$1), ["value", undefined]];
            }
          }
        }
      } else {
        return ___match_error(ph$1$0, "#data{test, #multi! #multi{*match}}");
      }
    }
  };t0$10 = getProjector(mac$0("if"))($targ$3);if (t0$10[0]) {
    if_mac$0 = t0$10[1];
  } else {
    ___match_error($targ$3, "mac{\"if\"}! if_mac{ctx, _, form, match}");
  }$targ$4 = function (ph$3$0, temp$2$0, form$2, temp$3$0) {
    var x$1 = undefined;var msg$0 = undefined;if ((x$1 = ph$3$0, x$1 instanceof Array && x$1[0] === "pattern")) {
      return ["ignore"];
    } else {
      msg$0 = "'else' should be found inside an 'if' block";throw ErrorFactory(["syntax", "else"]).create(msg$0, { node: form$2 });
    }
  };t0$11 = getProjector(mac$0("else"))($targ$4);if (t0$11[0]) {
    else_mac$0 = t0$11[1];
  } else {
    ___match_error($targ$4, "mac{\"else\"}! else_mac{match, _, form, _}");
  }$targ$5 = function (ph$4$0, temp$4$0, form$3, temp$5$0) {
    var t0$12 = undefined;var t1$8 = undefined;var t2$6 = undefined;var t3$6 = undefined;var x$2 = undefined;var x$3 = undefined;var x$4 = undefined;var other$2 = undefined;var bridge$$11822$0 = undefined;var rhs$0 = undefined;var arg$0 = undefined;t0$12 = temp$5$0;if (Array.isArray(t0$12) && (t1$8 = t0$12.length, t1$8 === 3 && (t0$12[0] === "data" && (t2$6 = t0$12[1], Array.isArray(t2$6) && (t3$6 = t2$6.length, t3$6 === 1 && t2$6[0] === "void"))))) {
      rhs$0 = t0$12[2];arg$0 = t0$12;
    } else {
      ___match_error(temp$5$0);
    }bridge$$11822$0 = ph$4$0;if ((x$2 = bridge$$11822$0, x$2 instanceof Array && x$2[0] === "check") || (x$3 = bridge$$11822$0, x$3 instanceof Array && x$3[0] === "project")) {
      return ["nostep", form$3];
    } else {
      if ((x$4 = ph$4$0, x$4 instanceof Array && x$4[0] === "pattern")) {
        return ["neg", rhs$0];
      } else {
        other$2 = ph$4$0;return ["send", ["variable", "not"], arg$0];
      }
    }
  };t0$13 = getProjector(mac$0("not"))($targ$5);if (t0$13[0]) {
    not_mac$0 = t0$13[1];
  } else {
    ___match_error($targ$5, "mac{\"not\"}! not_mac{match, _, form, #data{#void{}, rhs} and arg}");
  }$targ$6 = function (ph$5$0, temp$6$0, form$4, temp$7$0) {
    var t0$14 = undefined;var t1$9 = undefined;var x$5 = undefined;var x$6 = undefined;var x$7 = undefined;var other$3 = undefined;var bridge$$11892$0 = undefined;var lhs$0 = undefined;var rhs$1 = undefined;var arg$1 = undefined;t0$14 = temp$7$0;if (Array.isArray(t0$14) && (t1$9 = t0$14.length, t1$9 === 3 && t0$14[0] === "data")) {
      lhs$0 = t0$14[1];rhs$1 = t0$14[2];arg$1 = t0$14;
    } else {
      ___match_error(temp$7$0);
    }bridge$$11892$0 = ph$5$0;if ((x$5 = bridge$$11892$0, x$5 instanceof Array && x$5[0] === "check") || (x$6 = bridge$$11892$0, x$6 instanceof Array && x$6[0] === "project")) {
      return ["nostep", form$4];
    } else {
      if ((x$7 = ph$5$0, x$7 instanceof Array && x$7[0] === "pattern")) {
        return ["all", lhs$0, rhs$1];
      } else {
        other$3 = ph$5$0;return ["send", ["variable", "and"], arg$1];
      }
    }
  };t0$15 = getProjector(mac$0("and"))($targ$6);if (t0$15[0]) {
    and_mac$0 = t0$15[1];
  } else {
    ___match_error($targ$6, "mac{\"and\"}! and_mac{match, _, form, #data{lhs, rhs} and arg}");
  }$targ$7 = function (ph$6$0, temp$8$0, form$5, temp$9$0) {
    var t0$16 = undefined;var t1$10 = undefined;var x$8 = undefined;var x$9 = undefined;var x$10 = undefined;var other$4 = undefined;var bridge$$11952$0 = undefined;var lhs$1 = undefined;var rhs$2 = undefined;var arg$2 = undefined;t0$16 = temp$9$0;if (Array.isArray(t0$16) && (t1$10 = t0$16.length, t1$10 === 3 && t0$16[0] === "data")) {
      lhs$1 = t0$16[1];rhs$2 = t0$16[2];arg$2 = t0$16;
    } else {
      ___match_error(temp$9$0);
    }bridge$$11952$0 = ph$6$0;if ((x$8 = bridge$$11952$0, x$8 instanceof Array && x$8[0] === "check") || (x$9 = bridge$$11952$0, x$9 instanceof Array && x$9[0] === "project")) {
      return ["nostep", form$5];
    } else {
      if ((x$10 = ph$6$0, x$10 instanceof Array && x$10[0] === "pattern")) {
        return ["any", lhs$1, rhs$2];
      } else {
        other$4 = ph$6$0;return ["send", ["variable", "or"], arg$2];
      }
    }
  };t0$17 = getProjector(mac$0("or"))($targ$7);if (t0$17[0]) {
    or_mac$0 = t0$17[1];
  } else {
    ___match_error($targ$7, "mac{\"or\"}! or_mac{match, _, form, #data{lhs, rhs} and arg}");
  }$targ$8 = function (context$0, temp$10$0, form$6, temp$11$0) {
    var t0$18 = undefined;var t1$11 = undefined;var other$5 = undefined;var t0$19 = undefined;var t1$12 = undefined;var ph$7$0 = undefined;var condition$0 = undefined;t0$18 = temp$11$0;if (Array.isArray(t0$18) && (t1$11 = t0$18.length, t1$11 === 3 && t0$18[0] === "data")) {
      ph$7$0 = t0$18[1];condition$0 = t0$18[2];
    } else {
      ___match_error(temp$11$0);
    }t0$19 = ph$7$0;t1$12 = t0$19.length;if (t1$12 === 1 && t0$19[0] === "void") {
      return ["test", condition$0, ["ignore"]];
    } else {
      other$5 = ph$7$0;return ["test", condition$0, other$5];
    }
  };t0$20 = getProjector(mac$0("when"))($targ$8);if (t0$20[0]) {
    when_mac$0 = t0$20[1];
  } else {
    ___match_error($targ$8, "mac{\"when\"}! when_mac{context, _, form, #data{match, condition}}");
  }$targ$9 = function (temp$12$0, info$3, form$7, temp$13$0) {
    var t0$21 = undefined;var t0$22 = undefined;var t1$13 = undefined;var checker$1 = undefined;var m$5$0 = undefined;var x$11 = undefined;var checker$2 = undefined;var t0$23 = undefined;var m$6$0 = undefined;var subp$0 = undefined;var other$6 = undefined;var checker$0 = undefined;var context$1 = undefined;var ph$8$0 = undefined;var chk$0 = undefined;var target$1 = undefined;t0$21 = temp$12$0;context$1 = t0$21;ph$8$0 = t0$21;t0$22 = temp$13$0;if (Array.isArray(t0$22) && (t1$13 = t0$22.length, t1$13 === 3 && t0$22[0] === "data")) {
      chk$0 = t0$22[1];target$1 = t0$22[2];
    } else {
      ___match_error(temp$13$0);
    }m$5$0 = info$3.step(["check", context$1], chk$0);if (m$5$0 === chk$0) {
      checker$0 = ["send", ["symbol", "getChecker"], ["data", chk$0]];
    } else {
      checker$1 = m$5$0;checker$0 = checker$1;
    }if ((x$11 = ph$8$0, x$11 instanceof Array && x$11[0] === "pattern")) {
      if (equal(target$1, ["void"])) {
        subp$0 = ["ignore"];
      } else {
        subp$0 = target$1;
      }m$6$0 = checker$0;if (Array.isArray(m$6$0) && (t0$23 = m$6$0.length, t0$23 === 2 && m$6$0[0] === "raw")) {
        checker$2 = m$6$0[1];return checker$2;
      } else {
        return ["check", checker$0, subp$0];
      }
    } else {
      if (equal(target$1, ["void"])) {
        return checker$0;
      } else {
        other$6 = ph$8$0;return ["send", checker$0, ["data", target$1]];
      }
    }
  };t0$24 = getProjector(mac$0("?"))($targ$9);if (t0$24[0]) {
    check_mac$0 = t0$24[1];
  } else {
    ___match_error($targ$9, "mac{\"?\"}! check_mac{match context, info, form, #data{chk, target}}");
  }$targ$10 = function (temp$14$0, info$4, form$8, temp$15$0) {
    var t0$25 = undefined;var t0$26 = undefined;var t1$14 = undefined;var projector$1 = undefined;var m$7$0 = undefined;var x$12 = undefined;var projector$3 = undefined;var projector$2 = undefined;var $$12206$0 = undefined;var $$12207$0 = undefined;var $$12208$0 = undefined;var t0$27 = undefined;var m$8$0 = undefined;var subp$1 = undefined;var other$7 = undefined;var projector$0 = undefined;var context$2 = undefined;var ph$9$0 = undefined;var proj$0 = undefined;var target$2 = undefined;t0$25 = temp$14$0;context$2 = t0$25;ph$9$0 = t0$25;t0$26 = temp$15$0;if (Array.isArray(t0$26) && (t1$14 = t0$26.length, t1$14 === 3 && t0$26[0] === "data")) {
      proj$0 = t0$26[1];target$2 = t0$26[2];
    } else {
      ___match_error(temp$15$0);
    }m$7$0 = info$4.step(["project", context$2], proj$0);if (m$7$0 === proj$0) {
      projector$0 = ["send", ["symbol", "getProjector"], ["data", proj$0]];
    } else {
      projector$1 = m$7$0;projector$0 = projector$1;
    }if ((x$12 = ph$9$0, x$12 instanceof Array && x$12[0] === "pattern")) {
      if (equal(target$2, ["void"])) {
        subp$1 = ["ignore"];
      } else {
        subp$1 = target$2;
      }m$8$0 = projector$0;if (($$12206$0 = Array.isArray(m$8$0)) && (t0$27 = m$8$0.length, ($$12208$0 = t0$27 === 2) && m$8$0[0] === "raw")) {
        projector$2 = m$8$0[1];return projector$2;
      } else {
        if ($$12208$0 && m$8$0[0] === "unconditional") {
          projector$3 = m$8$0[1];return ["project", projector$3, subp$1, true];
        } else {
          return ["project", projector$0, subp$1];
        }
      }
    } else {
      if (equal(target$2, ["void"])) {
        return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "x"]], ["send", ["send", projector$0, ["data", ["symbol", "x"]]], ["value", 1]]]];
      } else {
        other$7 = ph$9$0;return ["send", ["send", projector$0, ["data", target$2]], ["value", 1]];
      }
    }
  };t0$28 = getProjector(mac$0("!"))($targ$10);if (t0$28[0]) {
    project_mac$0 = t0$28[1];
  } else {
    ___match_error($targ$10, "mac{\"!\"}! project_mac{match context, info, form, #data{proj, target}}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=logic.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../location":106,"../pattern":121,"../util":126,"./helpers":110,"earlgrey-runtime/5":446}],112:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var expr_mac$0 = undefined;var overridable$0 = undefined;var build_loop$0 = undefined;var match_error$0 = undefined;var Body$0 = undefined;var setup_label$0 = undefined;var break_mac$0 = undefined;var continue_mac$0 = undefined;$0$0 = require("./helpers");expr_mac$0 = getProperty($0$0, "expr_mac", "./helpers");overridable$0 = getProperty($0$0, "overridable", "./helpers");build_loop$0 = getProperty($0$0, "build_loop", "./helpers");match_error$0 = getProperty($0$0, "match_error", "./helpers");Body$0 = getProperty($0$0, "Body", "./helpers");setup_label$0 = function setup_label(label$0, env$0, body$0) {
  return ["bind", __amp__(["symbol", "break"], { env: env$0 }), ["macro", break_mac$0(label$0)], ["bind", __amp__(["symbol", "continue"], { env: env$0 }), ["macro", continue_mac$0(label$0)], ["js_label", ["value", label$0], body$0]]];
};break_mac$0 = function break_mac(default_label$0) {
  return overridable$0(function (context$0, temp$0$0, form$0, temp$1$0) {
    var t0$0 = undefined;var v$1 = undefined;var v$0 = undefined;var $$12293$0 = undefined;var $$12294$0 = undefined;var $$12295$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;var expr$0 = undefined;var ph$0$0 = undefined;t0$0 = temp$1$0;expr$0 = t0$0;ph$0$0 = t0$0;t0$1 = ph$0$0;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 1 && (t0$1[0] === "void" && default_label$0))) {
      return ["js_break", ["value", default_label$0]];
    } else {
      t1$0 = t0$1.length;if (t1$0 === 1 && t0$1[0] === "void") {
        return ["js_break"];
      } else {
        if (($$12295$0 = t1$0 === 2) && t0$1[0] === "value") {
          v$0 = t0$1[1];return ["js_break", expr$0];
        } else {
          if ($$12295$0 && t0$1[0] === "symbol") {
            v$1 = t0$1[1];return ["js_break", ["value", v$1]];
          } else {
            return ___match_error(ph$0$0, "#symbol{v}");
          }
        }
      }
    }
  });
};continue_mac$0 = function continue_mac(default_label$1) {
  return overridable$0(function (context$1, temp$2$0, form$1, temp$3$0) {
    var t0$2 = undefined;var v$3 = undefined;var v$2 = undefined;var $$12348$0 = undefined;var $$12349$0 = undefined;var $$12350$0 = undefined;var t0$3 = undefined;var t1$1 = undefined;var expr$1 = undefined;var ph$1$0 = undefined;t0$2 = temp$3$0;expr$1 = t0$2;ph$1$0 = t0$2;t0$3 = ph$1$0;if (Array.isArray(t0$3) && (t1$1 = t0$3.length, t1$1 === 1 && (t0$3[0] === "void" && default_label$1))) {
      return ["js_continue", ["value", default_label$1]];
    } else {
      t1$1 = t0$3.length;if (t1$1 === 1 && t0$3[0] === "void") {
        return ["js_continue"];
      } else {
        if (($$12350$0 = t1$1 === 2) && t0$3[0] === "value") {
          v$2 = t0$3[1];return ["js_continue", expr$1];
        } else {
          if ($$12350$0 && t0$3[0] === "symbol") {
            v$3 = t0$3[1];return ["js_continue", ["value", v$3]];
          } else {
            return ___match_error(ph$1$0, "#symbol{v}");
          }
        }
      }
    }
  });
};if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var m$0 = undefined;var acc$0 = undefined;var temp$4 = undefined;var defns$0 = undefined;var t0$10 = undefined;var t1$6 = undefined;var t0$17 = undefined;var $targ$7 = undefined;var accum$0 = undefined;var $targ$8 = undefined;var accum$1 = undefined;var t0$24 = undefined;var t0$30 = undefined;var $targ$2 = undefined;var while_mac$0 = undefined;var $targ$3 = undefined;var for_mac$0 = undefined;var EachHandler$0 = undefined;var $targ$4 = undefined;var each_mac$0 = undefined;var $targ$5 = undefined;var each_gen_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};defns$0 = { "break": break_mac$0(null), "continue": continue_mac$0(null) };acc$0 = [];temp$4 = null;m$0 = null;$1: for (var _iterator = items(defns$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$0 = _step.value;
    var k$0 = undefined;var v$4 = undefined;var t0$4 = undefined;var t1$2 = undefined;t0$4 = m$0;if (Array.isArray(t0$4) && (t1$2 = t0$4.length, t1$2 === 2)) {
      k$0 = t0$4[0];v$4 = t0$4[1];temp$4 = mac$0(k$0)(v$4);acc$0.push(temp$4);
    } else {
      ___match_error(m$0);
    }
  }$targ$2 = function (info$0, form$2, temp$5$0) {
    var t0$5 = undefined;var t0$7 = undefined;var t1$4 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t0$8 = undefined;var test$1 = undefined;var body$2 = undefined;var label$1 = undefined;var bridge$$12459$0 = undefined;var t0$6 = undefined;var t1$3 = undefined;var env$1 = undefined;var ph$2$0 = undefined;t0$5 = temp$5$0;if (___hasprop(t0$5, "env")) {
      env$1 = t0$5.env;ph$2$0 = t0$5;
    } else {
      ___match_error(temp$5$0);
    }bridge$$12459$0 = ph$2$0;if (Array.isArray(bridge$$12459$0) && (t0$7 = bridge$$12459$0.length, t0$7 === 3 && (bridge$$12459$0[0] === "send" && (t1$4 = bridge$$12459$0[1], Array.isArray(t1$4) && (t2$0 = t1$4.length, t2$0 === 2 && (t1$4[0] === "symbol" && (t1$4[1] === "." && (t3$0 = bridge$$12459$0[2], Array.isArray(t3$0) && (t4$0 = t3$0.length, t4$0 === 3 && (t3$0[0] === "data" && (t5$0 = t3$0[1], Array.isArray(t5$0) && (t6$0 = t5$0.length, t6$0 === 1 && (t5$0[0] === "void" && (t7$0 = t3$0[2], Array.isArray(t7$0) && (t8$0 = t7$0.length, t8$0 === 2 && (t7$0[0] === "symbol" && (label$1 = t7$0[1], true)))))))))))))))) || Array.isArray(bridge$$12459$0) && (t0$8 = bridge$$12459$0.length, t0$8 === 2 && (bridge$$12459$0[0] === "value" && (label$1 = bridge$$12459$0[1], true)))) {
      return ["macro", function (context$2, temp$6$0, form$3, temp$7$0) {
        var t0$9 = undefined;var t1$5 = undefined;var test$0 = undefined;var body$1 = undefined;t0$9 = temp$7$0;if (Array.isArray(t0$9) && (t1$5 = t0$9.length, t1$5 === 3 && t0$9[0] === "data")) {
          test$0 = t0$9[1];body$1 = t0$9[2];
        } else {
          ___match_error(temp$7$0);
        }return setup_label$0(label$1, env$1, ["js_while", test$0, body$1]);
      }];
    } else {
      t0$6 = ph$2$0;t1$3 = t0$6.length;if (t1$3 === 3 && t0$6[0] === "data") {
        test$1 = t0$6[1];body$2 = t0$6[2];return setup_label$0(info$0.gensym(), env$1, ["js_while", test$1, body$2]);
      } else {
        return ___match_error(ph$2$0, "#data{test, body}");
      }
    }
  };t0$10 = getProjector(expr_mac$0)($targ$2);if (t0$10[0] && (t1$6 = getProjector(mac$0("while"))(t0$10[1]), t1$6[0])) {
    while_mac$0 = t1$6[1];
  } else {
    ___match_error($targ$2, "expr_mac! mac{\"while\"}! while_mac{info, form, match {=> env}}");
  }$targ$3 = function (context$3, info$1, form$4, temp$8$0) {
    var t0$11 = undefined;var t0$14 = undefined;var t1$9 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$2 = undefined;var t5$2 = undefined;var t6$1 = undefined;var t7$1 = undefined;var t8$1 = undefined;var t0$15 = undefined;var spec$1 = undefined;var body$5 = undefined;var label$3 = undefined;var setup_for$0 = undefined;var bridge$$12581$0 = undefined;var t0$12 = undefined;var t1$7 = undefined;var expr$2 = undefined;var ph$3$0 = undefined;t0$11 = temp$8$0;expr$2 = t0$11;ph$3$0 = t0$11;setup_for$0 = function setup_for(label$2, env$2, ph$4$0, body$3) {
      var a$2 = undefined;var b$2 = undefined;var a$1 = undefined;var b$1 = undefined;var a$0 = undefined;var b$0 = undefined;var c$0 = undefined;var $$12602$0 = undefined;var $$12603$0 = undefined;var $$12604$0 = undefined;var $$12605$0 = undefined;var $$12606$0 = undefined;var $$12607$0 = undefined;var $$12608$0 = undefined;var $$12609$0 = undefined;var $$12610$0 = undefined;var t0$13 = undefined;var t1$8 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$1 = undefined;t0$13 = ph$4$0;t1$8 = t0$13.length;if (t1$8 === 4 && t0$13[0] === "multi") {
        a$0 = t0$13[1];b$0 = t0$13[2];c$0 = t0$13[3];return ["multi", a$0, setup_label$0(label$2, env$2, ["js_for", ["multi"], b$0, c$0, body$3])];
      } else {
        if (($$12604$0 = t1$8 === 3) && (($$12605$0 = t0$13[0] === "send") && (t2$1 = t0$13[1], ($$12607$0 = Array.isArray(t2$1)) && (t3$1 = t2$1.length, ($$12609$0 = t3$1 === 2) && (($$12610$0 = t2$1[0] === "symbol") && (t2$1[1] === "in" && (t4$1 = t0$13[2], Array.isArray(t4$1) && (t5$1 = t4$1.length, t5$1 === 3 && t4$1[0] === "data")))))))) {
          a$1 = t4$1[1];b$1 = t4$1[2];return ["multi", ["declare", a$1, ["value", null]], setup_label$0(label$2, env$2, ["js_for_in", a$1, b$1, body$3])];
        } else {
          if ($$12610$0 && (t2$1[1] === "of" && (t4$1 = t0$13[2], Array.isArray(t4$1) && (t5$1 = t4$1.length, t5$1 === 3 && t4$1[0] === "data")))) {
            a$2 = t4$1[1];b$2 = t4$1[2];return ["multi", ["declare", a$2, ["value", null]], setup_label$0(label$2, env$2, ["js_for_of", a$2, b$2, body$3])];
          } else {
            return ___match_error(ph$4$0, "`^a of ^b`");
          }
        }
      }
    };bridge$$12581$0 = ph$3$0;if (Array.isArray(bridge$$12581$0) && (t0$14 = bridge$$12581$0.length, t0$14 === 3 && (bridge$$12581$0[0] === "send" && (t1$9 = bridge$$12581$0[1], Array.isArray(t1$9) && (t2$2 = t1$9.length, t2$2 === 2 && (t1$9[0] === "symbol" && (t1$9[1] === "." && (t3$2 = bridge$$12581$0[2], Array.isArray(t3$2) && (t4$2 = t3$2.length, t4$2 === 3 && (t3$2[0] === "data" && (t5$2 = t3$2[1], Array.isArray(t5$2) && (t6$1 = t5$2.length, t6$1 === 1 && (t5$2[0] === "void" && (t7$1 = t3$2[2], Array.isArray(t7$1) && (t8$1 = t7$1.length, t8$1 === 2 && (t7$1[0] === "symbol" && (label$3 = t7$1[1], true)))))))))))))))) || Array.isArray(bridge$$12581$0) && (t0$15 = bridge$$12581$0.length, t0$15 === 2 && (bridge$$12581$0[0] === "value" && (label$3 = bridge$$12581$0[1], true)))) {
      return ["macro", function (context$4, temp$9$0, form$5, temp$10$0) {
        var t0$16 = undefined;var t1$10 = undefined;var spec$0 = undefined;var body$4 = undefined;t0$16 = temp$10$0;if (Array.isArray(t0$16) && (t1$10 = t0$16.length, t1$10 === 3 && t0$16[0] === "data")) {
          spec$0 = t0$16[1];body$4 = t0$16[2];
        } else {
          ___match_error(temp$10$0);
        }return setup_for$0(label$3, expr$2.env, spec$0, body$4);
      }];
    } else {
      t0$12 = ph$3$0;t1$7 = t0$12.length;if (t1$7 === 3 && t0$12[0] === "data") {
        spec$1 = t0$12[1];body$5 = t0$12[2];return setup_for$0(info$1.gensym(), form$4.env, spec$1, body$5);
      } else {
        return ___match_error(ph$3$0, "#data{spec, body}");
      }
    }
  };t0$17 = getProjector(mac$0("for"))($targ$3);if (t0$17[0]) {
    for_mac$0 = t0$17[1];
  } else {
    ___match_error($targ$3, "mac{\"for\"}! for_mac{context, info, form, match expr}");
  }EachHandler$0 = function EachHandler() {
    var $targ$6 = undefined;var t0$18 = undefined;var m$1$0 = undefined;var __at___$0 = undefined;if (!getChecker(EachHandler$0)(this)) {
      __at___$0 = Object.create(EachHandler$0.prototype);
    } else {
      __at___$0 = this;
    }m$1$0 = arguments;t0$18 = m$1$0.length;if (t0$18 >= 2 && t0$18 <= 3) {
      __at___$0.placeholder = m$1$0[0];__at___$0.loopvar = m$1$0[1];__at___$0.generator = 2 >= t0$18 ? false : m$1$0[2];$targ$6 = 2;__at___$0.wrapOrder = $targ$6;void 0;
    } else {
      ___match_error(m$1$0, "{@placeholder, @loopvar, @generator = false}");
    }return __at___$0;
  };EachHandler$0.prototype.expand = function expand(info$2) {
    var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;return __at___$1.placeholder;
  };EachHandler$0.prototype.wrap = function wrap(expr$3, info$3, opt$0) {
    var __at___$2 = undefined;var self$1 = undefined;__at___$2 = this;self$1 = this;if (__at___$2.generator) {
      return ["send", ["symbol", "each*"], ["data", __at___$2.placeholder, ["send", ["symbol", "->"], ["data", __at___$2.loopvar, expr$3]]]];
    } else {
      return ["send", ["symbol", "each"], ["data", __at___$2.placeholder, ["send", ["symbol", "->"], ["data", __at___$2.loopvar, expr$3]]]];
    }
  };__amp____colon__(EachHandler$0, __amp____colon__(($targ$7 = "EachHandler", accum$0 = {}, accum$0["::name"] = $targ$7, accum$0), ($targ$8 = true, accum$1 = {}, accum$1["::egclass"] = $targ$8, accum$1)));$targ$4 = function (ph$5$0, temp$11$0, form$6, expr$4) {
    var t0$19 = undefined;var x$0 = undefined;var t0$21 = undefined;var t1$12 = undefined;var ph$6 = undefined;var lv$0 = undefined;var $targ$9 = undefined;var li$0 = undefined;var body$6 = undefined;var t0$22 = undefined;var t1$13 = undefined;var t0$23 = undefined;var t1$14 = undefined;var t2$3 = undefined;var x$3 = undefined;var other$1 = undefined;var $targ$10 = undefined;var li$1 = undefined;var body$7 = undefined;var $targ$11 = undefined;var clauses$0 = undefined;var ends_with_test$0 = undefined;var _build_loop$0 = undefined;var $$12842$0 = undefined;var $$12843$0 = undefined;var $$12844$0 = undefined;var $$12845$0 = undefined;var t0$20 = undefined;var t1$11 = undefined;var info$4 = undefined;var env$3 = undefined;t0$19 = temp$11$0;info$4 = t0$19;if (___hasprop(t0$19, "env")) {
      env$3 = t0$19.env;
    } else {
      ___match_error(temp$11$0);
    }if ((x$0 = ph$5$0, x$0 instanceof Array && x$0[0] === "pattern")) {
      if (equal(expr$4, ["void"])) {
        expr$4 = ["data", ["void"], ["void"]];expr$4;
      }$targ$9 = expr$4;t0$21 = $targ$9;if (Array.isArray(t0$21) && (t1$12 = t0$21.length, t1$12 === 3 && t0$21[0] === "data")) {
        li$0 = t0$21[1];body$6 = t0$21[2];
      } else {
        ___match_error($targ$9, "#data{li, body}");
      }[li$0, body$6];if (equal(li$0, ["void"])) {
        ph$6 = info$4.env.mark(["symbol", info$4.gensym("xs")]);
      } else {
        ph$6 = li$0;
      }if (equal(body$6, ["void"])) {
        lv$0 = info$4.env.mark(["symbol", "match"]);
      } else {
        lv$0 = body$6;
      }return ["special", EachHandler$0(ph$6, lv$0)];
    } else {
      $targ$10 = expr$4;t0$22 = $targ$10;if (Array.isArray(t0$22) && (t1$13 = t0$22.length, t1$13 === 3 && t0$22[0] === "data")) {
        li$1 = t0$22[1];body$7 = t0$22[2];
      } else {
        ___match_error($targ$10, "#data{li, body}");
      }[li$1, body$7];$targ$11 = body$7;t0$23 = getProjector(Body$0)($targ$11);if (t0$23[0] && (t1$14 = t0$23[1], t2$3 = t1$14.length, t2$3 >= 0)) {
        clauses$0 = Array.prototype.slice.call(t1$14, 0);
      } else {
        ___match_error($targ$11, "Body! {*clauses}");
      }ends_with_test$0 = false;_build_loop$0 = function _build_loop(wrap$0, pre$0, post$0) {
        var accum$2 = undefined;var accum$3 = undefined;var opts$0 = undefined;opts$0 = __amp____colon__({ forof: true }, __amp____colon__((accum$2 = {}, accum$2.wrap_pattern = function wrap_pattern(x$1, toplevel$0) {
          var x$2 = undefined;var other$0 = undefined;var m$2$0 = undefined;m$2$0 = x$1;if ((x$2 = m$2$0, x$2 instanceof Array && x$2[0] === "test")) {
            ends_with_test$0 = toplevel$0;
          } else {
            other$0 = m$2$0;ends_with_test$0 = false;
          }return x$1;
        }, accum$2), (accum$3 = {}, accum$3.fallback = function fallback(target$0) {
          if (ends_with_test$0) {
            return ["symbol", "false"];
          } else {
            return match_error$0(target$0);
          }
        }, accum$3)));return build_loop$0(info$4, env$3, form$6, li$1, clauses$0, wrap$0, pre$0, post$0, opts$0);
      };if ((x$3 = ph$5$0, x$3 instanceof Array && x$3[0] === "test")) {
        return __amp__(["test_factory", li$1, clauses$0], { env: env$3 });
      } else {
        t0$20 = ph$5$0;t1$11 = t0$20.length;if (($$12844$0 = t1$11 === 2) && (($$12845$0 = t0$20[0] === "expr") && t0$20[1] === "multi")) {
          return ["nostep", form$6];
        } else {
          if ($$12845$0 && t0$20[1] === "ignore") {
            return _build_loop$0(null, ["splice"], ["splice"]);
          } else {
            other$1 = ph$5$0;return _build_loop$0(function (x$4) {
              return ["multi", ["send", ["symbol", "="], ["data", ["symbol", "temp"], ["multi", x$4]]], ["send", ["send", ["symbol", "acc"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "push"]]]], ["data", ["symbol", "temp"]]]];
            }, ["splice", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "acc"]], ["data"]]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "temp"]], ["symbol", "null"]]]], ["symbol", "acc"]);
          }
        }
      }
    }
  };t0$24 = getProjector(mac$0("each"))($targ$4);if (t0$24[0]) {
    each_mac$0 = t0$24[1];
  } else {
    ___match_error($targ$4, "mac{\"each\"}! each_mac{match, info and {=> env}, form, var expr}");
  }$targ$5 = function (ph$7$0, temp$12$0, form$7, expr$5) {
    var t0$25 = undefined;var x$5 = undefined;var t0$27 = undefined;var t1$16 = undefined;var ph$8 = undefined;var lv$1 = undefined;var $targ$12 = undefined;var li$2 = undefined;var body$8 = undefined;var t0$28 = undefined;var t1$17 = undefined;var t0$29 = undefined;var t1$18 = undefined;var t2$4 = undefined;var loop$0 = undefined;var other$3 = undefined;var $targ$13 = undefined;var li$3 = undefined;var body$9 = undefined;var $targ$14 = undefined;var clauses$1 = undefined;var ends_with_test$1 = undefined;var _build_loop$1 = undefined;var $$13023$0 = undefined;var $$13024$0 = undefined;var $$13025$0 = undefined;var $$13026$0 = undefined;var t0$26 = undefined;var t1$15 = undefined;var info$5 = undefined;var env$4 = undefined;t0$25 = temp$12$0;info$5 = t0$25;if (___hasprop(t0$25, "env")) {
      env$4 = t0$25.env;
    } else {
      ___match_error(temp$12$0);
    }if ((x$5 = ph$7$0, x$5 instanceof Array && x$5[0] === "pattern")) {
      if (equal(expr$5, ["void"])) {
        expr$5 = ["data", ["void"], ["void"]];expr$5;
      }$targ$12 = expr$5;t0$27 = $targ$12;if (Array.isArray(t0$27) && (t1$16 = t0$27.length, t1$16 === 3 && t0$27[0] === "data")) {
        li$2 = t0$27[1];body$8 = t0$27[2];
      } else {
        ___match_error($targ$12, "#data{li, body}");
      }[li$2, body$8];if (equal(li$2, ["void"])) {
        ph$8 = info$5.env.mark(["symbol", info$5.gensym("xs")]);
      } else {
        ph$8 = li$2;
      }if (equal(body$8, ["void"])) {
        lv$1 = info$5.env.mark(["symbol", "match"]);
      } else {
        lv$1 = body$8;
      }return ["special", EachHandler$0(ph$8, lv$1, true)];
    } else {
      $targ$13 = expr$5;t0$28 = $targ$13;if (Array.isArray(t0$28) && (t1$17 = t0$28.length, t1$17 === 3 && t0$28[0] === "data")) {
        li$3 = t0$28[1];body$9 = t0$28[2];
      } else {
        ___match_error($targ$13, "#data{li, body}");
      }[li$3, body$9];$targ$14 = body$9;t0$29 = getProjector(Body$0)($targ$14);if (t0$29[0] && (t1$18 = t0$29[1], t2$4 = t1$18.length, t2$4 >= 0)) {
        clauses$1 = Array.prototype.slice.call(t1$18, 0);
      } else {
        ___match_error($targ$14, "Body! {*clauses}");
      }ends_with_test$1 = false;_build_loop$1 = function _build_loop(wrap$1, pre$1, post$1) {
        var accum$4 = undefined;var accum$5 = undefined;var opts$1 = undefined;opts$1 = __amp____colon__({ forof: true }, __amp____colon__((accum$4 = {}, accum$4.wrap_pattern = function wrap_pattern(x$6, toplevel$1) {
          var x$7 = undefined;var other$2 = undefined;var m$3$0 = undefined;m$3$0 = x$6;if ((x$7 = m$3$0, x$7 instanceof Array && x$7[0] === "test")) {
            ends_with_test$1 = toplevel$1;
          } else {
            other$2 = m$3$0;ends_with_test$1 = false;
          }return x$6;
        }, accum$4), (accum$5 = {}, accum$5.fallback = function fallback(target$1) {
          if (ends_with_test$1) {
            return ["symbol", "false"];
          } else {
            return match_error$0(target$1);
          }
        }, accum$5)));return build_loop$0(info$5, env$4, form$7, li$3, clauses$1, wrap$1, pre$1, post$1, opts$1);
      };t0$26 = ph$7$0;t1$15 = t0$26.length;if (($$13025$0 = t1$15 === 2) && (($$13026$0 = t0$26[0] === "expr") && t0$26[1] === "multi")) {
        return ["nostep", form$7];
      } else {
        if ($$13026$0 && t0$26[1] === "ignore") {
          return ["multi"];
        } else {
          other$3 = ph$7$0;loop$0 = _build_loop$1(function (x$8) {
            return ["multi", ["send", ["symbol", "="], ["data", ["symbol", "temp"], ["multi", x$8]]], ["send", ["symbol", "yield"], ["symbol", "temp"]]];
          }, ["splice", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "acc"]], ["data"]]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], ["symbol", "temp"]], ["symbol", "null"]]]], ["symbol", "acc"]);return ["send", ["send", ["symbol", "*->"], ["data", ["data"], loop$0]], ["data"]];
        }
      }
    }
  };t0$30 = getProjector(mac$0("each*"))($targ$5);if (t0$30[0]) {
    each_gen_mac$0 = t0$30[1];
  } else {
    ___match_error($targ$5, "mac{\"each*\"}! each_gen_mac{match, info and {=> env}, form, var expr}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=loop.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":110,"earlgrey-runtime/5":446}],113:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var $1$0 = undefined;var Env$0 = undefined;var topscope$0 = undefined;var $2$0 = undefined;var ctx_mac$0 = undefined;var expr_mac2$0 = undefined;var multimacro$0 = undefined;var inject__minus__tools$0 = undefined;$0$0 = require("../location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "../location");$1$0 = require("../expand");Env$0 = getProperty($1$0, "Env", "../expand");topscope$0 = getProperty($1$0, "topscope", "../expand");$2$0 = require("./helpers");ctx_mac$0 = getProperty($2$0, "ctx_mac", "./helpers");expr_mac2$0 = getProperty($2$0, "expr_mac2", "./helpers");multimacro$0 = getProperty($2$0, "multimacro", "./helpers");inject__minus__tools$0 = getProperty($2$0, "injectTools", "./helpers");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var t0$3 = undefined;var t0$7 = undefined;var t0$11 = undefined;var mak$0 = undefined;var t0$16 = undefined;var wrap_macro$0 = undefined;var wrap_macro_func$0 = undefined;var $targ$2 = undefined;var imacro_mac$0 = undefined;var $targ$3 = undefined;var icmacro_mac$0 = undefined;var $targ$4 = undefined;var macros_mac$0 = undefined;var $targ$5 = undefined;var macro_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};wrap_macro$0 = function wrap_macro(info$0, mac$1) {
    var mac2$0 = undefined;mac2$0 = function mac2(c$0, s$0, f$0, e$0) {
      var bindings$0 = undefined;var env$0 = undefined;var $targ$6 = undefined;var r$0 = undefined;bindings$0 = info$0.env.list_bindings(info$0.scope);env$0 = Env$0();$targ$6 = bindings$0;env$0.scopes[topscope$0.name] = $targ$6;r$0 = mac$1.call(info$0, c$0, s$0, f$0, e$0);return env$0.mark(r$0);
    };return ["macro", mac2$0];
  };wrap_macro_func$0 = function wrap_macro_func(info$1, args$0, body$0) {
    var it$0 = undefined;it$0 = info$1.env.mark(["symbol", "@"]);return ["send", ["symbol", "_lambda"], ["data", args$0, ["send", ["symbol", "="], ["data", it$0, ["symbol", "this"]]], body$0, ["value", null]]];
  };$targ$2 = function (context$0, info$2, form$0, ph$0$0) {
    var t0$1 = undefined;var t0$2 = undefined;var mac$2 = undefined;var s$1 = undefined;var name$0 = undefined;var sym$0 = undefined;var arguments$1 = undefined;var ast$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var bridge$$13307$0 = undefined;t0$0 = ph$0$0;t1$0 = t0$0.length;if (t1$0 === 3 && (t0$0[0] === "data" && (t2$0 = t0$0[1], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 3 && (t2$0[0] === "send" && (t4$0 = t2$0[1], name$0 = t4$0, bridge$$13307$0 = t4$0, Array.isArray(bridge$$13307$0) && (t0$1 = bridge$$13307$0.length, t0$1 === 2 && (bridge$$13307$0[0] === "symbol" && (sym$0 = bridge$$13307$0[1], true))) || Array.isArray(bridge$$13307$0) && (t0$2 = bridge$$13307$0.length, t0$2 === 2 && (bridge$$13307$0[0] === "value" && (sym$0 = bridge$$13307$0[1], true))))))))) {
      arguments$1 = t2$0[2];ast$0 = t0$0[2];mac$2 = info$2.go(wrap_macro_func$0(info$2, arguments$1, ast$0), "parse", "eval");s$1 = __lt____lt____colon__$0(info$2.mark(__amp____colon__(["symbol", sym$0], { env: name$0.env })), name$0);return ["declare_raw", s$1, wrap_macro$0(info$2, expr_mac2$0(mac$2))];
    } else {
      return ___match_error(ph$0$0, "#data{#send{name and [#symbol{sym} or #value{sym}], arguments}, ast}");
    }
  };t0$3 = getProjector(mac$0("inlineMacro"))($targ$2);if (t0$3[0]) {
    imacro_mac$0 = t0$3[1];
  } else {
    ___match_error($targ$2, "mac{\"inlineMacro\"}! imacro_mac{context, info, form, match}");
  }$targ$3 = function (context$1, info$3, form$1, ph$1$0) {
    var t0$5 = undefined;var t0$6 = undefined;var mac$3 = undefined;var s$2 = undefined;var name$1 = undefined;var sym$1 = undefined;var arguments$2 = undefined;var ast$1 = undefined;var t0$4 = undefined;var t1$1 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$1 = undefined;var bridge$$13379$0 = undefined;t0$4 = ph$1$0;t1$1 = t0$4.length;if (t1$1 === 3 && (t0$4[0] === "data" && (t2$1 = t0$4[1], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 3 && (t2$1[0] === "send" && (t4$1 = t2$1[1], name$1 = t4$1, bridge$$13379$0 = t4$1, Array.isArray(bridge$$13379$0) && (t0$5 = bridge$$13379$0.length, t0$5 === 2 && (bridge$$13379$0[0] === "symbol" && (sym$1 = bridge$$13379$0[1], true))) || Array.isArray(bridge$$13379$0) && (t0$6 = bridge$$13379$0.length, t0$6 === 2 && (bridge$$13379$0[0] === "value" && (sym$1 = bridge$$13379$0[1], true))))))))) {
      arguments$2 = t2$1[2];ast$1 = t0$4[2];mac$3 = info$3.go(wrap_macro_func$0(info$3, arguments$2, ast$1), "parse", "eval");s$2 = __lt____lt____colon__$0(info$3.mark(__amp____colon__(["symbol", sym$1], { env: name$1.env })), name$1);return ["declare_raw", s$2, wrap_macro$0(info$3, ctx_mac$0(mac$3))];
    } else {
      return ___match_error(ph$1$0, "#data{#send{name and [#symbol{sym} or #value{sym}], arguments}, ast}");
    }
  };t0$7 = getProjector(mac$0("inlineCmacro"))($targ$3);if (t0$7[0]) {
    icmacro_mac$0 = t0$7[1];
  } else {
    ___match_error($targ$3, "mac{\"inlineCmacro\"}! icmacro_mac{context, info, form, match}");
  }$targ$4 = function (context$2, info$4, temp$0$0, temp$1$0) {
    var t0$8 = undefined;var t0$9 = undefined;var t1$2 = undefined;var m$0 = undefined;var acc$0 = undefined;var temp$2 = undefined;var macs$0 = undefined;var the_macros$0 = undefined;var form$2 = undefined;var env$1 = undefined;var body$1 = undefined;t0$8 = temp$0$0;form$2 = t0$8;if (___hasprop(t0$8, "env")) {
      env$1 = t0$8.env;
    } else {
      ___match_error(temp$0$0);
    }t0$9 = temp$1$0;if (Array.isArray(t0$9) && (t1$2 = t0$9.length, t1$2 === 2 && t0$9[0] === "data")) {
      body$1 = t0$9[1];
    } else {
      ___match_error(temp$1$0);
    }the_macros$0 = info$4.go(body$1, "parse", "eval");acc$0 = [];temp$2 = null;m$0 = null;$3: for (var _iterator = items(the_macros$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      (function () {
        m$0 = _step.value;
        var f$1 = undefined;var k$0 = undefined;var v$0 = undefined;var t0$10 = undefined;var t1$3 = undefined;t0$10 = m$0;if (Array.isArray(t0$10) && (t1$3 = t0$10.length, t1$3 === 2)) {
          k$0 = t0$10[0];v$0 = t0$10[1];f$1 = function f(ctx$0, info$5, form$3, expr$0) {
            return v$0.call(inject__minus__tools$0(info$5), expr$0);
          };temp$2 = ["declare_raw", __amp____colon__(["symbol", k$0], { env: env$1 }), ["macro", f$1]];acc$0.push(temp$2);
        } else {
          ___match_error(m$0);
        }
      })();
    }macs$0 = acc$0;return ["splice"].concat(macs$0);
  };t0$11 = getProjector(mac$0("macros"))($targ$4);if (t0$11[0]) {
    macros_mac$0 = t0$11[1];
  } else {
    ___match_error($targ$4, "mac{\"macros\"}! macros_mac{context, info, form and {=> env}, #data{body}}");
  }mak$0 = function mak(tosave$0) {
    return function (ph$2$0, info$6, form$4, expr$1) {
      var x$0 = undefined;var mac$4 = undefined;var tosave$1 = undefined;var t0$15 = undefined;var t1$7 = undefined;var ph$3$0 = undefined;if (equal(expr$1, ["void"])) {
        return ["nostep", form$4];
      } else {
        if ((x$0 = ph$2$0, x$0 instanceof Array && x$0[0] === "pattern")) {
          mac$4 = function mac() {
            var m$2 = undefined;var acc$1 = undefined;var temp$3 = undefined;var provides$0 = undefined;var e$1 = undefined;var args$1 = undefined;var body$2 = undefined;var env$2 = undefined;var x$1 = undefined;var $$13571$0 = undefined;var $$13572$0 = undefined;var $$13573$0 = undefined;var t0$13 = undefined;var t1$5 = undefined;var t2$3 = undefined;var t3$2 = undefined;var t4$2 = undefined;var t5$0 = undefined;var ph$5$0 = undefined;var blah$0 = undefined;var t0$12 = undefined;var t1$4 = undefined;var t2$2 = undefined;var m$1$0 = undefined;m$1$0 = arguments;t0$12 = m$1$0.length;if (t0$12 >= 1 && (blah$0 = Array.prototype.slice.call(m$1$0, 0, -1), t1$4 = m$1$0[t0$12 - 1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "data"))) {
              ph$5$0 = t1$4[1];t0$13 = ph$5$0;t1$5 = t0$13.length;if (($$13573$0 = t1$5 === 3) && t0$13[0] === "use") {
                env$2 = t0$13[1];x$1 = t0$13[2];return ["use", env$2, mac$4.call(this, ["data", x$1])];
              } else {
                if ($$13573$0 && (t0$13[0] === "send" && (t2$3 = t0$13[1], Array.isArray(t2$3) && (t3$2 = t2$3.length, t3$2 === 2 && (t2$3[0] === "symbol" && (t2$3[1] === "->" && (t4$2 = t0$13[2], Array.isArray(t4$2) && (t5$0 = t4$2.length, t5$0 === 3 && t4$2[0] === "data")))))))) {
                  args$1 = t4$2[1];body$2 = t4$2[2];e$1 = wrap_macro_func$0(info$6, args$1, body$2);acc$1 = [];temp$3 = null;m$2 = null;$4: for (var _iterator = tosave$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                    m$2 = _step.value;
                    var expn$0 = undefined;var exp$0 = undefined;var sym$2 = undefined;var name$2 = undefined;var t0$14 = undefined;var t1$6 = undefined;t0$14 = m$2;sym$2 = t0$14;if (Array.isArray(t0$14) && (t1$6 = t0$14.length, t1$6 === 2 && t0$14[0] === "symbol")) {
                      name$2 = t0$14[1];expn$0 = "__mdep_" + name$2;exp$0 = ["symbol", expn$0];temp$3 = ["multi", ["send", ["symbol", "provide"], ["data", ["send", ["symbol", "as"], ["data", sym$2, exp$0]]]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "deps"], ["value", name$2]], ["value", expn$0]]]];acc$1.push(temp$3);
                    } else {
                      ___match_error(m$2);
                    }
                  }provides$0 = acc$1;return ["multi", ["send", ["symbol", "="], ["data", ["symbol", "tmp"], e$1]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "and"], ["data", ["send", ["symbol", "tmp"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "__deps"]]]], ["symbol", "deps"]]], ["data", ["symbol", "="]]]]].concat(provides$0).concat([["send", ["symbol", "="], ["data", ["send", ["symbol", "tmp"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "__path"]]]], ["symbol", "__filename"]]], ["symbol", "tmp"]]);
                } else {
                  return ___match_error(ph$5$0, "`^args -> ^body`");
                }
              }
            } else {
              return ___match_error(m$1$0, "{*blah, #data{match}}");
            }
          };return ["project", ["macro", mac$4], expr$1, true];
        } else {
          ph$3$0 = expr$1;t0$15 = ph$3$0;t1$7 = t0$15.length;if (t1$7 >= 1 && t0$15[0] === "data") {
            tosave$1 = Array.prototype.slice.call(t0$15, 1);return ["macro", mak$0(tosave$1)];
          } else {
            return ___match_error(ph$3$0, "#data{*tosave}");
          }
        }
      }
    };
  };$targ$5 = mak$0([]);t0$16 = getProjector(mac$0("macro"))($targ$5);if (t0$16[0]) {
    macro_mac$0 = t0$16[1];
  } else {
    ___match_error($targ$5, "mac{\"macro\"}! macro_mac");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=macrodef.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../expand":104,"../location":106,"./helpers":110,"earlgrey-runtime/5":446}],114:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var $1$0 = undefined;var camelCase$0 = undefined;var $2$0 = undefined;var expr_mac$0 = undefined;var var_operator$0 = undefined;var overridable$0 = undefined;var pattern_handlers$0 = undefined;var Body$0 = undefined;var multimacro$0 = undefined;var $3$0 = undefined;var PatternCompiler$0 = undefined;$0$0 = require("../location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "../location");$1$0 = require("../util");camelCase$0 = getProperty($1$0, "camelCase", "../util");$2$0 = require("./helpers");expr_mac$0 = getProperty($2$0, "expr_mac", "./helpers");var_operator$0 = getProperty($2$0, "var_operator", "./helpers");overridable$0 = getProperty($2$0, "overridable", "./helpers");pattern_handlers$0 = getProperty($2$0, "pattern_handlers", "./helpers");Body$0 = getProperty($2$0, "Body", "./helpers");multimacro$0 = getProperty($2$0, "multimacro", "./helpers");$3$0 = require("../pattern");PatternCompiler$0 = getProperty($3$0, "PatternCompiler", "../pattern");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var m$0 = undefined;var acc$0 = undefined;var temp$0 = undefined;var defns$0 = undefined;var t0$3 = undefined;var $targ$20 = undefined;var accum$0 = undefined;var $targ$21 = undefined;var accum$1 = undefined;var t0$9 = undefined;var t0$11 = undefined;var t1$6 = undefined;var t0$14 = undefined;var t1$9 = undefined;var t0$29 = undefined;var t1$17 = undefined;var t0$32 = undefined;var t0$34 = undefined;var t0$38 = undefined;var t0$55 = undefined;var errf_macro$0 = undefined;var t0$57 = undefined;var t0$60 = undefined;var t0$62 = undefined;var t0$64 = undefined;var t0$69 = undefined;var t0$70 = undefined;var $targ$2 = undefined;var parameterize_mac$0 = undefined;var ChainHandler$0 = undefined;var $targ$3 = undefined;var chain_mac$0 = undefined;var $targ$4 = undefined;var using_mac$0 = undefined;var $targ$5 = undefined;var do_mac$0 = undefined;var $targ$6 = undefined;var buildnode_mac$0 = undefined;var $targ$7 = undefined;var S_mac$0 = undefined;var $targ$8 = undefined;var print_mac$0 = undefined;var $targ$9 = undefined;var method_mac$0 = undefined;var $targ$10 = undefined;var class_mac$0 = undefined;var $targ$11 = undefined;var E_mac$0 = undefined;var $targ$12 = undefined;var outer_mac$0 = undefined;var $targ$13 = undefined;var tagscope_mac$0 = undefined;var $targ$14 = undefined;var usescope_mac$0 = undefined;var $targ$15 = undefined;var maysend_mac$0 = undefined;var $targ$16 = undefined;var maybe_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};defns$0 = { "@": var_operator$0("@_") };acc$0 = [];temp$0 = null;m$0 = null;$4: for (var _iterator = items(defns$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$0 = _step.value;
    var k$0 = undefined;var v$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$0;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
      k$0 = t0$0[0];v$0 = t0$0[1];temp$0 = mac$0(k$0)(v$0);acc$0.push(temp$0);
    } else {
      ___match_error(m$0);
    }
  }$targ$2 = function (ctx$0, info$0, form$0, expr$0) {
    var t0$1 = undefined;var t1$1 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var m$1 = undefined;var acc$1 = undefined;var temp$1 = undefined;var xs$0 = undefined;var $targ$17 = undefined;var instructions$0 = undefined;$targ$17 = expr$0;t0$1 = $targ$17;if (Array.isArray(t0$1) && (t1$1 = t0$1.length, t1$1 === 2 && (t0$1[0] === "data" && (t2$0 = getProjector(["multi"])(t0$1[1]), t2$0[0] && (t3$0 = t2$0[1], t4$0 = t3$0.length, t4$0 >= 1 && t3$0[0] === "multi"))))) {
      instructions$0 = Array.prototype.slice.call(t3$0, 1);
    } else {
      ___match_error($targ$17, "#data{#multi! #multi{*instructions}}");
    }acc$1 = [];temp$1 = null;m$1 = null;$5: for (var _iterator2 = instructions$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
      m$1 = _step2.value;
      var stmt$0 = undefined;var k$1 = undefined;var v$1 = undefined;var name$0 = undefined;var t0$2 = undefined;var t1$2 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;t0$2 = m$1;if (Array.isArray(t0$2) && (t1$2 = t0$2.length, t1$2 === 3 && (t0$2[0] === "send" && (t2$1 = t0$2[1], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 2 && (t2$1[0] === "symbol" && (t2$1[1] === "=" && (t4$1 = t0$2[2], Array.isArray(t4$1) && (t5$0 = t4$1.length, t5$0 === 3 && (t4$1[0] === "data" && (k$1 = t4$1[1], v$1 = t4$1[2], t6$0 = k$1, Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 2 && t6$0[0] === "symbol")))))))))))) {
        name$0 = t6$0[1];info$0.setopt(name$0, info$0.go(v$1, "parse", "eval"));temp$1 = ["multi"];acc$1.push(temp$1);
      } else {
        stmt$0 = m$1;throw send(send(ErrorFactory(["syntax", "parameterize"]), "create", true), __amp____colon__(["Invalid parametrization"], { node: stmt$0, "::objinsert": 1 }));acc$1.push(temp$1);
      }
    }xs$0 = acc$1;return ["splice"].concat(xs$0);
  };t0$3 = getProjector(mac$0("parameterize"))($targ$2);if (t0$3[0]) {
    parameterize_mac$0 = t0$3[1];
  } else {
    ___match_error($targ$2, "mac{\"parameterize\"}! parameterize_mac{ctx, info, form, expr}");
  }ChainHandler$0 = function ChainHandler(temp$2$0) {
    var $targ$18 = undefined;var __at___$0 = undefined;if (!getChecker(ChainHandler$0)(this)) {
      __at___$0 = Object.create(ChainHandler$0.prototype);
    } else {
      __at___$0 = this;
    }__at___$0.env = temp$2$0;$targ$18 = 2;__at___$0.wrapOrder = $targ$18;return __at___$0;
  };ChainHandler$0.prototype.expand = function expand(info$1) {
    var $targ$19 = undefined;var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;$targ$19 = __at___$1.env.mark(["symbol", info$1.gensym("ph")]);__at___$1.placeholder = $targ$19;return __at___$1.placeholder;
  };ChainHandler$0.prototype.wrap = function wrap(expr$1, info$2, opt$0) {
    var __at___$2 = undefined;var self$1 = undefined;__at___$2 = this;self$1 = this;return ["send", ["symbol", "chain"], ["data", __at___$2.placeholder, expr$1]];
  };__amp____colon__(ChainHandler$0, __amp____colon__(($targ$20 = "ChainHandler", accum$0 = {}, accum$0["::name"] = $targ$20, accum$0), ($targ$21 = true, accum$1 = {}, accum$1["::egclass"] = $targ$21, accum$1)));$targ$3 = function (ph$0$0, info$3, form$1, expr$2) {
    var x$0 = undefined;var other$0 = undefined;var t0$4 = undefined;var m$2$0 = undefined;var t0$5 = undefined;var t0$6 = undefined;var t0$7 = undefined;var t1$3 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$2 = undefined;var t5$1 = undefined;var $targ$22 = undefined;var defn$0 = undefined;var env$0 = undefined;var body$0 = undefined;var it$0 = undefined;var construct$0 = undefined;var bridge$$14038$0 = undefined;if ((x$0 = ph$0$0, x$0 instanceof Array && x$0[0] === "pattern")) {
      m$2$0 = expr$2;if (Array.isArray(m$2$0) && (t0$4 = m$2$0.length, t0$4 === 1 && m$2$0[0] === "void")) {
        return ["special", ChainHandler$0(form$1.env)];
      } else {
        other$0 = m$2$0;return ["all", __lt____lt____colon__$0(other$0, expr$2), __lt____lt____colon__$0(["special", ChainHandler$0(form$1.env)], form$1)];
      }
    } else {
      bridge$$14038$0 = ph$0$0;if (Array.isArray(bridge$$14038$0) && (t0$5 = bridge$$14038$0.length, t0$5 === 2 && (bridge$$14038$0[0] === "expr" && bridge$$14038$0[1] === "expr")) || Array.isArray(bridge$$14038$0) && (t0$6 = bridge$$14038$0.length, t0$6 === 2 && (bridge$$14038$0[0] === "expr" && bridge$$14038$0[1] === "head"))) {
        $targ$22 = expr$2;t0$7 = $targ$22;if (Array.isArray(t0$7) && (t1$3 = t0$7.length, t1$3 === 3 && (t0$7[0] === "data" && (t2$2 = t0$7[1], defn$0 = t2$2, ___hasprop(t2$2, "env") && (env$0 = t2$2.env, t3$2 = getProjector(Body$0)(t0$7[2]), t3$2[0] && (t4$2 = t3$2[1], t5$1 = t4$2.length, t5$1 >= 0)))))) {
          body$0 = Array.prototype.slice.call(t4$2, 0);
        } else {
          ___match_error($targ$22, "#data{defn and {=> env}, Body! {*body}}");
        }[defn$0, env$0, body$0];it$0 = __amp__(["symbol", "@"], { env: env$0 });construct$0 = function construct(ph$1$0) {
          var x$2 = undefined;var rest$0 = undefined;var x$1 = undefined;var $$14137$0 = undefined;var $$14138$0 = undefined;var t0$8 = undefined;var t1$4 = undefined;t0$8 = ph$1$0;t1$4 = t0$8.length;if (t1$4 === 1) {
            x$1 = t0$8[0];return x$1;
          } else {
            if (t1$4 >= 1) {
              x$2 = t0$8[0];rest$0 = Array.prototype.slice.call(t0$8, 1);return ["send", ["symbol", "let"], ["data", ["send", ["symbol", "="], ["data", it$0, x$2]], construct$0(rest$0)]];
            } else {
              return ___match_error(ph$1$0, "{x, *rest}");
            }
          }
        };return construct$0([defn$0].concat(body$0));
      } else {
        return ["nostep", form$1];
      }
    }
  };t0$9 = getProjector(mac$0("chain"))($targ$3);if (t0$9[0]) {
    chain_mac$0 = t0$9[1];
  } else {
    ___match_error($targ$3, "mac{\"chain\"}! chain_mac{match, info, form, expr}");
  }$targ$4 = function (temp$3$0, form$2, temp$4$0) {
    var t0$10 = undefined;var t1$5 = undefined;var t2$3 = undefined;var it$1 = undefined;var defn$1 = undefined;var env$1 = undefined;var body$1 = undefined;t0$10 = temp$4$0;if (Array.isArray(t0$10) && (t1$5 = t0$10.length, t1$5 === 3 && (t0$10[0] === "data" && (t2$3 = t0$10[1], defn$1 = t2$3, ___hasprop(t2$3, "env"))))) {
      env$1 = t2$3.env;body$1 = t0$10[2];
    } else {
      ___match_error(temp$4$0);
    }it$1 = __amp__(["symbol", "@"], { env: env$1 });return ["send", ["symbol", "let"], ["data", ["send", ["symbol", "="], ["data", it$1, defn$1]], body$1]];
  };t0$11 = getProjector(expr_mac$0)($targ$4);if (t0$11[0] && (t1$6 = getProjector(mac$0("using"))(t0$11[1]), t1$6[0])) {
    using_mac$0 = t1$6[1];
  } else {
    ___match_error($targ$4, "expr_mac! mac{\"using\"}! using_mac{_, form, #data{defn and {=> env}, body}}");
  }$targ$5 = function (ph$2$0, temp$5$0, form$3, temp$6$0) {
    var t0$12 = undefined;var t1$7 = undefined;var x$3 = undefined;var x$4 = undefined;var t0$13 = undefined;var t1$8 = undefined;var t2$4 = undefined;var $targ$23 = undefined;var stmts$0 = undefined;var x$5 = undefined;var body$2 = undefined;t0$12 = temp$6$0;if (Array.isArray(t0$12) && (t1$7 = t0$12.length, t1$7 === 2 && t0$12[0] === "data")) {
      body$2 = t0$12[1];
    } else {
      ___match_error(temp$6$0);
    }if ((x$3 = ph$2$0, x$3 instanceof Array && x$3[0] === "clause")) {
      return ["block", body$2];
    } else {
      if ((x$4 = ph$2$0, x$4 instanceof Array && x$4[0] === "test")) {
        $targ$23 = body$2;t0$13 = getProjector(Body$0)($targ$23);if (t0$13[0] && (t1$8 = t0$13[1], t2$4 = t1$8.length, t2$4 >= 0)) {
          stmts$0 = Array.prototype.slice.call(t1$8, 0);
        } else {
          ___match_error($targ$23, "Body! {*stmts}");
        }return ["do", ["splice"].concat(stmts$0)];
      } else {
        if ((x$5 = ph$2$0, x$5 instanceof Array && x$5[0] === "expr")) {
          return ["multi", body$2];
        } else {
          return ___match_error(ph$2$0, "#expr");
        }
      }
    }
  };t0$14 = getProjector(overridable$0)($targ$5);if (t0$14[0] && (t1$9 = getProjector(mac$0("do"))(t0$14[1]), t1$9[0])) {
    do_mac$0 = t1$9[1];
  } else {
    ___match_error($targ$5, "overridable! mac{\"do\"}! do_mac{match, _, form, #data{body}}");
  }$targ$6 = function (context$0, temp$7$0, form$4, temp$8$0) {
    var t0$15 = undefined;var t0$16 = undefined;var t1$10 = undefined;var x$6 = undefined;var x$7 = undefined;var bridge$$14322$0 = undefined;var m$3$0 = undefined;var m$4 = undefined;var m$9 = undefined;var x$13 = undefined;var t0$28 = undefined;var m$8$0 = undefined;var xs$1 = undefined;var x$14 = undefined;var pair$1 = undefined;var k$3 = undefined;var v$3 = undefined;var args$1 = undefined;var $$14662$0 = undefined;var $$14663$0 = undefined;var t0$26 = undefined;var t1$15 = undefined;var t2$7 = undefined;var t3$4 = undefined;var t4$4 = undefined;var m$7$0 = undefined;var inner__minus__scope$0 = undefined;var wrap$0 = undefined;var tags$0 = undefined;var kv$0 = undefined;var parse$0 = undefined;var node$0 = undefined;var info$4 = undefined;var env$2 = undefined;var descr$0 = undefined;var contents$0 = undefined;t0$15 = temp$7$0;info$4 = t0$15;if (___hasprop(t0$15, "env")) {
      env$2 = t0$15.env;
    } else {
      ___match_error(temp$7$0);
    }t0$16 = temp$8$0;if (Array.isArray(t0$16) && (t1$10 = t0$16.length, t1$10 === 3 && t0$16[0] === "data")) {
      descr$0 = t0$16[1];contents$0 = t0$16[2];
    } else {
      ___match_error(temp$8$0);
    }m$3$0 = context$0;bridge$$14322$0 = m$3$0;if ((x$6 = bridge$$14322$0, x$6 instanceof Array && x$6[0] === "check") || (x$7 = bridge$$14322$0, x$7 instanceof Array && x$7[0] === "project")) {
      return ["nostep", form$4];
    } else {
      undefined;
    }inner__minus__scope$0 = info$4.scope.fork();m$4 = function m() {
      var x$8 = undefined;var t0$17 = undefined;var t1$11 = undefined;var t2$5 = undefined;var m$5$0 = undefined;m$5$0 = arguments;t0$17 = m$5$0.length;if (t0$17 >= 1 && (Array.prototype.slice.call(m$5$0, 0, -1), t1$11 = m$5$0[t0$17 - 1], Array.isArray(t1$11) && (t2$5 = t1$11.length, t2$5 === 2 && t1$11[0] === "data"))) {
        x$8 = t1$11[1];return x$8;
      } else {
        return ___match_error(m$5$0, "{*, `{^x}`}");
      }
    };env$2.bind(inner__minus__scope$0, "wrap-quote", ["macro", m$4]);wrap$0 = function wrap(x$9) {
      return ["use", inner__minus__scope$0, x$9];
    };tags$0 = ["data"];kv$0 = ["data", ["symbol", "="]];parse$0 = function parse(temp$9$0) {
      var t0$18 = undefined;var t0$20 = undefined;var t0$21 = undefined;var t1$13 = undefined;var t0$22 = undefined;var t0$23 = undefined;var t1$14 = undefined;var t0$24 = undefined;var t0$25 = undefined;var m$6 = undefined;var acc$2 = undefined;var temp$10 = undefined;var args$0 = undefined;var expr$4 = undefined;var rest$1 = undefined;var expr$3 = undefined;var x$12 = undefined;var x$11 = undefined;var x$10 = undefined;var s$0 = undefined;var $$14422$0 = undefined;var $$14423$0 = undefined;var $$14424$0 = undefined;var $$14425$0 = undefined;var $$14426$0 = undefined;var $$14427$0 = undefined;var $$14428$0 = undefined;var $$14429$0 = undefined;var $$14430$0 = undefined;var t0$19 = undefined;var t1$12 = undefined;var t2$6 = undefined;var t3$3 = undefined;var t4$3 = undefined;var t5$2 = undefined;var t6$1 = undefined;var t7$1 = undefined;var bridge$$14414$0 = undefined;var bridge$$14416$0 = undefined;var bridge$$14421$0 = undefined;var whole$0 = undefined;var ph$3$0 = undefined;t0$18 = temp$9$0;whole$0 = t0$18;ph$3$0 = t0$18;t0$19 = ph$3$0;t1$12 = t0$19.length;if (t1$12 === 1 && t0$19[0] === "void") {
        return null;
      } else {
        if (($$14424$0 = t1$12 === 2) && t0$19[0] === "symbol") {
          s$0 = t0$19[1];return tags$0.push(["value", s$0]);
        } else {
          if ($$14424$0 && (t0$19[0] === "value" && (t2$6 = [true, String(t0$19[1])], t2$6[0]))) {
            x$10 = t2$6[1];return tags$0.push(["value", x$10]);
          } else {
            if (($$14424$0 = t1$12 === 3) && (($$14425$0 = t0$19[0] === "send") && (t2$6 = t0$19[1], ($$14427$0 = Array.isArray(t2$6)) && (t3$3 = t2$6.length, ($$14429$0 = t3$3 === 2) && (($$14430$0 = t2$6[0] === "symbol") && (t2$6[1] === "." && (t4$3 = t0$19[2], Array.isArray(t4$3) && (t5$2 = t4$3.length, t5$2 === 3 && (t4$3[0] === "data" && (t6$1 = t4$3[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && (t6$1[0] === "void" && (bridge$$14414$0 = t4$3[2], Array.isArray(bridge$$14414$0) && (t0$20 = bridge$$14414$0.length, t0$20 === 2 && (bridge$$14414$0[0] === "symbol" && (x$11 = bridge$$14414$0[1], true))) || Array.isArray(bridge$$14414$0) && (t0$21 = bridge$$14414$0.length, t0$21 === 2 && (bridge$$14414$0[0] === "value" && (t1$13 = [true, String(bridge$$14414$0[1])], t1$13[0] && (x$11 = t1$13[1], true))))))))))))))))) {
              return tags$0.push(["value", "." + x$11]);
            } else {
              if ($$14430$0 && (t2$6[1] === "#" && (t4$3 = t0$19[2], Array.isArray(t4$3) && (t5$2 = t4$3.length, t5$2 === 3 && (t4$3[0] === "data" && (t6$1 = t4$3[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && (t6$1[0] === "void" && (bridge$$14416$0 = t4$3[2], Array.isArray(bridge$$14416$0) && (t0$22 = bridge$$14416$0.length, t0$22 === 2 && (bridge$$14416$0[0] === "symbol" && (x$12 = bridge$$14416$0[1], true))) || Array.isArray(bridge$$14416$0) && (t0$23 = bridge$$14416$0.length, t0$23 === 2 && (bridge$$14416$0[0] === "value" && (t1$14 = [true, String(bridge$$14416$0[1])], t1$14[0] && (x$12 = t1$14[1], true))))))))))))) {
                return tags$0.push(["value", "#" + x$12]);
              } else {
                if ($$14430$0 && (t2$6[1] === "^" && (t4$3 = t0$19[2], Array.isArray(t4$3) && (t5$2 = t4$3.length, t5$2 === 3 && (t4$3[0] === "data" && (t6$1 = t4$3[1], Array.isArray(t6$1) && (t7$1 = t6$1.length, t7$1 === 1 && t6$1[0] === "void"))))))) {
                  expr$3 = t4$3[2];return tags$0.push(expr$3);
                } else {
                  if ($$14430$0 && (t2$6[1] === "=" && (t4$3 = t0$19[2], Array.isArray(t4$3) && (t5$2 = t4$3.length, t5$2 === 3 && t4$3[0] === "data")))) {
                    t4$3[1];t4$3[2];return kv$0.push(whole$0);
                  } else {
                    if ($$14425$0) {
                      expr$4 = t0$19[1];rest$1 = t0$19[2];parse$0(expr$4);return parse$0(rest$1);
                    } else {
                      bridge$$14421$0 = ph$3$0;if (Array.isArray(bridge$$14421$0) && (t0$24 = bridge$$14421$0.length, t0$24 >= 1 && (bridge$$14421$0[0] === "multi" && (args$0 = Array.prototype.slice.call(bridge$$14421$0, 1), true))) || Array.isArray(bridge$$14421$0) && (t0$25 = bridge$$14421$0.length, t0$25 >= 1 && (bridge$$14421$0[0] === "data" && (args$0 = Array.prototype.slice.call(bridge$$14421$0, 1), true)))) {
                        acc$2 = [];temp$10 = null;m$6 = null;$6: for (var _iterator2 = args$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                          m$6 = _step2.value;
                          var arg$0 = undefined;arg$0 = m$6;temp$10 = parse$0(arg$0);acc$2.push(temp$10);
                        }return acc$2;
                      } else {
                        return ___match_error(ph$3$0, "#multi{*args} or #data{*args}");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };parse$0(descr$0);m$7$0 = contents$0;if (($$14662$0 = Array.isArray(m$7$0)) && (t0$26 = m$7$0.length, t0$26 === 1 && m$7$0[0] === "void")) {
      contents$0 = ["array"];
    } else {
      if ($$14662$0 && (t0$26 >= 1 && m$7$0[0] === "multi")) {
        args$1 = Array.prototype.slice.call(m$7$0, 1);xs$1 = [];m$9 = null;$7: for (var _iterator2 = args$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
          m$9 = _step2.value;
          var other$1 = undefined;var spl$0 = undefined;var pair$0 = undefined;var k$2 = undefined;var v$2 = undefined;var $$14690$0 = undefined;var t0$27 = undefined;var t1$16 = undefined;var t2$8 = undefined;var t3$5 = undefined;var t4$5 = undefined;var t5$3 = undefined;var t6$2 = undefined;var t7$2 = undefined;t0$27 = m$9;pair$0 = t0$27;if (Array.isArray(t0$27) && (t1$16 = t0$27.length, t1$16 === 3 && (t0$27[0] === "send" && (t2$8 = t0$27[1], Array.isArray(t2$8) && (t3$5 = t2$8.length, t3$5 === 2 && (t2$8[0] === "symbol" && (t2$8[1] === "=" && (t4$5 = t0$27[2], Array.isArray(t4$5) && (t5$3 = t4$5.length, t5$3 === 3 && t4$5[0] === "data"))))))))) {
            k$2 = t4$5[1];v$2 = t4$5[2];kv$0.push(pair$0);
          } else {
            spl$0 = t0$27;if (Array.isArray(t0$27) && (t1$16 = t0$27.length, t1$16 === 3 && (t0$27[0] === "send" && (t2$8 = t0$27[1], Array.isArray(t2$8) && (t3$5 = t2$8.length, t3$5 === 2 && (t2$8[0] === "symbol" && (t2$8[1] === "**" && (t4$5 = t0$27[2], Array.isArray(t4$5) && (t5$3 = t4$5.length, t5$3 === 3 && (t4$5[0] === "data" && (t6$2 = t4$5[1], Array.isArray(t6$2) && (t7$2 = t6$2.length, t7$2 === 1 && t6$2[0] === "void")))))))))))) {
              t4$5[2];kv$0.push(spl$0);
            } else {
              other$1 = m$9;xs$1.push(wrap$0(other$1));
            }
          }
        }m$8$0 = xs$1;if (Array.isArray(m$8$0) && (t0$28 = m$8$0.length, t0$28 === 1)) {
          x$13 = m$8$0[0];contents$0 = x$13;
        } else {
          contents$0 = ["array"].concat(xs$1);
        }
      } else {
        pair$1 = m$7$0;if (Array.isArray(m$7$0) && (t0$26 = m$7$0.length, t0$26 === 3 && (m$7$0[0] === "send" && (t1$15 = m$7$0[1], Array.isArray(t1$15) && (t2$7 = t1$15.length, t2$7 === 2 && (t1$15[0] === "symbol" && (t1$15[1] === "=" && (t3$4 = m$7$0[2], Array.isArray(t3$4) && (t4$4 = t3$4.length, t4$4 === 3 && t3$4[0] === "data"))))))))) {
          k$3 = t3$4[1];v$3 = t3$4[2];kv$0.push(pair$1);contents$0 = ["array"];
        } else {
          x$14 = m$7$0;contents$0 = wrap$0(x$14);
        }
      }
    }node$0 = form$4.env.mark(["symbol", "ENode"]);return ["send", node$0, ["data", tags$0, kv$0, contents$0]];
  };t0$29 = getProjector(overridable$0)($targ$6);if (t0$29[0] && (t1$17 = getProjector(mac$0("%"))(t0$29[1]), t1$17[0])) {
    buildnode_mac$0 = t1$17[1];
  } else {
    ___match_error($targ$6, "overridable! mac{\"%\"}! buildnode_mac{context\n                                     info and {=> env}\n                                     form\n                                     #data{descr, var contents}}");
  }$targ$7 = function (context$1, info$5, form$5, temp$11$0) {
    var t0$30 = undefined;var text$1 = undefined;var text$0 = undefined;var m$10$0 = undefined;var t0$31 = undefined;var t1$18 = undefined;var t2$9 = undefined;var t3$6 = undefined;var arg$1 = undefined;var ph$4$0 = undefined;t0$30 = temp$11$0;arg$1 = t0$30;ph$4$0 = t0$30;t0$31 = ph$4$0;t1$18 = t0$31.length;if (t1$18 === 3 && (t0$31[0] === "send" && (t2$9 = t0$31[1], Array.isArray(t2$9) && (t3$6 = t2$9.length, t3$6 === 2 && (t2$9[0] === "symbol" && t2$9[1] === "'"))))) {
      t0$31[2];return ["send", ["symbol", "String"], ["data", arg$1]];
    } else {
      return ["value", (m$10$0 = info$5.gettext(arg$1), getChecker(RegExp("^\\[(.|\\n)*\\]$", ""))(m$10$0) ? (text$0 = m$10$0, text$0.substring(1, text$0.length - 1)) : (text$1 = m$10$0, text$1))];
    }
  };t0$32 = getProjector(mac$0("S"))($targ$7);if (t0$32[0]) {
    S_mac$0 = t0$32[1];
  } else {
    ___match_error($targ$7, "mac{\"S\"}! S_mac{context, info, form, match arg}");
  }$targ$8 = function (context$2, info$6, form$6, ph$5$0) {
    var arg$2 = undefined;var t0$33 = undefined;var t1$19 = undefined;t0$33 = ph$5$0;t1$19 = t0$33.length;if (t1$19 === 1 && t0$33[0] === "void") {
      return ["send", ["send", ["symbol", "console"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "log"]]]], ["data"]];
    } else {
      arg$2 = ph$5$0;return ["multi", ["send", ["symbol", "="], ["data", ["symbol", "t"], arg$2]], ["send", ["send", ["symbol", "console"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "log"]]]], ["data", ["symbol", "t"]]], ["symbol", "t"]];
    }
  };t0$34 = getProjector(mac$0("print"))($targ$8);if (t0$34[0]) {
    print_mac$0 = t0$34[1];
  } else {
    ___match_error($targ$8, "mac{\"print\"}! print_mac{context, info, form, match}");
  }$targ$9 = function (ctx$1, info$7, form$7, expr$5) {
    var accum$2 = undefined;var cases$0 = undefined;accum$2 = {};accum$2.project = function project(temp$12$0) {
      var t0$35 = undefined;var t0$37 = undefined;var t1$21 = undefined;var $targ$24 = undefined;var at$0 = undefined;var self$2 = undefined;var args$3 = undefined;var body$4 = undefined;var args$2 = undefined;var pre$0 = undefined;var body$3 = undefined;var post$0 = undefined;var gen$0 = undefined;var $$14939$0 = undefined;var $$14940$0 = undefined;var $$14941$0 = undefined;var $$14942$0 = undefined;var $$14943$0 = undefined;var $$14944$0 = undefined;var $$14945$0 = undefined;var $$14946$0 = undefined;var $$14947$0 = undefined;var t0$36 = undefined;var t1$20 = undefined;var t2$10 = undefined;var t3$7 = undefined;var t4$6 = undefined;var t5$4 = undefined;var expr$6 = undefined;var ph$6$0 = undefined;t0$35 = temp$12$0;expr$6 = t0$35;ph$6$0 = t0$35;t0$36 = ph$6$0;t1$20 = t0$36.length;if (($$14941$0 = t1$20 === 3) && (($$14942$0 = t0$36[0] === "send") && (t2$10 = t0$36[1], ($$14944$0 = Array.isArray(t2$10)) && (t3$7 = t2$10.length, ($$14946$0 = t3$7 === 2) && (($$14947$0 = t2$10[0] === "symbol") && (t2$10[1] === "_lambda" && (t4$6 = t0$36[2], Array.isArray(t4$6) && (t5$4 = t4$6.length, t5$4 === 6 && t4$6[0] === "data")))))))) {
        args$2 = t4$6[1];pre$0 = t4$6[2];body$3 = t4$6[3];post$0 = t4$6[4];gen$0 = t4$6[5];$targ$24 = info$7.mark(["symbol", "@"], ["symbol", "self"]);t0$37 = $targ$24;if (Array.isArray(t0$37) && (t1$21 = t0$37.length, t1$21 === 2)) {
          at$0 = t0$37[0];self$2 = t0$37[1];
        } else {
          ___match_error($targ$24, "{at, self}");
        }[at$0, self$2];return ["send", ["symbol", "_lambda"], ["data", args$2, ["multi", pre$0, ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], ["send", ["symbol", "and"], ["data", at$0, self$2]]], ["symbol", "this"]]]], body$3, post$0, gen$0]];
      } else {
        if ($$14947$0 && (t2$10[1] === "->" && (t4$6 = t0$36[2], Array.isArray(t4$6) && (t5$4 = t4$6.length, t5$4 === 3 && t4$6[0] === "data")))) {
          args$3 = t4$6[1];body$4 = t4$6[2];return info$7.mark(["send", ["symbol", "@->"], ["data", args$3, body$4]]);
        } else {
          throw send(send(ErrorFactory(["syntax", "invalidMethod"]), "create", true), __amp____colon__(["Invalid use of method"], { node: expr$6, "::objinsert": 1 }));
        }
      }
    };cases$0 = accum$2;return multimacro$0(cases$0)(ctx$1, info$7, form$7, expr$5);
  };t0$38 = getProjector(mac$0("method"))($targ$9);if (t0$38[0]) {
    method_mac$0 = t0$38[1];
  } else {
    ___match_error($targ$9, "mac{\"method\"}! method_mac{ctx, info, form, expr}");
  }$targ$10 = function (context$3, temp$13$0, form$8, expr$7) {
    var t0$39 = undefined;var t0$53 = undefined;var t1$30 = undefined;var t2$17 = undefined;var t0$54 = undefined;var name$4 = undefined;var name$3 = undefined;var super$3 = undefined;var name$2 = undefined;var super$2 = undefined;var $$15047$0 = undefined;var $$15048$0 = undefined;var $$15049$0 = undefined;var $$15050$0 = undefined;var $$15051$0 = undefined;var t0$52 = undefined;var t1$29 = undefined;var t2$16 = undefined;var t3$13 = undefined;var t4$11 = undefined;var t5$9 = undefined;var bridge$$15046$0 = undefined;var stmts$3 = undefined;var ph$7$0 = undefined;var stmts$2 = undefined;var $$15053$0 = undefined;var $$15054$0 = undefined;var t0$51 = undefined;var t1$28 = undefined;var t2$15 = undefined;var t3$12 = undefined;var m$11$0 = undefined;var helper$0 = undefined;var info$8 = undefined;var env$3 = undefined;t0$39 = temp$13$0;info$8 = t0$39;if (___hasprop(t0$39, "env")) {
      env$3 = t0$39.env;
    } else {
      ___match_error(temp$13$0);
    }helper$0 = function helper(name$1, super$1, stmts$1) {
      var m$14 = undefined;var acc$3 = undefined;var temp$14 = undefined;var t0$47 = undefined;var t1$27 = undefined;var t0$48 = undefined;var $targ$27 = undefined;var env2$0 = undefined;var it$3 = undefined;var cls$0 = undefined;var name_str$0 = undefined;var t0$49 = undefined;var m$12$0 = undefined;var other$3 = undefined;var t0$50 = undefined;var m$13$0 = undefined;var statics$0 = undefined;var ctor$0 = undefined;var new_stmts$0 = undefined;var $targ$25 = undefined;var ctor_args$0 = undefined;var ctor_body$0 = undefined;var ctor_expr$0 = undefined;var node$1 = undefined;statics$0 = ["data", ["symbol", "="]];ctor$0 = [["data"], __amp__(["multi"], { env: env$3 })];acc$3 = [];temp$14 = null;m$14 = null;$8: for (var _iterator2 = stmts$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$14 = _step2.value;
        var t0$41 = undefined;var t1$23 = undefined;var t2$12 = undefined;var t3$9 = undefined;var t4$8 = undefined;var t5$6 = undefined;var t6$4 = undefined;var t7$4 = undefined;var t8$1 = undefined;var t0$42 = undefined;var t1$24 = undefined;var t2$13 = undefined;var t3$10 = undefined;var t4$9 = undefined;var t5$7 = undefined;var t6$5 = undefined;var t7$5 = undefined;var t8$2 = undefined;var t9$0 = undefined;var t10$0 = undefined;var t11$0 = undefined;var t12$0 = undefined;var accum$3 = undefined;var accum$4 = undefined;var accum$5 = undefined;var accum$6 = undefined;var opt$1 = undefined;var stmt$1 = undefined;var lhs$0 = undefined;var rhs$0 = undefined;var args$4 = undefined;var body$5 = undefined;var methods$0 = undefined;var t0$40 = undefined;var t1$22 = undefined;var t2$11 = undefined;var t3$8 = undefined;var t4$7 = undefined;var t5$5 = undefined;var t6$3 = undefined;var t7$3 = undefined;var t8$0 = undefined;var bridge$$15082$0 = undefined;t0$40 = m$14;if (Array.isArray(t0$40) && (t1$22 = t0$40.length, t1$22 === 3 && (t0$40[0] === "send" && (t2$11 = t0$40[1], Array.isArray(t2$11) && (t3$8 = t2$11.length, t3$8 === 2 && (t2$11[0] === "symbol" && (t2$11[1] === "static" && (t4$7 = t0$40[2], Array.isArray(t4$7) && (t5$5 = t4$7.length, t5$5 === 2 && (t4$7[0] === "data" && (t6$3 = getProjector(Body$0)(t4$7[1]), t6$3[0] && (t7$3 = t6$3[1], t8$0 = t7$3.length, t8$0 >= 0)))))))))))) {
          methods$0 = Array.prototype.slice.call(t7$3, 0);temp$14 = statics$0 = statics$0.concat(methods$0);acc$3.push(temp$14);
        } else {
          bridge$$15082$0 = m$14;if (Array.isArray(bridge$$15082$0) && (t0$41 = bridge$$15082$0.length, t0$41 === 3 && (bridge$$15082$0[0] === "send" && (t1$23 = bridge$$15082$0[1], Array.isArray(t1$23) && (t2$12 = t1$23.length, t2$12 === 2 && (t1$23[0] === "symbol" && (t1$23[1] === "=" && (t3$9 = bridge$$15082$0[2], Array.isArray(t3$9) && (t4$8 = t3$9.length, t4$8 === 3 && (t3$9[0] === "data" && (t5$6 = t3$9[1], Array.isArray(t5$6) && (t6$4 = t5$6.length, t6$4 === 3 && (t5$6[0] === "send" && (t7$4 = t5$6[1], Array.isArray(t7$4) && (t8$1 = t7$4.length, t8$1 === 2 && (t7$4[0] === "symbol" && (t7$4[1] === "constructor" && (args$4 = t5$6[2], body$5 = t3$9[2], true))))))))))))))))) || Array.isArray(bridge$$15082$0) && (t0$42 = bridge$$15082$0.length, t0$42 === 3 && (bridge$$15082$0[0] === "send" && (t1$24 = bridge$$15082$0[1], Array.isArray(t1$24) && (t2$13 = t1$24.length, t2$13 === 2 && (t1$24[0] === "symbol" && (t1$24[1] === "=" && (t3$10 = bridge$$15082$0[2], Array.isArray(t3$10) && (t4$9 = t3$10.length, t4$9 === 3 && (t3$10[0] === "data" && (t5$7 = t3$10[1], Array.isArray(t5$7) && (t6$5 = t5$7.length, t6$5 === 2 && (t5$7[0] === "symbol" && (t5$7[1] === "constructor" && (t7$5 = t3$10[2], Array.isArray(t7$5) && (t8$2 = t7$5.length, t8$2 === 3 && (t7$5[0] === "send" && (t9$0 = t7$5[1], Array.isArray(t9$0) && (t10$0 = t9$0.length, t10$0 === 2 && (t9$0[0] === "symbol" && (t9$0[1] === "->" && (t11$0 = t7$5[2], Array.isArray(t11$0) && (t12$0 = t11$0.length, t12$0 === 3 && (t11$0[0] === "data" && (args$4 = t11$0[1], body$5 = t11$0[2], true))))))))))))))))))))))))) {
            ctor$0 = [args$4, body$5];temp$14 = ["splice"];acc$3.push(temp$14);
          } else {
            t0$40 = m$14;if (Array.isArray(t0$40) && (t1$22 = t0$40.length, t1$22 === 3 && (t0$40[0] === "send" && (t2$11 = t0$40[1], Array.isArray(t2$11) && (t3$8 = t2$11.length, t3$8 === 2 && (t2$11[0] === "symbol" && (t2$11[1] === "=" && (t4$7 = t0$40[2], Array.isArray(t4$7) && (t5$5 = t4$7.length, t5$5 === 3 && t4$7[0] === "data"))))))))) {
              lhs$0 = t4$7[1];rhs$0 = t4$7[2];opt$1 = __amp__(pattern_handlers$0.build_object, __amp____colon__({ allow_nested: false }, __amp____colon__((accum$3 = {}, accum$3.assign = function assign(ph$8$0, value$0) {
                var t0$43 = undefined;var t1$25 = undefined;var t0$44 = undefined;var v$5 = undefined;var v$4 = undefined;var bridge$$15336$0 = undefined;bridge$$15336$0 = ph$8$0;if (Array.isArray(bridge$$15336$0) && (t0$43 = bridge$$15336$0.length, t0$43 === 2 && (bridge$$15336$0[0] === "symbol" && (t1$25 = getProjector(camelCase$0)(bridge$$15336$0[1]), t1$25[0] && (v$4 = t1$25[1], true)))) || Array.isArray(bridge$$15336$0) && (t0$44 = bridge$$15336$0.length, t0$44 === 2 && (bridge$$15336$0[0] === "value" && (v$4 = bridge$$15336$0[1], true)))) {
                  return ["do", __lt____lt____colon__$0(["assign", ["send", ["send", name$1, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "prototype"]]]], ["value", v$4]], value$0], v$4)];
                } else {
                  v$5 = ph$8$0;return ["do", __lt____lt____colon__$0(["assign", ["send", ["send", name$1, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "prototype"]]]], v$5], value$0], v$5)];
                }
              }, accum$3), __amp____colon__((accum$4 = {}, accum$4.declare = function declare(vars$0) {
                return [];
              }, accum$4), __amp____colon__((accum$5 = {}, accum$5.wrap_target = function wrap_target(ph$9$0) {
                var t0$46 = undefined;var $targ$26 = undefined;var other_env$0 = undefined;var it$2 = undefined;var it2$0 = undefined;var other$2 = undefined;var args$5 = undefined;var body$6 = undefined;var t0$45 = undefined;var t1$26 = undefined;var t2$14 = undefined;var t3$11 = undefined;var t4$10 = undefined;var t5$8 = undefined;t0$45 = ph$9$0;t1$26 = t0$45.length;if (t1$26 === 3 && (t0$45[0] === "send" && (t2$14 = t0$45[1], Array.isArray(t2$14) && (t3$11 = t2$14.length, t3$11 === 2 && (t2$14[0] === "symbol" && (t2$14[1] === "->" && (t4$10 = t0$45[2], Array.isArray(t4$10) && (t5$8 = t4$10.length, t5$8 === 3 && t4$10[0] === "data")))))))) {
                  args$5 = t4$10[1];body$6 = t4$10[2];$targ$26 = body$6;t0$46 = $targ$26;if (___hasprop(t0$46, "env")) {
                    other_env$0 = t0$46.env;
                  } else {
                    ___match_error($targ$26, "{env => other_env}");
                  }it$2 = __amp__(["symbol", "@"], { env: other_env$0 });it2$0 = __amp__(["symbol", "self"], { env: other_env$0 });return ["send", ["symbol", "_lambda"], ["data", args$5, ["send", ["symbol", "splice"], ["data", ["multi", ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], it$2], ["symbol", "this"]]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], it2$0], ["symbol", "this"]]]]]], body$6, ["value", null], ["value", false]]];
                } else {
                  other$2 = ph$9$0;return other$2;
                }
              }, accum$5), (accum$6 = {}, accum$6.success = function success(temp$15$0) {
                return ["splice"];
              }, accum$6))))));temp$14 = PatternCompiler$0(lhs$0, info$8, opt$1).extract_from_rhs(rhs$0);acc$3.push(temp$14);
            } else {
              stmt$1 = m$14;throw ErrorFactory(["syntax", "class"]).create("Illegal statement in class", { stmt: stmt$1 });acc$3.push(temp$14);
            }
          }
        }
      }new_stmts$0 = acc$3;$targ$25 = ctor$0;t0$47 = $targ$25;if (Array.isArray(t0$47) && (t1$27 = t0$47.length, t1$27 === 2)) {
        ctor_args$0 = t0$47[0];ctor_body$0 = t0$47[1];
      } else {
        ___match_error($targ$25, "{ctor_args, ctor_body}");
      }[ctor_args$0, ctor_body$0];$targ$27 = ctor_body$0;t0$48 = $targ$27;if (___hasprop(t0$48, "env")) {
        env2$0 = t0$48.env;
      } else {
        ___match_error($targ$27, "{env => env2}");
      }it$3 = __amp__(["symbol", "@"], { env: env2$0 });cls$0 = ["send", ["symbol", "_lambda"], ["data", ctor_args$0, ["send", ["symbol", "="], ["data", it$3, ["send", ["symbol", "if"], ["data", ["send", ["symbol", "not"], ["data", ["void"], ["send", ["symbol", "?"], ["data", name$1, ["symbol", "this"]]]]], ["send", ["send", ["symbol", "Object"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "create"]]]], ["data", ["send", name$1, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "prototype"]]]]]], ["symbol", "this"]]]]], ctor_body$0, it$3, ["value", false]]];if (super$1) {
        ctor_expr$0 = ["send", ["symbol", "___extend"], ["data", cls$0, super$1]];
      } else {
        ctor_expr$0 = cls$0;
      }m$12$0 = name$1;if (Array.isArray(m$12$0) && (t0$49 = m$12$0.length, t0$49 === 2 && m$12$0[0] === "symbol")) {
        name_str$0 = m$12$0[1];statics$0.push(["send", ["symbol", "="], ["data", ["value", "::name"], ["value", name_str$0]]]);
      } else {
        undefined;
      }statics$0.push(["send", ["symbol", "="], ["data", ["value", "::egclass"], ["symbol", "true"]]]);node$1 = ["splice", ["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], name$1], ctor_expr$0]]].concat(new_stmts$0).concat([["send", ["symbol", "&:"], ["data", name$1, statics$0]], name$1]);m$13$0 = context$3;if (Array.isArray(m$13$0) && (t0$50 = m$13$0.length, t0$50 === 2 && (m$13$0[0] === "expr" && m$13$0[1] === "multi"))) {
        return node$1;
      } else {
        other$3 = m$13$0;return ["multi", node$1];
      }
    };m$11$0 = expr$7;if (($$15053$0 = Array.isArray(m$11$0)) && (t0$51 = m$11$0.length, t0$51 === 3 && (m$11$0[0] === "data" && (ph$7$0 = m$11$0[1], t1$28 = getProjector(Body$0)(m$11$0[2]), t1$28[0] && (t2$15 = t1$28[1], t3$12 = t2$15.length, t3$12 >= 0))))) {
      stmts$2 = Array.prototype.slice.call(t2$15, 0);t0$52 = ph$7$0;if (($$15048$0 = Array.isArray(t0$52)) && (t1$29 = t0$52.length, ($$15050$0 = t1$29 === 3) && (($$15051$0 = t0$52[0] === "send") && (t2$16 = t0$52[1], Array.isArray(t2$16) && (t3$13 = t2$16.length, t3$13 === 2 && (t2$16[0] === "symbol" && (t2$16[1] === "<" && (t4$11 = t0$52[2], Array.isArray(t4$11) && (t5$9 = t4$11.length, t5$9 === 3 && t4$11[0] === "data"))))))))) {
        name$2 = t4$11[1];super$2 = t4$11[2];return helper$0(name$2, super$2, stmts$2);
      } else {
        if ($$15051$0 && (name$3 = t0$52[1], t2$16 = t0$52[2], Array.isArray(t2$16) && (t3$13 = t2$16.length, t3$13 === 2 && t2$16[0] === "data"))) {
          super$3 = t2$16[1];return helper$0(name$3, super$3, stmts$2);
        } else {
          bridge$$15046$0 = ph$7$0;if (Array.isArray(bridge$$15046$0) && (t0$53 = bridge$$15046$0.length, t0$53 === 3 && (bridge$$15046$0[0] === "send" && (name$4 = bridge$$15046$0[1], t1$30 = bridge$$15046$0[2], Array.isArray(t1$30) && (t2$17 = t1$30.length, t2$17 === 1 && t1$30[0] === "data")))) || Array.isArray(bridge$$15046$0) && (t0$54 = bridge$$15046$0.length, t0$54 === 2 && (bridge$$15046$0[0] === "symbol" && (bridge$$15046$0[1], name$4 = bridge$$15046$0, true)))) {
            return helper$0(name$4, null, stmts$2);
          } else {
            return ___match_error(ph$7$0, "`[^name {}]` or [#symbol{_} and name]");
          }
        }
      }
    } else {
      if ($$15053$0 && (t0$51 === 2 && (m$11$0[0] === "data" && (t1$28 = getProjector(Body$0)(m$11$0[1]), t1$28[0] && (t2$15 = t1$28[1], t3$12 = t2$15.length, t3$12 >= 0))))) {
        stmts$3 = Array.prototype.slice.call(t2$15, 0);return helper$0(["symbol", info$8.gensym()], null, stmts$3);
      } else {
        return ___match_error(m$11$0, "#data{Body! {*stmts}}");
      }
    }
  };t0$55 = getProjector(mac$0("class"))($targ$10);if (t0$55[0]) {
    class_mac$0 = t0$55[1];
  } else {
    ___match_error($targ$10, "mac{\"class\"}! class_mac{context, info and {=> env}, form, expr}");
  }errf_macro$0 = function errf_macro(tags$1) {
    return function (ph$10$0, temp$16$0, form$9, expr$8) {
      var x$15 = undefined;var x$16 = undefined;var other$4 = undefined;var args$6 = undefined;var $$15710$0 = undefined;var $$15711$0 = undefined;var t0$56 = undefined;var m$15$0 = undefined;var ctx$2 = undefined;var bridge$$15679$0 = undefined;bridge$$15679$0 = ph$10$0;if ((x$15 = bridge$$15679$0, x$15 instanceof Array && x$15[0] === "check") || (x$16 = bridge$$15679$0, x$16 instanceof Array && x$16[0] === "project")) {
        return ["nostep", form$9];
      } else {
        ctx$2 = ph$10$0;m$15$0 = expr$8;if (($$15710$0 = Array.isArray(m$15$0)) && (t0$56 = m$15$0.length, t0$56 === 1 && m$15$0[0] === "void")) {
          return ["send", ["symbol", "ErrorFactory"], ["data", ["data"].concat(tags$1)]];
        } else {
          if ($$15710$0 && (t0$56 >= 1 && m$15$0[0] === "data")) {
            args$6 = Array.prototype.slice.call(m$15$0, 1);return ["send", ["send", ["send", ["symbol", "ErrorFactory"], ["data", ["data"].concat(tags$1)]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "create"]]]], ["data"].concat(args$6)];
          } else {
            other$4 = m$15$0;return ["macro", errf_macro$0(tags$1.concat([other$4]))];
          }
        }
      }
    };
  };$targ$11 = errf_macro$0([]);t0$57 = getProjector(mac$0("E"))($targ$11);if (t0$57[0]) {
    E_mac$0 = t0$57[1];
  } else {
    ___match_error($targ$11, "mac{\"E\"}! E_mac");
  }$targ$12 = function (context$4, info$9, form$10, ph$11$0) {
    var t0$59 = undefined;var t1$32 = undefined;var t2$19 = undefined;var x$17 = undefined;var level$0 = undefined;var s$1 = undefined;var t0$58 = undefined;var bridge$$15743$0 = undefined;var t1$31 = undefined;var t2$18 = undefined;t0$58 = ph$11$0;bridge$$15743$0 = t0$58;if ((Array.isArray(bridge$$15743$0) && (t0$59 = bridge$$15743$0.length, t0$59 >= 2 && t0$59 <= 3 && (bridge$$15743$0[0] === "data" && (x$17 = bridge$$15743$0[1], t1$32 = 2 >= t0$59 ? ["value", 1] : bridge$$15743$0[2], Array.isArray(t1$32) && (t2$19 = t1$32.length, t2$19 === 2 && (t1$32[0] === "value" && (level$0 = t1$32[1], true)))))) || (x$17 = bridge$$15743$0, level$0 = 1, true)) && (t1$31 = x$17, Array.isArray(t1$31) && (t2$18 = t1$31.length, t2$18 === 2 && t1$31[0] === "symbol"))) {
      s$1 = t1$31[1];return __amp____colon__(x$17, { level: level$0 });
    } else {
      return ___match_error(ph$11$0, "[#data{x, #value{level} = #value{1}} or x and level is 1] and #symbol{s} is x");
    }
  };t0$60 = getProjector(mac$0("outer"))($targ$12);if (t0$60[0]) {
    outer_mac$0 = t0$60[1];
  } else {
    ___match_error($targ$12, "mac{\"outer\"}! outer_mac{context, info, form, match}");
  }$targ$13 = function (context$5, info$10, form$11, temp$17$0) {
    var t0$61 = undefined;var t1$33 = undefined;var t2$20 = undefined;var t3$14 = undefined;var name$5 = undefined;var expr$9 = undefined;t0$61 = temp$17$0;if (Array.isArray(t0$61) && (t1$33 = t0$61.length, t1$33 === 3 && (t0$61[0] === "data" && (t2$20 = t0$61[1], Array.isArray(t2$20) && (t3$14 = t2$20.length, t3$14 === 2 && t2$20[0] === "symbol"))))) {
      name$5 = t2$20[1];expr$9 = t0$61[2];
    } else {
      ___match_error(temp$17$0);
    }return ["tagscope", name$5, expr$9];
  };t0$62 = getProjector(mac$0("tagscope"))($targ$13);if (t0$62[0]) {
    tagscope_mac$0 = t0$62[1];
  } else {
    ___match_error($targ$13, "mac{\"tagscope\"}! tagscope_mac{context, info, form, `{^[#symbol{name}], ^expr}`}");
  }$targ$14 = function (context$6, info$11, form$12, temp$18$0) {
    var t0$63 = undefined;var t1$34 = undefined;var t2$21 = undefined;var t3$15 = undefined;var name$6 = undefined;var expr$10 = undefined;t0$63 = temp$18$0;if (Array.isArray(t0$63) && (t1$34 = t0$63.length, t1$34 === 3 && (t0$63[0] === "data" && (t2$21 = t0$63[1], Array.isArray(t2$21) && (t3$15 = t2$21.length, t3$15 === 2 && t2$21[0] === "symbol"))))) {
      name$6 = t2$21[1];expr$10 = t0$63[2];
    } else {
      ___match_error(temp$18$0);
    }return ["use", name$6, expr$10];
  };t0$64 = getProjector(mac$0("usescope"))($targ$14);if (t0$64[0]) {
    usescope_mac$0 = t0$64[1];
  } else {
    ___match_error($targ$14, "mac{\"usescope\"}! usescope_mac{context, info, form, `{^[#symbol{name}], ^expr}`}");
  }$targ$15 = function (ctx$3, info$12, form$13, temp$19$0) {
    var t0$65 = undefined;var t1$35 = undefined;var t2$22 = undefined;var t3$16 = undefined;var f$0 = undefined;var accum$7 = undefined;var x$18 = undefined;t0$65 = temp$19$0;if (Array.isArray(t0$65) && (t1$35 = t0$65.length, t1$35 === 3 && (t0$65[0] === "data" && (x$18 = t0$65[1], t2$22 = t0$65[2], Array.isArray(t2$22) && (t3$16 = t2$22.length, t3$16 === 1 && t2$22[0] === "void"))))) {} else {
      ___match_error(temp$19$0);
    }accum$7 = ["symbol", "tmp"];f$0 = function f(temp$20$0, info$13, form$14, msg$0) {
      var t0$66 = undefined;var x$19 = undefined;var x$20 = undefined;var t0$68 = undefined;var t1$36 = undefined;var ph$13$0 = undefined;var t0$67 = undefined;var ctx$4 = undefined;var ph$12$0 = undefined;t0$66 = temp$20$0;ctx$4 = t0$66;ph$12$0 = t0$66;t0$67 = ph$12$0;if ((x$19 = t0$67, x$19 instanceof Array && x$19[0] === "pattern") && (x$20 = msg$0, x$20 instanceof Array && x$20[0] === "void")) {
        return ["all", ["send", ["symbol", "is"], ["data", ["symbol", "tmp"], x$18]], ["if", ["symbol", "tmp"], accum$7, ["symbol", "_"]]];
      } else {
        ph$13$0 = msg$0;t0$68 = ph$13$0;t1$36 = t0$68.length;if (t1$36 === 1 && t0$68[0] === "void") {
          return ["multi", ["send", ["symbol", "="], ["data", ["symbol", "tmp"], x$18]], ["send", ["symbol", "if"], ["data", ["send", ["symbol", "or"], ["data", ["send", ["symbol", "==="], ["data", ["symbol", "tmp"], ["symbol", "undefined"]]], ["send", ["symbol", "==="], ["data", ["symbol", "tmp"], ["symbol", "null"]]]]], ["symbol", "tmp"], accum$7]]];
        } else {
          accum$7 = ["send", accum$7, msg$0];__amp____colon__(x$18, { called: true });return ["macro", f$0];
        }
      }
    };return ["macro", f$0];
  };t0$69 = getProjector(mac$0("??"))($targ$15);if (t0$69[0]) {
    maysend_mac$0 = t0$69[1];
  } else {
    ___match_error($targ$15, "mac{\"??\"}! maysend_mac{ctx, info, form, #data{x, #void{}}}");
  }$targ$16 = function (ctx$5, info$14, form$15, expr$11) {
    return ["maybe", expr$11];
  };t0$70 = getProjector(mac$0("maybe"))($targ$16);if (t0$70[0]) {
    maybe_mac$0 = t0$70[1];
  } else {
    ___match_error($targ$16, "mac{\"maybe\"}! maybe_mac{ctx, info, form, expr}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=misc.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../location":106,"../pattern":121,"../util":126,"./helpers":110,"earlgrey-runtime/5":446}],115:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var Body$0 = undefined;var inject__minus__tools$0 = undefined;var $1$0 = undefined;var __lt____lt____colon__$0 = undefined;var $2$0 = undefined;var camelCase$0 = undefined;$0$0 = require("./helpers");Body$0 = getProperty($0$0, "Body", "./helpers");inject__minus__tools$0 = getProperty($0$0, "injectTools", "./helpers");$1$0 = require("../location");__lt____lt____colon__$0 = getProperty($1$0, "<<:", "../location");$2$0 = require("../util");camelCase$0 = getProperty($2$0, "camelCase", "../util");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var t0$0 = undefined;var t0$1 = undefined;var t0$25 = undefined;var t0$35 = undefined;var t0$42 = undefined;var t0$44 = undefined;var t0$47 = undefined;var $targ$2 = undefined;var __require_mac$0 = undefined;var $targ$3 = undefined;var __requirem_mac$0 = undefined;var getreqs$0 = undefined;var $targ$4 = undefined;var require_mac$0 = undefined;var $targ$5 = undefined;var requiremac_mac$0 = undefined;var $targ$6 = undefined;var provide_mac$0 = undefined;var $targ$7 = undefined;var inject_mac$0 = undefined;var $targ$8 = undefined;var globals_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};$targ$2 = function (context$0, info$0, form$0, expr$0) {
    var req$0 = undefined;req$0 = __amp____colon__(["variable", "require"], { top: true });return ["send", req$0, expr$0];
  };t0$0 = getProjector(mac$0("__require"))($targ$2);if (t0$0[0]) {
    __require_mac$0 = t0$0[1];
  } else {
    ___match_error($targ$2, "mac{\"__require\"}! __require_mac{context, info, form, expr}");
  }$targ$3 = function (context$1, info$1, form$1, expr$1) {
    var req$1 = undefined;req$1 = __amp____colon__(["variable", "require"], { top: true });return ["send", req$1, expr$1];
  };t0$1 = getProjector(mac$0("__require-m"))($targ$3);if (t0$1[0]) {
    __requirem_mac$0 = t0$1[1];
  } else {
    ___match_error($targ$3, "mac{\"__require-m\"}! __requirem_mac{context, info, form, expr}");
  }getreqs$0 = function getreqs() {
    var stmts$0 = undefined;var names$0 = undefined;var curpkg$0 = undefined;var pkgs$0 = undefined;var w$0 = undefined;var logName$0 = undefined;var unlogName$0 = undefined;var topfetch$0 = undefined;var produce$0 = undefined;var info$2 = undefined;var req$2 = undefined;var expr$2 = undefined;var prefix$0 = undefined;var t0$2 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$2 = m$0$0.length;if (t0$2 >= 3 && t0$2 <= 4) {
      info$2 = m$0$0[0];req$2 = m$0$0[1];expr$2 = m$0$0[2];if (3 >= t0$2) {
        prefix$0 = null;
      } else {
        prefix$0 = m$0$0[3];
      }stmts$0 = [];names$0 = [];curpkg$0 = null;pkgs$0 = {};w$0 = function w() {
        var x$0 = undefined;var args$0 = undefined;var wrap$0 = undefined;var t0$3 = undefined;var m$1$0 = undefined;m$1$0 = arguments;t0$3 = m$1$0.length;if (t0$3 >= 1 && t0$3 <= 3) {
          x$0 = m$1$0[0];if (1 >= t0$3) {
            args$0 = null;
          } else {
            args$0 = m$1$0[1];
          }if (2 >= t0$3) {
            wrap$0 = null;
          } else {
            wrap$0 = m$1$0[2];
          }if (args$0) {
            x$0 = ["send", x$0, args$0];x$0;
          }if (wrap$0) {
            x$0 = wrap$0(x$0);x$0;
          }return x$0;
        } else {
          return ___match_error(m$1$0, "{var x, args = null, wrap = null}");
        }
      };logName$0 = function logName(temp$0$0) {
        var t0$5 = undefined;var t1$0 = undefined;var t0$6 = undefined;var bridge$$164$0 = undefined;var t0$7 = undefined;var t1$1 = undefined;var t0$4 = undefined;var bridge$$163$0 = undefined;var s$2 = undefined;var s$1 = undefined;var s$0 = undefined;var $$230$0 = undefined;var $$231$0 = undefined;var $$232$0 = undefined;var t0$8 = undefined;var m$2$0 = undefined;var res$0 = undefined;var $targ$10 = undefined;var $targ$9 = undefined;var name$0 = undefined;var n$0 = undefined;t0$4 = temp$0$0;name$0 = t0$4;bridge$$163$0 = t0$4;if ((bridge$$164$0 = bridge$$163$0, Array.isArray(bridge$$164$0) && (t0$5 = bridge$$164$0.length, t0$5 === 2 && (bridge$$164$0[0] === "symbol" && (t1$0 = getProjector(camelCase$0)(bridge$$164$0[1]), t1$0[0] && (n$0 = t1$0[1], true)))) || Array.isArray(bridge$$164$0) && (t0$6 = bridge$$164$0.length, t0$6 === 2 && (bridge$$164$0[0] === "variable" && (n$0 = bridge$$164$0[1], true)))) || Array.isArray(bridge$$163$0) && (t0$7 = bridge$$163$0.length, t0$7 === 2 && (bridge$$163$0[0] === "value" && (t1$1 = bridge$$163$0[1], t1$1 === "'" && (n$0 = t1$1, true))))) {} else {
          ___match_error(temp$0$0);
        }names$0.push(name$0);$targ$9 = curpkg$0;pkgs$0[n$0] = $targ$9;if (prefix$0 === null) {
          return name$0;
        } else {
          m$2$0 = name$0;if (($$230$0 = Array.isArray(m$2$0)) && (t0$8 = m$2$0.length, ($$232$0 = t0$8 === 2) && m$2$0[0] === "symbol")) {
            s$0 = m$2$0[1];res$0 = __lt____lt____colon__$0(["symbol", prefix$0 + s$0], name$0);
          } else {
            if ($$232$0 && m$2$0[0] === "variable") {
              s$1 = m$2$0[1];res$0 = __lt____lt____colon__$0(["symbol", prefix$0 + s$1], name$0);
            } else {
              if ($$232$0 && m$2$0[0] === "value") {
                s$2 = m$2$0[1];res$0 = __lt____lt____colon__$0(["symbol", prefix$0 + s$2], name$0);
              } else {
                res$0 = ___match_error(m$2$0, "#value{s}");
              }
            }
          }$targ$10 = name$0;res$0.other = $targ$10;return res$0;
        }
      };unlogName$0 = function unlogName(name$1) {
        var n$1 = undefined;var m$3$0 = undefined;m$3$0 = names$0.indexOf(name$1.other || name$1);if (m$3$0 === -1) {
          return undefined;
        } else {
          n$1 = m$3$0;return names$0.splice(n$1, 1);
        }
      };topfetch$0 = function topfetch() {
        var imp$0 = undefined;var pkg$0 = undefined;var v$0 = undefined;var args$1 = undefined;var wrap$1 = undefined;var t0$9 = undefined;var m$4$0 = undefined;m$4$0 = arguments;t0$9 = m$4$0.length;if (t0$9 >= 2 && t0$9 <= 4) {
          pkg$0 = m$4$0[0];v$0 = m$4$0[1];if (2 >= t0$9) {
            args$1 = null;
          } else {
            args$1 = m$4$0[2];
          }if (3 >= t0$9) {
            wrap$1 = null;
          } else {
            wrap$1 = m$4$0[3];
          }curpkg$0 = pkg$0;imp$0 = w$0(["send", req$2, ["data", pkg$0]], args$1, wrap$1);stmts$0.push(["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], v$0], imp$0]]);return v$0;
        } else {
          return ___match_error(m$4$0, "{pkg, v, args = null, wrap = null}");
        }
      };produce$0 = function produce(temp$1$0, fetch$0) {
        var t0$10 = undefined;var t0$12 = undefined;var t0$13 = undefined;var m$5 = undefined;var pkgv$0 = undefined;var rqn$0 = undefined;var t0$17 = undefined;var t1$4 = undefined;var $targ$11 = undefined;var projector$0 = undefined;var subp$2 = undefined;var m$11 = undefined;var acc$0 = undefined;var temp$2 = undefined;var dotdots$0 = undefined;var text$0 = undefined;var pfx$0 = undefined;var ph$2$0 = undefined;var rest$0 = undefined;var x$4 = undefined;var t0$19 = undefined;var t1$5 = undefined;var t2$1 = undefined;var t3$1 = undefined;var m$10$0 = undefined;var other$0 = undefined;var name$6 = undefined;var $$744$0 = undefined;var $$745$0 = undefined;var $$746$0 = undefined;var $$747$0 = undefined;var t0$20 = undefined;var t1$6 = undefined;var m$12$0 = undefined;var s$7 = undefined;var name$5 = undefined;var sym$1 = undefined;var name$7 = undefined;var s$8 = undefined;var args$6 = undefined;var operator$0 = undefined;var ph$1$0 = undefined;var args$4 = undefined;var pkg$2 = undefined;var subp$1 = undefined;var pkg$1 = undefined;var s$5 = undefined;var name$3 = undefined;var sym$0 = undefined;var name$2 = undefined;var subp$0 = undefined;var s$4 = undefined;var s$3 = undefined;var $$327$0 = undefined;var $$328$0 = undefined;var $$329$0 = undefined;var $$330$0 = undefined;var $$331$0 = undefined;var $$332$0 = undefined;var $$333$0 = undefined;var $$334$0 = undefined;var $$335$0 = undefined;var t0$11 = undefined;var t1$2 = undefined;var t2$0 = undefined;var bridge$$318$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t9$0 = undefined;var expr$3 = undefined;var ph$0$0 = undefined;t0$10 = temp$1$0;expr$3 = t0$10;ph$0$0 = t0$10;t0$11 = ph$0$0;t1$2 = t0$11.length;if (($$329$0 = t1$2 === 2) && t0$11[0] === "symbol") {
          s$3 = t0$11[1];return fetch$0(["value", s$3], logName$0(expr$3));
        } else {
          if ($$329$0 && (t0$11[0] === "value" && (t2$0 = t0$11[1], typeof t2$0 === "string"))) {
            s$4 = t2$0;return fetch$0(expr$3, __amp____colon__(["symbol", info$2.gensym()], { reqname: s$4 }));
          } else {
            bridge$$318$0 = ph$0$0;if (Array.isArray(bridge$$318$0) && (t0$12 = bridge$$318$0.length, t0$12 >= 1 && (bridge$$318$0[0] === "multi" && (subp$0 = Array.prototype.slice.call(bridge$$318$0, 1), true))) || Array.isArray(bridge$$318$0) && (t0$13 = bridge$$318$0.length, t0$13 >= 1 && (bridge$$318$0[0] === "data" && (subp$0 = Array.prototype.slice.call(bridge$$318$0, 1), true)))) {
              m$5 = null;$3: for (var _iterator = subp$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                m$5 = _step.value;
                var p$0 = undefined;p$0 = m$5;produce$0(p$0, fetch$0);
              }return null;
            } else {
              t0$11 = ph$0$0;t1$2 = t0$11.length;if (($$329$0 = t1$2 === 3) && (($$330$0 = t0$11[0] === "send") && (t2$0 = t0$11[1], ($$332$0 = Array.isArray(t2$0)) && (t3$0 = t2$0.length, ($$334$0 = t3$0 === 2) && (($$335$0 = t2$0[0] === "symbol") && (t2$0[1] === "/" && (t4$0 = t0$11[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && (t4$0[0] === "data" && (t6$0 = t4$0[1], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 1 && (t6$0[0] === "void" && (t8$0 = t4$0[2], sym$0 = t8$0, Array.isArray(t8$0) && (t9$0 = t8$0.length, t9$0 === 2 && t8$0[0] === "symbol")))))))))))))) {
                name$2 = t8$0[1];return fetch$0(["value", ENode([], {}, ["earlgrey-runtime/std/", name$2]).toString()], sym$0);
              } else {
                if ($$335$0 && (t2$0[1] === "^" && (t4$0 = t0$11[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && (t4$0[0] === "data" && (t6$0 = t4$0[1], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 1 && t6$0[0] === "void"))))))) {
                  name$3 = t4$0[2];return fetch$0(name$3, __amp____colon__(["symbol", info$2.gensym()], { reqname: name$3 }));
                } else {
                  if ($$335$0 && (t2$0[1] === "as" && (t4$0 = t0$11[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && t4$0[0] === "data")))) {
                    pkg$1 = t4$0[1];s$5 = t4$0[2];return produce$0(pkg$1, function () {
                      var the_pkg$0 = undefined;var ignore$0 = undefined;var args$2 = undefined;var wrap$2 = undefined;var t0$14 = undefined;var m$6$0 = undefined;m$6$0 = arguments;t0$14 = m$6$0.length;if (t0$14 >= 2 && t0$14 <= 4) {
                        the_pkg$0 = m$6$0[0];ignore$0 = m$6$0[1];if (2 >= t0$14) {
                          args$2 = null;
                        } else {
                          args$2 = m$6$0[2];
                        }if (3 >= t0$14) {
                          wrap$2 = null;
                        } else {
                          wrap$2 = m$6$0[3];
                        }unlogName$0(ignore$0);return fetch$0(the_pkg$0, logName$0(s$5), args$2, wrap$2);
                      } else {
                        return ___match_error(m$6$0, "{the_pkg, ignore, args = null, wrap = null}");
                      }
                    });
                  } else {
                    if ($$335$0 && (t2$0[1] === "->" && (t4$0 = t0$11[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && t4$0[0] === "data")))) {
                      pkg$2 = t4$0[1];subp$1 = t4$0[2];pkgv$0 = produce$0(pkg$2, fetch$0);rqn$0 = pkgv$0.reqname || pkgv$0[1];return produce$0(subp$1, function () {
                        var x$1 = undefined;var s$6 = undefined;var t0$16 = undefined;var t1$3 = undefined;var m$8$0 = undefined;var pkg$3 = undefined;var imp$1 = undefined;var _pkg$0 = undefined;var v$1 = undefined;var args$3 = undefined;var wrap$3 = undefined;var t0$15 = undefined;var m$7$0 = undefined;m$7$0 = arguments;t0$15 = m$7$0.length;if (t0$15 >= 2 && t0$15 <= 4) {
                          _pkg$0 = m$7$0[0];v$1 = m$7$0[1];if (2 >= t0$15) {
                            args$3 = null;
                          } else {
                            args$3 = m$7$0[2];
                          }if (3 >= t0$15) {
                            wrap$3 = null;
                          } else {
                            wrap$3 = m$7$0[3];
                          }m$8$0 = _pkg$0;if (Array.isArray(m$8$0) && (t0$16 = m$8$0.length, t0$16 === 2 && (m$8$0[0] === "value" && (t1$3 = getProjector(camelCase$0)(m$8$0[1]), t1$3[0])))) {
                            s$6 = t1$3[1];pkg$3 = ["value", s$6];
                          } else {
                            x$1 = m$8$0;pkg$3 = x$1;
                          }imp$1 = w$0(["send", ["symbol", "getProperty"], ["data", pkgv$0, pkg$3, ["value", rqn$0]]], args$3, wrap$3);stmts$0.push(["send", ["symbol", "="], ["data", ["send", ["symbol", "let"], v$1], imp$1]]);return v$1;
                        } else {
                          return ___match_error(m$7$0, "{_pkg, v, args = null, wrap = null}");
                        }
                      });
                    } else {
                      if (Array.isArray(t0$11) && (t1$2 = t0$11.length, t1$2 === 3 && (t0$11[0] === "send" && (t2$0 = t0$11[1], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 2 && (t2$0[0] === "symbol" && (t4$0 = t2$0[1], operator$0 = t4$0, ph$1$0 = t4$0, args$4 = t0$11[2], expr$3.fromop))))))) {
                        if (ph$1$0 === "!") {
                          $targ$11 = args$4;t0$17 = $targ$11;if (Array.isArray(t0$17) && (t1$4 = t0$17.length, t1$4 === 3 && t0$17[0] === "data")) {
                            projector$0 = t0$17[1];subp$2 = t0$17[2];
                          } else {
                            ___match_error($targ$11, "#data{projector, subp}");
                          }[projector$0, subp$2];return produce$0(subp$2, function () {
                            var wrap2$0 = undefined;var the_pkg$1 = undefined;var name$4 = undefined;var args$5 = undefined;var wrap$4 = undefined;var t0$18 = undefined;var m$9$0 = undefined;m$9$0 = arguments;t0$18 = m$9$0.length;if (t0$18 >= 2 && t0$18 <= 4) {
                              the_pkg$1 = m$9$0[0];name$4 = m$9$0[1];if (2 >= t0$18) {
                                args$5 = null;
                              } else {
                                args$5 = m$9$0[2];
                              }if (3 >= t0$18) {
                                wrap$4 = null;
                              } else {
                                wrap$4 = m$9$0[3];
                              }wrap$4 = wrap$4 || function (x$2) {
                                return x$2;
                              };wrap2$0 = function wrap2(x$3) {
                                return ["send", projector$0, ["data", wrap$4(x$3)]];
                              };return fetch$0(the_pkg$1, name$4, args$5, wrap2$0);
                            } else {
                              return ___match_error(m$9$0, "{the_pkg, name, args = null, var wrap = null}");
                            }
                          });
                        } else {
                          m$10$0 = info$2.raw(expr$3).trim().replace(RegExp("^,+|,+$", ""), "");if (getChecker(RegExp("^\\.*/", ""))(m$10$0)) {
                            x$4 = m$10$0;s$7 = x$4;
                          } else {
                            t0$19 = getProjector(RegExp("^(\\.+)(.*)", ""))(m$10$0);if (t0$19[0] && (t1$5 = t0$19[1], t2$1 = t1$5.length, t2$1 === 3)) {
                              t1$5[0];t3$1 = t1$5[1];pfx$0 = t3$1;ph$2$0 = t3$1;rest$0 = t1$5[2];if (ph$2$0 === ".") {
                                s$7 = ENode([], {}, [pfx$0, "/", rest$0]).toString();
                              } else {
                                acc$0 = [];temp$2 = null;m$11 = null;$4: for (var _iterator2 = range(2, pfx$0.length)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                                  m$11 = _step2.value;
                                  temp$2 = "../";acc$0.push(temp$2);
                                }dotdots$0 = acc$0;s$7 = ENode([], {}, [dotdots$0.join(""), rest$0]).toString();
                              }
                            } else {
                              text$0 = m$10$0;s$7 = text$0;
                            }
                          }m$12$0 = s$7.split("/");if (($$744$0 = Array.isArray(m$12$0)) && (t0$20 = m$12$0.length, ($$746$0 = t0$20 >= 1) && (Array.prototype.slice.call(m$12$0, 0, -1), t1$6 = m$12$0[t0$20 - 1], getChecker(RegExp("^[a-zA-Z0-9_\\-]+$", ""))(t1$6)))) {
                            name$6 = t1$6;name$5 = name$6;
                          } else {
                            if ($$746$0) {
                              other$0 = m$12$0[t0$20 - 1];throw ErrorFactory(["syntax", "module"]).create(ENode([], {}, ["`", other$0, "` is not a valid symbol; use `require: \"", s$7, "\" as xyz` instead"]).toString(), { node: expr$3 });
                            } else {
                              name$5 = ___match_error(m$12$0, "{*, other}");
                            }
                          }sym$1 = info$2.mark(["symbol", name$5]);return fetch$0(["value", s$7], logName$0(sym$1));
                        }
                      } else {
                        t1$2 = t0$11.length;if (t1$2 === 3 && (t0$11[0] === "send" && (t2$0 = t0$11[1], name$7 = t2$0, Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 2 && (t2$0[0] === "symbol" && (s$8 = t2$0[1], t4$0 = t0$11[2], args$6 = t4$0, Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 >= 1 && t4$0[0] === "data"))))))) {
                          Array.prototype.slice.call(t4$0, 1);return fetch$0(["value", s$8], logName$0(name$7), args$6);
                        } else {
                          return ___match_error(ph$0$0, "#send{name and #symbol{s}, args and #data{*_}}");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };produce$0(expr$2, topfetch$0);return [stmts$0, names$0, pkgs$0];
    } else {
      return ___match_error(m$0$0, "{info, req, expr, prefix = null}");
    }
  };$targ$4 = function (context$2, info$3, form$2, temp$3$0) {
    var t0$21 = undefined;var t0$23 = undefined;var t0$24 = undefined;var t1$8 = undefined;var $targ$12 = undefined;var stmts$1 = undefined;var expr$4 = undefined;var field$0 = undefined;var req$3 = undefined;var $$819$0 = undefined;var $$820$0 = undefined;var t0$22 = undefined;var t1$7 = undefined;var bridge$$818$0 = undefined;var arg$0 = undefined;var ph$3$0 = undefined;t0$21 = temp$3$0;arg$0 = t0$21;ph$3$0 = t0$21;req$3 = info$3.mark(["symbol", "__require"]);t0$22 = ph$3$0;t1$7 = t0$22.length;if (t1$7 === 1 && t0$22[0] === "void") {
      return ["variable", "require"];
    } else {
      if (t1$7 === 2 && t0$22[0] === "value") {
        field$0 = t0$22[1];return ["send", req$3, arg$0];
      } else {
        bridge$$818$0 = ph$3$0;if (Array.isArray(bridge$$818$0) && (t0$23 = bridge$$818$0.length, t0$23 === 2 && (bridge$$818$0[0] === "data" && (expr$4 = bridge$$818$0[1], true))) || (expr$4 = arg$0, true)) {
          $targ$12 = getreqs$0(info$3, req$3, expr$4);t0$24 = $targ$12;if (Array.isArray(t0$24) && (t1$8 = t0$24.length, t1$8 === 3)) {
            stmts$1 = t0$24[0];t0$24[1];t0$24[2];
          } else {
            ___match_error($targ$12, "{stmts, _, _}");
          }return ["splice"].concat(stmts$1);
        } else {
          return ___match_error(ph$3$0, "#data{expr} or expr is arg");
        }
      }
    }
  };t0$25 = getProjector(mac$0("require"))($targ$4);if (t0$25[0]) {
    require_mac$0 = t0$25[1];
  } else {
    ___match_error($targ$4, "mac{\"require\"}! require_mac{context, info, form, match arg}");
  }$targ$5 = function (context$3, info$4, form$3, temp$4$0) {
    var t0$26 = undefined;var t0$27 = undefined;var t0$28 = undefined;var t1$9 = undefined;var m$13 = undefined;var acc$1 = undefined;var temp$5 = undefined;var vs$0 = undefined;var m$14 = undefined;var acc$2 = undefined;var temp$6 = undefined;var macs$0 = undefined;var req$4 = undefined;var $targ$13 = undefined;var stmts$2 = undefined;var vars$0 = undefined;var pkgs$1 = undefined;var body$0 = undefined;var the_macros$0 = undefined;var user__minus__req$0 = undefined;var declarations$0 = undefined;var expr$5 = undefined;var bridge$$893$0 = undefined;var arg$1 = undefined;var ph$4$0 = undefined;t0$26 = temp$4$0;arg$1 = t0$26;ph$4$0 = t0$26;bridge$$893$0 = ph$4$0;if (Array.isArray(bridge$$893$0) && (t0$27 = bridge$$893$0.length, t0$27 === 2 && (bridge$$893$0[0] === "data" && (expr$5 = bridge$$893$0[1], true))) || (expr$5 = arg$1, true)) {
      req$4 = info$4.mark(["symbol", "__require-m"]);$targ$13 = getreqs$0(info$4, req$4, expr$5, "$MAC$");t0$28 = $targ$13;if (Array.isArray(t0$28) && (t1$9 = t0$28.length, t1$9 === 3)) {
        stmts$2 = t0$28[0];vars$0 = t0$28[1];pkgs$1 = t0$28[2];
      } else {
        ___match_error($targ$13, "{stmts, vars, pkgs}");
      }[stmts$2, vars$0, pkgs$1];acc$1 = [];temp$5 = null;m$13 = null;$5: for (var _iterator = vars$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$13 = _step.value;
        var t0$30 = undefined;var t0$31 = undefined;var bridge$$952$0 = undefined;var t0$32 = undefined;var v$2 = undefined;var s$9 = undefined;var t0$29 = undefined;var bridge$$951$0 = undefined;t0$29 = m$13;v$2 = t0$29;bridge$$951$0 = t0$29;if ((bridge$$952$0 = bridge$$951$0, Array.isArray(bridge$$952$0) && (t0$30 = bridge$$952$0.length, t0$30 === 2 && (bridge$$952$0[0] === "symbol" && (s$9 = bridge$$952$0[1], true))) || Array.isArray(bridge$$952$0) && (t0$31 = bridge$$952$0.length, t0$31 === 2 && (bridge$$952$0[0] === "variable" && (s$9 = bridge$$952$0[1], true)))) || Array.isArray(bridge$$951$0) && (t0$32 = bridge$$951$0.length, t0$32 === 2 && (bridge$$951$0[0] === "value" && (s$9 = bridge$$951$0[1], true)))) {
          temp$5 = ["send", ["symbol", "="], ["data", v$2, ["symbol", "$MAC$" + s$9]]];acc$1.push(temp$5);
        } else {
          ___match_error(m$13);
        }
      }vs$0 = acc$1;body$0 = ["multi"].concat(stmts$2).concat([["data"].concat(vs$0)]);__lt____lt____colon__$0(body$0, arg$1);the_macros$0 = info$4.go(body$0, "parse", "eval");user__minus__req$0 = info$4.mark(["symbol", "require"]);acc$2 = [];temp$6 = null;m$14 = null;$6: for (var _iterator2 = items(the_macros$0)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        (function () {
          m$14 = _step2.value;
          var m$15 = undefined;var acc$3 = undefined;var temp$7 = undefined;var r$0 = undefined;var deps$0 = undefined;var f$0 = undefined;var k$0 = undefined;var v$3 = undefined;var t0$33 = undefined;var t1$10 = undefined;var bridge$$1029$0 = undefined;t0$33 = m$14;if (Array.isArray(t0$33) && (t1$10 = t0$33.length, t1$10 === 2 && (k$0 = t0$33[0], bridge$$1029$0 = t0$33[1], (___hasprop(bridge$$1029$0, "macro") && (v$3 = bridge$$1029$0.macro, true) || (v$3 = bridge$$1029$0, true)) && typeof v$3 === "function"))) {
            r$0 = ["splice"];if (v$3.__deps) {
              deps$0 = clone(v$3.__deps);
            } else {
              deps$0 = {};
            }r$0 = r$0.concat((acc$3 = [], temp$7 = null, m$15 = null, (function () {
              $7: for (var _iterator3 = items(v$3.__deps || {})[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                m$15 = _step3.value;
                var mangled__minus__name$0 = undefined;var mangled$0 = undefined;var $targ$14 = undefined;var name$8 = undefined;var ename$0 = undefined;var t0$34 = undefined;var t1$11 = undefined;t0$34 = m$15;if (Array.isArray(t0$34) && (t1$11 = t0$34.length, t1$11 === 2)) {
                  name$8 = t0$34[0];ename$0 = t0$34[1];mangled__minus__name$0 = info$4.gensym("_mdep_" + name$8);mangled$0 = ["variable", mangled__minus__name$0];$targ$14 = mangled$0;deps$0[name$8] = $targ$14;temp$7 = ["splice", __amp____colon__(["send", user__minus__req$0, ["data", ["send", ["symbol", "->"], ["data", send(pkgs$1, k$0), ["send", ["symbol", "as"], ["data", ["symbol", ename$0], mangled$0]]]]]], { env: info$4.env }), ["send", ["symbol", "="], ["data", ["send", ["symbol", "global"], ["value", mangled__minus__name$0]], mangled$0]]];acc$3.push(temp$7);
                } else {
                  ___match_error(m$15);
                }
              }
            })(), acc$3));f$0 = function f(ctx$0, info$5, form$4, expr$6) {
              var $targ$15 = undefined;$targ$15 = deps$0;info$5.deps = $targ$15;return v$3.call(inject__minus__tools$0(info$5), expr$6);
            };r$0.push(["declare_raw", __amp____colon__(["symbol", k$0], { env: info$4.env }), ["macro", f$0]]);temp$6 = r$0;acc$2.push(temp$6);
          } else {
            false;
          }
        })();
      }macs$0 = acc$2;declarations$0 = ["splice"].concat(macs$0);return ["restmacro", function (stmts$3) {
        return [declarations$0, ["multi"].concat(stmts$3)];
      }];
    } else {
      return ___match_error(ph$4$0, "#data{expr} or expr is arg");
    }
  };t0$35 = getProjector(mac$0("requireMacros"))($targ$5);if (t0$35[0]) {
    requiremac_mac$0 = t0$35[1];
  } else {
    ___match_error($targ$5, "mac{\"requireMacros\"}! requiremac_mac{context, info, form, match arg}");
  }$targ$6 = function (temp$8$0, temp$9$0, form$5, e$0) {
    var t0$36 = undefined;var x$5 = undefined;var t0$37 = undefined;var m$16$0 = undefined;var t0$38 = undefined;var t1$12 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$1 = undefined;var m$17 = undefined;var acc$4 = undefined;var temp$10 = undefined;var $targ$16 = undefined;var expr$7 = undefined;var exp$0 = undefined;var context$4 = undefined;var ph$5$0 = undefined;t0$36 = temp$8$0;context$4 = t0$36;ph$5$0 = t0$36;if ((x$5 = ph$5$0, x$5 instanceof Array && x$5[0] === "pattern")) {
      m$16$0 = e$0;if (Array.isArray(m$16$0) && (t0$37 = m$16$0.length, t0$37 === 1 && m$16$0[0] === "void")) {
        return ["send", ["symbol", "and"], ["data", ["send", ["symbol", "module"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "exports"]]]], ["send", ["symbol", "set-var"], ["variable", "exports"]]]];
      } else {
        return ["send", ["send", ["symbol", "and"], ["data", ["send", ["symbol", "module"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "exports"]]]], ["send", ["symbol", "set-var"], ["variable", "exports"]]]], e$0];
      }
    } else {
      $targ$16 = e$0;t0$38 = $targ$16;if (Array.isArray(t0$38) && (t1$12 = t0$38.length, t1$12 === 2 && (t0$38[0] === "data" && (t2$2 = getProjector(Body$0)(t0$38[1]), t2$2[0] && (t3$2 = t2$2[1], t4$1 = t3$2.length, t4$1 >= 0))))) {
        expr$7 = Array.prototype.slice.call(t3$2, 0);
      } else {
        ___match_error($targ$16, "#data{Body! {*expr}}");
      }exp$0 = form$5.env.mark(["symbol", "exports"]);return ["sink", ["multi"].concat((acc$4 = [], temp$10 = null, m$17 = null, (function () {
        $8: for (var _iterator = expr$7[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          m$17 = _step.value;
          var t0$40 = undefined;var t0$41 = undefined;var other$1 = undefined;var s$11 = undefined;var name$10 = undefined;var s$10 = undefined;var name$9 = undefined;var $$1242$0 = undefined;var t0$39 = undefined;var t1$13 = undefined;var t2$3 = undefined;var t3$3 = undefined;var t4$2 = undefined;var t5$1 = undefined;var bridge$$1240$0 = undefined;t0$39 = m$17;s$10 = t0$39;if (Array.isArray(t0$39) && (t1$13 = t0$39.length, t1$13 === 2 && t0$39[0] === "symbol")) {
            name$9 = t0$39[1];temp$10 = ["send", ["symbol", "="], ["data", ["send", exp$0, ["value", camelCase$0(name$9)]], s$10]];acc$4.push(temp$10);
          } else {
            if (Array.isArray(t0$39) && (t1$13 = t0$39.length, t1$13 === 3 && (t0$39[0] === "send" && (t2$3 = t0$39[1], Array.isArray(t2$3) && (t3$3 = t2$3.length, t3$3 === 2 && (t2$3[0] === "symbol" && (t2$3[1] === "as" && (t4$2 = t0$39[2], Array.isArray(t4$2) && (t5$1 = t4$2.length, t5$1 === 3 && (t4$2[0] === "data" && (s$11 = t4$2[1], bridge$$1240$0 = t4$2[2], Array.isArray(bridge$$1240$0) && (t0$40 = bridge$$1240$0.length, t0$40 === 2 && (bridge$$1240$0[0] === "symbol" && (name$10 = bridge$$1240$0[1], true))) || Array.isArray(bridge$$1240$0) && (t0$41 = bridge$$1240$0.length, t0$41 === 2 && (bridge$$1240$0[0] === "value" && (name$10 = bridge$$1240$0[1], true)))))))))))))) {
              temp$10 = ["send", ["symbol", "="], ["data", ["send", exp$0, ["value", camelCase$0(name$10)]], s$11]];acc$4.push(temp$10);
            } else {
              other$1 = m$17;throw ErrorFactory(["syntax", "provide"]).create("Each clause of provide must be 'sym' or 'sym as name'");acc$4.push(temp$10);
            }
          }
        }
      })(), acc$4))];
    }
  };t0$42 = getProjector(mac$0("provide"))($targ$6);if (t0$42[0]) {
    provide_mac$0 = t0$42[1];
  } else {
    ___match_error($targ$6, "mac{\"provide\"}! provide_mac{match context, _, form, e}");
  }$targ$7 = function (context$5, temp$11$0, form$6, temp$12$0) {
    var t0$43 = undefined;var t1$14 = undefined;var t2$4 = undefined;var t3$4 = undefined;var t4$3 = undefined;var expr$8 = undefined;t0$43 = temp$12$0;if (Array.isArray(t0$43) && (t1$14 = t0$43.length, t1$14 === 2 && (t0$43[0] === "data" && (t2$4 = getProjector(Body$0)(t0$43[1]), t2$4[0] && (t3$4 = t2$4[1], t4$3 = t3$4.length, t4$3 >= 0))))) {
      expr$8 = Array.prototype.slice.call(t3$4, 0);
    } else {
      ___match_error(temp$12$0);
    }return ["restmacro", function (stmts$4) {
      var exp$1 = undefined;exp$1 = form$6.env.mark(["symbol", "exports"]);return [["multi", ["send", ["symbol", "globals"], ["data", ["symbol", "module"]]], ["send", ["symbol", "="], ["data", ["send", ["send", ["symbol", "module"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "exports"]]]], ["data"].concat(expr$8)], ["multi", ["send", ["symbol", "="], ["data", ["send", ["symbol", "var"], exp$1], ["data", ["symbol", "="]]]], ["multi"].concat(stmts$4), exp$1]]]]];
    }];
  };t0$44 = getProjector(mac$0("inject"))($targ$7);if (t0$44[0]) {
    inject_mac$0 = t0$44[1];
  } else {
    ___match_error($targ$7, "mac{\"inject\"}! inject_mac{context, _, form, #data{Body! {*expr}}}");
  }$targ$8 = function (context$6, temp$13$0, form$7, temp$14$0) {
    var t0$45 = undefined;var t1$15 = undefined;var t2$5 = undefined;var t3$5 = undefined;var t4$4 = undefined;var m$18 = undefined;var acc$5 = undefined;var temp$15 = undefined;var globs$0 = undefined;var vars$1 = undefined;t0$45 = temp$14$0;if (Array.isArray(t0$45) && (t1$15 = t0$45.length, t1$15 === 2 && (t0$45[0] === "data" && (t2$5 = getProjector(Body$0)(t0$45[1]), t2$5[0] && (t3$5 = t2$5[1], t4$4 = t3$5.length, t4$4 >= 0))))) {
      vars$1 = Array.prototype.slice.call(t3$5, 0);
    } else {
      ___match_error(temp$14$0);
    }acc$5 = [];temp$15 = null;m$18 = null;$9: for (var _iterator = vars$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$18 = _step.value;
      var variable$0 = undefined;var s$12 = undefined;var t0$46 = undefined;var t1$16 = undefined;t0$46 = m$18;variable$0 = t0$46;if (Array.isArray(t0$46) && (t1$16 = t0$46.length, t1$16 === 2 && t0$46[0] === "symbol")) {
        s$12 = t0$46[1];temp$15 = ["splice", ["declare_raw", variable$0, __amp____colon__(["variable", camelCase$0(s$12)], { top: true, mutable: true })], ["send", ["symbol", "if"], ["data", ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", variable$0]], ["value", "undefined"]]], ["send", ["symbol", "="], ["data", ["send", ["symbol", "global"], ["value", s$12]], ["symbol", "undefined"]]]]]];acc$5.push(temp$15);
      } else {
        ___match_error(m$18);
      }
    }globs$0 = acc$5;return ["splice"].concat(globs$0).concat([["symbol", "undefined"]]);
  };t0$47 = getProjector(mac$0("globals"))($targ$8);if (t0$47[0]) {
    globals_mac$0 = t0$47[1];
  } else {
    ___match_error($targ$8, "mac{\"globals\"}! globals_mac{context, _, form, #data{Body! {*vars}}}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=modularity.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../location":106,"../util":126,"./helpers":110,"earlgrey-runtime/5":446}],116:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var partial_pattern$0 = undefined;var make_assigner$0 = undefined;var overridable$0 = undefined;$0$0 = require("./helpers");partial_pattern$0 = getProperty($0$0, "partial_pattern", "./helpers");make_assigner$0 = getProperty($0$0, "make_assigner", "./helpers");overridable$0 = getProperty($0$0, "overridable", "./helpers");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var m$0 = undefined;var acc$0 = undefined;var temp$0 = undefined;var defns$0 = undefined;var t0$2 = undefined;var t0$5 = undefined;var t1$3 = undefined;var t0$7 = undefined;var t1$5 = undefined;var t0$9 = undefined;var t1$7 = undefined;var t0$11 = undefined;var t1$9 = undefined;var t0$13 = undefined;var t1$11 = undefined;var t0$16 = undefined;var t0$19 = undefined;var t1$14 = undefined;var t0$21 = undefined;var $targ$2 = undefined;var is_mac$0 = undefined;var $targ$3 = undefined;var minus_mac$0 = undefined;var $targ$4 = undefined;var append_mac$0 = undefined;var $targ$5 = undefined;var range_mac$0 = undefined;var $targ$6 = undefined;var xrange_mac$0 = undefined;var $targ$7 = undefined;var floor_mac$0 = undefined;var $targ$8 = undefined;var times_mac$0 = undefined;var $targ$9 = undefined;var exp_mac$0 = undefined;var $targ$10 = undefined;var shift_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};defns$0 = { "===": partial_pattern$0("==="), "!==": partial_pattern$0("!=="), "in": partial_pattern$0("__in__"), "==": partial_pattern$0("equal"), "!=": partial_pattern$0("nequal"), "<=": partial_pattern$0("<="), ">=": partial_pattern$0(">="), "<": partial_pattern$0("<"), ">": partial_pattern$0(">"), "+=": make_assigner$0("+"), "-=": make_assigner$0("-"), "*=": make_assigner$0("*"), "/=": make_assigner$0("/"), "<<=": make_assigner$0("<<"), ">>=": make_assigner$0(">>"), ">>>=": make_assigner$0(">>>"), "++=": make_assigner$0("++"), "?=": make_assigner$0("match"), "or=": make_assigner$0("or"), "and=": make_assigner$0("and"), "each=": make_assigner$0("each") };acc$0 = [];temp$0 = null;m$0 = null;$1: for (var _iterator = items(defns$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$0 = _step.value;
    var k$0 = undefined;var v$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$0;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
      k$0 = t0$0[0];v$0 = t0$0[1];temp$0 = mac$0(k$0)(v$0);acc$0.push(temp$0);
    } else {
      ___match_error(m$0);
    }
  }$targ$2 = function (ph$0$0, temp$1$0, form$0, temp$2$0) {
    var t0$1 = undefined;var t1$1 = undefined;var x$1 = undefined;var x$0 = undefined;var y$0 = undefined;t0$1 = temp$2$0;if (Array.isArray(t0$1) && (t1$1 = t0$1.length, t1$1 === 3 && t0$1[0] === "data")) {
      x$0 = t0$1[1];y$0 = t0$1[2];
    } else {
      ___match_error(temp$2$0);
    }if ((x$1 = ph$0$0, x$1 instanceof Array && x$1[0] === "pattern")) {
      return ["replace", x$0, y$0];
    } else {
      return ["send", ["symbol", "==="], ["data", x$0, y$0]];
    }
  };t0$2 = getProjector(mac$0("is"))($targ$2);if (t0$2[0]) {
    is_mac$0 = t0$2[1];
  } else {
    ___match_error($targ$2, "mac{\"is\"}! is_mac{match, _, form, #data{x, y}}");
  }$targ$3 = function (context$0, temp$3$0, form$1, temp$4$0) {
    var t0$3 = undefined;var other$0 = undefined;var n$0 = undefined;var $$17509$0 = undefined;var $$17510$0 = undefined;var t0$4 = undefined;var t1$2 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var expr$0 = undefined;var ph$1$0 = undefined;t0$3 = temp$4$0;expr$0 = t0$3;ph$1$0 = t0$3;t0$4 = ph$1$0;t1$2 = t0$4.length;if (t1$2 === 3 && (t0$4[0] === "data" && (t2$0 = t0$4[1], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 1 && (t2$0[0] === "void" && (t4$0 = t0$4[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 2 && (t4$0[0] === "value" && (t6$0 = t4$0[1], typeof t6$0 === "number"))))))))) {
      n$0 = t6$0;return ["value", -n$0];
    } else {
      if (t1$2 === 1 && t0$4[0] === "void") {
        return ["variable", "-"];
      } else {
        other$0 = ph$1$0;return ["send", ["variable", "-"], expr$0];
      }
    }
  };t0$5 = getProjector(overridable$0)($targ$3);if (t0$5[0] && (t1$3 = getProjector(mac$0("-"))(t0$5[1]), t1$3[0])) {
    minus_mac$0 = t1$3[1];
  } else {
    ___match_error($targ$3, "overridable! mac{\"-\"}! minus_mac{context, _, form, match expr}");
  }$targ$4 = function (context$1, temp$5$0, form$2, ph$2$0) {
    var other$1 = undefined;var x$4 = undefined;var y$1 = undefined;var x$3 = undefined;var x$2 = undefined;var $$17585$0 = undefined;var $$17586$0 = undefined;var $$17587$0 = undefined;var $$17588$0 = undefined;var t0$6 = undefined;var t1$4 = undefined;var t2$1 = undefined;var t3$1 = undefined;t0$6 = ph$2$0;t1$4 = t0$6.length;if (($$17587$0 = t1$4 === 3) && (($$17588$0 = t0$6[0] === "data") && (t2$1 = t0$6[1], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 1 && t2$1[0] === "void")))) {
      x$2 = t0$6[2];return ["send", ["variable", "++"], ["data", ["void"], x$2]];
    } else {
      if ($$17588$0 && (x$3 = t0$6[1], t2$1 = t0$6[2], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 1 && t2$1[0] === "void"))) {
        return ["send", ["variable", "++"], ["data", x$3, ["void"]]];
      } else {
        if ($$17588$0) {
          x$4 = t0$6[1];y$1 = t0$6[2];return ["send", ["send", x$4, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "concat"]]]], ["data", y$1]];
        } else {
          if (t1$4 === 1 && t0$6[0] === "void") {
            return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "x"], ["symbol", "y"]], ["send", ["send", ["symbol", "x"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "concat"]]]], ["data", ["symbol", "y"]]]]];
          } else {
            other$1 = ph$2$0;return ["send", ["symbol", "___build_array"], ["data", other$1]];
          }
        }
      }
    }
  };t0$7 = getProjector(overridable$0)($targ$4);if (t0$7[0] && (t1$5 = getProjector(mac$0("++"))(t0$7[1]), t1$5[0])) {
    append_mac$0 = t1$5[1];
  } else {
    ___match_error($targ$4, "overridable! mac{\"++\"}! append_mac{context, _, form, match}");
  }$targ$5 = function (context$2, temp$6$0, form$3, ph$3$0) {
    var x$7 = undefined;var y$2 = undefined;var x$6 = undefined;var x$5 = undefined;var $$17657$0 = undefined;var $$17658$0 = undefined;var $$17659$0 = undefined;var $$17660$0 = undefined;var t0$8 = undefined;var t1$6 = undefined;var t2$2 = undefined;var t3$2 = undefined;t0$8 = ph$3$0;t1$6 = t0$8.length;if (($$17659$0 = t1$6 === 3) && (($$17660$0 = t0$8[0] === "data") && (t2$2 = t0$8[1], Array.isArray(t2$2) && (t3$2 = t2$2.length, t3$2 === 1 && t2$2[0] === "void")))) {
      x$5 = t0$8[2];return ["send", ["symbol", "range"], ["data", ["value", 1], x$5]];
    } else {
      if ($$17660$0 && (x$6 = t0$8[1], t2$2 = t0$8[2], Array.isArray(t2$2) && (t3$2 = t2$2.length, t3$2 === 1 && t2$2[0] === "void"))) {
        return ["send", ["symbol", "range"], ["data", x$6]];
      } else {
        if ($$17660$0) {
          x$7 = t0$8[1];y$2 = t0$8[2];return ["send", ["symbol", "range"], ["data", x$7, y$2]];
        } else {
          if (t1$6 === 1 && t0$8[0] === "void") {
            return ["symbol", "range"];
          } else {
            return ___match_error(ph$3$0, "#void{}");
          }
        }
      }
    }
  };t0$9 = getProjector(overridable$0)($targ$5);if (t0$9[0] && (t1$7 = getProjector(mac$0(".."))(t0$9[1]), t1$7[0])) {
    range_mac$0 = t1$7[1];
  } else {
    ___match_error($targ$5, "overridable! mac{\"..\"}! range_mac{context, _, form, match}");
  }$targ$6 = function (context$3, temp$7$0, form$4, ph$4$0) {
    var x$10 = undefined;var y$3 = undefined;var x$9 = undefined;var x$8 = undefined;var $$17728$0 = undefined;var $$17729$0 = undefined;var $$17730$0 = undefined;var $$17731$0 = undefined;var t0$10 = undefined;var t1$8 = undefined;var t2$3 = undefined;var t3$3 = undefined;t0$10 = ph$4$0;t1$8 = t0$10.length;if (($$17730$0 = t1$8 === 3) && (($$17731$0 = t0$10[0] === "data") && (t2$3 = t0$10[1], Array.isArray(t2$3) && (t3$3 = t2$3.length, t3$3 === 1 && t2$3[0] === "void")))) {
      x$8 = t0$10[2];return ["send", ["symbol", "range"], ["data", ["value", 0], ["send", ["symbol", "-"], ["data", x$8, ["value", 1]]]]];
    } else {
      if ($$17731$0 && (x$9 = t0$10[1], t2$3 = t0$10[2], Array.isArray(t2$3) && (t3$3 = t2$3.length, t3$3 === 1 && t2$3[0] === "void"))) {
        return ["send", ["symbol", "range"], ["data", x$9]];
      } else {
        if ($$17731$0) {
          x$10 = t0$10[1];y$3 = t0$10[2];return ["send", ["symbol", "range"], ["data", x$10, ["send", ["symbol", "-"], ["data", y$3, ["value", 1]]]]];
        } else {
          return ___match_error(ph$4$0, "#data{x, y}");
        }
      }
    }
  };t0$11 = getProjector(overridable$0)($targ$6);if (t0$11[0] && (t1$9 = getProjector(mac$0("..."))(t0$11[1]), t1$9[0])) {
    xrange_mac$0 = t1$9[1];
  } else {
    ___match_error($targ$6, "overridable! mac{\"...\"}! xrange_mac{context, _, form, match}");
  }$targ$7 = function (context$4, temp$8$0, form$5, ph$5$0) {
    var a$0 = undefined;var b$0 = undefined;var $$17795$0 = undefined;var $$17796$0 = undefined;var t0$12 = undefined;var t1$10 = undefined;t0$12 = ph$5$0;t1$10 = t0$12.length;if (t1$10 === 1 && t0$12[0] === "void") {
      return ["send", ["symbol", "->"], ["data", ["data", ["symbol", "a"], ["symbol", "b"]], ["send", ["send", ["symbol", "Math"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "floor"]]]], ["data", ["send", ["symbol", "/"], ["data", ["symbol", "a"], ["symbol", "b"]]]]]]];
    } else {
      if (t1$10 === 3 && t0$12[0] === "data") {
        a$0 = t0$12[1];b$0 = t0$12[2];return ["send", ["send", ["symbol", "Math"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "floor"]]]], ["data", ["send", ["symbol", "/"], ["data", a$0, b$0]]]];
      } else {
        return ___match_error(ph$5$0, "#data{a, b}");
      }
    }
  };t0$13 = getProjector(overridable$0)($targ$7);if (t0$13[0] && (t1$11 = getProjector(mac$0("//"))(t0$13[1]), t1$11[0])) {
    floor_mac$0 = t1$11[1];
  } else {
    ___match_error($targ$7, "overridable! mac{\"//\"}! floor_mac{context, _, form, match}");
  }$targ$8 = function (context$5, temp$9$0, form$6, expr$1) {
    var x$11 = undefined;var x$12 = undefined;var t0$15 = undefined;var other$2 = undefined;var val$0 = undefined;var $$17841$0 = undefined;var $$17842$0 = undefined;var $$17843$0 = undefined;var t0$14 = undefined;var t1$12 = undefined;var t2$4 = undefined;var bridge$$17838$0 = undefined;var t3$4 = undefined;var t4$1 = undefined;var m$1$0 = undefined;m$1$0 = [context$5, expr$1];if (($$17841$0 = Array.isArray(m$1$0)) && (t0$14 = m$1$0.length, ($$17843$0 = t0$14 === 2) && ((x$11 = m$1$0[0], x$11 instanceof Array && x$11[0] === "pattern") && (t1$12 = m$1$0[1], Array.isArray(t1$12) && (t2$4 = t1$12.length, t2$4 === 1 && t1$12[0] === "void"))))) {
      return ["dynsplice", ["ignore"]];
    } else {
      if ($$17843$0 && (bridge$$17838$0 = m$1$0[0], ((x$12 = bridge$$17838$0, x$12 instanceof Array && x$12[0] === "pattern") || Array.isArray(bridge$$17838$0) && (t0$15 = bridge$$17838$0.length, t0$15 === 2 && (bridge$$17838$0[0] === "expr" && bridge$$17838$0[1] === "data"))) && (t1$12 = m$1$0[1], Array.isArray(t1$12) && (t2$4 = t1$12.length, t2$4 === 3 && (t1$12[0] === "data" && (t3$4 = t1$12[1], Array.isArray(t3$4) && (t4$1 = t3$4.length, t4$1 === 1 && t3$4[0] === "void"))))))) {
        val$0 = t1$12[2];return ["dynsplice", val$0];
      } else {
        if ($$17843$0 && (m$1$0[0], t1$12 = m$1$0[1], Array.isArray(t1$12) && (t2$4 = t1$12.length, t2$4 === 1 && t1$12[0] === "void"))) {
          return ["variable", "*"];
        } else {
          other$2 = m$1$0;return ["send", ["variable", "*"], expr$1];
        }
      }
    }
  };t0$16 = getProjector(mac$0("*"))($targ$8);if (t0$16[0]) {
    times_mac$0 = t0$16[1];
  } else {
    ___match_error($targ$8, "mac{\"*\"}! times_mac{context, _, form, expr}");
  }$targ$9 = function (context$6, temp$10$0, form$7, expr$2) {
    var x$13 = undefined;var x$14 = undefined;var t0$18 = undefined;var a$1 = undefined;var b$1 = undefined;var val$1 = undefined;var $$17948$0 = undefined;var $$17949$0 = undefined;var $$17950$0 = undefined;var $$17951$0 = undefined;var $$17952$0 = undefined;var $$17953$0 = undefined;var $$17954$0 = undefined;var t0$17 = undefined;var t1$13 = undefined;var t2$5 = undefined;var bridge$$17945$0 = undefined;var t3$5 = undefined;var t4$2 = undefined;var m$2$0 = undefined;m$2$0 = [context$6, expr$2];if (($$17948$0 = Array.isArray(m$2$0)) && (t0$17 = m$2$0.length, ($$17950$0 = t0$17 === 2) && ((x$13 = m$2$0[0], x$13 instanceof Array && x$13[0] === "pattern") && (t1$13 = m$2$0[1], Array.isArray(t1$13) && (t2$5 = t1$13.length, t2$5 === 1 && t1$13[0] === "void"))))) {
      return ["objsplice", ["ignore"]];
    } else {
      if ($$17950$0 && (bridge$$17945$0 = m$2$0[0], ((x$14 = bridge$$17945$0, x$14 instanceof Array && x$14[0] === "pattern") || Array.isArray(bridge$$17945$0) && (t0$18 = bridge$$17945$0.length, t0$18 === 2 && (bridge$$17945$0[0] === "expr" && bridge$$17945$0[1] === "data"))) && (t1$13 = m$2$0[1], Array.isArray(t1$13) && (t2$5 = t1$13.length, t2$5 === 3 && (t1$13[0] === "data" && (t3$5 = t1$13[1], Array.isArray(t3$5) && (t4$2 = t3$5.length, t4$2 === 1 && t3$5[0] === "void"))))))) {
        val$1 = t1$13[2];return ["objsplice", val$1];
      } else {
        if ($$17950$0 && (m$2$0[0], t1$13 = m$2$0[1], ($$17953$0 = Array.isArray(t1$13)) && (t2$5 = t1$13.length, t2$5 === 1 && t1$13[0] === "void"))) {
          return ["send", ["symbol", "Math"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "pow"]]]];
        } else {
          if ($$17953$0 && (t2$5 === 3 && t1$13[0] === "data")) {
            a$1 = t1$13[1];b$1 = t1$13[2];return ["send", ["send", ["symbol", "Math"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "pow"]]]], ["data", a$1, b$1]];
          } else {
            return ___match_error(m$2$0, "{_, #data{a, b}}");
          }
        }
      }
    }
  };t0$19 = getProjector(overridable$0)($targ$9);if (t0$19[0] && (t1$14 = getProjector(mac$0("**"))(t0$19[1]), t1$14[0])) {
    exp_mac$0 = t1$14[1];
  } else {
    ___match_error($targ$9, "overridable! mac{\"**\"}! exp_mac{context, _, form, expr}");
  }$targ$10 = function (ph$6$0, temp$11$0, form$8, expr$3) {
    var x$15 = undefined;var t0$20 = undefined;var t1$15 = undefined;var $targ$11 = undefined;var variable$0 = undefined;var result$0 = undefined;if ((x$15 = ph$6$0, x$15 instanceof Array && x$15[0] === "pattern")) {
      $targ$11 = expr$3;t0$20 = $targ$11;if (Array.isArray(t0$20) && (t1$15 = t0$20.length, t1$15 === 3 && t0$20[0] === "data")) {
        variable$0 = t0$20[1];result$0 = t0$20[2];
      } else {
        ___match_error($targ$11, "#data{variable, result}");
      }[variable$0, result$0];return ["project", ["send", ["symbol", "->"], ["data", ["data", variable$0], ["data", ["symbol", "true"], result$0]]], variable$0];
    } else {
      return ["send", ["variable", ">>"], expr$3];
    }
  };t0$21 = getProjector(mac$0(">>"))($targ$10);if (t0$21[0]) {
    shift_mac$0 = t0$21[1];
  } else {
    ___match_error($targ$10, "mac{\">>\"}! shift_mac{match, _, form, expr}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=operators.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":110,"earlgrey-runtime/5":446}],117:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var unescape$0 = undefined;var $1$0 = undefined;var Source$0 = undefined;var $2$0 = undefined;var qq$0 = undefined;var overridable$0 = undefined;var opg$0 = undefined;$0$0 = require("../lex");unescape$0 = getProperty($0$0, "unescape", "../lex");$1$0 = require("../location");Source$0 = getProperty($1$0, "Source", "../location");$2$0 = require("./helpers");qq$0 = getProperty($2$0, "qq", "./helpers");overridable$0 = getProperty($2$0, "overridable", "./helpers");opg$0 = require("opg");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var t0$3 = undefined;var t0$6 = undefined;var t0$17 = undefined;var t1$10 = undefined;var t0$21 = undefined;var $targ$2 = undefined;var unquote_mac$0 = undefined;var $targ$3 = undefined;var quote_mac$0 = undefined;var tok$0 = undefined;var gr$0 = undefined;var prio$0 = undefined;var finalize$0 = undefined;var parser$0 = undefined;var parse$0 = undefined;var $targ$4 = undefined;var wq_mac$0 = undefined;var $targ$5 = undefined;var interpolate_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};$targ$2 = function (temp$0$0, info$0, form$0, expr$0) {
    var t0$0 = undefined;var x$0 = undefined;var t0$2 = undefined;var t1$1 = undefined;var t2$0 = undefined;var t3$0 = undefined;var $targ$6 = undefined;var x$1 = undefined;var t0$1 = undefined;var t1$0 = undefined;var context$0 = undefined;var ph$0$0 = undefined;t0$0 = temp$0$0;context$0 = t0$0;ph$0$0 = t0$0;t0$1 = ph$0$0;t1$0 = t0$1.length;if (t1$0 === 2 && (t0$1[0] === "expr" && t0$1[1] === "head")) {
      return ["nostep"];
    } else {
      if ((x$0 = ph$0$0, x$0 instanceof Array && x$0[0] === "pattern")) {
        $targ$6 = expr$0;t0$2 = $targ$6;if (Array.isArray(t0$2) && (t1$1 = t0$2.length, t1$1 === 3 && (t0$2[0] === "data" && (t2$0 = t0$2[1], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 1 && t2$0[0] === "void"))))) {
          x$1 = t0$2[2];
        } else {
          ___match_error($targ$6, "#data{#void{}, x}");
        }return ["calc", x$1];
      } else {
        throw send(send(ErrorFactory(["syntax", "unquote"]), "create", true), __amp____colon__([ENode([], {}, ["Cannot unquote in context ", context$0, "."]).toString()], { expr: expr$0, "::objinsert": 1 }));
      }
    }
  };t0$3 = getProjector(mac$0("^"))($targ$2);if (t0$3[0]) {
    unquote_mac$0 = t0$3[1];
  } else {
    ___match_error($targ$2, "mac{\"^\"}! unquote_mac{match context, info, form, expr}");
  }$targ$3 = function (temp$1$0, info$1, form$1, temp$2$0) {
    var t0$4 = undefined;var t0$5 = undefined;var t1$2 = undefined;var parsed$0 = undefined;var context$1 = undefined;var ph$1$0 = undefined;var expr$1 = undefined;var s$0 = undefined;t0$4 = temp$1$0;context$1 = t0$4;ph$1$0 = t0$4;t0$5 = temp$2$0;expr$1 = t0$5;if (Array.isArray(t0$5) && (t1$2 = t0$5.length, t1$2 === 2 && t0$5[0] === "value")) {
      s$0 = t0$5[1];
    } else {
      ___match_error(temp$2$0);
    }parsed$0 = info$1.go(Source$0(s$0, "<quasiquote>"), "source", "parse");return info$1.mark(qq$0(parsed$0));
  };t0$6 = getProjector(mac$0("`"))($targ$3);if (t0$6[0]) {
    quote_mac$0 = t0$6[1];
  } else {
    ___match_error($targ$3, "mac{\"`\"}! quote_mac{match context, info, form, expr and #value{s}}");
  }tok$0 = opg$0.tokenize.Tokenizer({ regexps: { open: "\\{", close: "\\}", other: "(?:\\\\.|[^\\{\\}])+" }, post: [function (temp$3$0) {
      var t0$7 = undefined;var t0$8 = undefined;var tok$1 = undefined;var ph$2$0 = undefined;t0$7 = temp$3$0;tok$1 = t0$7;ph$2$0 = t0$7;t0$8 = ph$2$0;if (___hasprop(t0$8, "type") && t0$8.type === "open") {
        return [{ token: "", type: "other", location: tok$1.location.at_start() }, tok$1];
      } else {
        return tok$1;
      }
    }] });gr$0 = new opg$0.parse.TokenGroups({ open: ["open"], close: ["close"], other: ["str", "other"] });prio$0 = new opg$0.parse.PriorityOrder(gr$0, { open: { left: 1002, right: 0 }, close: { left: 0, right: 1003 }, other: { left: 1000, right: 1000 } });finalize$0 = function finalize(temp$4$0) {
    var t0$9 = undefined;var t0$11 = undefined;var t1$4 = undefined;var t2$2 = undefined;var tag$0 = undefined;var arg$0 = undefined;var text$0 = undefined;var bridge$$1379$0 = undefined;var m$0 = undefined;var rval$0 = undefined;var text$1 = undefined;var args$0 = undefined;var token$0 = undefined;var open$0 = undefined;var ph$4$0 = undefined;var _arg$0 = undefined;var close$0 = undefined;var $$1382$0 = undefined;var $$1383$0 = undefined;var t0$10 = undefined;var t1$3 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$0 = undefined;var zazz$0 = undefined;var ph$3$0 = undefined;t0$9 = temp$4$0;zazz$0 = t0$9;ph$3$0 = t0$9;t0$10 = ph$3$0;t1$3 = t0$10.length;if (t1$3 === 5 && (t0$10[0] === null && (t2$1 = t0$10[1], ___hasprop(t2$1, "type") && (t2$1.type === "open" && (___hasprop(t2$1, "token") && (t3$1 = t2$1.token, open$0 = t3$1, ph$4$0 = t3$1, _arg$0 = t0$10[2], t4$0 = t0$10[3], ___hasprop(t4$0, "type") && (t4$0.type === "close" && (___hasprop(t4$0, "token") && (close$0 = t4$0.token, t0$10[4] === null))))))))) {
      arg$0 = _arg$0 || __amp__(["join", ""], { text: "" });text$0 = open$0 + arg$0.text + close$0;bridge$$1379$0 = ph$4$0;if ((t0$11 = getProjector(RegExp("\\$([^\\{]*){", ""))(bridge$$1379$0), t0$11[0] && (t1$4 = t0$11[1], t2$2 = t1$4.length, t2$2 === 2 && (t1$4[0], tag$0 = t1$4[1], true))) || (tag$0 = "", true)) {
        return __amp____colon__(["bracket", tag$0, arg$0.text], { text: text$0 });
      } else {
        return ___match_error(ph$4$0, "R\"\\$([^\\{]*){\"! {_, tag} or tag is \"\"");
      }
    } else {
      if (t1$3 === 3 && (t0$10[0] === null && (t2$1 = t0$10[1], ___hasprop(t2$1, "token") && (token$0 = t2$1.token, t0$10[2] === null)))) {
        return __amp____colon__(["join", token$0], { text: token$0 });
      } else {
        args$0 = ph$3$0;rval$0 = ["join"];text$1 = "";m$0 = null;$3: for (var _iterator = enumerate(args$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          m$0 = _step.value;
          var x$2 = undefined;var sub$0 = undefined;var token$1 = undefined;var $$1484$0 = undefined;var t0$13 = undefined;var t1$6 = undefined;var i$0 = undefined;var arg$1 = undefined;var ph$5$0 = undefined;var t0$12 = undefined;var t1$5 = undefined;var t2$3 = undefined;t0$12 = m$0;if (Array.isArray(t0$12) && (t1$5 = t0$12.length, t1$5 === 2)) {
            i$0 = t0$12[0];t2$3 = t0$12[1];arg$1 = t2$3;ph$5$0 = t2$3;t0$13 = ph$5$0;if (___hasprop(t0$13, "token") && (token$1 = t0$13.token, equal(i$0 % 2, 1))) {
              rval$0.push(token$1);text$1 = text$1 + token$1;
            } else {
              if (Array.isArray(t0$13) && (t1$6 = t0$13.length, t1$6 >= 1 && t0$13[0] === "join")) {
                sub$0 = Array.prototype.slice.call(t0$13, 1);text$1 = text$1 + arg$1.text;rval$0 = rval$0.concat(sub$0);
              } else {
                if ((x$2 = ph$5$0, x$2 instanceof Array && x$2[0] === "bracket")) {
                  text$1 = text$1 + arg$1.text;rval$0.push(arg$1);
                } else {
                  if (ph$5$0 === null) {
                    undefined;
                  } else {
                    ___match_error(ph$5$0);
                  }
                }
              }
            }
          } else {
            ___match_error(m$0);
          }
        }return __amp____colon__(rval$0, { text: text$1 });
      }
    }
  };parser$0 = new opg$0.parse.Parser(tok$0, prio$0.getOrder(), finalize$0);parse$0 = function parse(text$2) {
    return parser$0.parse(text$2);
  };$targ$4 = function (context$2, info$2, form$2, temp$5$0) {
    var t0$14 = undefined;var t1$7 = undefined;var f$0 = undefined;var f$1 = undefined;var v$0 = undefined;var $$1566$0 = undefined;var $$1567$0 = undefined;var $$1568$0 = undefined;var t0$16 = undefined;var t1$9 = undefined;var t2$5 = undefined;var t3$3 = undefined;var elements$0 = undefined;var ph$6$0 = undefined;var t0$15 = undefined;var t1$8 = undefined;var t2$4 = undefined;var t3$2 = undefined;var t4$1 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t9$0 = undefined;var t10$0 = undefined;var t11$0 = undefined;var t12$0 = undefined;var m$1$0 = undefined;var x$3 = undefined;t0$14 = temp$5$0;if (Array.isArray(t0$14) && (t1$7 = t0$14.length, t1$7 === 2 && t0$14[0] === "data")) {
      x$3 = t0$14[1];
    } else {
      ___match_error(temp$5$0);
    }m$1$0 = x$3;if (Array.isArray(m$1$0) && (t0$15 = m$1$0.length, t0$15 === 3 && (m$1$0[0] === "send" && (t1$8 = m$1$0[1], Array.isArray(t1$8) && (t2$4 = t1$8.length, t2$4 === 2 && (t1$8[0] === "symbol" && (t1$8[1] === "ENode" && (t3$2 = m$1$0[2], Array.isArray(t3$2) && (t4$1 = t3$2.length, t4$1 === 4 && (t3$2[0] === "data" && (t5$0 = t3$2[1], Array.isArray(t5$0) && (t6$0 = t5$0.length, t6$0 === 1 && (t5$0[0] === "data" && (t7$0 = t3$2[2], Array.isArray(t7$0) && (t8$0 = t7$0.length, t8$0 === 2 && (t7$0[0] === "data" && (t9$0 = t7$0[1], Array.isArray(t9$0) && (t10$0 = t9$0.length, t10$0 === 2 && (t9$0[0] === "symbol" && (t9$0[1] === "=" && (t11$0 = t3$2[3], Array.isArray(t11$0) && (t12$0 = t11$0.length, t12$0 >= 1 && t11$0[0] === "data")))))))))))))))))))))) {
      elements$0 = Array.prototype.slice.call(t11$0, 1);ph$6$0 = elements$0;t0$16 = ph$6$0;if (($$1567$0 = Array.isArray(t0$16)) && (t1$9 = t0$16.length, t1$9 === 1 && (t2$5 = t0$16[0], v$0 = t2$5, Array.isArray(t2$5) && (t3$3 = t2$5.length, t3$3 === 2 && (t2$5[0] === "value" && typeof t2$5[1] === "string"))))) {
        return v$0;
      } else {
        if ($$1567$0 && (t1$9 >= 1 && (t2$5 = t0$16[0], Array.isArray(t2$5) && (t3$3 = t2$5.length, t3$3 === 2 && (t2$5[0] === "value" && typeof t2$5[1] === "string"))))) {
          Array.prototype.slice.call(t0$16, 1);f$0 = function f(x$4, y$0) {
            return ["send", ["symbol", "+"], ["data", x$4, y$0]];
          };return elements$0.reduce(f$0);
        } else {
          f$1 = function f(x$5, y$1) {
            return ["send", ["symbol", "+"], ["data", x$5, y$1]];
          };return elements$0.reduce(f$1, ["value", ""]);
        }
      }
    } else {
      return ["send", ["send", x$3, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "to-string"]]]], ["data"]];
    }
  };t0$17 = getProjector(overridable$0)($targ$4);if (t0$17[0] && (t1$10 = getProjector(mac$0("wrap-quote"))(t0$17[1]), t1$10[0])) {
    wq_mac$0 = t1$10[1];
  } else {
    ___match_error($targ$4, "overridable! mac{\"wrap-quote\"}! wq_mac{context, info, form, `{^x}`}");
  }$targ$5 = function (context$3, info$3, form$3, temp$6$0) {
    var t0$18 = undefined;var t1$11 = undefined;var t0$19 = undefined;var bridge$$1747$0 = undefined;var m$2 = undefined;var $targ$7 = undefined;var contents$0 = undefined;var parts$0 = undefined;var current$0 = undefined;var push$0 = undefined;var wq$0 = undefined;var s$1 = undefined;t0$18 = temp$6$0;if (Array.isArray(t0$18) && (t1$11 = t0$18.length, t1$11 === 2 && t0$18[0] === "value")) {
      s$1 = t0$18[1];
    } else {
      ___match_error(temp$6$0);
    }$targ$7 = parse$0(s$1);bridge$$1747$0 = $targ$7;if (Array.isArray(bridge$$1747$0) && (t0$19 = bridge$$1747$0.length, t0$19 >= 1 && (bridge$$1747$0[0] === "join" && (contents$0 = Array.prototype.slice.call(bridge$$1747$0, 1), true))) || (contents$0 = [], true)) {} else {
      ___match_error($targ$7, "#join{*contents} or contents is {}");
    }parts$0 = [];current$0 = "";push$0 = function push() {
      if (nequal(current$0, "")) {
        parts$0.push(["value", current$0]);current$0 = "";return current$0;
      }
    };m$2 = null;$4: for (var _iterator = contents$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$2 = _step.value;
      var p$0 = undefined;var ph$7$0 = undefined;var expr$2 = undefined;var s$2 = undefined;var $$1756$0 = undefined;var t0$20 = undefined;var t1$12 = undefined;t0$20 = m$2;if (typeof t0$20 === "string") {
        s$2 = t0$20;current$0 = current$0 + unescape$0(s$2);
      } else {
        if (Array.isArray(t0$20) && (t1$12 = t0$20.length, t1$12 === 3 && t0$20[0] === "bracket")) {
          ph$7$0 = t0$20[1];expr$2 = t0$20[2];push$0();p$0 = form$3.env.mark(["parse", expr$2]);if (ph$7$0 === "") {
            parts$0.push(p$0);
          } else {
            ___match_error(ph$7$0);
          }
        } else {
          ___match_error(m$2);
        }
      }
    }push$0();wq$0 = form$3.env.mark(["symbol", "wrap-quote"]);return ["send", wq$0, ["data", ["send", ["symbol", "ENode"], ["data", ["data"], ["data", ["symbol", "="]], ["data"].concat(parts$0)]]]];
  };t0$21 = getProjector(mac$0("'"))($targ$5);if (t0$21[0]) {
    interpolate_mac$0 = t0$21[1];
  } else {
    ___match_error($targ$5, "mac{\"'\"}! interpolate_mac{context, info, form, #value{s}}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=quote.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lex":105,"../location":106,"./helpers":110,"earlgrey-runtime/5":446,"opg":553}],118:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$0 = undefined;var $0$0 = undefined;var Source$0 = undefined;var $1$0 = undefined;var accum_flags$0 = undefined;$0$0 = require("../location");Source$0 = getProperty($0$0, "Source", "../location");$1$0 = require("./helpers");accum_flags$0 = getProperty($1$0, "accum_flags", "./helpers");if (typeof module === "undefined") {
  $targ$1 = undefined;global.module = $targ$1;void 0;
}$targ$0 = function (mac$0) {
  var $targ$10 = undefined;var accum$0 = undefined;var $targ$11 = undefined;var accum$1 = undefined;var t0$9 = undefined;var t1$9 = undefined;var RegexBuilder$0 = undefined;var build_regexp$0 = undefined;var accum_flagsf$0 = undefined;var $targ$2 = undefined;var regexp_mac$0 = undefined;var exports$0 = undefined;exports$0 = {};RegexBuilder$0 = function RegexBuilder() {
    var __at___$0 = undefined;if (!getChecker(RegexBuilder$0)(this)) {
      __at___$0 = Object.create(RegexBuilder$0.prototype);
    } else {
      __at___$0 = this;
    }return __at___$0;
  };RegexBuilder$0.prototype.wrap = function wrap(x$0) {
    var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;return "(?:" + x$0 + ")";
  };RegexBuilder$0.prototype.quote = function quote(x$1) {
    var __at___$2 = undefined;var self$1 = undefined;__at___$2 = this;self$1 = this;return x$1.replace(RegExp("([.?*+\\^$\\[\\]\\(\\)\\{\\}|\\\\])", "g"), "\\$1");
  };RegexBuilder$0.prototype.quote_charset = function quote_charset(x$2) {
    var __at___$3 = undefined;var self$2 = undefined;__at___$3 = this;self$2 = this;return x$2.replace(RegExp("([\\[\\]\\(\\)\\{\\}\\^])", "g"), "\\$1");
  };RegexBuilder$0.prototype.build = function build(expr$0) {
    var t0$1 = undefined;var t1$1 = undefined;var $targ$3 = undefined;var t0$2 = undefined;var t1$2 = undefined;var $targ$4 = undefined;var t0$3 = undefined;var t1$3 = undefined;var $targ$5 = undefined;var t0$4 = undefined;var t1$4 = undefined;var t0$5 = undefined;var t1$5 = undefined;var x$4 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var v$0 = undefined;var t0$6 = undefined;var t1$6 = undefined;var t0$7 = undefined;var t1$7 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var t8$0 = undefined;var t9$0 = undefined;var x$5 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var v$1 = undefined;var m$1 = undefined;var acc$0 = undefined;var temp$0 = undefined;var m$2 = undefined;var acc$1 = undefined;var temp$1 = undefined;var other$0 = undefined;var args$1 = undefined;var args$0 = undefined;var ph$1$0 = undefined;var a$0 = undefined;var b$0 = undefined;var s$0 = undefined;var x$3 = undefined;var ph$0$0 = undefined;var $$18769$0 = undefined;var $$18770$0 = undefined;var $$18771$0 = undefined;var $$18772$0 = undefined;var $$18773$0 = undefined;var $$18774$0 = undefined;var $$18775$0 = undefined;var $$18776$0 = undefined;var $$18777$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var m$0$0 = undefined;var __at___$4 = undefined;var self$3 = undefined;__at___$4 = this;self$3 = this;m$0$0 = expr$0;if (($$18769$0 = Array.isArray(m$0$0)) && (t0$0 = m$0$0.length, ($$18771$0 = t0$0 === 2) && m$0$0[0] === "symbol")) {
      ph$0$0 = m$0$0[1];if (ph$0$0 === "any") {
        return ".";
      } else {
        if (ph$0$0 === "start") {
          return "^";
        } else {
          if (ph$0$0 === "end") {
            return "$";
          } else {
            if (ph$0$0 === "alpha") {
              return "\\a";
            } else {
              if (ph$0$0 === "digit") {
                return "\\d";
              } else {
                if (ph$0$0 === "word") {
                  return "\\w";
                } else {
                  if (ph$0$0 === "space") {
                    return "\\s";
                  } else {
                    if (ph$0$0 === "boundary") {
                      return "\\b";
                    } else {
                      if (ph$0$0 === "a") {
                        return "\\a";
                      } else {
                        if (ph$0$0 === "d") {
                          return "\\d";
                        } else {
                          if (ph$0$0 === "w") {
                            return "\\w";
                          } else {
                            if (ph$0$0 === "s") {
                              return "\\s";
                            } else {
                              if (ph$0$0 === "b") {
                                return "\\b";
                              } else {
                                return ___match_error(ph$0$0, ".b");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if ($$18771$0 && m$0$0[0] === "value") {
        x$3 = m$0$0[1];return __at___$4.quote(x$3);
      } else {
        if ($$18769$0 && (($$18771$0 = t0$0 === 3) && (($$18772$0 = m$0$0[0] === "send") && (t1$0 = m$0$0[1], ($$18774$0 = Array.isArray(t1$0)) && (t2$0 = t1$0.length, ($$18776$0 = t2$0 === 2) && (($$18777$0 = t1$0[0] === "symbol") && (t1$0[1] === "raw" && (t3$0 = m$0$0[2], Array.isArray(t3$0) && (t4$0 = t3$0.length, t4$0 === 2 && t3$0[0] === "value"))))))))) {
          s$0 = t3$0[1];return s$0;
        } else {
          if ($$18777$0 && (ph$1$0 = t1$0[1], t3$0 = m$0$0[2], Array.isArray(t3$0) && (t4$0 = t3$0.length, t4$0 === 3 && t3$0[0] === "data"))) {
            a$0 = t3$0[1];b$0 = t3$0[2];if (ph$1$0 === "||") {
              return __at___$4.wrap(__at___$4.build(a$0) + "|" + __at___$4.build(b$0));
            } else {
              if (ph$1$0 === "or") {
                return __at___$4.wrap(__at___$4.build(a$0) + "|" + __at___$4.build(b$0));
              } else {
                if (ph$1$0 === "*") {
                  $targ$3 = a$0;t0$1 = $targ$3;if (Array.isArray(t0$1) && (t1$1 = t0$1.length, t1$1 === 1 && t0$1[0] === "void")) {} else {
                    ___match_error($targ$3, "#void{}");
                  }return __at___$4.wrap(__at___$4.build(b$0) + "*");
                } else {
                  if (ph$1$0 === "+") {
                    $targ$4 = a$0;t0$2 = $targ$4;if (Array.isArray(t0$2) && (t1$2 = t0$2.length, t1$2 === 1 && t0$2[0] === "void")) {} else {
                      ___match_error($targ$4, "#void{}");
                    }return __at___$4.wrap(__at___$4.build(b$0) + "+");
                  } else {
                    if (ph$1$0 === "?") {
                      $targ$5 = a$0;t0$3 = $targ$5;if (Array.isArray(t0$3) && (t1$3 = t0$3.length, t1$3 === 1 && t0$3[0] === "void")) {} else {
                        ___match_error($targ$5, "#void{}");
                      }return __at___$4.wrap(__at___$4.build(b$0) + "?");
                    } else {
                      if (ph$1$0 === "in") {
                        $targ$6 = a$0;t0$4 = $targ$6;if (Array.isArray(t0$4) && (t1$4 = t0$4.length, t1$4 === 1 && t0$4[0] === "void")) {} else {
                          ___match_error($targ$6, "#void{}");
                        }$targ$7 = b$0;t0$5 = $targ$7;if (Array.isArray(t0$5) && (t1$5 = t0$5.length, t1$5 === 2 && t0$5[0] === "value")) {
                          v$0 = t0$5[1];
                        } else {
                          ___match_error($targ$7, "#value{v}");
                        }x$4 = __at___$4.quote_charset(v$0);return "[" + x$4 + "]";
                      } else {
                        if (ph$1$0 === "not") {
                          $targ$8 = a$0;t0$6 = $targ$8;if (Array.isArray(t0$6) && (t1$6 = t0$6.length, t1$6 === 1 && t0$6[0] === "void")) {} else {
                            ___match_error($targ$8, "#void{}");
                          }$targ$9 = b$0;t0$7 = $targ$9;if (Array.isArray(t0$7) && (t1$7 = t0$7.length, t1$7 === 3 && (t0$7[0] === "send" && (t2$1 = t0$7[1], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 2 && (t2$1[0] === "symbol" && (t2$1[1] === "in" && (t4$1 = t0$7[2], Array.isArray(t4$1) && (t5$0 = t4$1.length, t5$0 === 3 && (t4$1[0] === "data" && (t6$0 = t4$1[1], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 1 && (t6$0[0] === "void" && (t8$0 = t4$1[2], Array.isArray(t8$0) && (t9$0 = t8$0.length, t9$0 === 2 && t8$0[0] === "value"))))))))))))))) {
                            v$1 = t8$0[1];
                          } else {
                            ___match_error($targ$9, "#send{#symbol{\"in\"}, #data{#void{}, #value{v}}}");
                          }x$5 = __at___$4.quote_charset(v$1);return "[^" + x$5 + "]";
                        } else {
                          return ___match_error(ph$1$0, "\"not\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if ($$18769$0 && (($$18771$0 = t0$0 >= 1) && m$0$0[0] === "data")) {
              args$0 = Array.prototype.slice.call(m$0$0, 1);return "(" + (acc$0 = [], temp$0 = null, m$1 = null, (function () {
                $6: for (var _iterator = args$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                  m$1 = _step.value;
                  var arg$0 = undefined;arg$0 = m$1;temp$0 = __at___$4.build(arg$0);acc$0.push(temp$0);
                }
              })(), acc$0).join("") + ")";
            } else {
              if ($$18771$0 && m$0$0[0] === "multi") {
                args$1 = Array.prototype.slice.call(m$0$0, 1);return "(?:" + (acc$1 = [], temp$1 = null, m$2 = null, (function () {
                  $11: for (var _iterator = args$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                    m$2 = _step.value;
                    var arg$1 = undefined;arg$1 = m$2;temp$1 = __at___$4.build(arg$1);acc$1.push(temp$1);
                  }
                })(), acc$1).join("") + ")";
              } else {
                other$0 = m$0$0;return ErrorFactory(["syntax", "regexp"]).create("Illegal regular expression", { expr: expr$0 });
              }
            }
          }
        }
      }
    }
  };__amp____colon__(RegexBuilder$0, __amp____colon__(($targ$10 = "RegexBuilder", accum$0 = {}, accum$0["::name"] = $targ$10, accum$0), ($targ$11 = true, accum$1 = {}, accum$1["::egclass"] = $targ$11, accum$1)));build_regexp$0 = function build_regexp(x$6) {
    return RegexBuilder$0().build(x$6);
  };accum_flagsf$0 = function accum_flagsf(f$0) {
    return accum_flags$0(f$0, false);
  };$targ$2 = function (ph$2$0, info$0, form$0, arg$2, flags$0) {
    var x$7 = undefined;var x$8 = undefined;var text$2 = undefined;var text$1 = undefined;var m$4$0 = undefined;var text$0 = undefined;var s$1 = undefined;var arg$3 = undefined;var v$2 = undefined;var $$19176$0 = undefined;var $$19177$0 = undefined;var $$19178$0 = undefined;var $$19179$0 = undefined;var $$19180$0 = undefined;var $$19181$0 = undefined;var $$19182$0 = undefined;var $$19183$0 = undefined;var $$19184$0 = undefined;var t0$8 = undefined;var t1$8 = undefined;var t2$2 = undefined;var t3$2 = undefined;var t4$2 = undefined;var t5$1 = undefined;var t6$1 = undefined;var m$3$0 = undefined;var bridge$$19148$0 = undefined;bridge$$19148$0 = ph$2$0;if ((x$7 = bridge$$19148$0, x$7 instanceof Array && x$7[0] === "check") || (x$8 = bridge$$19148$0, x$8 instanceof Array && x$8[0] === "project")) {
      return ["nostep", form$0];
    } else {
      m$3$0 = arg$2;if (($$19176$0 = Array.isArray(m$3$0)) && (t0$8 = m$3$0.length, t0$8 === 2 && (m$3$0[0] === "value" && (t1$8 = m$3$0[1], typeof t1$8 === "string")))) {
        v$2 = t1$8;m$4$0 = info$0.gettext(arg$2);if (getChecker(RegExp("^\\\".*\\\"$", ""))(m$4$0)) {
          text$1 = m$4$0;text$0 = text$1.substring(1, text$1.length - 1);
        } else {
          text$2 = m$4$0;text$0 = text$2;
        }return ["send", ["symbol", "RegExp"], ["data", ["value", text$0], ["value", flags$0.join("")]]];
      } else {
        if ($$19176$0 && (($$19178$0 = t0$8 === 3) && (($$19179$0 = m$3$0[0] === "send") && (t1$8 = m$3$0[1], ($$19181$0 = Array.isArray(t1$8)) && (t2$2 = t1$8.length, ($$19183$0 = t2$2 === 2) && (($$19184$0 = t1$8[0] === "symbol") && (t1$8[1] === "'" && (t3$2 = m$3$0[2], Array.isArray(t3$2) && (t4$2 = t3$2.length, t4$2 === 3 && (t3$2[0] === "data" && (t5$1 = t3$2[1], Array.isArray(t5$1) && (t6$1 = t5$1.length, t6$1 === 1 && t5$1[0] === "void")))))))))))) {
          arg$3 = t3$2[2];return ["send", ["symbol", "RegExp"], ["data", ["value", build_regexp$0(arg$3)], ["value", flags$0.join("")]]];
        } else {
          if ($$19184$0 && (t1$8[1] === "`" && (t3$2 = m$3$0[2], Array.isArray(t3$2) && (t4$2 = t3$2.length, t4$2 === 2 && t3$2[0] === "value")))) {
            s$1 = t3$2[1];arg$2 = info$0.go(Source$0(s$1, "<quasiquote>"), "source", "parse");return ["send", ["symbol", "RegExp"], ["data", ["value", build_regexp$0(arg$2)], ["value", flags$0.join("")]]];
          } else {
            return ___match_error(m$3$0, "#send{#symbol{\"`\"}, #value{s}}");
          }
        }
      }
    }
  };t0$9 = getProjector(accum_flagsf$0)($targ$2);if (t0$9[0] && (t1$9 = getProjector(mac$0("R"))(t0$9[1]), t1$9[0])) {
    regexp_mac$0 = t1$9[1];
  } else {
    ___match_error($targ$2, "accum_flagsf! mac{\"R\"}! regexp_mac{match, info, form, var arg, flags}");
  }return exports$0;
};module.exports = $targ$0;void 0;
//# sourceMappingURL=regexp.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../location":106,"./helpers":110,"earlgrey-runtime/5":446}],119:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$12 = undefined;var $targ$13 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var s$0 = undefined;var varstats$0 = undefined;var replaceVars$0 = undefined;var eliminate_spurious_variables$0 = undefined;var hoist$0 = undefined;var hoistable$0 = undefined;var not_hoistable$0 = undefined;var hoist_helper$0 = undefined;$0$0 = require("./location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "./location");s$0 = function s(stats$0, v$0) {
  var $targ$0 = undefined;if (!Object.hasOwnProperty.call(stats$0, v$0)) {
    $targ$0 = { assigns: 0, uses: 0, transfers: [], replaceable: false };stats$0[v$0] = $targ$0;void 0;
  }return send(stats$0, v$0);
};varstats$0 = function varstats(temp$0$0, stats$1) {
  var t0$0 = undefined;var x$0 = undefined;var m$0 = undefined;var m$1 = undefined;var m$2 = undefined;var acc$0 = undefined;var temp$1 = undefined;var other$0 = undefined;var vars$1 = undefined;var body$1 = undefined;var generator$0 = undefined;var vars$0 = undefined;var body$0 = undefined;var v$1 = undefined;var v1$1 = undefined;var expr$1 = undefined;var v1$0 = undefined;var v2$0 = undefined;var $$19333$0 = undefined;var $$19334$0 = undefined;var $$19335$0 = undefined;var $$19336$0 = undefined;var $$19337$0 = undefined;var $$19338$0 = undefined;var $$19339$0 = undefined;var $$19340$0 = undefined;var $$19341$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var expr$0 = undefined;var ph$0$0 = undefined;t0$0 = temp$0$0;expr$0 = t0$0;ph$0$0 = t0$0;t0$1 = ph$0$0;t1$0 = t0$1.length;if (($$19335$0 = t1$0 === 3) && (($$19336$0 = t0$1[0] === "assign") && (t2$0 = t0$1[1], ($$19338$0 = Array.isArray(t2$0)) && (t3$0 = t2$0.length, ($$19340$0 = t3$0 === 2) && (($$19341$0 = t2$0[0] === "variable") && (v1$0 = t2$0[1], t4$0 = t0$1[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 2 && t4$0[0] === "variable"))))))) {
    v2$0 = t4$0[1];s$0(stats$1, v1$0).assigns = s$0(stats$1, v1$0).assigns + 1;s$0(stats$1, v2$0).uses = s$0(stats$1, v2$0).uses + 1;return s$0(stats$1, v2$0).transfers.push(v1$0);
  } else {
    if ($$19341$0) {
      v1$1 = t2$0[1];expr$1 = t0$1[2];s$0(stats$1, v1$1).assigns = s$0(stats$1, v1$1).assigns + 1;return varstats$0(expr$1, stats$1);
    } else {
      if (t1$0 === 2 && t0$1[0] === "variable") {
        v$1 = t0$1[1];return s$0(stats$1, v$1).uses = s$0(stats$1, v$1).uses + 1;
      } else {
        if ((x$0 = ph$0$0, x$0 instanceof Array && x$0[0] === "value")) {
          return undefined;
        } else {
          t0$1 = ph$0$0;t1$0 = t0$1.length;if (t1$0 === 3 && t0$1[0] === "scope") {
            vars$0 = t0$1[1];body$0 = t0$1[2];m$0 = null;$1: for (var _iterator = vars$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$0 = _step.value;
              var $targ$1 = undefined;var v$2 = undefined;var t0$2 = undefined;var t1$1 = undefined;t0$2 = m$0;if (Array.isArray(t0$2) && (t1$1 = t0$2.length, t1$1 === 2 && t0$2[0] === "variable")) {
                v$2 = t0$2[1];$targ$1 = true;s$0(stats$1, v$2).replaceable = $targ$1;void 0;
              } else {
                ___match_error(m$0);
              }
            }return varstats$0(body$0, stats$1);
          } else {
            if (t1$0 >= 3 && t1$0 <= 4 && t0$1[0] === "lambda") {
              vars$1 = t0$1[1];body$1 = t0$1[2];if (3 >= t1$0) {
                generator$0 = null;
              } else {
                generator$0 = t0$1[3];
              }m$1 = null;$2: for (var _iterator2 = vars$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                m$1 = _step2.value;
                var v$3 = undefined;var t0$3 = undefined;var t1$2 = undefined;t0$3 = m$1;if (Array.isArray(t0$3) && (t1$2 = t0$3.length, t1$2 === 2 && t0$3[0] === "variable")) {
                  v$3 = t0$3[1];s$0(stats$1, v$3).assigns = s$0(stats$1, v$3).assigns + 1;
                } else {
                  ___match_error(m$1);
                }
              }return varstats$0(body$1, stats$1);
            } else {
              other$0 = ph$0$0;acc$0 = [];temp$1 = null;m$2 = null;$3: for (var _iterator3 = other$0.slice(1)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                m$2 = _step3.value;
                var x$1 = undefined;x$1 = m$2;temp$1 = varstats$0(x$1, stats$1);acc$0.push(temp$1);
              }return acc$0;
            }
          }
        }
      }
    }
  }
};replaceVars$0 = function replaceVars(temp$2$0, repl$0) {
  var t0$4 = undefined;var x$2 = undefined;var x$3 = undefined;var m$3 = undefined;var newvars$0 = undefined;var m$4 = undefined;var acc$1 = undefined;var temp$3 = undefined;var newrest$0 = undefined;var other$1 = undefined;var x$4 = undefined;var rest$0 = undefined;var vars$3 = undefined;var body$3 = undefined;var generator$1 = undefined;var vars$2 = undefined;var body$2 = undefined;var v1$2 = undefined;var v2$1 = undefined;var v$4 = undefined;var $$19503$0 = undefined;var $$19504$0 = undefined;var $$19505$0 = undefined;var t0$5 = undefined;var t1$3 = undefined;var t2$1 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$1 = undefined;var bridge$$19498$0 = undefined;var expr$2 = undefined;var ph$1$0 = undefined;t0$4 = temp$2$0;expr$2 = t0$4;ph$1$0 = t0$4;t0$5 = ph$1$0;if (($$19504$0 = Array.isArray(t0$5)) && (t1$3 = t0$5.length, t1$3 === 2 && (t0$5[0] === "variable" && (v$4 = t0$5[1], Object.hasOwnProperty.call(repl$0, v$4) && send(repl$0, v$4))))) {
    return __lt____lt____colon__$0(["variable", send(repl$0, v$4)], expr$2);
  } else {
    if ($$19504$0 && (t1$3 === 3 && (t0$5[0] === "assign" && (t2$1 = t0$5[1], Array.isArray(t2$1) && (t3$1 = t2$1.length, t3$1 === 2 && (t2$1[0] === "variable" && (v1$2 = t2$1[1], t4$1 = t0$5[2], Array.isArray(t4$1) && (t5$1 = t4$1.length, t5$1 === 2 && (t4$1[0] === "variable" && (v2$1 = t4$1[1], equal(send(repl$0, v1$2), v2$1) || equal(send(repl$0, v2$1), v1$2))))))))))) {
      return __lt____lt____colon__$0(["multi"], expr$2);
    } else {
      bridge$$19498$0 = ph$1$0;if ((x$2 = bridge$$19498$0, x$2 instanceof Array && x$2[0] === "variable") || (x$3 = bridge$$19498$0, x$3 instanceof Array && x$3[0] === "value")) {
        return expr$2;
      } else {
        t0$5 = ph$1$0;t1$3 = t0$5.length;if (t1$3 === 3 && t0$5[0] === "scope") {
          vars$2 = t0$5[1];body$2 = t0$5[2];newvars$0 = [];m$3 = null;$4: for (var _iterator = vars$2[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
            m$3 = _step.value;
            var _var$0 = undefined;var v$5 = undefined;var t0$6 = undefined;var t1$4 = undefined;t0$6 = m$3;_var$0 = t0$6;if (Array.isArray(t0$6) && (t1$4 = t0$6.length, t1$4 === 2 && t0$6[0] === "variable")) {
              v$5 = t0$6[1];if (Object.hasOwnProperty.call(repl$0, v$5)) {
                if (send(repl$0, v$5) !== false) {
                  newvars$0.push(__lt____lt____colon__$0(["variable", send(repl$0, v$5)], _var$0));
                }
              } else {
                newvars$0.push(_var$0);
              }
            } else {
              ___match_error(m$3);
            }
          }return __lt____lt____colon__$0(["scope", newvars$0, replaceVars$0(body$2, repl$0)], expr$2);
        } else {
          if (t1$3 >= 3 && t1$3 <= 4 && t0$5[0] === "lambda") {
            vars$3 = t0$5[1];body$3 = t0$5[2];if (3 >= t1$3) {
              generator$1 = null;
            } else {
              generator$1 = t0$5[3];
            }return __lt____lt____colon__$0(["lambda", vars$3, replaceVars$0(body$3, repl$0), generator$1], expr$2);
          } else {
            if (t1$3 >= 1) {
              x$4 = t0$5[0];rest$0 = Array.prototype.slice.call(t0$5, 1);acc$1 = [];temp$3 = null;m$4 = null;$5: for (var _iterator2 = rest$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                m$4 = _step2.value;
                var elem$0 = undefined;elem$0 = m$4;temp$3 = replaceVars$0(elem$0, repl$0);acc$1.push(temp$3);
              }newrest$0 = acc$1;return __lt____lt____colon__$0([x$4].concat(newrest$0), expr$2);
            } else {
              other$1 = ph$1$0;console.error(other$1);throw ErrorFactory(["replaceVars"]).create("Unknown: " + String(other$1));
            }
          }
        }
      }
    }
  }
};eliminate_spurious_variables$0 = function eliminate_spurious_variables(expr$3) {
  var m$5 = undefined;var stats$2 = undefined;var repl$1 = undefined;stats$2 = {};varstats$0(expr$3, stats$2);repl$1 = {};m$5 = null;$6: for (var _iterator = items(stats$2)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$5 = _step.value;
    var t0$8 = undefined;var t1$6 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$2 = undefined;var tr$0 = undefined;var st2$0 = undefined;var v$6 = undefined;var st$0 = undefined;var t0$7 = undefined;var t1$5 = undefined;t0$7 = m$5;if (Array.isArray(t0$7) && (t1$5 = t0$7.length, t1$5 === 2)) {
      v$6 = t0$7[0];st$0 = t0$7[1];if (equal(st$0.uses, 1) && equal(st$0.assigns, 1) && equal(st$0.transfers.length, 1) && st$0.replaceable) {
        $targ$2 = st$0.transfers;t0$8 = $targ$2;if (Array.isArray(t0$8) && (t1$6 = t0$8.length, t1$6 === 1)) {
          tr$0 = t0$8[0];
        } else {
          ___match_error($targ$2, "{tr}");
        }st2$0 = s$0(stats$2, tr$0);if (equal(st2$0.assigns, 1) && st2$0.replaceable) {
          $targ$3 = tr$0;repl$1[v$6] = $targ$3;$targ$4 = false;repl$1[tr$0] = $targ$4;$targ$5 = false;st$0.replaceable = $targ$5;$targ$6 = false;st2$0.replaceable = $targ$6;void 0;
        }
      }
    } else {
      ___match_error(m$5);
    }
  }return replaceVars$0(expr$3, repl$1);
};hoist$0 = function hoist(expr$4) {
  var t0$9 = undefined;var t1$7 = undefined;var $targ$7 = undefined;var b$0 = undefined;var inner$0 = undefined;$targ$7 = hoist_helper$0(expr$4);t0$9 = $targ$7;if (Array.isArray(t0$9) && (t1$7 = t0$9.length, t1$7 === 2)) {
    b$0 = t0$9[0];inner$0 = t0$9[1];
  } else {
    ___match_error($targ$7, "{b, inner}");
  }[b$0, inner$0];return ["scope", inner$0, b$0];
};hoistable$0 = ["send", "array", "object", "multi", "if", "assign", "js_break", "js_continue", "js_return", "js_delete", "js_throw", "js_try", "js_new", "js_yield"];not_hoistable$0 = ["void", "js_while", "js_for", "js_for_in", "js_for_of", "js_label"];hoist_helper$0 = function hoist_helper(temp$4$0) {
  var t0$10 = undefined;var x$5 = undefined;var x$6 = undefined;var bridge$$19757$0 = undefined;var x$7 = undefined;var t0$12 = undefined;var t1$9 = undefined;var $targ$8 = undefined;var newbody$0 = undefined;var inner$1 = undefined;var t0$13 = undefined;var t1$10 = undefined;var $targ$9 = undefined;var newbody$1 = undefined;var inner$2 = undefined;var newlambda$0 = undefined;var m$6 = undefined;var acc$2 = undefined;var temp$5 = undefined;var accum$0 = undefined;var newargs$0 = undefined;var m$7 = undefined;var acc$3 = undefined;var temp$6 = undefined;var newargs$1 = undefined;var other$3 = undefined;var type$1 = undefined;var args$1 = undefined;var type$0 = undefined;var args$0 = undefined;var vars$5 = undefined;var body$5 = undefined;var generator$2 = undefined;var vars$4 = undefined;var body$4 = undefined;var $$19763$0 = undefined;var $$19764$0 = undefined;var $$19765$0 = undefined;var $$19766$0 = undefined;var bridge$$19756$0 = undefined;var t0$11 = undefined;var t1$8 = undefined;var expr$5 = undefined;var ph$2$0 = undefined;t0$10 = temp$4$0;expr$5 = t0$10;ph$2$0 = t0$10;bridge$$19756$0 = ph$2$0;if ((bridge$$19757$0 = bridge$$19756$0, (x$5 = bridge$$19757$0, x$5 instanceof Array && x$5[0] === "symbol") || (x$6 = bridge$$19757$0, x$6 instanceof Array && x$6[0] === "value")) || (x$7 = bridge$$19756$0, x$7 instanceof Array && x$7[0] === "variable")) {
    return [expr$5, []];
  } else {
    t0$11 = ph$2$0;t1$8 = t0$11.length;if (t1$8 === 3 && t0$11[0] === "scope") {
      vars$4 = t0$11[1];body$4 = t0$11[2];$targ$8 = hoist_helper$0(body$4);t0$12 = $targ$8;if (Array.isArray(t0$12) && (t1$9 = t0$12.length, t1$9 === 2)) {
        newbody$0 = t0$12[0];inner$1 = t0$12[1];
      } else {
        ___match_error($targ$8, "{newbody, inner}");
      }[newbody$0, inner$1];return [newbody$0, inner$1.concat(vars$4)];
    } else {
      if (t1$8 === 4 && t0$11[0] === "lambda") {
        vars$5 = t0$11[1];body$5 = t0$11[2];generator$2 = t0$11[3];$targ$9 = hoist_helper$0(body$5);t0$13 = $targ$9;if (Array.isArray(t0$13) && (t1$10 = t0$13.length, t1$10 === 2)) {
          newbody$1 = t0$13[0];inner$2 = t0$13[1];
        } else {
          ___match_error($targ$9, "{newbody, inner}");
        }[newbody$1, inner$2];newlambda$0 = __amp____colon__(["lambda", vars$5, __lt____lt____colon__$0(["scope", inner$2, newbody$1], body$5), generator$2], { name: expr$5.name });return [__lt____lt____colon__$0(newlambda$0, expr$5), []];
      } else {
        if (($$19764$0 = Array.isArray(t0$11)) && (t1$8 = t0$11.length, ($$19766$0 = t1$8 >= 1) && (type$0 = t0$11[0], args$0 = Array.prototype.slice.call(t0$11, 1), hoistable$0.indexOf(type$0) !== -1))) {
          accum$0 = [];acc$2 = [];temp$5 = null;m$6 = null;$7: for (var _iterator = args$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
            m$6 = _step.value;
            var t0$14 = undefined;var t1$11 = undefined;var $targ$10 = undefined;var b$1 = undefined;var inner$3 = undefined;var arg$0 = undefined;arg$0 = m$6;$targ$10 = hoist_helper$0(arg$0);t0$14 = $targ$10;if (Array.isArray(t0$14) && (t1$11 = t0$14.length, t1$11 === 2)) {
              b$1 = t0$14[0];inner$3 = t0$14[1];
            } else {
              ___match_error($targ$10, "{b, inner}");
            }[b$1, inner$3];accum$0 = accum$0.concat(inner$3);temp$5 = b$1;acc$2.push(temp$5);
          }newargs$0 = acc$2;return [__lt____lt____colon__$0([type$0].concat(newargs$0), expr$5), accum$0];
        } else {
          if ($$19766$0 && (type$1 = t0$11[0], args$1 = Array.prototype.slice.call(t0$11, 1), not_hoistable$0.indexOf(type$1) !== -1)) {
            acc$3 = [];temp$6 = null;m$7 = null;$8: for (var _iterator2 = args$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
              m$7 = _step2.value;
              var t0$15 = undefined;var t1$12 = undefined;var other$2 = undefined;var t0$16 = undefined;var m$8$0 = undefined;var $targ$11 = undefined;var b$2 = undefined;var inner$4 = undefined;var arg$1 = undefined;arg$1 = m$7;$targ$11 = hoist_helper$0(arg$1);t0$15 = $targ$11;if (Array.isArray(t0$15) && (t1$12 = t0$15.length, t1$12 === 2)) {
                b$2 = t0$15[0];inner$4 = t0$15[1];
              } else {
                ___match_error($targ$11, "{b, inner}");
              }[b$2, inner$4];m$8$0 = inner$4;if (Array.isArray(m$8$0) && (t0$16 = m$8$0.length, t0$16 === 0)) {
                temp$6 = b$2;
              } else {
                other$2 = m$8$0;temp$6 = ["scope", inner$4, b$2];
              }acc$3.push(temp$6);
            }newargs$1 = acc$3;return [__lt____lt____colon__$0([type$1].concat(newargs$1), expr$5), []];
          } else {
            other$3 = ph$2$0;throw ErrorFactory(["syntax", "illegal"]).create("Illegal node -- this should not happen.", { node: other$3 });
          }
        }
      }
    }
  }
};$targ$12 = hoist$0;exports.hoist = $targ$12;$targ$13 = eliminate_spurious_variables$0;exports.eliminate_spurious_variables = $targ$13;void 0;
//# sourceMappingURL=opt.js.map


},{"./location":106,"earlgrey-runtime/5":446}],120:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$6 = undefined;var accum$0 = undefined;var $targ$7 = undefined;var accum$1 = undefined;var $targ$16 = undefined;var accum$2 = undefined;var $targ$17 = undefined;var accum$3 = undefined;var $targ$18 = undefined;var accum$4 = undefined;var $targ$19 = undefined;var accum$5 = undefined;var $targ$20 = undefined;var accum$6 = undefined;var $targ$21 = undefined;var accum$7 = undefined;var $targ$22 = undefined;var accum$8 = undefined;var $targ$23 = undefined;var accum$9 = undefined;var $targ$24 = undefined;var accum$10 = undefined;var $targ$25 = undefined;var accum$11 = undefined;var $targ$26 = undefined;var accum$12 = undefined;var $targ$27 = undefined;var accum$13 = undefined;var $targ$28 = undefined;var accum$14 = undefined;var $targ$29 = undefined;var accum$15 = undefined;var $targ$30 = undefined;var accum$16 = undefined;var $targ$31 = undefined;var accum$17 = undefined;var $targ$32 = undefined;var accum$18 = undefined;var $targ$33 = undefined;var accum$19 = undefined;var eg_groups$0 = undefined;var eg_prio$0 = undefined;var $targ$39 = undefined;var $targ$40 = undefined;var $targ$41 = undefined;var $targ$42 = undefined;var $targ$43 = undefined;var $targ$44 = undefined;var $targ$45 = undefined;var $targ$46 = undefined;var $targ$47 = undefined;var $targ$48 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var __plus____plus____colon__$0 = undefined;var $1$0 = undefined;var Body$0 = undefined;var transform$0 = undefined;var OperatorGroups$0 = undefined;var $targ$0 = undefined;var parse_op_description$0 = undefined;var SimplePriority$0 = undefined;var MAX$0 = undefined;var eg_order$0 = undefined;var DONE$0 = undefined;var NONE$0 = undefined;var LEFT$0 = undefined;var RIGHT$0 = undefined;var BOTH$0 = undefined;var oparse$0 = undefined;var finalize$0 = undefined;var parse$0 = undefined;$0$0 = require("./location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "./location");__plus____plus____colon__$0 = getProperty($0$0, "++:", "./location");$1$0 = require("./util");Body$0 = getProperty($1$0, "Body", "./util");transform$0 = function transform(expr$0, cb$0) {
  var rval$0 = undefined;var tr$0 = undefined;var result$0 = undefined;tr$0 = function tr(x$0) {
    return transform$0(x$0, cb$0);
  };rval$0 = false;try {
    rval$0 = cb$0.call(tr$0, expr$0);rval$0;
  } catch (excv$0) {
    var name$0 = undefined;var args$0 = undefined;var v$0 = undefined;var s$0 = undefined;var $$1562$0 = undefined;var $$1563$0 = undefined;var $$1564$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;var e$0 = undefined;e$0 = excv$0;m$0$0 = expr$0;if (($$1562$0 = Array.isArray(m$0$0)) && (t0$0 = m$0$0.length, t0$0 === 1 && m$0$0[0] === "void")) {
      rval$0 = ["void"];
    } else {
      if ($$1562$0 && (($$1564$0 = t0$0 === 2) && m$0$0[0] === "symbol")) {
        s$0 = m$0$0[1];rval$0 = expr$0;
      } else {
        if ($$1564$0 && m$0$0[0] === "value") {
          v$0 = m$0$0[1];rval$0 = expr$0;
        } else {
          if ($$1562$0 && t0$0 >= 1) {
            name$0 = m$0$0[0];args$0 = Array.prototype.slice.call(m$0$0, 1);rval$0 = [name$0].concat(args$0.map(tr$0));
          } else {
            rval$0 = ___match_error(m$0$0, "{name, *args}");
          }
        }
      }
    }rval$0;
  }result$0 = rval$0;return __lt____lt____colon__$0(result$0, expr$0);
};OperatorGroups$0 = function OperatorGroups(groups$0) {
  var m$1 = undefined;var acc$0 = undefined;var temp$0 = undefined;var m$2 = undefined;var acc$1 = undefined;var temp$1 = undefined;var m$4 = undefined;var acc$3 = undefined;var temp$3 = undefined;var itg$0 = undefined;var $targ$1 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $it$0 = undefined;if (!getChecker(OperatorGroups$0)(this)) {
    $it$0 = Object.create(OperatorGroups$0.prototype);
  } else {
    $it$0 = this;
  }itg$0 = items(groups$0);acc$0 = [];temp$0 = null;m$1 = null;$3: for (var _iterator = itg$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$1 = _step.value;
    var name$1 = undefined;var t0$1 = undefined;var t1$0 = undefined;t0$1 = m$1;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 2)) {
      name$1 = t0$1[0];t0$1[1];temp$0 = name$1;acc$0.push(temp$0);
    } else {
      ___match_error(m$1);
    }
  }$targ$1 = acc$0;$it$0.gnames = $targ$1;acc$1 = [];temp$1 = null;m$2 = null;$4: for (var _iterator2 = itg$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    (function () {
      m$2 = _step2.value;
      var m$3 = undefined;var acc$2 = undefined;var temp$2 = undefined;var name$2 = undefined;var descrs$0 = undefined;var t0$2 = undefined;var t1$1 = undefined;t0$2 = m$2;if (Array.isArray(t0$2) && (t1$1 = t0$2.length, t1$1 === 2)) {
        name$2 = t0$2[0];descrs$0 = t0$2[1];temp$1 = ___build_array((acc$2 = [], temp$2 = null, m$3 = null, (function () {
          $5: for (var _iterator3 = descrs$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
            m$3 = _step3.value;
            var descr$0 = undefined;descr$0 = m$3;temp$2 = parse_op_description$0(descr$0);acc$2.push(temp$2);
          }
        })(), acc$2));acc$1.push(temp$1);
      } else {
        ___match_error(m$2);
      }
    })();
  }$targ$2 = acc$1;$it$0.groups = $targ$2;$targ$3 = [];$it$0.fns = $targ$3;$targ$4 = { IFX: { wide: {}, short: {} }, PFX: { wide: {}, short: {} }, SFX: { wide: {}, short: {} } };$it$0.to_gid = $targ$4;acc$3 = [];temp$3 = null;m$4 = null;$2: for (var _iterator3 = enumerate($it$0.groups)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
    m$4 = _step3.value;
    var m$5 = undefined;var acc$4 = undefined;var temp$4 = undefined;var i$0 = undefined;var group$0 = undefined;var t0$3 = undefined;var t1$2 = undefined;t0$3 = m$4;if (Array.isArray(t0$3) && (t1$2 = t0$3.length, t1$2 === 2)) {
      i$0 = t0$3[0];group$0 = t0$3[1];acc$4 = [];temp$4 = null;m$5 = null;$6: for (var _iterator4 = group$0[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
        m$5 = _step4.value;
        var $targ$5 = undefined;var f$0 = undefined;var fixity$0 = undefined;var width$0 = undefined;var name$3 = undefined;var t0$4 = undefined;var t1$3 = undefined;t0$4 = m$5;if (Array.isArray(t0$4) && (t1$3 = t0$4.length, t1$3 === 3)) {
          fixity$0 = t0$4[0];width$0 = t0$4[1];name$3 = t0$4[2];$targ$5 = i$0;send(send(send($it$0, "to_gid", true), fixity$0, true), width$0)[name$3] = $targ$5;temp$4 = void 0;acc$4.push(temp$4);
        } else {
          f$0 = m$5;temp$4 = $it$0.fns.push([f$0, i$0]);acc$4.push(temp$4);
        }
      }temp$3 = acc$4;acc$3.push(temp$3);
    } else {
      ___match_error(m$4);
    }
  }return $it$0;
};OperatorGroups$0.prototype.get_name = function get_name(o$0) {
  var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;return send(send($it$1, "gnames", true), $it$1.get(o$0));
};$targ$0 = function (temp$5$0) {
  var t0$5 = undefined;var t1$4 = undefined;var m$6 = undefined;var attempt$0 = undefined;var o$1 = undefined;var fixity$1 = undefined;var width$1 = undefined;var name$4 = undefined;var $it$2 = undefined;var self$1 = undefined;$it$2 = this;self$1 = this;t0$5 = temp$5$0;o$1 = t0$5;if (Array.isArray(t0$5) && (t1$4 = t0$5.length, t1$4 === 3)) {
    fixity$1 = t0$5[0];width$1 = t0$5[1];name$4 = t0$5[2];
  } else {
    ___match_error(temp$5$0);
  }attempt$0 = send(send(send(send($it$2, "to_gid", true), fixity$1, true), width$1, true), name$4);if (attempt$0 === void 0) {
    m$6 = null;$7: for (var _iterator = $it$2.fns[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$6 = _step.value;
      var f$1 = undefined;var i$1 = undefined;var t0$6 = undefined;var t1$5 = undefined;t0$6 = m$6;if (Array.isArray(t0$6) && (t1$5 = t0$6.length, t1$5 === 2)) {
        f$1 = t0$6[0];i$1 = t0$6[1];if (f$1(o$1)) {
          return i$1;
        }
      } else {
        ___match_error(m$6);
      }
    }throw ErrorFactory(["syntax", "unknown_operator"]).create("Unknown operator: " + [true, String(o$1)][1], { operator: o$1 });
  } else {
    return attempt$0;
  }
};OperatorGroups$0.prototype.get = $targ$0;__amp____colon__(OperatorGroups$0, __amp____colon__(($targ$6 = "OperatorGroups", accum$0 = {}, accum$0["::name"] = $targ$6, accum$0), ($targ$7 = true, accum$1 = {}, accum$1["::egclass"] = $targ$7, accum$1)));parse_op_description$0 = function parse_op_description(ph$0$0) {
  var otherwise$0 = undefined;var $$1928$0 = undefined;var m$7$0 = undefined;var t0$8 = undefined;var t1$7 = undefined;var $targ$8 = undefined;var fixity$2 = undefined;var short$1 = undefined;var other$0 = undefined;var x$1 = undefined;var w1$0 = undefined;var op$0 = undefined;var w2$0 = undefined;var y$0 = undefined;var f$2 = undefined;var rx$0 = undefined;var t0$7 = undefined;var t1$6 = undefined;var t2$0 = undefined;rx$0 = RegExp("(?:^((?:X?))((?:[ _]?))((?:[^ _Y]*))((?:[ _]?))((?:Y?))$)", "");t0$7 = ph$0$0;if (typeof t0$7 === "function") {
    f$2 = t0$7;return f$2;
  } else {
    t0$7 = getProjector(rx$0)(ph$0$0);if (t0$7[0] && (t1$6 = t0$7[1], t2$0 = t1$6.length, t2$0 === 6)) {
      t1$6[0];x$1 = t1$6[1];w1$0 = t1$6[2];op$0 = t1$6[3];w2$0 = t1$6[4];y$0 = t1$6[5];m$7$0 = null;if (x$1 === "") {
        $targ$8 = ["PFX", w2$0 === ""];
      } else {
        if (y$0 === "") {
          $targ$8 = ["SFX", w1$0 === ""];
        } else {
          otherwise$0 = m$7$0;$targ$8 = ["IFX", w1$0 === "" || w2$0 === ""];
        }
      }t0$8 = $targ$8;if (Array.isArray(t0$8) && (t1$7 = t0$8.length, t1$7 === 2)) {
        fixity$2 = t0$8[0];short$1 = t0$8[1];
      } else {
        ___match_error($targ$8, "{fixity, short}");
      }[fixity$2, short$1];if (w1$0 === "_" || w2$0 === "_") {
        return [[fixity$2, "short", op$0], [fixity$2, "wide", op$0]];
      } else {
        return [[fixity$2, short$1 ? "short" : "wide", op$0]];
      }
    } else {
      other$0 = ph$0$0;throw ErrorFactory(["invalid_op_description"]).create("Invalid operator description: " + other$0);
    }
  }
};SimplePriority$0 = function SimplePriority(groups$1, priorities$0) {
  var m$8 = undefined;var acc$5 = undefined;var temp$6 = undefined;var $targ$9 = undefined;var _i$0 = undefined;var tracks$0 = undefined;var $targ$10 = undefined;var $it$3 = undefined;if (!getChecker(SimplePriority$0)(this)) {
    $it$3 = Object.create(SimplePriority$0.prototype);
  } else {
    $it$3 = this;
  }$targ$9 = groups$1;$it$3.groups = $targ$9;_i$0 = 0;tracks$0 = {};acc$5 = [];temp$6 = null;m$8 = null;$8: for (var _iterator = groups$1.gnames[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$8 = _step.value;
    var t$0 = undefined;var t$1 = undefined;var t0$9 = undefined;var t1$8 = undefined;var t2$1 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var m$9 = undefined;var acc$6 = undefined;var temp$7 = undefined;var t0$10 = undefined;var t1$9 = undefined;var $targ$11 = undefined;var ltracks$0 = undefined;var lp$0 = undefined;var rtracks$0 = undefined;var rp$0 = undefined;var $targ$12 = undefined;var lt$0 = undefined;var rt$0 = undefined;var name$5 = undefined;name$5 = m$8;$targ$11 = send(priorities$0, name$5);t0$9 = $targ$11;if (Array.isArray(t0$9) && (t1$8 = t0$9.length, t1$8 === 2 && (t2$1 = t0$9[0], Array.isArray(t2$1) && (t3$0 = t2$1.length, t3$0 === 2 && (t4$0 = [true, (t$0 = t2$1[0], Array.isArray(t$0) ? t$0 : [t$0])], t4$0[0] && (ltracks$0 = t4$0[1], lp$0 = t2$1[1], t5$0 = t0$9[1], Array.isArray(t5$0) && (t6$0 = t5$0.length, t6$0 === 2 && (t7$0 = [true, (t$1 = t5$0[0], Array.isArray(t$1) ? t$1 : [t$1])], t7$0[0])))))))) {
      rtracks$0 = t7$0[1];rp$0 = t5$0[1];
    } else {
      ___match_error($targ$11, "{{Array! ltracks, lp}, {Array! rtracks, rp}}");
    }[ltracks$0, lp$0, rtracks$0, rp$0];acc$6 = [];temp$7 = null;m$9 = null;$9: for (var _iterator2 = [ltracks$0, rtracks$0][Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
      m$9 = _step2.value;
      var m$10 = undefined;var rval$1 = undefined;var tr$1 = undefined;tr$1 = m$9;rval$1 = 0;m$10 = null;$10: for (var _iterator3 = tr$1[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
        m$10 = _step3.value;
        var $targ$13 = undefined;var t$3 = undefined;var t$2 = undefined;if (m$10 === "all") {
          rval$1 = Math.pow(2, 31) - 1;rval$1;
        } else {
          t$2 = m$10;if (!send(tracks$0, t$2)) {
            rval$1 = rval$1 | Math.pow(2, _i$0);$targ$13 = _i$0++;tracks$0[t$2] = $targ$13;void 0;
          } else {
            t$3 = m$10;rval$1 = rval$1 | Math.pow(2, send(tracks$0, t$3));rval$1;
          }
        }
      }temp$7 = rval$1;acc$6.push(temp$7);
    }$targ$12 = acc$6;t0$10 = $targ$12;if (Array.isArray(t0$10) && (t1$9 = t0$10.length, t1$9 === 2)) {
      lt$0 = t0$10[0];rt$0 = t0$10[1];
    } else {
      ___match_error($targ$12, "{lt, rt}");
    }[lt$0, rt$0];temp$6 = [[lt$0, lp$0], [rt$0, rp$0]];acc$5.push(temp$6);
  }$targ$10 = acc$5;$it$3.prio = $targ$10;return $it$3;
};SimplePriority$0.prototype.compare = function compare(op1$0, op2$0) {
  var t0$11 = undefined;var t1$10 = undefined;var t2$2 = undefined;var t3$1 = undefined;var t0$12 = undefined;var t1$11 = undefined;var t2$3 = undefined;var t3$2 = undefined;var $$2171$0 = undefined;var m$11$0 = undefined;var i1$0 = undefined;var i2$0 = undefined;var $targ$14 = undefined;var code1$0 = undefined;var ord1$0 = undefined;var $targ$15 = undefined;var code2$0 = undefined;var ord2$0 = undefined;var $it$4 = undefined;var self$2 = undefined;$it$4 = this;self$2 = this;i1$0 = $it$4.groups.get(op1$0);i2$0 = $it$4.groups.get(op2$0);$targ$14 = send(send($it$4, "prio", true), i1$0);t0$11 = $targ$14;if (Array.isArray(t0$11) && (t1$10 = t0$11.length, t1$10 === 2 && (t0$11[0], t2$2 = t0$11[1], Array.isArray(t2$2) && (t3$1 = t2$2.length, t3$1 === 2)))) {
    code1$0 = t2$2[0];ord1$0 = t2$2[1];
  } else {
    ___match_error($targ$14, "{_, {code1, ord1}}");
  }[code1$0, ord1$0];$targ$15 = send(send($it$4, "prio", true), i2$0);t0$12 = $targ$15;if (Array.isArray(t0$12) && (t1$11 = t0$12.length, t1$11 === 2 && (t2$3 = t0$12[0], Array.isArray(t2$3) && (t3$2 = t2$3.length, t3$2 === 2)))) {
    code2$0 = t2$3[0];ord2$0 = t2$3[1];t0$12[1];
  } else {
    ___match_error($targ$15, "{{code2, ord2}, _}");
  }[code2$0, ord2$0];m$11$0 = null;if ((code1$0 & code2$0) === 0) {
    return NONE$0;
  } else {
    if (ord1$0 > ord2$0) {
      return LEFT$0;
    } else {
      if (ord1$0 < ord2$0) {
        return RIGHT$0;
      } else {
        if (ord1$0 === ord2$0) {
          return BOTH$0;
        } else {
          return ___match_error(m$11$0, "when [ord1 === ord2]");
        }
      }
    }
  }
};__amp____colon__(SimplePriority$0, __amp____colon__(($targ$16 = "SimplePriority", accum$2 = {}, accum$2["::name"] = $targ$16, accum$2), ($targ$17 = true, accum$3 = {}, accum$3["::egclass"] = $targ$17, accum$3)));MAX$0 = 1 / 0;eg_groups$0 = OperatorGroups$0(__amp____colon__(($targ$18 = [function (ph$1$0) {
  var t0$13 = undefined;var t1$12 = undefined;t0$13 = ph$1$0;t1$12 = t0$13.length;if (t1$12 === 3 && (t0$13[0] === "PFX" && (t0$13[1], getChecker(RegExp("^each", ""))(t0$13[2])))) {
    return true;
  } else {
    return false;
  }
}], accum$4 = {}, accum$4.eachp = $targ$18, accum$4), __amp____colon__(($targ$19 = [function (ph$2$0) {
  var t0$14 = undefined;var t1$13 = undefined;t0$14 = ph$2$0;t1$13 = t0$14.length;if (t1$13 === 3 && (t0$14[0] === "IFX" && (t0$14[1], getChecker(RegExp("^each", ""))(t0$14[2])))) {
    return true;
  } else {
    return false;
  }
}], accum$5 = {}, accum$5.each = $targ$19, accum$5), __amp____colon__({ sh_ifx: [function (ph$3$0) {
    var t0$15 = undefined;var t1$14 = undefined;t0$15 = ph$3$0;t1$14 = t0$15.length;if (t1$14 === 3 && (t0$15[0] === "IFX" && t0$15[1] === "short")) {
      t0$15[2];return true;
    } else {
      return false;
    }
  }], sh_pfx: [function (ph$4$0) {
    var t0$16 = undefined;var t1$15 = undefined;t0$16 = ph$4$0;t1$15 = t0$16.length;if (t1$15 === 3 && (t0$16[0] === "PFX" && t0$16[1] === "short")) {
      t0$16[2];return true;
    } else {
      return false;
    }
  }], sh_sfx: [function (ph$5$0) {
    var t0$17 = undefined;var t1$16 = undefined;t0$17 = ph$5$0;t1$16 = t0$17.length;if (t1$16 === 3 && (t0$17[0] === "SFX" && t0$17[1] === "short")) {
      t0$17[2];return true;
    } else {
      return false;
    }
  }], wi_ifx: [function (ph$6$0) {
    var t0$18 = undefined;var t1$17 = undefined;t0$18 = ph$6$0;t1$17 = t0$18.length;if (t1$17 === 3 && (t0$18[0] === "IFX" && t0$18[1] === "wide")) {
      t0$18[2];return true;
    } else {
      return false;
    }
  }], wi_pfx: [function (ph$7$0) {
    var t0$19 = undefined;var t1$18 = undefined;t0$19 = ph$7$0;t1$18 = t0$19.length;if (t1$18 === 3 && (t0$19[0] === "PFX" && t0$19[1] === "wide")) {
      t0$19[2];return true;
    } else {
      return false;
    }
  }], wi_sfx: [function (ph$8$0) {
    var t0$20 = undefined;var t1$19 = undefined;t0$20 = ph$8$0;t1$19 = t0$20.length;if (t1$19 === 3 && (t0$20[0] === "SFX" && t0$20[1] === "wide")) {
      t0$20[2];return true;
    } else {
      return false;
    }
  }], comma: ["X_,_Y"], semico: ["X_;_Y"], obrack: ["(_Y", "[_Y", "{_Y"], cbrack: ["X_)", "X_]", "X_}"] }, __amp____colon__(($targ$20 = ["with Y"], accum$6 = {}, accum$6.withp = $targ$20, accum$6), __amp____colon__(($targ$21 = ["X with Y"], accum$7 = {}, accum$7["with"] = $targ$21, accum$7), __amp____colon__({ assign: ["X_=>_Y", "X_=_Y", "X_:=_Y", "X_+=_Y", "X_-=_Y", "X_*=_Y", "X_/=_Y", "X_<<=_Y", "X_>>=_Y", "X_>>>=_Y", "X_++=_Y", "X_?=_Y", "X_or=_Y", "X_and=_Y", "X_each=_Y"], assignp: ["=_Y", "=>_Y"], lbda: ["X_->_Y", "X_*->_Y", "X_@->_Y"], lbdap: ["->_Y", "*->_Y", "@->_Y"], lowprio: ["X where Y", "X_!!_Y"], colonp: [":_Y"], build: ["X_%_Y"], buildp: ["%_Y"] }, __amp____colon__(($targ$22 = ["X_when_Y"], accum$8 = {}, accum$8.when = $targ$22, accum$8), __amp____colon__(($targ$23 = ["X_as_Y"], accum$9 = {}, accum$9.as = $targ$23, accum$9), __amp____colon__(($targ$24 = ["X_or_Y"], accum$10 = {}, accum$10.or = $targ$24, accum$10), __amp____colon__(($targ$25 = ["X_and_Y"], accum$11 = {}, accum$11.and = $targ$25, accum$11), __amp____colon__(($targ$26 = ["not_Y"], accum$12 = {}, accum$12.not = $targ$26, accum$12), { type: ["X_!_Y", "X_?_Y"], cmp: ["X_==_Y", "X_!=_Y", "X_is_Y", "X_>=_Y", "X_<=_Y", "X_>_Y", "X_<_Y"], binxor: ["X_^+_Y"], binor: ["X_|+_Y"], binand: ["X_&+_Y"], shift: ["X_<<_Y", "X_>>_Y", "X_>>>_Y"], add: ["X_+_Y", "X_-_Y"], mul: ["X_*_Y", "X_/_Y", "X_//_Y", "X_mod_Y"], exp: ["X_**_Y"], sjuxt: ["XWHITEY"], wjuxt: ["X WHITE Y"], colon: ["X_:_Y"], maysend: ["X_??"], pfx: ["._Y", "#_Y", "@_Y"], when2: ["when Y"], pp: ["<>_Y"], pipe: ["X_|>_Y"] }))))))))))));eg_prio$0 = __amp____colon__({ comma: [["all", 5], ["all", 5]], semico: [["all", 2], ["all", 2]], obrack: [["all", MAX$0], ["all", 1]], cbrack: [["all", 1], ["all", MAX$0]] }, __amp____colon__(($targ$27 = [["all", 1999], ["all", 4]], accum$13 = {}, accum$13["with"] = $targ$27, accum$13), __amp____colon__({ lowprio: [["all", 11], ["all", 4]], lbda: [["all", 11], ["all", 10]], assign: [["all", 11], ["all", 10]], build: [["all", 13], ["all", 10]] }, __amp____colon__(($targ$28 = [["all", 135], ["all", 10]], accum$14 = {}, accum$14.each = $targ$28, accum$14), __amp____colon__(($targ$29 = [["all", 100], ["all", 101]], accum$15 = {}, accum$15.when = $targ$29, accum$15), __amp____colon__(($targ$30 = [["all", 104], ["all", 105]], accum$16 = {}, accum$16.as = $targ$30, accum$16), __amp____colon__(($targ$31 = [["all", 110], ["all", 111]], accum$17 = {}, accum$17.or = $targ$31, accum$17), __amp____colon__(($targ$32 = [["all", 120], ["all", 121]], accum$18 = {}, accum$18.and = $targ$32, accum$18), __amp____colon__(($targ$33 = [["all", MAX$0], ["all", 131]], accum$19 = {}, accum$19.not = $targ$33, accum$19), { type: [["all", 141], ["all", 140]], cmp: [["all", 200], ["all", 201]], binxor: [["all", 400], ["all", 401]], binor: [["all", 410], ["all", 411]], binand: [["all", 420], ["all", 421]], shift: [["arith", 500], ["arith", 501]], add: [["arith", 550], ["arith", 551]], mul: [["arith", 560], ["arith", 561]], exp: [["arith", 571], ["arith", 570]], wjuxt: [["all", 1000], ["all", 12]], colon: [["all", 12], ["all", 4]], sjuxt: [["all", 2000], ["all", 2001]], pfx: [["all", MAX$0], ["all", 3000]], pp: [["all", MAX$0], ["all", 5]], when2: [["all", MAX$0], ["all", 101]], withp: [["all", MAX$0], ["all", 4]], eachp: [["all", MAX$0], ["all", 10]], lbdap: [["all", MAX$0], ["all", 10]], colonp: [["all", MAX$0], ["all", 4]], assignp: [["all", MAX$0], ["all", 10]], buildp: [["all", MAX$0], ["all", 10]], pipe: [["pipe", 550], ["pipe", 551]], sh_ifx: [["all", 1800], ["all", 1801]], maysend: [["all", 1850], ["all", MAX$0]], sh_pfx: [["all", MAX$0], ["all", 1901]], sh_sfx: [["all", 1900], ["all", MAX$0]], wi_ifx: [["customl", 900], ["customr", 901]], wi_pfx: [["all", MAX$0], ["all", 901]], wi_sfx: [["all", 900], ["all", MAX$0]] })))))))));eg_order$0 = SimplePriority$0(eg_groups$0, eg_prio$0);DONE$0 = -1;NONE$0 = 0;LEFT$0 = 1;RIGHT$0 = 2;BOTH$0 = 3;oparse$0 = function oparse(next$0, order$0, finalize$1) {
  var between$0 = undefined;var right_op$0 = undefined;var stack$0 = undefined;var left_op$0 = undefined;var current$0 = undefined;between$0 = finalize$1(next$0());right_op$0 = next$0();stack$0 = [];left_op$0 = null;current$0 = null;$11: while (true) {
    var v$1 = undefined;var $targ$34 = undefined;var other$1 = undefined;var bridge$$2544$0 = undefined;var m$12$0 = undefined;var o$2 = undefined;if (!left_op$0 && !right_op$0) {
      o$2 = DONE$0;
    } else {
      o$2 = !left_op$0 && RIGHT$0 || !right_op$0 && LEFT$0 || order$0(left_op$0, right_op$0);
    }m$12$0 = o$2;if (m$12$0 === DONE$0) {
      return between$0;
    } else {
      if (m$12$0 === LEFT$0) {
        current$0.push(between$0);between$0 = finalize$1(current$0);v$1 = stack$0.pop();left_op$0 = v$1[0];current$0 = v$1[1];current$0;
      } else {
        if (m$12$0 === RIGHT$0) {
          stack$0.push([left_op$0, current$0]);left_op$0 = right_op$0;current$0 = [[right_op$0], between$0];between$0 = finalize$1(next$0());right_op$0 = next$0();right_op$0;
        } else {
          bridge$$2544$0 = m$12$0;if (bridge$$2544$0 === BOTH$0 || bridge$$2544$0 === NONE$0) {
            current$0[0].push(right_op$0);current$0.push(between$0);left_op$0 = right_op$0;between$0 = finalize$1(next$0());right_op$0 = next$0();if (o$2 === NONE$0) {
              $targ$34 = true;current$0.tainted = $targ$34;void 0;
            }
          } else {
            other$1 = m$12$0;throw ErrorFactory(["should_never_happen"]).create("undefined priority", { left: left_op$0, right: right_op$0 });
          }
        }
      }
    }
  }
};finalize$0 = function finalize(temp$8$0) {
  var t0$21 = undefined;var m$14 = undefined;var m$15 = undefined;var m$16 = undefined;var acc$7 = undefined;var temp$9 = undefined;var other$4 = undefined;var args$6 = undefined;var f$6 = undefined;var orig_args$0 = undefined;var args$5 = undefined;var $$3090$0 = undefined;var $$3091$0 = undefined;var t0$31 = undefined;var t1$26 = undefined;var t2$6 = undefined;var m$20$0 = undefined;var inserted$0 = undefined;var result$2 = undefined;var args$8 = undefined;var $$3182$0 = undefined;var t0$32 = undefined;var m$21$0 = undefined;var res$1 = undefined;var oloc$0 = undefined;var abloc$0 = undefined;var oabloc$0 = undefined;var rval$2 = undefined;var $targ$37 = undefined;var $targ$38 = undefined;var a$1 = undefined;var b$1 = undefined;var $$2704$0 = undefined;var $$2705$0 = undefined;var $$2706$0 = undefined;var $$2707$0 = undefined;var t0$33 = undefined;var t1$27 = undefined;var t2$7 = undefined;var t3$5 = undefined;var t4$2 = undefined;var t5$2 = undefined;var m$22 = undefined;var acc$8 = undefined;var temp$11 = undefined;var op_strings$0 = undefined;var args$9 = undefined;var ph$10$0 = undefined;var f$7 = undefined;var x$5 = undefined;var commas$0 = undefined;var args$7 = undefined;var target$0 = undefined;var _b$0 = undefined;var body$2 = undefined;var f$4 = undefined;var body$1 = undefined;var f$3 = undefined;var arg$2 = undefined;var body$0 = undefined;var $$2709$0 = undefined;var $$2710$0 = undefined;var $$2711$0 = undefined;var $$2712$0 = undefined;var $$2713$0 = undefined;var $$2714$0 = undefined;var $$2715$0 = undefined;var t0$27 = undefined;var t1$23 = undefined;var t2$4 = undefined;var t3$3 = undefined;var t4$1 = undefined;var t5$1 = undefined;var t6$1 = undefined;var t7$1 = undefined;var t8$0 = undefined;var m$13$0 = undefined;var sumloc$0 = undefined;var orig_ops$0 = undefined;var width$2 = undefined;var op$1 = undefined;var collapse$0 = undefined;var multiargs$0 = undefined;var other$5 = undefined;var ops$0 = undefined;var args$1 = undefined;var value$5 = undefined;var value$4 = undefined;var value$3 = undefined;var value$2 = undefined;var value$1 = undefined;var value$0 = undefined;var $$2639$0 = undefined;var $$2640$0 = undefined;var $$2641$0 = undefined;var t0$22 = undefined;var t1$20 = undefined;var token$0 = undefined;var ph$9$0 = undefined;t0$21 = temp$8$0;token$0 = t0$21;ph$9$0 = t0$21;t0$22 = ph$9$0;t1$20 = t0$22.length;if (($$2641$0 = t1$20 === 2) && t0$22[0] === "ID") {
    value$0 = t0$22[1];return __lt____lt____colon__$0(["symbol", value$0], token$0);
  } else {
    if ($$2641$0 && t0$22[0] === "ILLEGAL") {
      value$1 = t0$22[1];return __lt____lt____colon__$0(["char", value$1], token$0);
    } else {
      if ($$2641$0 && t0$22[0] === "NUM") {
        value$2 = t0$22[1];return __lt____lt____colon__$0(["value", value$2], token$0);
      } else {
        if ($$2641$0 && t0$22[0] === "STR") {
          value$3 = t0$22[1];return __lt____lt____colon__$0(["value", value$3], token$0);
        } else {
          if ($$2641$0 && t0$22[0] === "QUASI") {
            value$4 = t0$22[1];return __lt____lt____colon__$0(["send", ["symbol", "`"], __lt____lt____colon__$0(["value", value$4], token$0)], token$0);
          } else {
            if ($$2641$0 && t0$22[0] === "QUAINT") {
              value$5 = t0$22[1];return __lt____lt____colon__$0(["send", ["symbol", "'"], __lt____lt____colon__$0(["value", value$5], token$0)], token$0);
            } else {
              if (t1$20 === 1 && t0$22[0] === "VOID") {
                return __lt____lt____colon__$0(["void"], token$0);
              } else {
                if (t1$20 >= 1) {
                  ops$0 = t0$22[0];args$1 = Array.prototype.slice.call(t0$22, 1);sumloc$0 = ops$0[0].location;m$14 = null;$12: for (var _iterator = ops$0.slice(1)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                    m$14 = _step.value;
                    var op$2 = undefined;op$2 = m$14;sumloc$0 = __plus____plus____colon__$0(sumloc$0, op$2);sumloc$0;
                  }m$15 = null;$13: for (var _iterator2 = args$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                    m$15 = _step2.value;
                    var arg$0 = undefined;var t0$23 = undefined;var t1$21 = undefined;t0$23 = m$15;if (Array.isArray(t0$23) && (t1$21 = t0$23.length, t1$21 === 1 && t0$23[0] === "void")) {
                      undefined;
                    } else {
                      arg$0 = m$15;sumloc$0 = __plus____plus____colon__$0(sumloc$0, arg$0);sumloc$0;
                    }
                  }orig_ops$0 = ops$0;width$2 = ops$0[0][1];acc$7 = [];temp$9 = null;m$16 = null;$14: for (var _iterator3 = ops$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                    m$16 = _step3.value;
                    var o$3 = undefined;o$3 = m$16;temp$9 = o$3[2];acc$7.push(temp$9);
                  }ops$0 = acc$7;op$1 = ops$0[0];collapse$0 = function collapse(args$2) {
                    var m$17 = undefined;var accum$20 = undefined;accum$20 = [];m$17 = null;$15: for (var _iterator4 = args$2[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                      m$17 = _step4.value;
                      var members$0 = undefined;var $$2808$0 = undefined;var t0$25 = undefined;var t1$22 = undefined;var arg$1 = undefined;var ph$11$0 = undefined;var t0$24 = undefined;t0$24 = m$17;arg$1 = t0$24;ph$11$0 = t0$24;t0$25 = ph$11$0;if (Array.isArray(t0$25) && (t1$22 = t0$25.length, t1$22 === 1 && t0$25[0] === "void")) {
                        undefined;
                      } else {
                        if (___hasprop(t0$25, "brackets") && (t0$25.brackets === "" && (Array.isArray(t0$25) && (t1$22 = t0$25.length, t1$22 >= 1 && t0$25[0] === "multi")))) {
                          members$0 = Array.prototype.slice.call(t0$25, 1);accum$20 = accum$20.concat(members$0);
                        } else {
                          accum$20.push(arg$1);
                        }
                      }
                    }return accum$20;
                  };multiargs$0 = function multiargs(args$3) {
                    var $targ$35 = undefined;var $targ$36 = undefined;var other$2 = undefined;var x$2 = undefined;var $$2861$0 = undefined;var $$2862$0 = undefined;var t0$26 = undefined;var m$18$0 = undefined;var result$1 = undefined;m$18$0 = collapse$0(args$3);if (($$2861$0 = Array.isArray(m$18$0)) && (t0$26 = m$18$0.length, t0$26 === 0)) {
                      result$1 = ["multi"];
                    } else {
                      if ($$2861$0 && t0$26 === 1) {
                        x$2 = m$18$0[0];if (typeof isNaN === "undefined") {
                          $targ$35 = undefined;global.isNaN = $targ$35;void 0;
                        }if (!isNaN(sumloc$0.start) && !isNaN(sumloc$0.end)) {
                          $targ$36 = sumloc$0;x$2.location = $targ$36;void 0;
                        }result$1 = x$2;
                      } else {
                        other$2 = m$18$0;result$1 = ["multi"].concat(other$2);
                      }
                    }return __lt____lt____colon__$0(result$1, sumloc$0);
                  };m$13$0 = [ops$0, args$1];if (($$2709$0 = Array.isArray(m$13$0)) && (t0$27 = m$13$0.length, ($$2711$0 = t0$27 === 2) && (t1$23 = m$13$0[0], ($$2713$0 = Array.isArray(t1$23)) && (t2$4 = t1$23.length, t2$4 === 2 && (t1$23[0] === "WHITE" && (t1$23[1] === ":" && (t3$3 = m$13$0[1], Array.isArray(t3$3) && (t4$1 = t3$3.length, t4$1 === 3)))))))) {
                    f$3 = t3$3[0];arg$2 = t3$3[1];body$0 = t3$3[2];return __lt____lt____colon__$0(["send", f$3, __lt____lt____colon__$0(["data", arg$2, body$0], __plus____plus____colon__$0(arg$2, body$0))], sumloc$0);
                  } else {
                    if ($$2713$0 && (($$2715$0 = t2$4 === 1) && (t1$23[0] === ":" && (t3$3 = m$13$0[1], Array.isArray(t3$3) && (t4$1 = t3$3.length, t4$1 === 2))))) {
                      f$4 = t3$3[0];body$1 = t3$3[1];return __lt____lt____colon__$0(["send", f$4, __lt____lt____colon__$0(["data", body$1], body$1)], sumloc$0);
                    } else {
                      if ($$2715$0 && (t1$23[0] === "with" && (t3$3 = m$13$0[1], Array.isArray(t3$3) && (t4$1 = t3$3.length, t4$1 === 2 && (target$0 = t3$3[0], t5$1 = t3$3[1], _b$0 = t5$1, t6$1 = getProjector(Body$0)(t5$1), t6$1[0] && (t7$1 = t6$1[1], t8$0 = t7$1.length, t8$0 >= 0)))))) {
                        body$2 = Array.prototype.slice.call(t7$1, 0);inserted$0 = false;result$2 = transform$0(target$0, function (temp$10$0) {
                          var t0$28 = undefined;var m$19 = undefined;var tr$2 = undefined;var res$0 = undefined;var args$4 = undefined;var x$3 = undefined;var f$5 = undefined;var a$0 = undefined;var b$0 = undefined;var $$2991$0 = undefined;var t0$29 = undefined;var t1$24 = undefined;var t2$5 = undefined;var t3$4 = undefined;var expr$1 = undefined;var ph$12$0 = undefined;t0$28 = temp$10$0;expr$1 = t0$28;ph$12$0 = t0$28;t0$29 = ph$12$0;t1$24 = t0$29.length;if (t1$24 === 2 && (t0$29[0] === "symbol" && t0$29[1] === "___")) {
                            inserted$0 = true;return __lt____lt____colon__$0(["multi"].concat(body$2), _b$0);
                          } else {
                            x$3 = t0$29;if (x$3.fromop && (Array.isArray(t0$29) && (t1$24 = t0$29.length, t1$24 === 3 && (t0$29[0] === "send" && (f$5 = t0$29[1], t2$5 = t0$29[2], Array.isArray(t2$5) && (t3$4 = t2$5.length, t3$4 === 3 && t2$5[0] === "data")))))) {
                              a$0 = t2$5[1];b$0 = t2$5[2];return ["send", this(f$5), __lt____lt____colon__$0(["data", this(a$0), this(b$0)], __plus____plus____colon__$0(a$0, b$0))];
                            } else {
                              t1$24 = t0$29.length;if (t1$24 >= 1 && t0$29[0] === "data") {
                                args$4 = Array.prototype.slice.call(t0$29, 1);tr$2 = this;res$0 = ["data"];m$19 = null;$16: for (var _iterator4 = args$4[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                  m$19 = _step4.value;
                                  var other$3 = undefined;var t0$30 = undefined;var t1$25 = undefined;t0$30 = m$19;if (Array.isArray(t0$30) && (t1$25 = t0$30.length, t1$25 === 2 && (t0$30[0] === "symbol" && t0$30[1] === "___"))) {
                                    inserted$0 = true;res$0 = res$0.concat(body$2);
                                  } else {
                                    other$3 = m$19;res$0.push(__lt____lt____colon__$0(tr$2(other$3), other$3));
                                  }
                                }return __lt____lt____colon__$0(res$0, expr$1);
                              } else {
                                return ___match_error(ph$12$0, "#data{*args}");
                              }
                            }
                          }
                        });if (!inserted$0) {
                          m$20$0 = target$0;if (Array.isArray(m$20$0) && (t0$31 = m$20$0.length, t0$31 === 1 && m$20$0[0] === "void")) {
                            return __lt____lt____colon__$0(["data"].concat(body$2), sumloc$0);
                          } else {
                            if (target$0.fromop) {
                              return __lt____lt____colon__$0(["send", target$0, __lt____lt____colon__$0(["data"].concat(body$2), _b$0)], sumloc$0);
                            } else {
                              if (($$3090$0 = Array.isArray(m$20$0)) && (t0$31 = m$20$0.length, t0$31 === 3 && (m$20$0[0] === "send" && (f$6 = m$20$0[1], t1$26 = m$20$0[2], orig_args$0 = t1$26, Array.isArray(t1$26) && (t2$6 = t1$26.length, t2$6 >= 1 && t1$26[0] === "data"))))) {
                                args$5 = Array.prototype.slice.call(t1$26, 1);return __lt____lt____colon__$0(["send", f$6, __lt____lt____colon__$0(["data"].concat(args$5).concat(body$2), __plus____plus____colon__$0(orig_args$0, _b$0))], sumloc$0);
                              } else {
                                if ($$3090$0 && (t0$31 >= 1 && m$20$0[0] === "data")) {
                                  args$6 = Array.prototype.slice.call(m$20$0, 1);return __lt____lt____colon__$0(target$0.concat(body$2), sumloc$0);
                                } else {
                                  other$4 = m$20$0;return __lt____lt____colon__$0(["send", target$0, __lt____lt____colon__$0(["data"].concat(body$2), _b$0)], sumloc$0);
                                }
                              }
                            }
                          }
                        } else {
                          return __lt____lt____colon__$0(result$2, sumloc$0);
                        }
                      } else {
                        if ($$2711$0 && (Array.isArray(t1$23) && (commas$0 = t1$23, args$7 = m$13$0[1], commas$0.every(function (x$4) {
                          return equal(x$4, ",") || equal(x$4, ";");
                        })))) {
                          return __amp____colon__(multiargs$0(args$7), { brackets: "" });
                        } else {
                          if ($$2711$0 && (($$2713$0 = Array.isArray(t1$23)) && (t2$4 = t1$23.length, ($$2715$0 = t2$4 === 2) && (t1$23[0] === "[" && t1$23[1] === "]")))) {
                            m$13$0[1];return __amp____colon__(multiargs$0(args$1), { brackets: "[]" });
                          } else {
                            if ($$2715$0 && (t1$23[0] === "{" && t1$23[1] === "}")) {
                              m$13$0[1];args$1 = collapse$0(args$1);return __lt____lt____colon__$0(["data"].concat(args$1), sumloc$0);
                            } else {
                              if ($$2715$0 && (t1$23[0] === "(" && t1$23[1] === ")")) {
                                m$13$0[1];return __amp____colon__(multiargs$0(args$1), { brackets: "()" });
                              } else {
                                if ($$2713$0 && (($$2715$0 = t2$4 === 1) && (t1$23[0] === "WHITE" && (t3$3 = m$13$0[1], Array.isArray(t3$3) && (t4$1 = t3$3.length, t4$1 === 2))))) {
                                  f$7 = t3$3[0];x$5 = t3$3[1];m$21$0 = x$5;if (Array.isArray(m$21$0) && (t0$32 = m$21$0.length, t0$32 >= 1 && (m$21$0[0] === "multi" && (args$8 = Array.prototype.slice.call(m$21$0, 1), equal(x$5.brackets, "()"))))) {
                                    res$1 = __lt____lt____colon__$0(["send", f$7, __lt____lt____colon__$0(__amp____colon__(["data"].concat(args$8), { brackets: "()" }), x$5)], sumloc$0);
                                  } else {
                                    if (equal(x$5.brackets, "()")) {
                                      res$1 = __lt____lt____colon__$0(["send", f$7, __lt____lt____colon__$0(__amp____colon__(["data", x$5], { brackets: "()" }), x$5)], sumloc$0);
                                    } else {
                                      res$1 = ["send", f$7, x$5];
                                    }
                                  }return __lt____lt____colon__$0(__amp____colon__(res$1, { width: width$2 }), sumloc$0);
                                } else {
                                  if ($$2715$0) {
                                    t1$23[0];ph$10$0 = m$13$0[1];t0$33 = ph$10$0;if (($$2705$0 = Array.isArray(t0$33)) && (t1$27 = t0$33.length, ($$2707$0 = t1$27 === 2) && (t2$7 = t0$33[0], Array.isArray(t2$7) && (t3$5 = t2$7.length, t3$5 === 1 && (t2$7[0] === "void" && (t4$2 = t0$33[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 === 1 && t4$2[0] === "void"))))))) {
                                      return __lt____lt____colon__$0(["symbol", op$1], orig_ops$0[0]);
                                    } else {
                                      if ($$2707$0) {
                                        a$1 = t0$33[0];b$1 = t0$33[1];oloc$0 = orig_ops$0[0].location;abloc$0 = __plus____plus____colon__$0(a$1, b$1);oabloc$0 = __plus____plus____colon__$0(orig_ops$0[0], abloc$0);rval$2 = __lt____lt____colon__$0(["send", __lt____lt____colon__$0(["symbol", op$1], oloc$0), __lt____lt____colon__$0(["data", a$1, b$1], abloc$0)], __plus____plus____colon__$0(oloc$0, abloc$0));$targ$37 = true;rval$2.fromop = $targ$37;$targ$38 = width$2;rval$2.width = $targ$38;return rval$2;
                                      } else {
                                        return ___match_error(ph$10$0, "{a, b}");
                                      }
                                    }
                                  } else {
                                    if ($$2711$0) {
                                      op_strings$0 = m$13$0[0];args$9 = m$13$0[1];return __lt____lt____colon__$0(["mismix", (acc$8 = [], temp$11 = null, m$22 = null, (function () {
                                        $17: for (var _iterator4 = orig_ops$0[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                          m$22 = _step4.value;
                                          var op$3 = undefined;op$3 = m$22;temp$11 = __lt____lt____colon__$0(["symbol", op$3[2]], op$3);acc$8.push(temp$11);
                                        }
                                      })(), acc$8)].concat(args$9), sumloc$0);
                                    } else {
                                      return ___match_error(m$13$0, "{op_strings, args}");
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  other$5 = ph$9$0;throw ErrorFactory(["should_never_happen"]).create("unknown node (B)", { node: token$0 });
                }
              }
            }
          }
        }
      }
    }
  }
};parse$0 = function parse(tokens$0) {
  var next$1 = undefined;next$1 = function next() {
    return tokens$0.shift();
  };return oparse$0(next$1, eg_order$0.compare.bind(eg_order$0), finalize$0);
};$targ$39 = OperatorGroups$0;exports.OperatorGroups = $targ$39;$targ$40 = SimplePriority$0;exports.SimplePriority = $targ$40;$targ$41 = parse$0;exports.parse = $targ$41;$targ$42 = oparse$0;exports.oparse = $targ$42;$targ$43 = finalize$0;exports.finalize = $targ$43;$targ$44 = DONE$0;exports.DONE = $targ$44;$targ$45 = NONE$0;exports.NONE = $targ$45;$targ$46 = LEFT$0;exports.LEFT = $targ$46;$targ$47 = RIGHT$0;exports.RIGHT = $targ$47;$targ$48 = BOTH$0;exports.BOTH = $targ$48;void 0;
//# sourceMappingURL=parse.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./location":106,"./util":126,"earlgrey-runtime/5":446}],121:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var accum$0 = undefined;var $targ$1 = undefined;var accum$1 = undefined;var $targ$2 = undefined;var accum$2 = undefined;var accum$3 = undefined;var $targ$3 = undefined;var accum$4 = undefined;var $targ$4 = undefined;var accum$5 = undefined;var $targ$30 = undefined;var accum$6 = undefined;var $targ$31 = undefined;var accum$7 = undefined;var $targ$36 = undefined;var accum$8 = undefined;var $targ$37 = undefined;var accum$9 = undefined;var $targ$43 = undefined;var $targ$44 = undefined;var $0$0 = undefined;var __lt____lt____colon__$0 = undefined;var util$0 = undefined;var GenSym$0 = undefined;var gensym$0 = undefined;var classify$0 = undefined;var classify_contiguous$0 = undefined;var identity$0 = undefined;var Body$0 = undefined;var camelCase$0 = undefined;var checker_db$0 = undefined;var PatternInfo$0 = undefined;var PatternCompiler$0 = undefined;var PatternProcessor$0 = undefined;var $targ$0 = undefined;var assemble_conditions$0 = undefined;var assemble_pattern$0 = undefined;var inject_below_uses$0 = undefined;var checkall$0 = undefined;var same_block$0 = undefined;var parse_clauses$0 = undefined;var opt_clauses$0 = undefined;var weave_clauses$0 = undefined;$0$0 = require("./location");__lt____lt____colon__$0 = getProperty($0$0, "<<:", "./location");util$0 = require("./util");GenSym$0 = getProperty(util$0, "GenSym", "util");gensym$0 = getProperty(util$0, "gensym", "util");classify$0 = getProperty(util$0, "classify", "util");classify_contiguous$0 = getProperty(util$0, "classify_contiguous", "util");identity$0 = getProperty(util$0, "identity", "util");Body$0 = getProperty(util$0, "Body", "util");camelCase$0 = getProperty(util$0, "camelCase", "util");checker_db$0 = getProperty(util$0, "checker_db", "util");PatternInfo$0 = function PatternInfo() {
  var t0$0 = undefined;var m$0$0 = undefined;var $it$0 = undefined;if (!getChecker(PatternInfo$0)(this)) {
    $it$0 = Object.create(PatternInfo$0.prototype);
  } else {
    $it$0 = this;
  }m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 0 && t0$0 <= 3) {
    $it$0.handlers = 0 >= t0$0 ? [] : m$0$0[0];$it$0.vars = 1 >= t0$0 ? [] : m$0$0[1];$it$0.arguments = 2 >= t0$0 ? [] : m$0$0[2];undefined;
  } else {
    ___match_error(m$0$0, "{@handlers = {}, @vars = {}, @arguments = {}}");
  }return $it$0;
};__amp____colon__((accum$0 = {}, accum$0.mergeAll = function mergeAll(pinfos$0) {
  var f$0 = undefined;var rval$0 = undefined;rval$0 = PatternInfo$0();f$0 = function f(acc$0, pinfo$0) {
    return acc$0.merge(pinfo$0.pinfo || pinfo$0);
  };return pinfos$0.reduce(f$0, rval$0);
}, accum$0), __amp____colon__(($targ$1 = "PatternInfo", accum$1 = {}, accum$1["::name"] = $targ$1, accum$1), ($targ$2 = true, accum$2 = {}, accum$2["::egclass"] = $targ$2, accum$2)));PatternInfo$0.prototype.merge = function merge(pinfo$1) {
  var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;$it$1.handlers = $it$1.handlers.concat(pinfo$1.handlers);$it$1.vars = $it$1.vars.concat(pinfo$1.vars);$it$1.arguments = $it$1.arguments.concat(pinfo$1.arguments);return $it$1;
};__amp____colon__(PatternInfo$0, __amp____colon__((accum$3 = {}, accum$3.mergeAll = function mergeAll(pinfos$1) {
  var f$1 = undefined;var rval$1 = undefined;rval$1 = PatternInfo$0();f$1 = function f(acc$1, pinfo$2) {
    return acc$1.merge(pinfo$2.pinfo || pinfo$2);
  };return pinfos$1.reduce(f$1, rval$1);
}, accum$3), __amp____colon__(($targ$3 = "PatternInfo", accum$4 = {}, accum$4["::name"] = $targ$3, accum$4), ($targ$4 = true, accum$5 = {}, accum$5["::egclass"] = $targ$4, accum$5))));PatternCompiler$0 = function PatternCompiler(temp$0$0, temp$1$0, temp$2$0) {
  var $it$2 = undefined;if (!getChecker(PatternCompiler$0)(this)) {
    $it$2 = Object.create(PatternCompiler$0.prototype);
  } else {
    $it$2 = this;
  }$it$2.pattern = temp$0$0;$it$2.info = temp$1$0;$it$2.opt = temp$2$0;return $it$2;
};PatternCompiler$0.prototype.compile = function compile() {
  var tags$0 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $it$3 = undefined;var self$1 = undefined;$it$3 = this;self$1 = this;if ($it$3.compiled) {
    return $it$3.compiled;
  }tags$0 = clone($it$3.opt.tags || {});tags$0.group_id = tags$0.group_id || gensym$0("group");$targ$5 = $it$3.expand($it$3.pattern, tags$0, true, $it$3.opt.indexable);$it$3.compiled = $targ$5;$targ$6 = $it$3.info;$it$3.compiled.pinfo.info = $targ$6;$targ$7 = $it$3.opt;$it$3.compiled.pinfo.opt = $targ$7;$targ$8 = $it$3.compiled.pinfo.vars;$it$3.vars = $targ$8;$targ$9 = $it$3.compiled.pinfo.handlers;$it$3.handlers = $targ$9;$targ$10 = $it$3.compiled.pinfo.arguments;$it$3.arguments = $targ$10;return $it$3.compiled;
};PatternCompiler$0.prototype.fork = function fork(pattern$0) {
  var pc$0 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var $it$4 = undefined;var self$2 = undefined;$it$4 = this;self$2 = this;pc$0 = PatternCompiler$0(null, $it$4.info, $it$4.opt);$targ$11 = pattern$0;pc$0.compiled = $targ$11;$targ$12 = $it$4.vars;pc$0.vars = $targ$12;$targ$13 = $it$4.arguments;pc$0.arguments = $targ$13;$targ$14 = $it$4.handlers;pc$0.handlers = $targ$14;__amp____colon__(pc$0, pattern$0.pinfo);return pc$0;
};PatternCompiler$0.prototype.parse_specs = function parse_specs(specs$0, tags$1) {
  var m$2 = undefined;var acc$2 = undefined;var temp$3 = undefined;var rest$0 = undefined;var has_defaults$0 = undefined;var curidx$0 = undefined;var insidx$0 = undefined;var setInsidx$0 = undefined;var rval$2 = undefined;var $targ$15 = undefined;var $targ$16 = undefined;var $it$5 = undefined;var self$3 = undefined;$it$5 = this;self$3 = this;rest$0 = undefined;has_defaults$0 = false;curidx$0 = 0;insidx$0 = null;setInsidx$0 = function setInsidx(spec$0) {
    var msg$0 = undefined;var x$0 = undefined;var m$1$0 = undefined;if (equal(insidx$0, null)) {
      m$1$0 = curidx$0;if (m$1$0 === null) {
        msg$0 = "Object patterns cannot be after rest/default arguments.";throw ErrorFactory(["syntax", "pattern"]).create(msg$0, { expr: spec$0 });
      } else {
        x$0 = m$1$0;insidx$0 = x$0;return insidx$0;
      }
    }
  };rval$2 = classify$0("fw", "bw", "keys", "defaults", (acc$2 = [], temp$3 = null, m$2 = null, (function () {
    $2: for (var _iterator = $it$5.info.step_all(["pattern"], specs$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      (function () {
        m$2 = _step.value;
        var t0$3 = undefined;var t0$4 = undefined;var msg$1 = undefined;var res$0 = undefined;var v$0 = undefined;var t0$11 = undefined;var t1$5 = undefined;var t2$1 = undefined;var m$5$0 = undefined;var m$3$0 = undefined;var esubp$0 = undefined;var wrap$0 = undefined;var finalize$0 = undefined;var v$2 = undefined;var v$1 = undefined;var variable$1 = undefined;var value$2 = undefined;var key$0 = undefined;var subp$0 = undefined;var variable$0 = undefined;var t0$2 = undefined;var t1$0 = undefined;var bridge$$5675$0 = undefined;var spec$1 = undefined;var ph$0$0 = undefined;var t0$1 = undefined;t0$1 = m$2;spec$1 = t0$1;ph$0$0 = t0$1;t0$2 = ph$0$0;if (Array.isArray(t0$2) && (t1$0 = t0$2.length, t1$0 === 2 && t0$2[0] === "dynsplice")) {
          variable$0 = t0$2[1];curidx$0 = null;rest$0 = $it$5.expand(variable$0, tags$1);temp$3 = ["ignore"];
        } else {
          bridge$$5675$0 = ph$0$0;if (Array.isArray(bridge$$5675$0) && (t0$3 = bridge$$5675$0.length, t0$3 === 3 && (bridge$$5675$0[0] === "assoc" && (key$0 = bridge$$5675$0[1], subp$0 = bridge$$5675$0[2], true))) || Array.isArray(bridge$$5675$0) && (t0$4 = bridge$$5675$0.length, t0$4 === 2 && (bridge$$5675$0[0] === "assoc" && (subp$0 = bridge$$5675$0[1], key$0 = null, true)))) {
            setInsidx$0(spec$1);esubp$0 = $it$5.expand(subp$0, tags$1);wrap$0 = function wrap() {
              var p2$0 = undefined;var t0$7 = undefined;var t1$3 = undefined;var t0$8 = undefined;var field$0 = undefined;var x$1 = undefined;var y$0 = undefined;var kexpr$0 = undefined;var $$5769$0 = undefined;var $$5770$0 = undefined;var $$5771$0 = undefined;var $$5772$0 = undefined;var t0$6 = undefined;var t1$2 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var t6$0 = undefined;var t7$0 = undefined;var bridge$$5767$0 = undefined;var key$1 = undefined;var ph$2$0 = undefined;var value$0 = undefined;var default$1 = undefined;var t0$5 = undefined;var t1$1 = undefined;var m$4$0 = undefined;m$4$0 = arguments;t0$5 = m$4$0.length;if (t0$5 >= 2 && t0$5 <= 3) {
                t1$1 = m$4$0[0];key$1 = t1$1;ph$2$0 = t1$1;value$0 = m$4$0[1];if (2 >= t0$5) {
                  default$1 = [];
                } else {
                  default$1 = m$4$0[2];
                }t0$6 = ph$2$0;t1$2 = t0$6.length;if (($$5771$0 = t1$2 === 3) && (($$5772$0 = t0$6[0] === "send") && (t2$0 = t0$6[1], Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 2 && (t2$0[0] === "symbol" && (t2$0[1] === "^" && (t4$0 = t0$6[2], Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && (t4$0[0] === "data" && (t6$0 = t4$0[1], Array.isArray(t6$0) && (t7$0 = t6$0.length, t7$0 === 1 && t6$0[0] === "void"))))))))))) {
                  kexpr$0 = t4$0[2];return [kexpr$0, value$0].concat(default$1);
                } else {
                  if ($$5772$0) {
                    x$1 = t0$6[1];y$0 = t0$6[2];p2$0 = __amp____colon__(["object_pattern", [y$0, value$0].concat(default$1)], { pinfo: value$0.pinfo, "::objinsert": 2 });return wrap$0(x$1, p2$0, default$1);
                  } else {
                    bridge$$5767$0 = ph$2$0;if (Array.isArray(bridge$$5767$0) && (t0$7 = bridge$$5767$0.length, t0$7 === 2 && (bridge$$5767$0[0] === "symbol" && (t1$3 = getProjector(camelCase$0)(bridge$$5767$0[1]), t1$3[0] && (field$0 = t1$3[1], true)))) || Array.isArray(bridge$$5767$0) && (t0$8 = bridge$$5767$0.length, t0$8 === 2 && (bridge$$5767$0[0] === "value" && (field$0 = bridge$$5767$0[1], true)))) {
                      return [__lt____lt____colon__$0(["value", field$0], key$1), value$0].concat(default$1);
                    } else {
                      throw send(send(ErrorFactory(["syntax", "invalid_key"]), "create", true), __amp____colon__(["Invalid key."], { expr: key$1, "::objinsert": 1 }));
                    }
                  }
                }
              } else {
                return ___match_error(m$4$0, "{match key, value, default = {}}");
              }
            };finalize$0 = function finalize(key$2, temp$4$0) {
              var t0$9 = undefined;var pattern$1 = undefined;var default$2 = undefined;var t0$10 = undefined;var t1$4 = undefined;var value$1 = undefined;var ph$3$0 = undefined;t0$9 = temp$4$0;value$1 = t0$9;ph$3$0 = t0$9;t0$10 = ph$3$0;t1$4 = t0$10.length;if (t1$4 === 3 && t0$10[0] === "default") {
                pattern$1 = t0$10[1];default$2 = t0$10[2];return ["keys", wrap$0(key$2, pattern$1, [default$2])];
              } else {
                return ["keys", wrap$0(key$2, value$1)];
              }
            };m$3$0 = key$0;if (m$3$0 === null) {
              m$5$0 = esubp$0;res$0 = m$5$0;if (___hasprop(m$5$0, "pinfo") && (t0$11 = m$5$0.pinfo, ___hasprop(t0$11, "vars") && (t1$5 = t0$11.vars, Array.isArray(t1$5) && (t2$1 = t1$5.length, t2$1 === 1)))) {
                v$0 = t1$5[0];temp$3 = finalize$0(v$0, esubp$0);
              } else {
                msg$1 = ENode([], {}, ["Could not identify the name of the field to extract"]).toString();throw send(send(ErrorFactory(["syntax", "no_field"]), "create", true), __amp____colon__([msg$1], { expr: spec$1, "::objinsert": 1 }));
              }
            } else {
              temp$3 = finalize$0(key$0, esubp$0);
            }
          } else {
            t0$2 = ph$0$0;if (Array.isArray(t0$2) && (t1$0 = t0$2.length, t1$0 === 3 && t0$2[0] === "default")) {
              variable$1 = t0$2[1];value$2 = t0$2[2];curidx$0 = null;has_defaults$0 = true;if (rest$0) {
                throw ErrorFactory(["syntax", "pattern"]).create("No default arguments after rest arg.");
              } else {
                temp$3 = ["defaults", [$it$5.expand(variable$1, tags$1), value$2]];
              }
            } else {
              v$1 = ph$0$0;if (rest$0 === undefined && !has_defaults$0) {
                curidx$0 = curidx$0 + 1;temp$3 = ["fw", $it$5.expand(v$1, tags$1)];
              } else {
                v$2 = ph$0$0;curidx$0 = null;temp$3 = ["bw", $it$5.expand(v$2, tags$1)];
              }
            }
          }
        }acc$2.push(temp$3);
      })();
    }
  })(), acc$2));$targ$15 = rest$0;rval$2.rest = $targ$15;$targ$16 = insidx$0;rval$2.insertion_index = $targ$16;return rval$2;
};PatternCompiler$0.prototype.expand = function expand() {
  var x$2 = undefined;var x$3 = undefined;var p$0 = undefined;var variable$2 = undefined;var $targ$17 = undefined;var x$4 = undefined;var x$5 = undefined;var variable$3 = undefined;var variable$4 = undefined;var csubp$0 = undefined;var csubp$1 = undefined;var csubp$2 = undefined;var csubp$3 = undefined;var x$8 = undefined;var fn$0 = undefined;var $targ$18 = undefined;var msg$2 = undefined;var msg$3 = undefined;var cx$0 = undefined;var m$8 = undefined;var acc$3 = undefined;var temp$5 = undefined;var cxs$0 = undefined;var m$13 = undefined;var acc$6 = undefined;var temp$8 = undefined;var ps$0 = undefined;var vs$0 = undefined;var v$6 = undefined;var t0$16 = undefined;var m$12$0 = undefined;var p$1 = undefined;var r$0 = undefined;var m$15 = undefined;var acc$7 = undefined;var temp$9 = undefined;var m$16 = undefined;var acc$8 = undefined;var temp$10 = undefined;var m$17 = undefined;var acc$9 = undefined;var temp$11 = undefined;var m$18 = undefined;var acc$10 = undefined;var temp$12 = undefined;var patt$0 = undefined;var keys$1 = undefined;var fw$1 = undefined;var bw$1 = undefined;var defaults$1 = undefined;var rest$2 = undefined;var keys$0 = undefined;var fw$0 = undefined;var bw$0 = undefined;var defaults$0 = undefined;var rest$1 = undefined;var $$6468$0 = undefined;var t0$21 = undefined;var t1$11 = undefined;var t2$4 = undefined;var t3$1 = undefined;var t4$1 = undefined;var t5$1 = undefined;var m$14$0 = undefined;var specs$1 = undefined;var pinfos$2 = undefined;var pinfo$3 = undefined;var r$1 = undefined;var other$0 = undefined;var subp$6 = undefined;var expr$1 = undefined;var mode$0 = undefined;var subp$5 = undefined;var args$1 = undefined;var pattern$3 = undefined;var default$3 = undefined;var cond$0 = undefined;var t$0 = undefined;var f$4 = undefined;var xs$2 = undefined;var make__minus__any$0 = undefined;var xs$0 = undefined;var x$9 = undefined;var f$3 = undefined;var arg$0 = undefined;var f$2 = undefined;var args$0 = undefined;var checker$0 = undefined;var subp$4 = undefined;var projector$0 = undefined;var subp$3 = undefined;var unconditional$0 = undefined;var condition$0 = undefined;var subp$2 = undefined;var before$0 = undefined;var subp$1 = undefined;var value$3 = undefined;var x$7 = undefined;var x$6 = undefined;var v$4 = undefined;var v$3 = undefined;var s$0 = undefined;var handler$0 = undefined;var $$6051$0 = undefined;var $$6052$0 = undefined;var $$6053$0 = undefined;var $$6054$0 = undefined;var $$6055$0 = undefined;var $$6056$0 = undefined;var $$6057$0 = undefined;var t0$13 = undefined;var bridge$$6030$0 = undefined;var t1$6 = undefined;var m$7$0 = undefined;var $targ$19 = undefined;var expr$0 = undefined;var rval$3 = undefined;var pattern$2 = undefined;var tags$2 = undefined;var toplevel$0 = undefined;var checked$0 = undefined;var t0$12 = undefined;var m$6$0 = undefined;var $it$6 = undefined;var self$4 = undefined;$it$6 = this;self$4 = this;m$6$0 = arguments;t0$12 = m$6$0.length;if (t0$12 >= 2 && t0$12 <= 4) {
    pattern$2 = m$6$0[0];tags$2 = m$6$0[1];if (2 >= t0$12) {
      toplevel$0 = false;
    } else {
      toplevel$0 = m$6$0[2];
    }if (3 >= t0$12) {
      checked$0 = false;
    } else {
      checked$0 = m$6$0[3];
    }expr$0 = $it$6.info.step(["pattern"], pattern$2);m$7$0 = expr$0;if ((x$2 = m$7$0, x$2 instanceof Array && x$2[0] === "void")) {
      rval$3 = ["ignore"];
    } else {
      if ((x$3 = m$7$0, x$3 instanceof Array && x$3[0] === "ignore")) {
        rval$3 = expr$0;
      } else {
        if (($$6051$0 = Array.isArray(m$7$0)) && (t0$13 = m$7$0.length, ($$6053$0 = t0$13 === 2) && m$7$0[0] === "special")) {
          handler$0 = m$7$0[1];p$0 = $it$6.expand(handler$0.expand($it$6.info), tags$2, toplevel$0, false);p$0.pinfo.handlers.push(handler$0);rval$3 = p$0;
        } else {
          if ($$6053$0 && m$7$0[0] === "raw-symbol") {
            s$0 = m$7$0[1];variable$2 = __amp__(__lt____lt____colon__$0(["symbol", s$0], expr$0), tags$2);$targ$17 = expr$0.env;variable$2.env = $targ$17;rval$3 = __amp____colon__(["assign", variable$2], { pinfo: PatternInfo$0([], [variable$2]) });
          } else {
            bridge$$6030$0 = m$7$0;if ((x$4 = bridge$$6030$0, x$4 instanceof Array && x$4[0] === "symbol") || (x$5 = bridge$$6030$0, x$5 instanceof Array && x$5[0] === "variable")) {
              variable$3 = __amp__(expr$0, tags$2);rval$3 = __amp____colon__(["assign", variable$3], { pinfo: PatternInfo$0([], [variable$3]) });
            } else {
              if (($$6051$0 = Array.isArray(m$7$0)) && (t0$13 = m$7$0.length, ($$6053$0 = t0$13 === 2) && (($$6054$0 = m$7$0[0] === "value") && (v$3 = m$7$0[1], $it$6.opt.strings_as_variables)))) {
                variable$4 = __lt____lt____colon__$0(__amp__(["value", v$3], tags$2), expr$0);rval$3 = __amp____colon__(["assign", variable$4], { pinfo: PatternInfo$0([], [variable$4]) });
              } else {
                if ($$6054$0) {
                  v$4 = m$7$0[1];rval$3 = ["check", checker_db$0(v$4), ["ignore"]];
                } else {
                  if ($$6053$0 && (($$6054$0 = m$7$0[0] === "calc") && (x$6 = m$7$0[1], $it$6.opt.strings_as_variables))) {
                    rval$3 = ["assign", ["multi", x$6]];
                  } else {
                    if ($$6054$0) {
                      x$7 = m$7$0[1];throw send(send(ErrorFactory(["syntax", "pattern"]), "create", true), __amp____colon__([ENode([], {}, ["Computed properties are not allowed here"]).toString()], { expr: expr$0, "::objinsert": 1 }));
                    } else {
                      if ($$6051$0 && (t0$13 === 3 && m$7$0[0] === "replace")) {
                        subp$1 = m$7$0[1];value$3 = m$7$0[2];csubp$0 = $it$6.expand(subp$1, tags$2, toplevel$0, false);rval$3 = __amp____colon__(["replace", csubp$0, value$3], { pinfo: csubp$0.pinfo });
                      } else {
                        if ($$6051$0 && (($$6053$0 = t0$13 >= 3 && t0$13 <= 4) && m$7$0[0] === "test")) {
                          condition$0 = m$7$0[1];subp$2 = m$7$0[2];if (3 >= t0$13) {
                            before$0 = false;
                          } else {
                            before$0 = m$7$0[3];
                          }csubp$1 = $it$6.expand(subp$2, tags$2, toplevel$0, false);rval$3 = __amp____colon__(["test", condition$0, csubp$1, before$0], { pinfo: csubp$1.pinfo });
                        } else {
                          if ($$6053$0 && m$7$0[0] === "project") {
                            projector$0 = m$7$0[1];subp$3 = m$7$0[2];if (3 >= t0$13) {
                              unconditional$0 = false;
                            } else {
                              unconditional$0 = m$7$0[3];
                            }csubp$2 = $it$6.expand(subp$3, tags$2, toplevel$0, true);rval$3 = __amp____colon__(["project", projector$0, csubp$2, unconditional$0], { pinfo: csubp$2.pinfo });
                          } else {
                            if ($$6051$0 && (($$6053$0 = t0$13 === 3) && m$7$0[0] === "check")) {
                              checker$0 = m$7$0[1];subp$4 = m$7$0[2];csubp$3 = $it$6.expand(subp$4, tags$2, toplevel$0, true);rval$3 = __amp____colon__(["check", checker$0, csubp$3], { pinfo: csubp$3.pinfo });
                            } else {
                              if ($$6053$0 && (($$6054$0 = m$7$0[0] === "send") && (f$2 = m$7$0[1], t1$6 = m$7$0[2], x$8 = t1$6, x$8 instanceof Array && x$8[0] === "data"))) {
                                args$0 = t1$6;if (toplevel$0) {
                                  fn$0 = $it$6.expand(f$2, tags$2, true, false);$targ$18 = PatternInfo$0.mergeAll([fn$0.pinfo, PatternInfo$0([], [], [args$0])]);fn$0.pinfo = $targ$18;rval$3 = fn$0;
                                } else {
                                  msg$2 = "Function arguments can only be declared as a top level pattern.";throw ErrorFactory(["syntax", "pattern"]).create(msg$2, { node: expr$0, arg: args$0 });
                                }
                              } else {
                                if ($$6054$0) {
                                  f$3 = m$7$0[1];arg$0 = m$7$0[2];rval$3 = ["assign", expr$0];
                                } else {
                                  if (!$it$6.opt.allow_nested) {
                                    msg$3 = "Nested patterns are not allowed here.";throw ErrorFactory(["syntax", "pattern"]).create(msg$3, { node: expr$0 });
                                  } else {
                                    if (($$6051$0 = Array.isArray(m$7$0)) && (t0$13 = m$7$0.length, t0$13 === 2 && m$7$0[0] === "neg")) {
                                      x$9 = m$7$0[1];cx$0 = $it$6.expand(x$9, tags$2);rval$3 = __amp____colon__(["neg", cx$0], { pinfo: cx$0.pinfo });
                                    } else {
                                      if ($$6051$0 && (t0$13 >= 1 && m$7$0[0] === "all")) {
                                        xs$0 = Array.prototype.slice.call(m$7$0, 1);acc$3 = [];temp$5 = null;m$8 = null;$3: for (var _iterator = xs$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                                          m$8 = _step.value;
                                          var x$10 = undefined;x$10 = m$8;temp$5 = $it$6.expand(x$10, tags$2);acc$3.push(temp$5);
                                        }cxs$0 = acc$3;rval$3 = __amp____colon__(["all"].concat(cxs$0), { pinfo: PatternInfo$0.mergeAll(cxs$0) });
                                      } else {
                                        make__minus__any$0 = function makeAny(xs$1) {
                                          var m$10 = undefined;var acc$5 = undefined;var temp$7 = undefined;var m$11 = undefined;var canon$0 = undefined;var normalize$0 = undefined;var pps$0 = undefined;canon$0 = function canon(all$0) {
                                            return all$0.sort().join(",");
                                          };normalize$0 = function normalize(vars$0) {
                                            var m$9 = undefined;var acc$4 = undefined;var temp$6 = undefined;return canon$0((acc$4 = [], temp$6 = null, m$9 = null, (function () {
                                              $5: for (var _iterator2 = vars$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                                                m$9 = _step2.value;
                                                var v$5 = undefined;var t0$14 = undefined;var t1$7 = undefined;t0$14 = m$9;if (Array.isArray(t0$14) && (t1$7 = t0$14.length, t1$7 === 2 && t0$14[0] === "symbol")) {
                                                  v$5 = t0$14[1];temp$6 = v$5;acc$4.push(temp$6);
                                                } else {
                                                  ___match_error(m$9);
                                                }
                                              }
                                            })(), acc$4));
                                          };acc$5 = [];temp$7 = null;m$10 = null;$6: for (var _iterator2 = xs$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                                            m$10 = _step2.value;
                                            var x$11 = undefined;x$11 = m$10;temp$7 = $it$6.expand(x$11, tags$2);acc$5.push(temp$7);
                                          }pps$0 = acc$5;m$11 = null;$4: for (var _iterator3 = neighbours(pps$0)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                            m$11 = _step3.value;
                                            var v1$0 = undefined;var v2$0 = undefined;var pp1$0 = undefined;var pp2$0 = undefined;var t0$15 = undefined;var t1$8 = undefined;t0$15 = m$11;if (Array.isArray(t0$15) && (t1$8 = t0$15.length, t1$8 === 2)) {
                                              pp1$0 = t0$15[0];pp2$0 = t0$15[1];v1$0 = pp1$0.pinfo.vars;v2$0 = pp2$0.pinfo.vars;if (normalize$0(v1$0) !== normalize$0(v2$0)) {
                                                throw ErrorFactory(["syntax", "pattern"]).create("Both branches of 'or' must contain the same variables", { vars1: __lt____lt____colon__$0(v1$0.sort(), pp1$0), vars2: __lt____lt____colon__$0(v2$0.sort(), pp2$0) });
                                              }
                                            } else {
                                              ___match_error(m$11);
                                            }
                                          }return __amp____colon__(["any"].concat(pps$0), { pinfo: pps$0[0] && pps$0[0].pinfo });
                                        };if (($$6055$0 = Array.isArray(m$7$0)) && (t0$13 = m$7$0.length, t0$13 >= 1 && m$7$0[0] === "any")) {
                                          xs$2 = Array.prototype.slice.call(m$7$0, 1);rval$3 = make__minus__any$0(xs$2);
                                        } else {
                                          if ($$6055$0 && (t0$13 === 4 && m$7$0[0] === "if")) {
                                            cond$0 = m$7$0[1];t$0 = m$7$0[2];f$4 = m$7$0[3];rval$3 = make__minus__any$0([["test", cond$0, t$0, true], f$4]);
                                          } else {
                                            if ($$6055$0 && (t0$13 >= 2 && t0$13 <= 3 && m$7$0[0] === "maybe")) {
                                              pattern$3 = m$7$0[1];if (2 >= t0$13) {
                                                default$3 = null;
                                              } else {
                                                default$3 = m$7$0[2];
                                              }p$1 = $it$6.expand(pattern$3, tags$2);m$12$0 = p$1.pinfo.vars;if (Array.isArray(m$12$0) && (t0$16 = m$12$0.length, t0$16 === 1)) {
                                                v$6 = m$12$0[0];r$0 = ["any", p$1, ["check", checker_db$0(default$3), ["assign", v$6]]];
                                              } else {
                                                vs$0 = m$12$0;acc$6 = [];temp$8 = null;m$13 = null;$7: for (var _iterator2 = vs$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                                                  m$13 = _step2.value;
                                                  var v$7 = undefined;v$7 = m$13;temp$8 = ["check", checker_db$0(default$3), ["assign", v$7]];acc$6.push(temp$8);
                                                }ps$0 = acc$6;r$0 = ["any", p$1, ["all"].concat(ps$0)];
                                              }rval$3 = __amp____colon__(r$0, { pinfo: p$1.pinfo });
                                            } else {
                                              if ($$6055$0 && (t0$13 >= 1 && m$7$0[0] === "data")) {
                                                args$1 = Array.prototype.slice.call(m$7$0, 1);specs$1 = $it$6.parse_specs(args$1, tags$2);pinfos$2 = [];pinfos$2 = pinfos$2.concat((acc$7 = [], temp$9 = null, m$15 = null, (function () {
                                                  $8: for (var _iterator3 = specs$1.keys[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                                    m$15 = _step3.value;
                                                    var pinfo$4 = undefined;var t0$17 = undefined;var t1$9 = undefined;var t2$2 = undefined;t0$17 = m$15;if (Array.isArray(t0$17) && (t1$9 = t0$17.length, t1$9 >= 2 && t1$9 <= 3 && (t0$17[0], t2$2 = t0$17[1], ___hasprop(t2$2, "pinfo")))) {
                                                      pinfo$4 = t2$2.pinfo;if (2 >= t1$9) {
                                                        null;
                                                      } else {
                                                        t0$17[2];
                                                      }temp$9 = pinfo$4;acc$7.push(temp$9);
                                                    } else {
                                                      ___match_error(m$15);
                                                    }
                                                  }
                                                })(), acc$7));pinfos$2 = pinfos$2.concat((acc$8 = [], temp$10 = null, m$16 = null, (function () {
                                                  $9: for (var _iterator3 = specs$1.fw[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                                    m$16 = _step3.value;
                                                    var pinfo$5 = undefined;var t0$18 = undefined;t0$18 = m$16;if (___hasprop(t0$18, "pinfo")) {
                                                      pinfo$5 = t0$18.pinfo;temp$10 = pinfo$5;acc$8.push(temp$10);
                                                    } else {
                                                      ___match_error(m$16);
                                                    }
                                                  }
                                                })(), acc$8));pinfos$2 = pinfos$2.concat((acc$9 = [], temp$11 = null, m$17 = null, (function () {
                                                  $10: for (var _iterator3 = specs$1.bw[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                                    m$17 = _step3.value;
                                                    var pinfo$6 = undefined;var t0$19 = undefined;t0$19 = m$17;if (___hasprop(t0$19, "pinfo")) {
                                                      pinfo$6 = t0$19.pinfo;temp$11 = pinfo$6;acc$9.push(temp$11);
                                                    } else {
                                                      ___match_error(m$17);
                                                    }
                                                  }
                                                })(), acc$9));pinfos$2 = pinfos$2.concat((acc$10 = [], temp$12 = null, m$18 = null, (function () {
                                                  $11: for (var _iterator3 = specs$1.defaults[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                                    m$18 = _step3.value;
                                                    var pinfo$7 = undefined;var t0$20 = undefined;var t1$10 = undefined;var t2$3 = undefined;t0$20 = m$18;if (Array.isArray(t0$20) && (t1$10 = t0$20.length, t1$10 === 2 && (t2$3 = t0$20[0], ___hasprop(t2$3, "pinfo")))) {
                                                      pinfo$7 = t2$3.pinfo;t0$20[1];temp$12 = pinfo$7;acc$10.push(temp$12);
                                                    } else {
                                                      ___match_error(m$18);
                                                    }
                                                  }
                                                })(), acc$10));if (specs$1.rest) {
                                                  pinfos$2.push(specs$1.rest.pinfo);
                                                }pinfo$3 = PatternInfo$0.mergeAll(pinfos$2);m$14$0 = specs$1;if (($$6468$0 = ___hasprop(m$14$0, "keys")) && (t0$21 = m$14$0.keys, Array.isArray(t0$21) && (t1$11 = t0$21.length, t1$11 === 0 && (___hasprop(m$14$0, "fw") && (fw$0 = m$14$0.fw, ___hasprop(m$14$0, "bw") && (bw$0 = m$14$0.bw, ___hasprop(m$14$0, "defaults") && (defaults$0 = m$14$0.defaults, ___hasprop(m$14$0, "rest")))))))) {
                                                  rest$1 = m$14$0.rest;patt$0 = __amp____colon__(__lt____lt____colon__$0(["array_pattern", fw$0, bw$0, defaults$0, rest$1], pattern$2), { pinfo: pinfo$3 });if (checked$0) {
                                                    rval$3 = patt$0;
                                                  } else {
                                                    rval$3 = __amp____colon__(["check", checker_db$0.Array, patt$0], { pinfo: pinfo$3 });
                                                  }
                                                } else {
                                                  if ($$6468$0 && (keys$0 = m$14$0.keys, ___hasprop(m$14$0, "fw") && (t0$21 = m$14$0.fw, Array.isArray(t0$21) && (t1$11 = t0$21.length, t1$11 === 0 && (___hasprop(m$14$0, "bw") && (t2$4 = m$14$0.bw, Array.isArray(t2$4) && (t3$1 = t2$4.length, t3$1 === 0 && (___hasprop(m$14$0, "defaults") && (t4$1 = m$14$0.defaults, Array.isArray(t4$1) && (t5$1 = t4$1.length, t5$1 === 0 && (___hasprop(m$14$0, "rest") && m$14$0.rest === void 0))))))))))) {
                                                    rval$3 = __amp____colon__(["object_pattern"].concat(keys$0), { pinfo: pinfo$3 });
                                                  } else {
                                                    if ($$6468$0 && (keys$1 = m$14$0.keys, ___hasprop(m$14$0, "fw") && (fw$1 = m$14$0.fw, ___hasprop(m$14$0, "bw") && (bw$1 = m$14$0.bw, ___hasprop(m$14$0, "defaults") && (defaults$1 = m$14$0.defaults, ___hasprop(m$14$0, "rest")))))) {
                                                      rest$2 = m$14$0.rest;rval$3 = __amp____colon__(["all", ["array_pattern", fw$1, bw$1, defaults$1, rest$2], ["object_pattern"].concat(keys$1)], { pinfo: pinfo$3, insertion_index: specs$1.insertion_index });
                                                    } else {
                                                      rval$3 = ___match_error(m$14$0, "{=> keys, => fw, => bw, => defaults, => rest}");
                                                    }
                                                  }
                                                }
                                              } else {
                                                if ($$6055$0 && (($$6057$0 = t0$13 === 3) && m$7$0[0] === "mode")) {
                                                  mode$0 = m$7$0[1];subp$5 = m$7$0[2];rval$3 = $it$6.expand(subp$5, __amp__(tags$2, { declare_mode: mode$0 }), toplevel$0, checked$0);
                                                } else {
                                                  if ($$6057$0 && m$7$0[0] === "default") {
                                                    subp$6 = m$7$0[1];expr$1 = m$7$0[2];r$1 = $it$6.expand(subp$6, tags$2, toplevel$0, checked$0);rval$3 = __amp____colon__(["default", r$1, expr$1], { pinfo: r$1.pinfo, "::objinsert": 3 });
                                                  } else {
                                                    other$0 = m$7$0;throw ErrorFactory(["syntax", "pattern"]).create("Illegal pattern: " + other$0, { node: other$0 });
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }if (!rval$3.pinfo) {
      $targ$19 = PatternInfo$0();rval$3.pinfo = $targ$19;void 0;
    }return ($it$6.opt.wrap_pattern || identity$0)(__lt____lt____colon__$0(rval$3, pattern$2), toplevel$0);
  } else {
    return ___match_error(m$6$0, "{pattern, tags, toplevel = false, checked = false}");
  }
};PatternCompiler$0.prototype.shift_rhs = function shift_rhs(temp$13$0, rhs$0) {
  var t0$22 = undefined;var projector$1 = undefined;var subp$7 = undefined;var t0$23 = undefined;var t1$12 = undefined;var pattern$4 = undefined;var ph$4$0 = undefined;var $it$7 = undefined;var self$5 = undefined;$it$7 = this;self$5 = this;t0$22 = temp$13$0;pattern$4 = t0$22;ph$4$0 = t0$22;t0$23 = ph$4$0;t1$12 = t0$23.length;if (t1$12 === 4 && (t0$23[0] === "project" && (projector$1 = t0$23[1], subp$7 = t0$23[2], t0$23[3] === true))) {
    return $it$7.shift_rhs(subp$7, ["send", projector$1, ["data", rhs$0]]);
  } else {
    return [pattern$4, rhs$0];
  }
};PatternCompiler$0.prototype.process_for_rhs = function process_for_rhs(rhs$1) {
  var t0$24 = undefined;var t0$25 = undefined;var t1$13 = undefined;var x$13 = undefined;var x$14 = undefined;var t0$27 = undefined;var t0$28 = undefined;var $targ$26 = undefined;var t0$29 = undefined;var t1$15 = undefined;var $targ$27 = undefined;var name$0 = undefined;var t0$26 = undefined;var t1$14 = undefined;var bridge$$6778$0 = undefined;var ph$5$0 = undefined;var bridge$$6775$0 = undefined;var m$19$0 = undefined;var t0$30 = undefined;var $targ$20 = undefined;var real_rhs$0 = undefined;var $targ$21 = undefined;var cpattern$0 = undefined;var target$0 = undefined;var expr$2 = undefined;var proc$0 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var $targ$25 = undefined;var $it$8 = undefined;var self$6 = undefined;$it$8 = this;self$6 = this;if (!$it$8.compiled) {
    $it$8.compile();
  }if (!$it$8.opt.allow_arguments && $it$8.arguments.length) {
    throw ErrorFactory(["syntax", "pattern", "arguments"]).create("Arguments cannot be declared in this pattern", { args: $it$8.arguments[0], rhs: rhs$1 });
  }if ($it$8.arguments.length) {
    $targ$20 = inject_below_uses$0(rhs$1, function (x$12) {
      return util$0.construct($it$8.arguments.concat([x$12]), function (args$2, rest$3) {
        return ["send", ["symbol", "->"], ["data", args$2, rest$3]];
      });
    });
  } else {
    $targ$20 = rhs$1;
  }t0$24 = getProjector($it$8.opt.wrap_target || identity$0)($targ$20);if (t0$24[0]) {
    real_rhs$0 = t0$24[1];
  } else {
    ___match_error($targ$20, "[@opt.wrap_target or identity]! real_rhs");
  }$targ$21 = $it$8.shift_rhs($it$8.compiled, real_rhs$0);t0$25 = $targ$21;if (Array.isArray(t0$25) && (t1$13 = t0$25.length, t1$13 === 2)) {
    cpattern$0 = t0$25[0];target$0 = t0$25[1];
  } else {
    ___match_error($targ$21, "{cpattern, var target}");
  }[cpattern$0, target$0];__lt____lt____colon__$0(target$0, rhs$1);expr$2 = null;m$19$0 = target$0;bridge$$6775$0 = m$19$0;if ((x$13 = bridge$$6775$0, x$13 instanceof Array && x$13[0] === "symbol") || (x$14 = bridge$$6775$0, x$14 instanceof Array && x$14[0] === "variable")) {
    undefined;
  } else {
    ph$5$0 = cpattern$0;t0$26 = ph$5$0;if (Array.isArray(t0$26) && (t1$14 = t0$26.length, t1$14 === 2 && (t0$26[0] === "assign" && (bridge$$6778$0 = t0$26[1], Array.isArray(bridge$$6778$0) && (t0$27 = bridge$$6778$0.length, t0$27 === 2 && (bridge$$6778$0[0] === "symbol" && (name$0 = bridge$$6778$0[1], true))) || Array.isArray(bridge$$6778$0) && (t0$28 = bridge$$6778$0.length, t0$28 === 2 && (bridge$$6778$0[0] === "variable" && (name$0 = bridge$$6778$0[1], true))))))) {
      $targ$26 = name$0;target$0.name = $targ$26;void 0;
    } else {
      $targ$27 = [__lt____lt____colon__$0(["variable", $it$8.info.gensym("$targ")], target$0), target$0];t0$29 = $targ$27;if (Array.isArray(t0$29) && (t1$15 = t0$29.length, t1$15 === 2)) {
        target$0 = t0$29[0];expr$2 = t0$29[1];
      } else {
        ___match_error($targ$27, "{target, expr}");
      }[target$0, expr$2];
    }
  }proc$0 = PatternProcessor$0();proc$0.process(cpattern$0, target$0, $it$8.opt);$targ$22 = proc$0;t0$30 = $targ$22;if (___hasprop(t0$30, "temps") && ($it$8.temps = t0$30.temps, ___hasprop(t0$30, "parts"))) {
    $it$8.parts = t0$30.parts;
  } else {
    ___match_error($targ$22, "{temps => @temps, parts => @parts}");
  }$targ$23 = true;$it$8.processed = $targ$23;$targ$24 = target$0;$it$8.target = $targ$24;$targ$25 = expr$2;$it$8.expr = $targ$25;return [$it$8.temps, $it$8.parts];
};PatternCompiler$0.prototype.extract_from_rhs = function extract_from_rhs(rhs$2) {
  var m$20 = undefined;var acc$11 = undefined;var temp$14 = undefined;var succ$0 = undefined;var fail$0 = undefined;var assembly$0 = undefined;var $it$9 = undefined;var self$7 = undefined;$it$9 = this;self$7 = this;if (!$it$9.processed) {
    $it$9.process_for_rhs(rhs$2);
  }succ$0 = $it$9.opt.success($it$9.target);fail$0 = $it$9.opt.failure($it$9.target, $it$9.pattern);assembly$0 = assemble_pattern$0($it$9.parts, succ$0, fail$0);return ["splice", $it$9.expr === null ? ["splice"] : ["splice", ["declare", $it$9.target], ["assign", $it$9.target, $it$9.expr]]].concat($it$9.opt.declare($it$9.info, $it$9.vars)).concat([["multi"].concat((acc$11 = [], temp$14 = null, m$20 = null, (function () {
    $12: for (var _iterator = $it$9.temps[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$20 = _step.value;
      var t$1 = undefined;t$1 = m$20;temp$14 = ["declare", t$1];acc$11.push(temp$14);
    }
  })(), acc$11)).concat([assembly$0])]);
};PatternCompiler$0.prototype.wrapBody = function wrapBody(body$0) {
  var m$21 = undefined;var m$22 = undefined;var x$15 = undefined;var $it$10 = undefined;var self$8 = undefined;$it$10 = this;self$8 = this;m$21 = null;$13: for (var _iterator = enumerate($it$10.handlers)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$21 = _step.value;
    var $targ$28 = undefined;var i$0 = undefined;var h$0 = undefined;var t0$31 = undefined;var t1$16 = undefined;t0$31 = m$21;if (Array.isArray(t0$31) && (t1$16 = t0$31.length, t1$16 === 2)) {
      i$0 = t0$31[0];h$0 = t0$31[1];$targ$28 = h$0.wrapOrder + i$0 / 1000000;h$0.__ord = $targ$28;void 0;
    } else {
      ___match_error(m$21);
    }
  }$it$10.handlers.sort(function (x$16, y$1) {
    return x$16.__ord < y$1.__ord;
  });x$15 = body$0;m$22 = null;$14: for (var _iterator2 = $it$10.handlers[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    m$22 = _step2.value;
    var handler$1 = undefined;handler$1 = m$22;x$15 = handler$1.wrap(x$15, $it$10.info, $it$10.opt);x$15;
  }return x$15;
};PatternCompiler$0.prototype.wrapAssignment = function wrapAssignment(expr$3) {
  var m$23 = undefined;var m$24 = undefined;var x$17 = undefined;var $it$11 = undefined;var self$9 = undefined;$it$11 = this;self$9 = this;m$23 = null;$15: for (var _iterator = enumerate($it$11.handlers)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$23 = _step.value;
    var $targ$29 = undefined;var i$1 = undefined;var h$1 = undefined;var t0$32 = undefined;var t1$17 = undefined;t0$32 = m$23;if (Array.isArray(t0$32) && (t1$17 = t0$32.length, t1$17 === 2)) {
      i$1 = t0$32[0];h$1 = t0$32[1];$targ$29 = h$1.wrapBodyOrder + i$1 / 1000000;h$1.__ord = $targ$29;void 0;
    } else {
      ___match_error(m$23);
    }
  }$it$11.handlers.sort(function (x$18, y$2) {
    return x$18.__ord < y$2.__ord;
  });x$17 = expr$3;m$24 = null;$16: for (var _iterator2 = $it$11.handlers[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    m$24 = _step2.value;
    var handler$2 = undefined;handler$2 = m$24;x$17 = handler$2.wrapAssignment(x$17, $it$11.info, $it$11.opt);x$17;
  }return x$17;
};__amp____colon__(PatternCompiler$0, __amp____colon__(($targ$30 = "PatternCompiler", accum$6 = {}, accum$6["::name"] = $targ$30, accum$6), ($targ$31 = true, accum$7 = {}, accum$7["::egclass"] = $targ$31, accum$7)));PatternProcessor$0 = function PatternProcessor() {
  var $targ$32 = undefined;var $targ$33 = undefined;var $targ$34 = undefined;var $it$12 = undefined;if (!getChecker(PatternProcessor$0)(this)) {
    $it$12 = Object.create(PatternProcessor$0.prototype);
  } else {
    $it$12 = this;
  }$targ$32 = [];$it$12.temps = $targ$32;$targ$33 = [];$it$12.parts = $targ$33;$targ$34 = GenSym$0("t");$it$12.gen = $targ$34;return $it$12;
};$targ$0 = function (part$0) {
  var $it$13 = undefined;var self$10 = undefined;$it$13 = this;self$10 = this;return $it$13.parts.push(["do", part$0]);
};PatternProcessor$0.prototype["do"] = $targ$0;PatternProcessor$0.prototype.check = function check() {
  var part$1 = undefined;var tags$3 = undefined;var t0$33 = undefined;var m$25$0 = undefined;var $it$14 = undefined;var self$11 = undefined;$it$14 = this;self$11 = this;m$25$0 = arguments;t0$33 = m$25$0.length;if (t0$33 >= 1 && t0$33 <= 2) {
    part$1 = m$25$0[0];if (1 >= t0$33) {
      tags$3 = {};
    } else {
      tags$3 = m$25$0[1];
    }return $it$14.parts.push(__amp__(["check", part$1], tags$3));
  } else {
    return ___match_error(m$25$0, "{part, tags = {=}}");
  }
};PatternProcessor$0.prototype.temp = function temp() {
  var x$20 = undefined;var x$21 = undefined;var x$22 = undefined;var $targ$35 = undefined;var init$0 = undefined;var t0$35 = undefined;var bridge$$7179$0 = undefined;var x$19 = undefined;var ph$7$0 = undefined;var v$8 = undefined;var t0$34 = undefined;var t1$18 = undefined;var m$26$0 = undefined;var $it$15 = undefined;var self$12 = undefined;$it$15 = this;self$12 = this;m$26$0 = arguments;t0$34 = m$26$0.length;if (t0$34 >= 1 && t0$34 <= 2) {
    t1$18 = m$26$0[0];x$19 = t1$18;ph$7$0 = t1$18;if (1 >= t0$34) {
      v$8 = null;
    } else {
      v$8 = m$26$0[1];
    }t0$35 = ph$7$0;bridge$$7179$0 = t0$35;if (((x$20 = bridge$$7179$0, x$20 instanceof Array && x$20[0] === "variable") || (x$21 = bridge$$7179$0, x$21 instanceof Array && x$21[0] === "symbol")) && (___hasprop(t0$35, "single_assignment") && ((t0$35.single_assignment ? true : false) && !v$8))) {
      return x$19;
    } else {
      if ((x$22 = ph$7$0, x$22 instanceof Array && x$22[0] === "value")) {
        return x$19;
      } else {
        init$0 = ph$7$0;v$8 = v$8 || ["symbol", $it$15.gen()];$targ$35 = true;v$8.single_assignment = $targ$35;$it$15.temps.push(v$8);$it$15["do"](["send", ["symbol", "="], ["data", ["send", ["symbol", "set-var"], v$8], init$0]]);return v$8;
      }
    }
  } else {
    return ___match_error(m$26$0, "{match x, var v = null}");
  }
};PatternProcessor$0.prototype.process = function process(pattern$5, rhs$3, fns$0) {
  var x$23 = undefined;var x$24 = undefined;var t$2 = undefined;var t$3 = undefined;var t$4 = undefined;var pp$0 = undefined;var x$25 = undefined;var m$28 = undefined;var t$5 = undefined;var m$29 = undefined;var acc$12 = undefined;var temp$15 = undefined;var fn$1 = undefined;var parts$0 = undefined;var t$6 = undefined;var m$30 = undefined;var acc$13 = undefined;var temp$16 = undefined;var t$7 = undefined;var otherwise$0 = undefined;var m$31$0 = undefined;var m$32 = undefined;var m$34 = undefined;var end$0 = undefined;var pos$0 = undefined;var m$35 = undefined;var acc$14 = undefined;var temp$17 = undefined;var nfw$0 = undefined;var nbw$0 = undefined;var ndflt$0 = undefined;var extract_length$0 = undefined;var check_length$0 = undefined;var lo$0 = undefined;var hi$0 = undefined;var t$8 = undefined;var len$0 = undefined;var x$29 = undefined;var fw$2 = undefined;var bw$2 = undefined;var dflt$0 = undefined;var rest$5 = undefined;var subp$12 = undefined;var xs$4 = undefined;var xs$3 = undefined;var patt$1 = undefined;var projector$2 = undefined;var subp$11 = undefined;var unconditional$1 = undefined;var ph$8$0 = undefined;var checker$2 = undefined;var subp$10 = undefined;var checker$1 = undefined;var condition$1 = undefined;var subp$9 = undefined;var before$1 = undefined;var subp$8 = undefined;var value$4 = undefined;var sym$0 = undefined;var $$7283$0 = undefined;var $$7284$0 = undefined;var $$7285$0 = undefined;var $$7286$0 = undefined;var t0$36 = undefined;var t1$19 = undefined;var m$27$0 = undefined;var rval$4 = undefined;var $it$16 = undefined;var self$13 = undefined;$it$16 = this;self$13 = this;m$27$0 = pattern$5;if ((x$23 = m$27$0, x$23 instanceof Array && x$23[0] === "ignore")) {
    rval$4 = $it$16["do"](rhs$3);
  } else {
    if (($$7283$0 = Array.isArray(m$27$0)) && (t0$36 = m$27$0.length, t0$36 === 2 && m$27$0[0] === "assign")) {
      sym$0 = m$27$0[1];rval$4 = $it$16.parts.push(fns$0.assign(sym$0, rhs$3));
    } else {
      if ($$7283$0 && (t0$36 === 3 && m$27$0[0] === "replace")) {
        subp$8 = m$27$0[1];value$4 = m$27$0[2];rval$4 = $it$16.process(subp$8, value$4, fns$0);
      } else {
        if ($$7283$0 && (t0$36 >= 3 && t0$36 <= 4 && m$27$0[0] === "test")) {
          condition$1 = m$27$0[1];subp$9 = m$27$0[2];if (3 >= t0$36) {
            before$1 = false;
          } else {
            before$1 = m$27$0[3];
          }if (before$1) {
            $it$16.check(condition$1, { test: true });rval$4 = $it$16.process(subp$9, rhs$3, fns$0);
          } else {
            $it$16.process(subp$9, rhs$3, fns$0);rval$4 = $it$16.check(condition$1, { test: true });
          }
        } else {
          if ($$7283$0 && (($$7285$0 = t0$36 === 3) && (($$7286$0 = m$27$0[0] === "check") && (checker$1 = m$27$0[1], x$24 = m$27$0[2], x$24 instanceof Array && x$24[0] === "ignore")))) {
            rval$4 = $it$16.check(["send", checker$1, ["data", rhs$3]]);
          } else {
            if ($$7286$0) {
              checker$2 = m$27$0[1];subp$10 = m$27$0[2];t$2 = $it$16.temp(rhs$3);$it$16.check(["send", checker$2, ["data", t$2]]);rval$4 = $it$16.process(subp$10, t$2, fns$0);
            } else {
              if ($$7283$0 && (t0$36 === 4 && m$27$0[0] === "project")) {
                projector$2 = m$27$0[1];subp$11 = m$27$0[2];t1$19 = m$27$0[3];unconditional$1 = t1$19;ph$8$0 = t1$19;if (ph$8$0 ? true : false) {
                  t$3 = $it$16.temp(["send", projector$2, ["data", rhs$3]]);rval$4 = $it$16.process(subp$11, t$3, fns$0);
                } else {
                  t$4 = $it$16.temp(["send", projector$2, ["data", rhs$3]]);$it$16.check(["send", t$4, ["value", 0]]);rval$4 = $it$16.process(subp$11, ["send", t$4, ["value", 1]], fns$0);
                }
              } else {
                if ($$7283$0 && (t0$36 === 2 && m$27$0[0] === "neg")) {
                  patt$1 = m$27$0[1];pp$0 = PatternProcessor$0();pp$0.process(patt$1, rhs$3, fns$0);x$25 = assemble_conditions$0(pp$0);rval$4 = $it$16.check(["send", ["symbol", "not"], ["data", ["void"], x$25]]);
                } else {
                  if ($$7283$0 && (($$7285$0 = t0$36 >= 1) && m$27$0[0] === "all")) {
                    xs$3 = Array.prototype.slice.call(m$27$0, 1);t$5 = $it$16.temp(rhs$3);m$28 = null;$17: for (var _iterator = xs$3[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                      m$28 = _step.value;
                      var x$26 = undefined;x$26 = m$28;$it$16.process(x$26, t$5, fns$0);
                    }rval$4 = null;
                  } else {
                    if ($$7285$0 && m$27$0[0] === "any") {
                      xs$4 = Array.prototype.slice.call(m$27$0, 1);t$6 = $it$16.temp(rhs$3, ["symbol", gensym$0("bridge")]);rval$4 = $it$16.check((fn$1 = function fn(x$27, rest$4) {
                        return ["send", ["symbol", "or"], ["data", x$27, rest$4]];
                      }, parts$0 = (acc$12 = [], temp$15 = null, m$29 = null, (function () {
                        $18: for (var _iterator2 = xs$4[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                          m$29 = _step2.value;
                          var pp$1 = undefined;var x$28 = undefined;x$28 = m$29;pp$1 = PatternProcessor$0();pp$1.process(x$28, t$6, fns$0);temp$15 = assemble_conditions$0(pp$1);acc$12.push(temp$15);
                        }
                      })(), acc$12), util$0.construct(parts$0, fn$1, ["symbol", "false"])));
                    } else {
                      if ($$7285$0 && m$27$0[0] === "object_pattern") {
                        subp$12 = Array.prototype.slice.call(m$27$0, 1);t$7 = $it$16.temp(rhs$3);acc$13 = [];temp$16 = null;m$30 = null;$19: for (var _iterator2 = subp$12[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                          m$30 = _step2.value;
                          var t2$5 = undefined;var t2$6 = undefined;var k$1 = undefined;var v$10 = undefined;var default$4 = undefined;var k$0 = undefined;var v$9 = undefined;var $$7448$0 = undefined;var $$7449$0 = undefined;var $$7450$0 = undefined;var t0$37 = undefined;var t1$20 = undefined;t0$37 = m$30;if (($$7449$0 = Array.isArray(t0$37)) && (t1$20 = t0$37.length, t1$20 === 2)) {
                            k$0 = t0$37[0];v$9 = t0$37[1];t2$5 = $it$16.temp(k$0);$it$16.check(["send", ["symbol", "___hasprop"], ["data", t$7, t2$5]]);temp$16 = $it$16.process(v$9, ["send", t$7, t2$5], fns$0);acc$13.push(temp$16);
                          } else {
                            if ($$7449$0 && t1$20 === 3) {
                              k$1 = t0$37[0];v$10 = t0$37[1];default$4 = t0$37[2];t2$6 = $it$16.temp(k$1);temp$16 = $it$16.process(v$10, ["send", ["symbol", "if"], ["data", ["send", ["symbol", "___hasprop"], ["data", t$7, t2$6]], ["send", t$7, t2$6], default$4]], fns$0);acc$13.push(temp$16);
                            } else {
                              ___match_error(m$30);
                            }
                          }
                        }rval$4 = acc$13;
                      } else {
                        if ($$7283$0 && (t0$36 === 5 && m$27$0[0] === "array_pattern")) {
                          fw$2 = m$27$0[1];bw$2 = m$27$0[2];dflt$0 = m$27$0[3];rest$5 = m$27$0[4];nfw$0 = fw$2.length;nbw$0 = bw$2.length;ndflt$0 = dflt$0.length;extract_length$0 = true;check_length$0 = true;lo$0 = nfw$0 + nbw$0;hi$0 = lo$0 + ndflt$0;t$8 = $it$16.temp(rhs$3);len$0 = $it$16.temp(["send", t$8, ["send", ["symbol", "."], ["data", ["void"], ["symbol", "length"]]]]);$it$16.check((m$31$0 = rest$5, (m$31$0 ? true : false) ? ["send", ["symbol", ">="], ["data", len$0, ["value", lo$0]]] : lo$0 === hi$0 ? ["send", ["symbol", "==="], ["data", len$0, ["value", lo$0]]] : (otherwise$0 = m$31$0, ["send", ["symbol", "and"], ["data", ["send", ["symbol", ">="], ["data", len$0, ["value", lo$0]]], ["send", ["symbol", "<="], ["data", len$0, ["value", hi$0]]]]])));m$32 = null;$20: for (var _iterator3 = enumerate(fw$2)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                            m$32 = _step3.value;
                            var i$2 = undefined;var m$33 = undefined;var t0$38 = undefined;var t1$21 = undefined;t0$38 = m$32;if (Array.isArray(t0$38) && (t1$21 = t0$38.length, t1$21 === 2)) {
                              i$2 = t0$38[0];m$33 = t0$38[1];$it$16.process(m$33, ["send", t$8, ["value", i$2]], fns$0);
                            } else {
                              ___match_error(m$32);
                            }
                          }m$34 = null;$21: for (var _iterator4 = enumerate(dflt$0)[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                            m$34 = _step4.value;
                            var idx$0 = undefined;var i$3 = undefined;var patt$2 = undefined;var value$5 = undefined;var t0$39 = undefined;var t1$22 = undefined;var t2$7 = undefined;var t3$2 = undefined;t0$39 = m$34;if (Array.isArray(t0$39) && (t1$22 = t0$39.length, t1$22 === 2 && (i$3 = t0$39[0], t2$7 = t0$39[1], Array.isArray(t2$7) && (t3$2 = t2$7.length, t3$2 === 2)))) {
                              patt$2 = t2$7[0];value$5 = t2$7[1];idx$0 = i$3 + nfw$0;$it$16.process(patt$2, ["send", ["symbol", "if"], ["data", ["send", ["symbol", ">="], ["data", ["value", idx$0 + nbw$0], len$0]], value$5, ["send", t$8, ["value", idx$0]]]], fns$0);
                            } else {
                              ___match_error(m$34);
                            }
                          }if (rest$5 !== undefined) {
                            pos$0 = nfw$0 + ndflt$0;if (nbw$0 > 0) {
                              end$0 = [["value", -nbw$0]];
                            } else {
                              end$0 = [];
                            }$it$16.process(rest$5, ["send", ["send", ["send", ["send", ["symbol", "Array"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "prototype"]]]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "slice"]]]], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "call"]]]], ["data", t$8, ["value", pos$0]].concat(end$0)], fns$0);
                          } else {
                            [];
                          }acc$14 = [];temp$17 = null;m$35 = null;$22: for (var _iterator5 = enumerate(bw$2)[Symbol.iterator](), _step5; !(_step5 = _iterator5.next()).done;) {
                            m$35 = _step5.value;
                            var i$4 = undefined;var m$36 = undefined;var t0$40 = undefined;var t1$23 = undefined;t0$40 = m$35;if (Array.isArray(t0$40) && (t1$23 = t0$40.length, t1$23 === 2)) {
                              i$4 = t0$40[0];m$36 = t0$40[1];temp$17 = $it$16.process(m$36, ["send", ["symbol", "___js_fetch"], ["data", t$8, ["send", ["symbol", "-"], ["data", len$0, ["value", nbw$0 - i$4]]]]], fns$0);acc$14.push(temp$17);
                            } else {
                              ___match_error(m$35);
                            }
                          }rval$4 = acc$14;
                        } else {
                          if ((x$29 = m$27$0, x$29 instanceof Array && x$29[0] === "default")) {
                            throw send(send(ErrorFactory(["syntax", "pattern"]), "create", true), __amp____colon__([ENode([], {}, ["Cannot declare default value here"]).toString()], { expr: pattern$5, "::objinsert": 1 }));
                          } else {
                            rval$4 = ___match_error(m$27$0, "#default");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }return rval$4;
};__amp____colon__(PatternProcessor$0, __amp____colon__(($targ$36 = "PatternProcessor", accum$8 = {}, accum$8["::name"] = $targ$36, accum$8), ($targ$37 = true, accum$9 = {}, accum$9["::egclass"] = $targ$37, accum$9)));assemble_conditions$0 = function assemble_conditions(pp$2) {
  var m$37 = undefined;var acc$15 = undefined;var temp$18 = undefined;var decls$0 = undefined;var construct$0 = undefined;construct$0 = function construct(ph$9$0) {
    var x$32 = undefined;var rest$7 = undefined;var x$31 = undefined;var x$30 = undefined;var rest$6 = undefined;var $$7704$0 = undefined;var $$7705$0 = undefined;var t0$41 = undefined;var t1$24 = undefined;var t2$8 = undefined;var t3$3 = undefined;t0$41 = ph$9$0;t1$24 = t0$41.length;if (t1$24 === 0) {
      return ["value", true];
    } else {
      if (t1$24 >= 1 && (t2$8 = t0$41[0], Array.isArray(t2$8) && (t3$3 = t2$8.length, t3$3 === 2 && t2$8[0] === "do"))) {
        x$30 = t2$8[1];rest$6 = Array.prototype.slice.call(t0$41, 1);return ["multi", x$30, construct$0(rest$6)];
      } else {
        if (t1$24 === 1 && (t2$8 = t0$41[0], Array.isArray(t2$8) && (t3$3 = t2$8.length, t3$3 === 2 && t2$8[0] === "check"))) {
          x$31 = t2$8[1];return x$31;
        } else {
          if (t1$24 >= 1 && (t2$8 = t0$41[0], Array.isArray(t2$8) && (t3$3 = t2$8.length, t3$3 === 2 && t2$8[0] === "check"))) {
            x$32 = t2$8[1];rest$7 = Array.prototype.slice.call(t0$41, 1);return ["send", ["symbol", "and"], ["data", x$32, construct$0(rest$7)]];
          } else {
            return ___match_error(ph$9$0, "{#check{x}, *rest}");
          }
        }
      }
    }
  };if (pp$2.temps.length) {
    acc$15 = [];temp$18 = null;m$37 = null;$23: for (var _iterator = pp$2.temps[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$37 = _step.value;
      var t$9 = undefined;t$9 = m$37;temp$18 = ["declare", t$9];acc$15.push(temp$18);
    }decls$0 = acc$15;return ["multi"].concat(decls$0).concat([construct$0(pp$2.parts)]);
  } else {
    return construct$0(pp$2.parts);
  }
};assemble_pattern$0 = function assemble_pattern() {
  var m$39 = undefined;var m$40 = undefined;var x$40 = undefined;var test$0 = undefined;var lead$0 = undefined;var trail$0 = undefined;var construct$1 = undefined;var parts$1 = undefined;var t$10 = undefined;var f$5 = undefined;var t0$42 = undefined;var m$38$0 = undefined;m$38$0 = arguments;t0$42 = m$38$0.length;if (t0$42 >= 2 && t0$42 <= 3) {
    parts$1 = m$38$0[0];t$10 = m$38$0[1];if (2 >= t0$42) {
      f$5 = null;
    } else {
      f$5 = m$38$0[2];
    }lead$0 = [];m$39 = null;$24: for (var _iterator = parts$1.slice(0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$39 = _step.value;
      var x$34 = undefined;var x$33 = undefined;var $$7819$0 = undefined;var $$7820$0 = undefined;var $$7821$0 = undefined;var $$7822$0 = undefined;var t0$43 = undefined;var t1$25 = undefined;t0$43 = m$39;if (($$7820$0 = Array.isArray(t0$43)) && (t1$25 = t0$43.length, ($$7822$0 = t1$25 === 2) && t0$43[0] === "do")) {
        x$33 = t0$43[1];lead$0.push(x$33);parts$1.shift();
      } else {
        if ($$7822$0 && t0$43[0] === "check") {
          x$34 = t0$43[1];if (_iterator["return"]) _iterator["return"]();
          break $24;
        } else {
          ___match_error(m$39);
        }
      }
    }trail$0 = [];m$40 = null;$25: for (var _iterator2 = parts$1.slice(0).reverse()[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
      m$40 = _step2.value;
      var x$36 = undefined;var x$35 = undefined;var $$7826$0 = undefined;var $$7827$0 = undefined;var $$7828$0 = undefined;var $$7829$0 = undefined;var t0$44 = undefined;var t1$26 = undefined;t0$44 = m$40;if (($$7827$0 = Array.isArray(t0$44)) && (t1$26 = t0$44.length, ($$7829$0 = t1$26 === 2) && t0$44[0] === "do")) {
        x$35 = t0$44[1];trail$0.unshift(x$35);parts$1.pop();
      } else {
        if ($$7829$0 && t0$44[0] === "check") {
          x$36 = t0$44[1];if (_iterator2["return"]) _iterator2["return"]();
          break $25;
        } else {
          ___match_error(m$40);
        }
      }
    }construct$1 = function construct(ph$10$0) {
      var other$1 = undefined;var x$39 = undefined;var rest$9 = undefined;var x$38 = undefined;var x$37 = undefined;var rest$8 = undefined;var $$7892$0 = undefined;var $$7893$0 = undefined;var t0$45 = undefined;var t1$27 = undefined;var t2$9 = undefined;var t3$4 = undefined;t0$45 = ph$10$0;t1$27 = t0$45.length;if (t1$27 === 0) {
        return ["value", true];
      } else {
        if (t1$27 >= 1 && (t2$9 = t0$45[0], Array.isArray(t2$9) && (t3$4 = t2$9.length, t3$4 === 2 && t2$9[0] === "do"))) {
          x$37 = t2$9[1];rest$8 = Array.prototype.slice.call(t0$45, 1);return ["multi", x$37, construct$1(rest$8)];
        } else {
          if (t1$27 === 1 && (t2$9 = t0$45[0], Array.isArray(t2$9) && (t3$4 = t2$9.length, t3$4 === 2 && t2$9[0] === "check"))) {
            x$38 = t2$9[1];return x$38;
          } else {
            if (t1$27 >= 1 && (t2$9 = t0$45[0], Array.isArray(t2$9) && (t3$4 = t2$9.length, t3$4 === 2 && t2$9[0] === "check"))) {
              x$39 = t2$9[1];rest$9 = Array.prototype.slice.call(t0$45, 1);return ["send", ["symbol", "and"], ["data", x$39, construct$1(rest$9)]];
            } else {
              other$1 = ph$10$0;throw ErrorFactory(["oops"]).create("?!?", other$1);
            }
          }
        }
      }
    };if (parts$1.length) {
      test$0 = construct$1(parts$1);if (f$5) {
        x$40 = ["send", ["symbol", "if"], ["data", test$0, ["multi"].concat(trail$0).concat([t$10]), f$5]];
      } else {
        x$40 = ["send", ["symbol", "if"], ["data", test$0, ["multi"].concat(trail$0).concat([t$10])]];
      }return ["multi"].concat(lead$0).concat([x$40]);
    } else {
      return ["multi"].concat(lead$0).concat(trail$0).concat([t$10]);
    }
  } else {
    return ___match_error(m$38$0, "{parts, t, f = null}");
  }
};inject_below_uses$0 = function inject_below_uses(ph$11$0, fn$2) {
  var other$2 = undefined;var scope$0 = undefined;var x$41 = undefined;var t0$46 = undefined;var t1$28 = undefined;t0$46 = ph$11$0;t1$28 = t0$46.length;if (t1$28 === 3 && t0$46[0] === "use") {
    scope$0 = t0$46[1];x$41 = t0$46[2];return ["use", scope$0, inject_below_uses$0(x$41, fn$2)];
  } else {
    other$2 = ph$11$0;return fn$2(other$2);
  }
};checkall$0 = ["send", "data", "multi", "assign", "void", "check", "do"];same_block$0 = function same_block(ph$12$0, ban1$0, ban2$0) {
  var m$41 = undefined;var other$3 = undefined;var type1$0 = undefined;var args1$0 = undefined;var type2$0 = undefined;var args2$0 = undefined;var m1$0 = undefined;var m2$0 = undefined;var v1$2 = undefined;var v2$2 = undefined;var s1$0 = undefined;var s2$0 = undefined;var v1$1 = undefined;var v2$1 = undefined;var $$7999$0 = undefined;var $$8000$0 = undefined;var $$8001$0 = undefined;var $$8002$0 = undefined;var $$8003$0 = undefined;var $$8004$0 = undefined;var $$8005$0 = undefined;var t0$47 = undefined;var t1$29 = undefined;var t2$10 = undefined;var t3$5 = undefined;var t4$2 = undefined;var t5$2 = undefined;t0$47 = ph$12$0;t1$29 = t0$47.length;if (($$8001$0 = t1$29 === 2) && (t2$10 = t0$47[0], ($$8003$0 = Array.isArray(t2$10)) && (t3$5 = t2$10.length, ($$8005$0 = t3$5 === 2) && (t2$10[0] === "variable" && (v1$1 = t2$10[1], t4$2 = t0$47[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 === 2 && t4$2[0] === "variable")))))) {
    v2$1 = t4$2[1];return v1$1 === v2$1;
  } else {
    if ($$8005$0 && (t2$10[0] === "symbol" && (s1$0 = t2$10[1], t4$2 = t0$47[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 === 2 && t4$2[0] === "symbol")))) {
      s2$0 = t4$2[1];return !send(ban1$0, s1$0) && !send(ban2$0, s2$0) && s1$0 === s2$0;
    } else {
      if ($$8005$0 && (t2$10[0] === "value" && (v1$2 = t2$10[1], t4$2 = t0$47[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 === 2 && t4$2[0] === "value")))) {
        v2$2 = t4$2[1];return v1$2 === v2$2;
      } else {
        if ($$8005$0 && (t2$10[0] === "macro" && (m1$0 = t2$10[1], t4$2 = t0$47[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 === 2 && t4$2[0] === "macro")))) {
          m2$0 = t4$2[1];return m1$0 === m2$0;
        } else {
          if (Array.isArray(t0$47) && (t1$29 = t0$47.length, t1$29 === 2 && (t2$10 = t0$47[0], Array.isArray(t2$10) && (t3$5 = t2$10.length, t3$5 >= 1 && (type1$0 = t2$10[0], args1$0 = Array.prototype.slice.call(t2$10, 1), t4$2 = t0$47[1], Array.isArray(t4$2) && (t5$2 = t4$2.length, t5$2 >= 1 && (type2$0 = t4$2[0], args2$0 = Array.prototype.slice.call(t4$2, 1), checkall$0.indexOf(type1$0) !== -1))))))) {
            if (type1$0 === type2$0 && args1$0.length === args2$0.length) {
              m$41 = null;$26: for (var _iterator = zip(args1$0, args2$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                m$41 = _step.value;
                var pair$0 = undefined;pair$0 = m$41;if (!same_block$0(pair$0, ban1$0, ban2$0)) {
                  return false;
                }
              }return true;
            } else {
              return false;
            }
          } else {
            other$3 = ph$12$0;return false;
          }
        }
      }
    }
  }
};parse_clauses$0 = function parse_clauses(info$0, target$1, stmts$0, opt$0) {
  var m$42 = undefined;var acc$16 = undefined;var temp$19 = undefined;var m$44 = undefined;var acc$17 = undefined;var temp$20 = undefined;var m$45 = undefined;var acc$18 = undefined;var temp$21 = undefined;var decls$1 = undefined;var all_temps$0 = undefined;var last_clause$0 = undefined;var the_parts$0 = undefined;var unique_temps$0 = undefined;all_temps$0 = [];last_clause$0 = null;acc$16 = [];temp$19 = null;m$42 = null;$27: for (var _iterator = info$0.step_all(["clause"], stmts$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$42 = _step.value;
    var accum$10 = undefined;var t0$49 = undefined;var m$43 = undefined;var pc$1 = undefined;var $targ$38 = undefined;var vars$1 = undefined;var temps$0 = undefined;var blocks$0 = undefined;var vars2$0 = undefined;var x$42 = undefined;var other$5 = undefined;var b$0 = undefined;var pattern$6 = undefined;var body$1 = undefined;var $$8153$0 = undefined;var t0$48 = undefined;var t1$30 = undefined;t0$48 = m$42;if (Array.isArray(t0$48) && (t1$30 = t0$48.length, t1$30 === 3 && t0$48[0] === "clause")) {
      pattern$6 = t0$48[1];body$1 = t0$48[2];last_clause$0 = pattern$6;pc$1 = PatternCompiler$0(pattern$6, info$0, __amp__(opt$0, __amp____colon__({ allow_arguments: false, allow_nested: true }, (accum$10 = {}, accum$10.assign = function assign(v$11, value$6) {
        return ["do", __lt____lt____colon__$0(["assign", v$11, value$6], v$11)];
      }, accum$10))));pc$1.process_for_rhs(target$1);$targ$38 = pc$1;t0$49 = $targ$38;if (___hasprop(t0$49, "vars") && (vars$1 = t0$49.vars, ___hasprop(t0$49, "temps") && (temps$0 = t0$49.temps, ___hasprop(t0$49, "parts")))) {
        blocks$0 = t0$49.parts;
      } else {
        ___match_error($targ$38, "{=> vars, => temps, parts => blocks}");
      }[vars$1, temps$0, blocks$0];all_temps$0 = all_temps$0.concat(temps$0);vars2$0 = {};m$43 = null;$28: for (var _iterator2 = vars$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$43 = _step2.value;
        var $targ$39 = undefined;var other$4 = undefined;var xxx$0 = undefined;var t0$50 = undefined;var t1$31 = undefined;t0$50 = m$43;if (Array.isArray(t0$50) && (t1$31 = t0$50.length, t1$31 === 2 && t0$50[0] === "symbol")) {
          xxx$0 = t0$50[1];$targ$39 = true;vars2$0[xxx$0] = $targ$39;void 0;
        } else {
          other$4 = m$43;throw ErrorFactory(["syntax", "unexpected"]).create("Huh", { expr: other$4 });
        }
      }if (opt$0.wrap) {
        pc$1.handlers.push(opt$0);
      }temp$19 = ["clause", vars$1, vars2$0, blocks$0, pc$1.wrapBody(body$1)];acc$16.push(temp$19);
    } else {
      if ((x$42 = t0$48, x$42 instanceof Array && x$42[0] === "block")) {
        b$0 = t0$48;temp$19 = b$0;acc$16.push(temp$19);
      } else {
        other$5 = m$42;throw ErrorFactory(["syntax", "clause"]).create("Illegal clause", { clause: other$5 });acc$16.push(temp$19);
      }
    }
  }the_parts$0 = acc$16;if (opt$0.fallback) {
    the_parts$0.push(["block", opt$0.fallback(target$1, last_clause$0)]);
  }unique_temps$0 = keys(util$0.mkset((acc$17 = [], temp$20 = null, m$44 = null, (function () {
    $29: for (var _iterator3 = all_temps$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
      m$44 = _step3.value;
      var t$11 = undefined;var t0$51 = undefined;var t1$32 = undefined;t0$51 = m$44;if (Array.isArray(t0$51) && (t1$32 = t0$51.length, t1$32 === 2 && t0$51[0] === "symbol")) {
        t$11 = t0$51[1];temp$20 = t$11;acc$17.push(temp$20);
      } else {
        ___match_error(m$44);
      }
    }
  })(), acc$17)));acc$18 = [];temp$21 = null;m$45 = null;$30: for (var _iterator3 = unique_temps$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
    m$45 = _step3.value;
    var t$12 = undefined;t$12 = m$45;temp$21 = ["declare", __amp____colon__(["symbol", t$12], { mutable: true })];acc$18.push(temp$21);
  }decls$1 = acc$18;return ["multi"].concat(decls$1).concat([weave_clauses$0(the_parts$0)]);
};opt_clauses$0 = function opt_clauses(clauses$0) {
  var m$46 = undefined;var acc$19 = undefined;var temp$22 = undefined;var m$49 = undefined;var acc$20 = undefined;var temp$23 = undefined;var m$50 = undefined;var acc$21 = undefined;var temp$24 = undefined;var m$51 = undefined;var acc$22 = undefined;var temp$25 = undefined;var shares$0 = undefined;var max$0 = undefined;var temps$1 = undefined;var shared_last$0 = undefined;var idx_last$0 = undefined;var new_clauses$0 = undefined;acc$19 = [];temp$22 = null;m$46 = null;$31: for (var _iterator = enumerate(clauses$0.slice(1))[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$46 = _step.value;
    var t0$53 = undefined;var t1$34 = undefined;var m$47 = undefined;var $targ$40 = undefined;var varsd0$0 = undefined;var blocks0$0 = undefined;var share$0 = undefined;var idx$1 = undefined;var i$5 = undefined;var vars$2 = undefined;var varsd$0 = undefined;var blocks$1 = undefined;var body$2 = undefined;var t0$52 = undefined;var t1$33 = undefined;var t2$11 = undefined;var t3$6 = undefined;t0$52 = m$46;if (Array.isArray(t0$52) && (t1$33 = t0$52.length, t1$33 === 2 && (i$5 = t0$52[0], t2$11 = t0$52[1], Array.isArray(t2$11) && (t3$6 = t2$11.length, t3$6 === 5 && t2$11[0] === "clause")))) {
      vars$2 = t2$11[1];varsd$0 = t2$11[2];blocks$1 = t2$11[3];body$2 = t2$11[4];$targ$40 = send(clauses$0, i$5);t0$53 = $targ$40;if (Array.isArray(t0$53) && (t1$34 = t0$53.length, t1$34 === 5 && t0$53[0] === "clause")) {
        t0$53[1];varsd0$0 = t0$53[2];blocks0$0 = t0$53[3];t0$53[4];
      } else {
        ___match_error($targ$40, "#clause{_, varsd0, blocks0, _}");
      }[varsd0$0, blocks0$0];share$0 = 0;idx$1 = 0;m$47 = null;$32: for (var _iterator2 = blocks$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$47 = _step2.value;
        var x$43 = undefined;var x$44 = undefined;var t$13 = undefined;var other$6 = undefined;var m$48$0 = undefined;var b$1 = undefined;b$1 = m$47;if (same_block$0([send(blocks0$0, share$0), b$1], varsd0$0, varsd$0)) {
          share$0++;m$48$0 = b$1;if ((x$43 = m$48$0, x$43 instanceof Array && x$43[0] === "do")) {
            null;
          } else {
            if ((x$44 = m$48$0, x$44 instanceof Array && x$44[0] === "check")) {
              idx$1 = share$0;idx$1;
            } else {
              other$6 = m$48$0;t$13 = other$6;console.log(t$13);t$13;
            }
          }
        } else {
          if (_iterator2["return"]) _iterator2["return"]();
          break $32;
        }
      }temp$22 = [share$0, idx$1];acc$19.push(temp$22);
    } else {
      ___match_error(m$46);
    }
  }shares$0 = acc$19;max$0 = send(send(Math, "max", true), (acc$20 = [], temp$23 = null, m$49 = null, (function () {
    $33: for (var _iterator3 = shares$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
      m$49 = _step3.value;
      var x$45 = undefined;var t0$54 = undefined;var t1$35 = undefined;t0$54 = m$49;if (Array.isArray(t0$54) && (t1$35 = t0$54.length, t1$35 === 2)) {
        x$45 = t0$54[0];t0$54[1];temp$23 = x$45;acc$20.push(temp$23);
      } else {
        ___match_error(m$49);
      }
    }
  })(), acc$20));shares$0.push([0, 0]);acc$21 = [];temp$24 = null;m$50 = null;$34: for (var _iterator3 = range(1, max$0)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
    m$50 = _step3.value;
    temp$24 = ["symbol", gensym$0()];acc$21.push(temp$24);
  }temps$1 = acc$21;shared_last$0 = 0;idx_last$0 = 0;acc$22 = [];temp$25 = null;m$51 = null;$35: for (var _iterator4 = enumerate(clauses$0)[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
    m$51 = _step4.value;
    var t0$56 = undefined;var t1$37 = undefined;var m$52 = undefined;var acc$23 = undefined;var temp$26 = undefined;var rest$10 = undefined;var newblocks$0 = undefined;var $targ$41 = undefined;var share$1 = undefined;var idx$2 = undefined;var shared$0 = undefined;var n_to_share$0 = undefined;var to_share$0 = undefined;var other$7 = undefined;var i$6 = undefined;var vars$3 = undefined;var varsd$1 = undefined;var blocks$2 = undefined;var body$3 = undefined;var t0$55 = undefined;var t1$36 = undefined;var t2$12 = undefined;var t3$7 = undefined;t0$55 = m$51;if (Array.isArray(t0$55) && (t1$36 = t0$55.length, t1$36 === 2 && (i$6 = t0$55[0], t2$12 = t0$55[1], Array.isArray(t2$12) && (t3$7 = t2$12.length, t3$7 === 5 && t2$12[0] === "clause")))) {
      vars$3 = t2$12[1];varsd$1 = t2$12[2];blocks$2 = t2$12[3];body$3 = t2$12[4];$targ$41 = send(shares$0, i$6);t0$56 = $targ$41;if (Array.isArray(t0$56) && (t1$37 = t0$56.length, t1$37 === 2)) {
        share$1 = t0$56[0];idx$2 = t0$56[1];
      } else {
        ___match_error($targ$41, "{share, idx}");
      }[share$1, idx$2];if (idx_last$0) {
        shared$0 = [["check", send(temps$1, idx_last$0 - 1)]];
      } else {
        shared$0 = [];
      }n_to_share$0 = Math.max(shared_last$0, share$1);acc$23 = [];temp$26 = null;m$52 = null;$36: for (var _iterator5 = enumerate(blocks$2.slice(shared_last$0, n_to_share$0))[Symbol.iterator](), _step5; !(_step5 = _iterator5.next()).done;) {
        m$52 = _step5.value;
        var j$1 = undefined;var x$47 = undefined;var j$0 = undefined;var x$46 = undefined;var $$8621$0 = undefined;var $$8622$0 = undefined;var $$8623$0 = undefined;var $$8624$0 = undefined;var t0$57 = undefined;var t1$38 = undefined;var t2$13 = undefined;var t3$8 = undefined;t0$57 = m$52;if (($$8622$0 = Array.isArray(t0$57)) && (t1$38 = t0$57.length, ($$8624$0 = t1$38 === 2) && (j$0 = t0$57[0], t2$13 = t0$57[1], Array.isArray(t2$13) && (t3$8 = t2$13.length, t3$8 === 2 && t2$13[0] === "check")))) {
          x$46 = t2$13[1];temp$26 = ["check", ["assign", send(temps$1, shared_last$0 + j$0), x$46]];acc$23.push(temp$26);
        } else {
          if ($$8624$0 && (j$1 = t0$57[0], t2$13 = t0$57[1], Array.isArray(t2$13) && (t3$8 = t2$13.length, t3$8 === 2 && t2$13[0] === "do"))) {
            x$47 = t2$13[1];temp$26 = ["do", x$47];acc$23.push(temp$26);
          } else {
            ___match_error(m$52);
          }
        }
      }to_share$0 = acc$23;shared_last$0 = share$1;idx_last$0 = idx$2;rest$10 = blocks$2.slice(n_to_share$0);newblocks$0 = shared$0.concat(to_share$0).concat(rest$10);temp$25 = ["clause", vars$3, varsd$1, newblocks$0, body$3];acc$22.push(temp$25);
    } else {
      other$7 = m$51;throw ErrorFactory(["oops"]).create("what", { value: other$7 });acc$22.push(temp$25);
    }
  }new_clauses$0 = acc$22;return [temps$1, new_clauses$0];
};weave_clauses$0 = function weave_clauses(parts$2) {
  var m$53 = undefined;var m$56 = undefined;var acc$25 = undefined;var temp$29 = undefined;var groups$0 = undefined;var reassemble$0 = undefined;var new_temps$0 = undefined;var helper$0 = undefined;groups$0 = classify_contiguous$0(parts$2, function (temp$27$0) {
    var t0$58 = undefined;var t1$39 = undefined;var cls$0 = undefined;t0$58 = temp$27$0;if (Array.isArray(t0$58) && (t1$39 = t0$58.length, t1$39 >= 1)) {
      cls$0 = t0$58[0];Array.prototype.slice.call(t0$58, 1);
    } else {
      ___match_error(temp$27$0);
    }return cls$0;
  });reassemble$0 = [];new_temps$0 = [];m$53 = null;$37: for (var _iterator = groups$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$53 = _step.value;
    var t0$60 = undefined;var t1$41 = undefined;var $targ$42 = undefined;var ts$0 = undefined;var new_clauses$1 = undefined;var elems$1 = undefined;var elems$0 = undefined;var $$8731$0 = undefined;var $$8732$0 = undefined;var $$8733$0 = undefined;var $$8734$0 = undefined;var t0$59 = undefined;var t1$40 = undefined;t0$59 = m$53;if (($$8732$0 = Array.isArray(t0$59)) && (t1$40 = t0$59.length, ($$8734$0 = t1$40 >= 1) && t0$59[0] === "clause")) {
      elems$0 = Array.prototype.slice.call(t0$59, 1);$targ$42 = opt_clauses$0(elems$0);t0$60 = $targ$42;if (Array.isArray(t0$60) && (t1$41 = t0$60.length, t1$41 === 2)) {
        ts$0 = t0$60[0];new_clauses$1 = t0$60[1];
      } else {
        ___match_error($targ$42, "{ts, new_clauses}");
      }[ts$0, new_clauses$1];new_temps$0 = new_temps$0.concat(ts$0);reassemble$0 = reassemble$0.concat(new_clauses$1);
    } else {
      if ($$8734$0 && t0$59[0] === "block") {
        elems$1 = Array.prototype.slice.call(t0$59, 1);reassemble$0 = reassemble$0.concat(elems$1);
      } else {
        ___match_error(m$53);
      }
    }
  }helper$0 = function helper(ph$13$0) {
    var m$54 = undefined;var acc$24 = undefined;var temp$28 = undefined;var decls$2 = undefined;var vars$4 = undefined;var varsd$2 = undefined;var blocks$3 = undefined;var body$5 = undefined;var rest$12 = undefined;var body$4 = undefined;var rest$11 = undefined;var $$8804$0 = undefined;var $$8805$0 = undefined;var $$8806$0 = undefined;var $$8807$0 = undefined;var $$8808$0 = undefined;var $$8809$0 = undefined;var t0$61 = undefined;var t1$42 = undefined;var t2$14 = undefined;var t3$9 = undefined;var t4$3 = undefined;var t5$3 = undefined;var t6$1 = undefined;t0$61 = ph$13$0;t1$42 = t0$61.length;if (t1$42 === 0) {
      return ["multi"];
    } else {
      if (($$8806$0 = t1$42 >= 1) && (t2$14 = t0$61[0], ($$8808$0 = Array.isArray(t2$14)) && (t3$9 = t2$14.length, t3$9 === 2 && (t2$14[0] === "block" && (t4$3 = getProjector(Body$0)(t2$14[1]), t4$3[0] && (t5$3 = t4$3[1], t6$1 = t5$3.length, t6$1 >= 0)))))) {
        body$4 = Array.prototype.slice.call(t5$3, 0);rest$11 = Array.prototype.slice.call(t0$61, 1);return ["multi"].concat(body$4).concat([helper$0(rest$11)]);
      } else {
        if ($$8808$0 && (t3$9 === 5 && t2$14[0] === "clause")) {
          vars$4 = t2$14[1];varsd$2 = t2$14[2];blocks$3 = t2$14[3];body$5 = t2$14[4];rest$12 = Array.prototype.slice.call(t0$61, 1);acc$24 = [];temp$28 = null;m$54 = null;$38: for (var _iterator2 = vars$4[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
            m$54 = _step2.value;
            var bridge$$8887$0 = undefined;var m$55$0 = undefined;var v$12 = undefined;v$12 = m$54;m$55$0 = v$12.declare_mode;if (m$55$0 === "set") {
              temp$28 = ["splice"];
            } else {
              if (m$55$0 === "let") {
                temp$28 = ["declare", __amp__(v$12, { mutable: false })];
              } else {
                if (m$55$0 === "var") {
                  temp$28 = ["declare", __amp__(v$12, { mutable: true })];
                } else {
                  bridge$$8887$0 = m$55$0;if (bridge$$8887$0 === "unqualified" || bridge$$8887$0 === void 0) {
                    temp$28 = ["declare", __amp__(v$12, { mutable: false })];
                  } else {
                    temp$28 = ___match_error(m$55$0, ".unqualified or undefined? ");
                  }
                }
              }
            }acc$24.push(temp$28);
          }decls$2 = acc$24;return ["tagscope", "back", ["multi"].concat(decls$2).concat([assemble_pattern$0(blocks$3, body$5, ["use", "back", helper$0(rest$12)])])];
        } else {
          return ___match_error(ph$13$0, "{#clause{vars, varsd, blocks, body}, *rest}");
        }
      }
    }
  };return ["multi"].concat((acc$25 = [], temp$29 = null, m$56 = null, (function () {
    $39: for (var _iterator2 = new_temps$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
      m$56 = _step2.value;
      var t$14 = undefined;t$14 = m$56;temp$29 = ["declare", t$14];acc$25.push(temp$29);
    }
  })(), acc$25)).concat([helper$0(reassemble$0)]);
};$targ$43 = PatternCompiler$0;exports.PatternCompiler = $targ$43;$targ$44 = parse_clauses$0;exports.parse_clauses = $targ$44;void 0;
//# sourceMappingURL=pattern.js.map


},{"./location":106,"./util":126,"earlgrey-runtime/5":446}],122:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var $targ$1 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var pr_terminus$0 = undefined;var pr$0 = undefined;var __lt____gt__$0 = undefined;var repr$0 = undefined;var escape_html$0 = undefined;var quotify$0 = undefined;var HTML$0 = undefined;pr_terminus$0 = function pr_terminus(node$0) {
  var r$0 = undefined;var pre$0 = undefined;var post$0 = undefined;r$0 = HTML$0(node$0, "span");pre$0 = String.fromCharCode(27) + "[?0;7y+h <div class=\"ug\">";post$0 = "</div>" + String.fromCharCode(7);return console.log(pre$0 + r$0 + post$0);
};pr$0 = function pr(ph$0$0, r$1) {
  var x$0 = undefined;var n$0 = undefined;var t0$0 = undefined;t0$0 = ph$0$0;if (getChecker(ENode)(t0$0)) {
    n$0 = t0$0;return pr_terminus$0(n$0);
  } else {
    x$0 = ph$0$0;return pr_terminus$0((r$1 || repr$0)(x$0));
  }
};__lt____gt__$0 = function (temp$0$0, x$1) {
  return pr$0(x$1);
};repr$0 = function repr() {
  var m$1 = undefined;var acc$0 = undefined;var temp$1 = undefined;var m$2 = undefined;var acc$1 = undefined;var temp$2 = undefined;var other$0 = undefined;var entries$0 = undefined;var $$25532$0 = undefined;var t0$2 = undefined;var x$2 = undefined;var ph$2$0 = undefined;var recur$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;var t2$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$1 = m$0$0.length;if (t0$1 >= 1 && t0$1 <= 2 && (t1$0 = m$0$0[0], x$2 = t1$0, ph$2$0 = t1$0, t2$0 = 1 >= t0$1 ? repr$0 : m$0$0[1], typeof t2$0 === "function")) {
    recur$0 = t2$0;if (ph$2$0 === true) {
      return ENode([".special", ".true"], {}, "true");
    } else {
      if (ph$2$0 === false) {
        return ENode([".special", ".false"], {}, "false");
      } else {
        if (ph$2$0 === null) {
          return ENode([".special", ".nil"], {}, "null");
        } else {
          if (ph$2$0 === void 0) {
            return ENode([".special", ".nil"], {}, "undefined");
          } else {
            if (typeof ph$2$0 === "number") {
              return ENode([".num"], {}, String(x$2));
            } else {
              if (typeof ph$2$0 === "string") {
                return ENode([".str"], {}, x$2);
              } else {
                t0$2 = ph$2$0;if (Array.isArray(t0$2)) {
                  entries$0 = t0$2;return ENode([".sequence"], {}, (acc$0 = [], temp$1 = null, m$1 = null, (function () {
                    $0: for (var _iterator = entries$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                      m$1 = _step.value;
                      var x$3 = undefined;x$3 = m$1;temp$1 = recur$0(x$3, repr$0);acc$0.push(temp$1);
                    }
                  })(), acc$0));
                } else {
                  if (x$2["::repr"]) {
                    return x$2["::repr"](recur$0);
                  } else {
                    if (Object.getPrototypeOf(x$2) === Object.prototype) {
                      return ENode(["table", ".object"], {}, (acc$1 = [], temp$2 = null, m$2 = null, (function () {
                        $1: for (var _iterator = items(x$2)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                          m$2 = _step.value;
                          var k$0 = undefined;var v$0 = undefined;var t0$3 = undefined;var t1$1 = undefined;t0$3 = m$2;if (Array.isArray(t0$3) && (t1$1 = t0$3.length, t1$1 === 2)) {
                            k$0 = t0$3[0];v$0 = t0$3[1];temp$2 = ENode(["tr"], {}, [ENode(["th"], {}, recur$0(k$0, repr$0)), ENode(["td"], {}, recur$0(v$0, repr$0))]);acc$1.push(temp$2);
                          } else {
                            ___match_error(m$2);
                          }
                        }
                      })(), acc$1));
                    } else {
                      other$0 = ph$2$0;return ENode([".unknown"], {}, other$0.toString());
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
    return ___match_error(m$0$0, "{x and match, Function? recur = repr}");
  }
};escape_html$0 = function escape_html(temp$3$0) {
  var t0$4 = undefined;var repl$0 = undefined;var s$0 = undefined;t0$4 = [true, String(temp$3$0)];if (t0$4[0]) {
    s$0 = t0$4[1];
  } else {
    ___match_error(temp$3$0);
  }repl$0 = { "&": "&amp;", "<": "&lt;", ">": "&gt;" };return s$0.replace(RegExp("[&<>]", "g"), function (x$4) {
    return send(repl$0, x$4);
  });
};quotify$0 = function quotify(temp$4$0) {
  var t0$5 = undefined;var s$1 = undefined;t0$5 = [true, String(temp$4$0)];if (t0$5[0]) {
    s$1 = t0$5[1];
  } else {
    ___match_error(temp$4$0);
  }return s$1.replace(RegExp("[\\\"\\\\]", "g"), function (x$5) {
    return "\\" + x$5;
  });
};HTML$0 = function HTML(ph$3$0, default_tag$0) {
  var m$3 = undefined;var acc$2 = undefined;var temp$5 = undefined;var chs$0 = undefined;var m$5 = undefined;var m$6 = undefined;var m$7 = undefined;var acc$3 = undefined;var temp$6 = undefined;var m$9 = undefined;var acc$4 = undefined;var temp$7 = undefined;var m$10 = undefined;var acc$5 = undefined;var temp$8 = undefined;var other$2 = undefined;var m$8$0 = undefined;var x$6 = undefined;var other$3 = undefined;var m$4$0 = undefined;var tag$0 = undefined;var classes$0 = undefined;var id$0 = undefined;var kv$0 = undefined;var sub$0 = undefined;var accum$0 = undefined;var children2$0 = undefined;var other$4 = undefined;var tags$0 = undefined;var props$0 = undefined;var children$1 = undefined;var children$0 = undefined;var s$2 = undefined;var $$25715$0 = undefined;var t0$6 = undefined;t0$6 = ph$3$0;if (typeof t0$6 === "string") {
    s$2 = t0$6;return escape_html$0(s$2);
  } else {
    if (Array.isArray(t0$6)) {
      children$0 = t0$6;acc$2 = [];temp$5 = null;m$3 = null;$2: for (var _iterator = children$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$3 = _step.value;
        var child$0 = undefined;child$0 = m$3;temp$5 = HTML$0(child$0, default_tag$0);acc$2.push(temp$5);
      }chs$0 = acc$2;return chs$0.join("");
    } else {
      if (getChecker(ENode)(t0$6) && (___hasprop(t0$6, "tags") && (tags$0 = t0$6.tags, ___hasprop(t0$6, "props") && (props$0 = t0$6.props, ___hasprop(t0$6, "children"))))) {
        children$1 = t0$6.children;tag$0 = default_tag$0 || "span";classes$0 = [];id$0 = null;kv$0 = [];sub$0 = [];m$5 = null;$3: for (var _iterator2 = tags$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
          m$5 = _step2.value;
          var other$1 = undefined;var cls$0 = undefined;var t0$7 = undefined;var t1$2 = undefined;var t2$1 = undefined;t0$7 = getProjector(RegExp("^\\.(.*)", ""))(m$5);if (t0$7[0] && (t1$2 = t0$7[1], t2$1 = t1$2.length, t2$1 === 2)) {
            t1$2[0];cls$0 = t1$2[1];classes$0.push(cls$0);
          } else {
            other$1 = m$5;tag$0 = other$1;tag$0;
          }
        }m$6 = null;$4: for (var _iterator3 = items(props$0)[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
          m$6 = _step3.value;
          var k$1 = undefined;var v$1 = undefined;var t0$8 = undefined;var t1$3 = undefined;t0$8 = m$6;if (Array.isArray(t0$8) && (t1$3 = t0$8.length, t1$3 === 2)) {
            k$1 = t0$8[0];v$1 = t0$8[1];kv$0.push([k$1, v$1]);
          } else {
            ___match_error(m$6);
          }
        }if (tag$0 === "raw") {
          accum$0 = [];
        } else {
          accum$0 = ["<", tag$0];
        }if (id$0) {
          accum$0 = accum$0.concat(" id=\"", id$0, "\"");accum$0;
        }if (classes$0.length) {
          accum$0 = accum$0.concat(" class=\"", quotify$0(classes$0.join(" ")), "\"");accum$0;
        }if (kv$0) {
          acc$3 = [];temp$6 = null;m$7 = null;$5: for (var _iterator4 = kv$0[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
            m$7 = _step4.value;
            var k$2 = undefined;var v$2 = undefined;var t0$9 = undefined;var t1$4 = undefined;t0$9 = m$7;if (Array.isArray(t0$9) && (t1$4 = t0$9.length, t1$4 === 2)) {
              k$2 = t0$9[0];v$2 = t0$9[1];accum$0 = accum$0.concat(v$2 !== null ? [" ", k$2, "=\"", quotify$0(v$2), "\""] : [" ", k$2]);temp$6 = accum$0;acc$3.push(temp$6);
            } else {
              ___match_error(m$7);
            }
          }acc$3;
        }m$8$0 = tag$0;if (m$8$0 === "raw") {
          acc$4 = [];temp$7 = null;m$9 = null;$6: for (var _iterator5 = children$1[Symbol.iterator](), _step5; !(_step5 = _iterator5.next()).done;) {
            m$9 = _step5.value;
            var c$0 = undefined;var s$3 = undefined;var t0$10 = undefined;t0$10 = m$9;if (typeof t0$10 === "string") {
              s$3 = t0$10;temp$7 = s$3;acc$4.push(temp$7);
            } else {
              c$0 = m$9;temp$7 = HTML$0(c$0, default_tag$0);acc$4.push(temp$7);
            }
          }children2$0 = acc$4;
        } else {
          other$2 = m$8$0;acc$5 = [];temp$8 = null;m$10 = null;$7: for (var _iterator6 = children$1[Symbol.iterator](), _step6; !(_step6 = _iterator6.next()).done;) {
            m$10 = _step6.value;
            var c$1 = undefined;c$1 = m$10;temp$8 = HTML$0(c$1, default_tag$0);acc$5.push(temp$8);
          }children2$0 = acc$5;
        }m$4$0 = tag$0;if (m$4$0 === "raw") {
          return accum$0.concat(children2$0).join("");
        } else {
          other$3 = m$4$0;x$6 = [">"].concat(children2$0).concat(["</", tag$0, ">"]);return accum$0.concat(x$6).join("");
        }
      } else {
        other$4 = ph$3$0;return HTML$0([true, String(other$4)][1], default_tag$0);
      }
    }
  }
};$targ$0 = pr_terminus$0;exports.pr_terminus = $targ$0;$targ$1 = pr$0;exports.pr = $targ$1;$targ$2 = __lt____gt__$0;exports["<>"] = $targ$2;$targ$3 = repr$0;exports.repr = $targ$3;void 0;
//# sourceMappingURL=pp.js.map


},{"earlgrey-runtime/5":446}],123:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var $targ$1 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var fs$0 = undefined;var path$0 = undefined;var sm$0 = undefined;var $1$0 = undefined;var version$0 = undefined;var getCache$0 = undefined;var load$0 = undefined;var extensions$0 = undefined;var install$0 = undefined;fs$0 = require("fs");path$0 = require("path");sm$0 = require("source-map-support");$1$0 = require("./version");version$0 = getProperty($1$0, "version", "./version");if (typeof module === "undefined") {
  $targ$0 = undefined;global.module = $targ$0;void 0;
}if (typeof JSON === "undefined") {
  $targ$1 = undefined;global.JSON = $targ$1;void 0;
}sm$0.install();getCache$0 = function getCache() {
  var rval$0 = undefined;var rval$1 = undefined;var bridge$$141$0 = undefined;var eg$0 = undefined;var $3$0 = undefined;var Source$0 = undefined;var text$0 = undefined;var g$1 = undefined;var $targ$3 = undefined;var code$0 = undefined;var map$0 = undefined;var t0$1 = undefined;var t1$0 = undefined;var cachedir$0 = undefined;var cache$0 = undefined;var cacheoptsFile$0 = undefined;var sstat$0 = undefined;var cstat$0 = undefined;var cacheopts$0 = undefined;var newcacheopts$0 = undefined;var $targ$2 = undefined;var g$0 = undefined;var compiled$0 = undefined;var srcfile$0 = undefined;var file$0 = undefined;var opts$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 1 && t0$0 <= 2) {
    file$0 = m$0$0[0];if (1 >= t0$0) {
      opts$0 = {};
    } else {
      opts$0 = m$0$0[1];
    }cachedir$0 = path$0.join(path$0.dirname(file$0), "egcache");cache$0 = path$0.join(cachedir$0, path$0.basename(file$0).replace(RegExp(".eg$|$", ""), ".js"));cacheoptsFile$0 = cache$0.replace(RegExp(".js$|$", ""), ".json");sstat$0 = fs$0.statSync(file$0);rval$0 = false;try {
      rval$0 = fs$0.statSync(cache$0);rval$0;
    } catch (excv$0) {
      var e$0 = undefined;e$0 = excv$0;rval$0 = null;rval$0;
    }cstat$0 = rval$0;rval$1 = false;try {
      rval$1 = JSON.parse(fs$0.readFileSync(cacheoptsFile$0, "utf8"));rval$1;
    } catch (excv$1) {
      var e$1 = undefined;e$1 = excv$1;rval$1 = null;rval$1;
    }cacheopts$0 = rval$1;newcacheopts$0 = { versions: { ecmascript: opts$0.es5 ? 5 : 6, earlgrey: version$0 }, runtime: opts$0.runtime, parameters: opts$0.parameters || {} };if (!opts$0.recompile && equal(cacheopts$0, newcacheopts$0) && cstat$0 && sstat$0.mtime.getTime() < cstat$0.mtime.getTime()) {
      if (opts$0.verbose) {
        console.error("Using cached file: " + cache$0);
      }$targ$2 = [null, fs$0.readFileSync(cache$0, "utf8"), cache$0];
    } else {
      eg$0 = require("./earl-grey");$3$0 = require("./location");Source$0 = getProperty($3$0, "Source", "./location");if (opts$0.verbose) {
        console.error("Compiling: " + file$0);
      }text$0 = fs$0.readFileSync(file$0, "utf8");g$1 = eg$0.Generator(__amp__({ sourceMap: true }, opts$0));$targ$3 = g$1.generate(Source$0(text$0, file$0));bridge$$141$0 = $targ$3;if (___hasprop(bridge$$141$0, "code") && (code$0 = bridge$$141$0.code, ___hasprop(bridge$$141$0, "map") && (map$0 = bridge$$141$0.map, true)) || (code$0 = bridge$$141$0, map$0 = null, true)) {} else {
        ___match_error($targ$3, "{=> code, => map} or code and map is null");
      }[code$0, map$0];try {
        try {
          fs$0.mkdirSync(cachedir$0);
        } catch (excv$2) {
          var e$2 = undefined;e$2 = excv$2;"ignore error";
        }fs$0.writeFileSync(cache$0, code$0);fs$0.writeFileSync(cache$0 + ".map", map$0);fs$0.writeFileSync(cacheoptsFile$0, JSON.stringify(newcacheopts$0));
      } catch (excv$3) {
        var e$3 = undefined;e$3 = excv$3;console.error("Failed to cache compiled version of: " + file$0);
      }$targ$2 = [g$1, code$0, cache$0];
    }t0$1 = $targ$2;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 3)) {
      g$0 = t0$1[0];compiled$0 = t0$1[1];srcfile$0 = t0$1[2];
    } else {
      ___match_error($targ$2, "{g, compiled, srcfile}");
    }[g$0, compiled$0, srcfile$0];return [g$0, compiled$0, srcfile$0];
  } else {
    return ___match_error(m$0$0, "{file, opts = {=}}");
  }
};load$0 = function load(opts$1) {
  return function (module$0, file$1) {
    var t0$2 = undefined;var t1$1 = undefined;var $targ$4 = undefined;var compiled$1 = undefined;var srcfile$1 = undefined;$targ$4 = getCache$0(file$1, opts$1);t0$2 = $targ$4;if (Array.isArray(t0$2) && (t1$1 = t0$2.length, t1$1 === 3)) {
      t0$2[0];compiled$1 = t0$2[1];srcfile$1 = t0$2[2];
    } else {
      ___match_error($targ$4, "{_, compiled, srcfile}");
    }[compiled$1, srcfile$1];return module$0._compile(compiled$1, srcfile$1);
  };
};extensions$0 = [".eg"];install$0 = function install() {
  var xreg$0 = undefined;var m$2 = undefined;var acc$0 = undefined;var temp$0 = undefined;var req$0 = undefined;var opts$2 = undefined;var t0$3 = undefined;var m$1$0 = undefined;m$1$0 = arguments;t0$3 = m$1$0.length;if (t0$3 >= 0 && t0$3 <= 1) {
    if (0 >= t0$3) {
      opts$2 = { recompile: false, runtime: null };
    } else {
      opts$2 = m$1$0[0];
    }req$0 = require;if ((xreg$0 = req$0.extensions, xreg$0)) {
      acc$0 = [];temp$0 = null;m$2 = null;$4: for (var _iterator = extensions$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$2 = _step.value;
        var $targ$5 = undefined;var ext$0 = undefined;ext$0 = m$2;if (!send(xreg$0, ext$0)) {
          $targ$5 = load$0(opts$2);xreg$0[ext$0] = $targ$5;temp$0 = void 0;
        }acc$0.push(temp$0);
      }return acc$0;
    }
  } else {
    return ___match_error(m$1$0, "{opts = {recompile = false, runtime = null}}");
  }
};$targ$6 = getCache$0;exports.getCache = $targ$6;$targ$7 = install$0;exports.install = $targ$7;void 0;
//# sourceMappingURL=register.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./earl-grey":102,"./location":106,"./version":127,"earlgrey-runtime/5":446,"fs":697,"path":706,"source-map-support":570}],124:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $24$0 = undefined;var $26$0 = undefined;var $28$0 = undefined;var $30$0 = undefined;var $32$0 = undefined;var $34$0 = undefined;var $36$0 = undefined;var $38$0 = undefined;var $40$0 = undefined;var $42$0 = undefined;var $44$0 = undefined;var $targ$0 = undefined;var $targ$1 = undefined;var mt$0 = undefined;var Env$0 = undefined;var Expander$0 = undefined;var topscope$0 = undefined;var stdenv$0 = undefined;var mac$0 = undefined;var bind$0 = undefined;var make_expander$0 = undefined;mt$0 = require("./expand");Env$0 = getProperty(mt$0, "Env", "mt");Expander$0 = getProperty(mt$0, "Expander", "mt");topscope$0 = getProperty(mt$0, "topscope", "mt");stdenv$0 = Env$0();mac$0 = function mac(name$0) {
  return function (m$0) {
    var m2$0 = undefined;m2$0 = function m2(ctx$0, info$0, form$0, temp$0$0) {
      var t0$0 = undefined;var t0$1 = undefined;var expr$0 = undefined;var ph$0$0 = undefined;t0$0 = temp$0$0;expr$0 = t0$0;ph$0$0 = t0$0;t0$1 = ph$0$0;if (___hasprop(t0$1, "brackets") && t0$1.brackets === "()") {
        throw ErrorFactory(["syntax", "no_parens"]).create("Parentheses cannot be used here.\n             Use [] or {} depending on your intent.\n             []s are usually equivalent to an absence\n             of brackets.\n             ".replace(RegExp("\\n *", "g"), " "), { expr: expr$0 });
      } else {
        return m$0.call(this, ctx$0, info$0, form$0, expr$0);
      }
    };stdenv$0.bind(topscope$0, name$0, ["macro", m2$0]);return m2$0;
  };
};bind$0 = function bind(name$1, value$0) {
  return stdenv$0.bind(topscope$0, name$1, value$0);
};($24$0 = require("./macros/consts"), $24$0)(mac$0, bind$0);($26$0 = require("./macros/core"), $26$0)(mac$0, bind$0);($28$0 = require("./macros/operators"), $28$0)(mac$0, bind$0);($30$0 = require("./macros/loop"), $30$0)(mac$0, bind$0);($32$0 = require("./macros/quote"), $32$0)(mac$0, bind$0);($34$0 = require("./macros/regexp"), $34$0)(mac$0, bind$0);($36$0 = require("./macros/modularity"), $36$0)(mac$0, bind$0);($38$0 = require("./macros/misc"), $38$0)(mac$0, bind$0);($40$0 = require("./macros/macrodef"), $40$0)(mac$0, bind$0);($42$0 = require("./macros/async"), $42$0)(mac$0, bind$0);($44$0 = require("./macros/logic"), $44$0)(mac$0, bind$0);make_expander$0 = function make_expander(pipeline$0) {
  var generic_nodes$0 = undefined;generic_nodes$0 = ["if", "js_while", "js_for", "js_for_in", "js_for_of", "js_label", "js_break", "js_continue", "js_return", "js_delete", "js_throw", "js_try", "js_new", "js_yield"];return Expander$0(stdenv$0.fork(), generic_nodes$0, pipeline$0);
};$targ$0 = stdenv$0;exports.stdenv = $targ$0;$targ$1 = make_expander$0;exports.make_expander = $targ$1;void 0;
//# sourceMappingURL=stdenv.js.map


},{"./expand":104,"./macros/async":107,"./macros/consts":108,"./macros/core":109,"./macros/logic":111,"./macros/loop":112,"./macros/macrodef":113,"./macros/misc":114,"./macros/modularity":115,"./macros/operators":116,"./macros/quote":117,"./macros/regexp":118,"earlgrey-runtime/5":446}],125:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$7 = undefined;var accum$0 = undefined;var $targ$8 = undefined;var accum$1 = undefined;var $targ$9 = undefined;var $0$0 = undefined;var gensym$0 = undefined;var Body$0 = undefined;var $1$0 = undefined;var __lt____gt__$0 = undefined;var $2$0 = undefined;var jsKeywords$0 = undefined;var join$0 = undefined;var js_op_table2$0 = undefined;var js_op_table$0 = undefined;var Translator$0 = undefined;$0$0 = require("./util");gensym$0 = getProperty($0$0, "gensym", "./util");Body$0 = getProperty($0$0, "Body", "./util");$1$0 = require("./pp");__lt____gt__$0 = getProperty($1$0, "<>", "./pp");$2$0 = require("./expand");jsKeywords$0 = getProperty($2$0, "jsKeywords", "./expand");join$0 = function join(things$0, sep$0) {
  var m$0 = undefined;var acc$0 = undefined;var temp$0 = undefined;acc$0 = [];temp$0 = null;m$0 = null;$3: for (var _iterator = enumerate(things$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$0 = _step.value;
    var ph$0$0 = undefined;var x$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$0;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
      ph$0$0 = t0$0[0];x$0 = t0$0[1];if (ph$0$0 === 0) {
        temp$0 = x$0;
      } else {
        temp$0 = [",", x$0];
      }acc$0.push(temp$0);
    } else {
      ___match_error(m$0);
    }
  }return acc$0;
};js_op_table2$0 = { "+": "+", "-": "-", "*": "*", "/": "/", mod: "%", "&+": "&", "|+": "|", "^+": "^", "~": "~", and: "&&", or: "||", not: "!", "==": "===", "!=": "!==", "===": "===", "!==": "!==", "<": "<", ">": ">", "<=": "<=", ">=": ">=", "<<": "<<", ">>": ">>", ">>>": ">>>", "instanceof": " instanceof ", "++": "++", "--": "--" };js_op_table$0 = { ___plus: "+", ___minus: "-", ___times: "*", ___div: "/", ___mod: "%", ___binxor: "^", ___binand: "&", ___binor: "|", ___binnot: "~", ___and: "&&", ___or: "||", ___not: "!", ___is: "===", ___isnt: "!==", ___eq: "===", ___neq: "!==", ___lt: "<", ___gt: ">", ___lte: "<=", ___gte: ">=", ___shl: "<<", ___shr: ">>", ___shr2: ">>>", ___in: " in ", ___instanceof: " instanceof ", ___plusplus: "++", ___minusminus: "--" };Translator$0 = function Translator() {
  var m$2$0 = undefined;var $targ$0 = undefined;var $targ$1 = undefined;var prelude$0 = undefined;var t0$1 = undefined;var m$1$0 = undefined;var $it$0 = undefined;if (!getChecker(Translator$0)(this)) {
    $it$0 = Object.create(Translator$0.prototype);
  } else {
    $it$0 = this;
  }m$1$0 = arguments;t0$1 = m$1$0.length;if (t0$1 >= 0 && t0$1 <= 2) {
    if (0 >= t0$1) {
      prelude$0 = null;
    } else {
      prelude$0 = m$1$0[0];
    }$it$0.globvar = 1 >= t0$1 ? null : m$1$0[1];$targ$0 = {};$it$0.cache = $targ$0;$targ$1 = [];$it$0.prepend = $targ$1;m$2$0 = prelude$0;if (m$2$0 === null) {
      undefined;
    } else {
      if (typeof m$2$0 === "string") {
        $it$0.prepend.push(prelude$0);
      } else {
        $it$0.prepend.push($it$0.translate(___serialize_ast(prelude$0), "stmt"));
      }
    }
  } else {
    ___match_error(m$1$0, "{prelude = null, @globvar = null}");
  }return $it$0;
};Translator$0.prototype.register_value = function register_value(v$0, id$0) {
  var x$1 = undefined;var temp$1 = undefined;var $targ$2 = undefined;var name$0 = undefined;var m$3$0 = undefined;var $it$1 = undefined;var self$0 = undefined;$it$1 = this;self$0 = this;m$3$0 = send(send($it$1, "cache", true), id$0);if (m$3$0 === void 0) {
    temp$1 = ["symbol", gensym$0()];$targ$2 = temp$1;$it$1.cache[id$0] = $targ$2;x$1 = ["declare", temp$1, ___serialize_ast(v$0)];$it$1.prepend.push($it$1.translate(x$1, "stmt"));return temp$1;
  } else {
    name$0 = m$3$0;return name$0;
  }
};Translator$0.prototype.register_raw = function register_raw(raw$0, id$1) {
  var x$2 = undefined;var temp$2 = undefined;var $targ$3 = undefined;var name$1 = undefined;var m$4$0 = undefined;var $it$2 = undefined;var self$1 = undefined;$it$2 = this;self$1 = this;m$4$0 = send(send($it$2, "cache", true), id$1);if (m$4$0 === void 0) {
    temp$2 = ["symbol", gensym$0()];$targ$3 = temp$2;$it$2.cache[id$1] = $targ$3;x$2 = ["declare", temp$2, ["raw", raw$0]];$it$2.prepend.push($it$2.translate(x$2, "stmt"));return temp$2;
  } else {
    name$1 = m$4$0;return name$1;
  }
};Translator$0.prototype.dump_store = function dump_store() {
  var rval$0 = undefined;var $targ$4 = undefined;var $it$3 = undefined;var self$2 = undefined;$it$3 = this;self$2 = this;rval$0 = $it$3.prepend.join("\n");$targ$4 = [];$it$3.prepend = $targ$4;return rval$0;
};Translator$0.prototype.mangle = function mangle(name$2) {
  var i$0 = undefined;var tr$0 = undefined;var r$0 = undefined;var $it$4 = undefined;var self$3 = undefined;$it$4 = this;self$3 = this;tr$0 = { "+": "__plus__", "-": "__minus__", "*": "__asterisk__", "/": "__slash__", "%": "__percent__", "^": "__caret__", "#": "__hash__", "&": "__amp__", "|": "__pipe__", "@": "__at__", "!": "__bang__", "?": "__qmark__", "=": "__equal__", "<": "__lt__", ">": "__gt__", "~": "__tilde__", ".": "__dot__", ":": "__colon__", "'": "__quote__" };r$0 = [];i$0 = 0;$4: for (null; i$0 < name$2.length; ++i$0) {
    var c$0 = undefined;c$0 = send(name$2, i$0);r$0.push(send(tr$0, c$0) || c$0);
  }return r$0.join("");
};Translator$0.prototype.body = function body(orig$0, mode$0) {
  var t0$2 = undefined;var t1$1 = undefined;var t2$0 = undefined;var x$3 = undefined;var stmts$0 = undefined;var ret$0 = undefined;var m$6 = undefined;var acc$1 = undefined;var temp$3 = undefined;var stmts$1 = undefined;var ret$1 = undefined;var other$0 = undefined;var variable$0 = undefined;var t0$3 = undefined;var m$5$0 = undefined;var $targ$5 = undefined;var b$0 = undefined;var trst$0 = undefined;var $it$5 = undefined;var self$4 = undefined;$it$5 = this;self$4 = this;$targ$5 = orig$0;t0$2 = getProjector(Body$0)($targ$5);if (t0$2[0] && (t1$1 = t0$2[1], t2$0 = t1$1.length, t2$0 >= 0)) {
    b$0 = Array.prototype.slice.call(t1$1, 0);
  } else {
    ___match_error($targ$5, "Body! {*b}");
  }trst$0 = function trst(stmt$0) {
    return $it$5.translate(stmt$0, "stmt");
  };m$5$0 = mode$0;if (m$5$0 === "expr") {
    x$3 = ["send", ["lambda", [], orig$0], ["array"]];return $it$5.translate(x$3, mode$0);
  } else {
    if (m$5$0 === "return") {
      stmts$0 = b$0.slice(0, -1);ret$0 = send(b$0, b$0.length - 1);return ENode(["splice"], {}, [stmts$0.map(trst$0), $it$5.translate(ret$0, "return")]);
    } else {
      if (m$5$0 === "stmt") {
        return ENode(["splice"], {}, (acc$1 = [], temp$3 = null, m$6 = null, (function () {
          $5: for (var _iterator = b$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
            m$6 = _step.value;
            var x$4 = undefined;x$4 = m$6;temp$3 = trst$0(x$4);acc$1.push(temp$3);
          }
        })(), acc$1));
      } else {
        if (Array.isArray(m$5$0) && (t0$3 = m$5$0.length, t0$3 === 2 && m$5$0[0] === "return")) {
          variable$0 = m$5$0[1];stmts$1 = b$0.slice(0, -1);ret$1 = send(b$0, b$0.length - 1);return ENode(["splice"], {}, [stmts$1.map(trst$0), $it$5.translate(ret$1, mode$0)]);
        } else {
          other$0 = m$5$0;throw ErrorFactory(["syntax", "mode"]).create("Unknown translate mode", { mode: mode$0 });
        }
      }
    }
  }
};Translator$0.prototype.expr = function expr(x$5, temp$4$0) {
  var t0$4 = undefined;var other$1 = undefined;var variable$1 = undefined;var t0$5 = undefined;var t1$2 = undefined;var mode$1 = undefined;var ph$1$0 = undefined;var $it$6 = undefined;var self$5 = undefined;$it$6 = this;self$5 = this;t0$4 = temp$4$0;mode$1 = t0$4;ph$1$0 = t0$4;if (ph$1$0 === "expr") {
    return x$5;
  } else {
    if (ph$1$0 === "stmt") {
      return ENode(["splice"], {}, [x$5, ";"]);
    } else {
      if (ph$1$0 === "return") {
        return ENode(["splice"], {}, ["return ", x$5, ";"]);
      } else {
        t0$5 = ph$1$0;t1$2 = t0$5.length;if (t1$2 === 2 && t0$5[0] === "return") {
          variable$1 = t0$5[1];return ENode(["splice"], {}, [variable$1, "=", x$5, ";"]);
        } else {
          other$1 = ph$1$0;throw ErrorFactory(["syntax", "mode"]).create("Unknown translate mode", { mode: mode$1 });
        }
      }
    }
  }
};Translator$0.prototype.op = function op(op$0, a$0, b$1) {
  var $$11293$0 = undefined;var $$11294$0 = undefined;var $$11295$0 = undefined;var t0$6 = undefined;var t1$3 = undefined;var t2$1 = undefined;var m$7$0 = undefined;var e$0 = undefined;var $it$7 = undefined;var self$6 = undefined;$it$7 = this;self$6 = this;m$7$0 = [a$0, b$1];if (($$11293$0 = Array.isArray(m$7$0)) && (t0$6 = m$7$0.length, ($$11295$0 = t0$6 === 2) && (t1$3 = m$7$0[0], Array.isArray(t1$3) && (t2$1 = t1$3.length, t2$1 === 1 && t1$3[0] === "void")))) {
    m$7$0[1];e$0 = ENode(["splice"], {}, [op$0, $it$7.translate(b$1, "expr")]);
  } else {
    if ($$11295$0 && (m$7$0[0], t1$3 = m$7$0[1], Array.isArray(t1$3) && (t2$1 = t1$3.length, t2$1 === 1 && t1$3[0] === "void"))) {
      e$0 = ENode(["splice"], {}, [$it$7.translate(a$0, "expr"), op$0]);
    } else {
      e$0 = ENode(["splice"], {}, [$it$7.translate(a$0, "expr"), op$0, $it$7.translate(b$1, "expr")]);
    }
  }return ENode(["splice"], {}, ["(", e$0, ")"]);
};Translator$0.prototype.translate = function translate() {
  var repl$0 = undefined;var $it$12 = undefined;var $it$11 = undefined;var $it$10 = undefined;var $it$9 = undefined;var bridge$$11474$0 = undefined;var bridge$$11473$0 = undefined;var other$2 = undefined;var id$2 = undefined;var bridge$$11472$0 = undefined;var m$11$0 = undefined;var r$1 = undefined;var t0$9 = undefined;var t0$10 = undefined;var x$6 = undefined;var x$9 = undefined;var x$8 = undefined;var m$14$0 = undefined;var x$7 = undefined;var x$10 = undefined;var otherwise$0 = undefined;var m$13$0 = undefined;var x$12 = undefined;var x$11 = undefined;var $$11687$0 = undefined;var $$11688$0 = undefined;var $$11689$0 = undefined;var t0$11 = undefined;var m$15$0 = undefined;var m$16 = undefined;var acc$2 = undefined;var temp$5 = undefined;var x$13 = undefined;var op$1 = undefined;var x$15 = undefined;var codevar$0 = undefined;var m$17 = undefined;var acc$3 = undefined;var temp$6 = undefined;var r$2 = undefined;var f$5 = undefined;var m$18 = undefined;var acc$4 = undefined;var temp$9 = undefined;var v$3 = undefined;var all_strings$0 = undefined;var r$3 = undefined;var m$19$0 = undefined;var m$20 = undefined;var acc$5 = undefined;var temp$10 = undefined;var r$4 = undefined;var name$3 = undefined;var x$20 = undefined;var other$4 = undefined;var x$21 = undefined;var other$5 = undefined;var bridge$$11396$0 = undefined;var x$22 = undefined;var other$6 = undefined;var bridge$$11395$0 = undefined;var bridge$$11401$0 = undefined;var x$23 = undefined;var other$7 = undefined;var bridge$$11400$0 = undefined;var x$24 = undefined;var x$25 = undefined;var core$0 = undefined;var m$21$0 = undefined;var flatten$0 = undefined;var m$24 = undefined;var acc$6 = undefined;var temp$11 = undefined;var m$25 = undefined;var acc$7 = undefined;var temp$12 = undefined;var m$26 = undefined;var acc$8 = undefined;var temp$13 = undefined;var xs$0 = undefined;var m$22$0 = undefined;var all_args$0 = undefined;var args$3 = undefined;var isdecl$0 = undefined;var x$32 = undefined;var m$27 = undefined;var acc$9 = undefined;var temp$14 = undefined;var decls$0 = undefined;var x$33 = undefined;var x$34 = undefined;var x$35 = undefined;var y$3 = undefined;var t0$20 = undefined;var t1$10 = undefined;var m$28$0 = undefined;var other$10 = undefined;var other$11 = undefined;var other$12 = undefined;var other$13 = undefined;var other$14 = undefined;var t0$21 = undefined;var t0$22 = undefined;var other$15 = undefined;var m$30$0 = undefined;var other$16 = undefined;var t0$23 = undefined;var m$29$0 = undefined;var r$5 = undefined;var other$17 = undefined;var x$39 = undefined;var attempt$0 = undefined;var v$5 = undefined;var body$7 = undefined;var finally$1 = undefined;var x$38 = undefined;var y$6 = undefined;var body$6 = undefined;var ph$11$0 = undefined;var x$37 = undefined;var y$5 = undefined;var body$5 = undefined;var ph$10$0 = undefined;var x$36 = undefined;var y$4 = undefined;var z$0 = undefined;var body$4 = undefined;var ph$9$0 = undefined;var test$2 = undefined;var body$3 = undefined;var ph$8$0 = undefined;var label$2 = undefined;var body$2 = undefined;var ph$7$0 = undefined;var value$5 = undefined;var ph$6$0 = undefined;var value$4 = undefined;var all$0 = undefined;var value$3 = undefined;var label$1 = undefined;var label$0 = undefined;var value$2 = undefined;var vars$0 = undefined;var body$1 = undefined;var s$2 = undefined;var args$5 = undefined;var _args$0 = undefined;var lhs$0 = undefined;var rhs$1 = undefined;var obj$0 = undefined;var msg$3 = undefined;var rhs$0 = undefined;var binding$1 = undefined;var value$0 = undefined;var ph$5$0 = undefined;var binding$0 = undefined;var ph$4$0 = undefined;var test$1 = undefined;var pos$1 = undefined;var neg$0 = undefined;var ph$3$0 = undefined;var test$0 = undefined;var pos$0 = undefined;var ph$2$0 = undefined;var bindings$0 = undefined;var body$0 = undefined;var generator$0 = undefined;var args$2 = undefined;var args$1 = undefined;var f$4 = undefined;var msg$2 = undefined;var f$3 = undefined;var args$0 = undefined;var f$2 = undefined;var msg$1 = undefined;var s$1 = undefined;var f$1 = undefined;var msg$0 = undefined;var f$0 = undefined;var v$1 = undefined;var s$0 = undefined;var $$11438$0 = undefined;var $$11439$0 = undefined;var $$11440$0 = undefined;var $$11441$0 = undefined;var $$11442$0 = undefined;var t0$8 = undefined;var t1$4 = undefined;var t2$2 = undefined;var t3$0 = undefined;var t4$0 = undefined;var bridge$$11380$0 = undefined;var bridge$$11435$0 = undefined;var m$10$0 = undefined;var $targ$6 = undefined;var n$0 = undefined;var m$9$0 = undefined;var rval$1 = undefined;var expr$0 = undefined;var mode$2 = undefined;var called$0 = undefined;var t0$7 = undefined;var m$8$0 = undefined;var $it$8 = undefined;var self$7 = undefined;$it$8 = this;self$7 = this;m$8$0 = arguments;t0$7 = m$8$0.length;if (t0$7 >= 2 && t0$7 <= 3) {
    expr$0 = m$8$0[0];mode$2 = m$8$0[1];if (2 >= t0$7) {
      if (expr$0.called) {
        called$0 = "send";
      } else {
        called$0 = false;
      }
    } else {
      called$0 = m$8$0[2];
    }m$10$0 = expr$0;if (($$11438$0 = Array.isArray(m$10$0)) && (t0$8 = m$10$0.length, t0$8 === 2 && m$10$0[0] === "symbol")) {
      s$0 = m$10$0[1];rval$1 = $it$8.expr($it$8.mangle(s$0), mode$2);
    } else {
      if ($$11438$0 && (t0$8 === 1 && m$10$0[0] === "void")) {
        rval$1 = $it$8.expr("null", mode$2);
      } else {
        if ($$11438$0 && (t0$8 === 2 && m$10$0[0] === "value")) {
          v$1 = m$10$0[1];m$11$0 = v$1;if (typeof m$11$0 === "string") {
            repl$0 = { "\"": "\\\"", "\n": "\\n", "\r": "\\r", "\b": "\\b", "\\": "\\\\" };v$1 = v$1.replace(RegExp("((?:(?:(?:(?:\"|\\\\)|\n)|\r)|\b))", "g"), function (m$12) {
              return send(repl$0, m$12);
            });r$1 = "\"" + v$1 + "\"";
          } else {
            if (m$11$0 === void 0) {
              r$1 = "(void 0)";
            } else {
              if (getChecker(RegExp)(m$11$0)) {
                $it$9 = String(v$1);$it$10 = $it$9.slice(1, -1);$it$11 = $it$10.replace(RegExp("/", "g"), "\\/");$it$12 = $it$11.replace(RegExp("\\n", "g"), "\\n");r$1 = "/".concat($it$12).concat("/");
              } else {
                bridge$$11472$0 = m$11$0;if ((bridge$$11473$0 = bridge$$11472$0, (bridge$$11474$0 = bridge$$11473$0, typeof bridge$$11474$0 === "number" || bridge$$11474$0 === true) || bridge$$11473$0 === false) || bridge$$11472$0 === null) {
                  r$1 = String(v$1);
                } else {
                  if (___hasprop(m$11$0, "::id") && (id$2 = m$11$0["::id"], id$2)) {
                    r$1 = $it$8.translate($it$8.register_value(v$1, id$2), mode$2);
                  } else {
                    other$2 = m$11$0;throw ErrorFactory(["cannot_serialize"]).create("Cannot serialize value", { value: v$1 });
                  }
                }
              }
            }
          }rval$1 = $it$8.expr(r$1, mode$2);
        } else {
          if ($$11438$0 && (($$11440$0 = t0$8 === 3) && (($$11441$0 = m$10$0[0] === "send") && (t1$4 = m$10$0[1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && (t1$4[0] === "variable" && (t1$4[1] === "___node" && (t3$0 = m$10$0[2], Array.isArray(t3$0) && (t4$0 = t3$0.length, t4$0 === 2 && t3$0[0] === "value"))))))))) {
            f$0 = t3$0[1];rval$1 = f$0;
          } else {
            if ($$11441$0 && (bridge$$11380$0 = m$10$0[1], (Array.isArray(bridge$$11380$0) && (t0$9 = bridge$$11380$0.length, t0$9 === 2 && (bridge$$11380$0[0] === "symbol" && bridge$$11380$0[1] === "___js_fetch")) || Array.isArray(bridge$$11380$0) && (t0$10 = bridge$$11380$0.length, t0$10 === 2 && (bridge$$11380$0[0] === "variable" && bridge$$11380$0[1] === "___js_fetch"))) && (t1$4 = m$10$0[2], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 3 && t1$4[0] === "array")))) {
              f$1 = t1$4[1];msg$0 = t1$4[2];x$6 = ENode(["splice"], {}, [$it$8.translate(f$1, "expr"), "[", $it$8.translate(msg$0, "expr"), "]"]);rval$1 = $it$8.expr(x$6, mode$2);
            } else {
              if ($$11441$0 && (f$2 = m$10$0[1], t1$4 = m$10$0[2], msg$1 = t1$4, Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && (t1$4[0] === "value" && (s$1 = t1$4[1], nequal(called$0, "send")))))) {
                m$13$0 = null;if (typeof s$1 === "string" && s$1.match(RegExp("(?:^(?:[a-zA-Z_$]+)$)", ""))) {
                  x$7 = ENode(["splice"], {}, [(m$14$0 = $it$8.translate(f$2, "expr"), getChecker(RegExp("^\\d+$", ""))(m$14$0) ? (x$8 = m$14$0, "(" + x$8 + ")") : (x$9 = m$14$0, x$9)), ".", $it$8.translate(["symbol", s$1], "expr")]);rval$1 = $it$8.expr(x$7, mode$2);
                } else {
                  otherwise$0 = m$13$0;x$10 = ENode(["splice"], {}, [$it$8.translate(f$2, "expr"), "[", $it$8.translate(msg$1, "expr"), "]"]);rval$1 = $it$8.expr(x$10, mode$2);
                }
              } else {
                if ($$11441$0 && (f$3 = m$10$0[1], t1$4 = m$10$0[2], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 >= 1 && t1$4[0] === "array"))) {
                  args$0 = Array.prototype.slice.call(t1$4, 1);m$15$0 = f$3;if (($$11687$0 = Array.isArray(m$15$0)) && (t0$11 = m$15$0.length, ($$11689$0 = t0$11 === 2) && m$15$0[0] === "symbol")) {
                    x$11 = m$15$0[1];op$1 = send(js_op_table$0, x$11);
                  } else {
                    if ($$11689$0 && m$15$0[0] === "variable") {
                      x$12 = m$15$0[1];op$1 = send(js_op_table2$0, x$12);
                    } else {
                      op$1 = null;
                    }
                  }if (op$1) {
                    rval$1 = $it$8.expr($it$8.op(op$1, args$0[0], args$0[1]), mode$2);
                  } else {
                    x$13 = ENode(["splice"], {}, [$it$8.translate(f$3, "expr", true), "(", join$0((acc$2 = [], temp$5 = null, m$16 = null, (function () {
                      $6: for (var _iterator = args$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                        m$16 = _step.value;
                        var x$14 = undefined;x$14 = m$16;temp$5 = $it$8.translate(x$14, "expr");acc$2.push(temp$5);
                      }
                    })(), acc$2), ","), ")"]);rval$1 = $it$8.expr(x$13, mode$2);
                  }
                } else {
                  if ($$11441$0) {
                    f$4 = m$10$0[1];msg$2 = m$10$0[2];codevar$0 = "send";x$15 = ENode(["splice"], {}, [codevar$0, "(", $it$8.translate(f$4, "expr", "send"), ",", $it$8.translate(msg$2, "expr"), called$0 ? ", true" : "", ")"]);rval$1 = $it$8.expr(x$15, mode$2);
                  } else {
                    if ($$11438$0 && (($$11440$0 = t0$8 >= 1) && m$10$0[0] === "array")) {
                      args$1 = Array.prototype.slice.call(m$10$0, 1);r$2 = ENode(["splice"], {}, ["[", join$0((acc$3 = [], temp$6 = null, m$17 = null, (function () {
                        $7: for (var _iterator = args$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                          m$17 = _step.value;
                          var x$16 = undefined;x$16 = m$17;temp$6 = $it$8.translate(x$16, "expr");acc$3.push(temp$6);
                        }
                      })(), acc$3), ","), "]"]);rval$1 = $it$8.expr(r$2, mode$2);
                    } else {
                      if ($$11440$0 && m$10$0[0] === "object") {
                        args$2 = Array.prototype.slice.call(m$10$0, 1);all_strings$0 = args$2.every(function (temp$7$0) {
                          var t0$12 = undefined;var t1$5 = undefined;var other$3 = undefined;var v$2 = undefined;var t0$13 = undefined;var t1$6 = undefined;var ph$12$0 = undefined;var y$0 = undefined;t0$12 = temp$7$0;if (Array.isArray(t0$12) && (t1$5 = t0$12.length, t1$5 === 3 && t0$12[0] === "array")) {
                            ph$12$0 = t0$12[1];y$0 = t0$12[2];
                          } else {
                            ___match_error(temp$7$0);
                          }t0$13 = ph$12$0;t1$6 = t0$13.length;if (t1$6 === 2 && t0$13[0] === "value") {
                            v$2 = t0$13[1];return true;
                          } else {
                            other$3 = ph$12$0;return false;
                          }
                        });if (all_strings$0) {
                          r$3 = ENode(["splice"], {}, ["({", (f$5 = function f(temp$8$0) {
                            var t0$14 = undefined;var t1$7 = undefined;var a$1 = undefined;var b$2 = undefined;var x$17 = undefined;var y$1 = undefined;t0$14 = temp$8$0;if (Array.isArray(t0$14) && (t1$7 = t0$14.length, t1$7 === 3 && t0$14[0] === "array")) {
                              x$17 = t0$14[1];y$1 = t0$14[2];
                            } else {
                              ___match_error(temp$8$0);
                            }a$1 = $it$8.translate(x$17, "expr");b$2 = $it$8.translate(y$1, "expr");return ENode(["splice"], {}, [a$1, ":", b$2]);
                          }, join$0(args$2.map(f$5), ",")), "})"]);
                        } else {
                          v$3 = gensym$0();r$3 = ENode(["splice"], {}, ["(function(){let ", v$3, "={};", (acc$4 = [], temp$9 = null, m$18 = null, (function () {
                            $8: for (var _iterator = args$2[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                              m$18 = _step.value;
                              var x$18 = undefined;var y$2 = undefined;var t0$15 = undefined;var t1$8 = undefined;t0$15 = m$18;if (Array.isArray(t0$15) && (t1$8 = t0$15.length, t1$8 === 3 && t0$15[0] === "array")) {
                                x$18 = t0$15[1];y$2 = t0$15[2];temp$9 = ENode(["splice"], {}, [v$3, "[", $it$8.translate(x$18, "expr"), "]=", $it$8.translate(y$2, "expr"), ";"]);acc$4.push(temp$9);
                              } else {
                                ___match_error(m$18);
                              }
                            }
                          })(), acc$4), "return ", v$3, "})()"]);
                        }rval$1 = $it$8.expr(r$3, mode$2);
                      } else {
                        if ($$11438$0 && (t0$8 >= 3 && t0$8 <= 4 && (m$10$0[0] === "lambda" && (bindings$0 = m$10$0[1], body$0 = m$10$0[2], t1$4 = 3 >= t0$8 ? ["value", false] : m$10$0[3], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "value"))))) {
                          generator$0 = t1$4[1];m$19$0 = expr$0.name;if (__in__(m$19$0, jsKeywords$0)) {
                            name$3 = "";
                          } else {
                            if (getChecker(RegExp("^[$_a-zA-Z0-9]*$", ""))(m$19$0)) {
                              name$3 = " " + expr$0.name;
                            } else {
                              name$3 = "";
                            }
                          }r$4 = ENode(["splice"], {}, ["(function", generator$0 ? "*" : "", name$3, "(", join$0((acc$5 = [], temp$10 = null, m$20 = null, (function () {
                            $9: for (var _iterator = bindings$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                              m$20 = _step.value;
                              var x$19 = undefined;x$19 = m$20;temp$10 = $it$8.translate(x$19, "expr");acc$5.push(temp$10);
                            }
                          })(), acc$5), ","), "){", $it$8.body(body$0, "return"), "})"]);rval$1 = $it$8.expr(r$4, mode$2);
                        } else {
                          if ($$11438$0 && (($$11440$0 = t0$8 === 4) && (($$11441$0 = m$10$0[0] === "if") && (test$0 = m$10$0[1], pos$0 = m$10$0[2], t1$4 = m$10$0[3], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && (t1$4[0] === "value" && t1$4[1] === void 0)))))) {
                            ph$2$0 = mode$2;if (ph$2$0 === "expr") {
                              x$20 = ENode(["splice"], {}, ["(", $it$8.translate(test$0, "expr"), "?", $it$8.translate(pos$0, "expr"), ":undefined)"]);rval$1 = $it$8.expr(x$20, "expr");
                            } else {
                              other$4 = ph$2$0;rval$1 = ENode(["splice"], {}, ["if(", $it$8.translate(test$0, "expr"), "){", $it$8.translate(pos$0, mode$2), "}"]);
                            }
                          } else {
                            if ($$11441$0) {
                              test$1 = m$10$0[1];pos$1 = m$10$0[2];neg$0 = m$10$0[3];ph$3$0 = mode$2;if (ph$3$0 === "expr") {
                                x$21 = ENode(["splice"], {}, ["(", $it$8.translate(test$1, "expr"), "?", $it$8.translate(pos$1, "expr"), ":", $it$8.translate(neg$0, "expr"), ")"]);rval$1 = $it$8.expr(x$21, "expr");
                              } else {
                                other$5 = ph$3$0;rval$1 = ENode(["splice"], {}, ["if(", $it$8.translate(test$1, "expr"), "){", $it$8.translate(pos$1, mode$2), "}else{", $it$8.translate(neg$0, mode$2), "}"]);
                              }
                            } else {
                              if ($$11438$0 && (($$11440$0 = t0$8 === 3) && (($$11441$0 = m$10$0[0] === "declare") && (binding$0 = m$10$0[1], t1$4 = m$10$0[2], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && (t1$4[0] === "value" && t1$4[1] === void 0)))))) {
                                ph$4$0 = mode$2;bridge$$11395$0 = ph$4$0;if ((bridge$$11396$0 = bridge$$11395$0, bridge$$11396$0 === "expr" || bridge$$11396$0 === "return") || (x$22 = bridge$$11395$0, x$22 instanceof Array && x$22[0] === "return")) {
                                  throw "Invalid in expr ctx";
                                } else {
                                  other$6 = ph$4$0;if ($it$8.globvar && binding$0.top) {
                                    rval$1 = "";
                                  } else {
                                    rval$1 = ENode(["splice"], {}, ["let ", $it$8.translate(binding$0, "expr"), ";"]);
                                  }
                                }
                              } else {
                                if ($$11441$0) {
                                  binding$1 = m$10$0[1];value$0 = m$10$0[2];ph$5$0 = mode$2;bridge$$11400$0 = ph$5$0;if ((bridge$$11401$0 = bridge$$11400$0, bridge$$11401$0 === "expr" || bridge$$11401$0 === "return") || (x$23 = bridge$$11400$0, x$23 instanceof Array && x$23[0] === "return")) {
                                    throw "Invalid in expr ctx";
                                  } else {
                                    other$7 = ph$5$0;rval$1 = ENode(["splice"], {}, ["let ", $it$8.translate(binding$1, "expr"), "=", $it$8.translate(value$0, "expr"), ";"]);
                                  }
                                } else {
                                  if ($$11440$0 && (($$11441$0 = m$10$0[0] === "assign") && (t1$4 = m$10$0[1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 3 && t1$4[0] === "send")))) {
                                    obj$0 = t1$4[1];msg$3 = t1$4[2];rhs$0 = m$10$0[2];x$24 = ENode(["splice"], {}, ["(", $it$8.translate(obj$0, "expr"), "[", $it$8.translate(msg$3, "expr"), "]=", $it$8.translate(rhs$0, "expr"), ")"]);rval$1 = $it$8.expr(x$24, mode$2);
                                  } else {
                                    if ($$11441$0 && (lhs$0 = t1$4, Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "variable"))) {
                                      t1$4[1];rhs$1 = m$10$0[2];m$21$0 = mode$2;if (m$21$0 === "stmt") {
                                        rval$1 = $it$8.translate(rhs$1, ["return", $it$8.translate(lhs$0, "expr")]);
                                      } else {
                                        core$0 = ENode(["splice"], {}, [$it$8.translate(lhs$0, "expr"), "=", $it$8.translate(rhs$1, "expr")]);x$25 = ENode(["splice"], {}, ["(", core$0, ")"]);rval$1 = $it$8.expr(x$25, mode$2);
                                      }
                                    } else {
                                      if ($$11438$0 && (t0$8 === 1 && m$10$0[0] === "multi")) {
                                        if (mode$2 === "stmt") {
                                          rval$1 = "";
                                        } else {
                                          rval$1 = "null";
                                        }
                                      } else {
                                        if ($$11438$0 && (($$11440$0 = t0$8 >= 1) && m$10$0[0] === "multi")) {
                                          _args$0 = Array.prototype.slice.call(m$10$0, 1);flatten$0 = function flatten(args$4) {
                                            var m$23 = undefined;var res$0 = undefined;res$0 = [];m$23 = null;$10: for (var _iterator = args$4[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                                              m$23 = _step.value;
                                              var t0$16 = undefined;var t0$17 = undefined;var other$8 = undefined;var more$0 = undefined;var bridge$$12170$0 = undefined;bridge$$12170$0 = m$23;if (Array.isArray(bridge$$12170$0) && (t0$16 = bridge$$12170$0.length, t0$16 >= 1 && (bridge$$12170$0[0] === "multi" && (more$0 = Array.prototype.slice.call(bridge$$12170$0, 1), true))) || Array.isArray(bridge$$12170$0) && (t0$17 = bridge$$12170$0.length, t0$17 >= 1 && (bridge$$12170$0[0] === "splice" && (more$0 = Array.prototype.slice.call(bridge$$12170$0, 1), true)))) {
                                                res$0 = res$0.concat(flatten$0(more$0));
                                              } else {
                                                other$8 = m$23;res$0.push(other$8);
                                              }
                                            }return res$0;
                                          };all_args$0 = flatten$0(_args$0);acc$6 = [];temp$11 = null;m$24 = null;$11: for (var _iterator = all_args$0.slice(0, -1)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                                            m$24 = _step.value;
                                            var x$26 = undefined;var x$27 = undefined;var bridge$$12212$0 = undefined;var x$28 = undefined;var x$29 = undefined;var bridge$$12211$0 = undefined;var elem$0 = undefined;var ph$13$0 = undefined;var t0$18 = undefined;t0$18 = m$24;elem$0 = t0$18;ph$13$0 = t0$18;bridge$$12211$0 = ph$13$0;if ((bridge$$12212$0 = bridge$$12211$0, (x$26 = bridge$$12212$0, x$26 instanceof Array && x$26[0] === "value") || (x$27 = bridge$$12212$0, x$27 instanceof Array && x$27[0] === "symbol")) || (x$28 = bridge$$12211$0, x$28 instanceof Array && x$28[0] === "variable")) {
                                              continue $11;
                                            } else {
                                              x$29 = ph$13$0;temp$11 = x$29;
                                            }acc$6.push(temp$11);
                                          }args$3 = acc$6;if (all_args$0.length > 0) {
                                            args$3.push(send(all_args$0, all_args$0.length - 1));
                                          }isdecl$0 = function isdecl(ph$14$0) {
                                            var other$9 = undefined;var variable$2 = undefined;var value$1 = undefined;var t0$19 = undefined;var t1$9 = undefined;t0$19 = ph$14$0;t1$9 = t0$19.length;if (t1$9 === 3 && t0$19[0] === "declare") {
                                              variable$2 = t0$19[1];value$1 = t0$19[2];return true;
                                            } else {
                                              other$9 = ph$14$0;return false;
                                            }
                                          };m$22$0 = mode$2;if (args$3.length === 1) {
                                            rval$1 = $it$8.translate(args$3[0], mode$2);
                                          } else {
                                            if (m$22$0 === "expr" && !args$3.some(isdecl$0)) {
                                              acc$7 = [];temp$12 = null;m$25 = null;$12: for (var _iterator2 = args$3.slice(0, -1)[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                                                m$25 = _step2.value;
                                                var x$30 = undefined;x$30 = m$25;temp$12 = $it$8.translate(x$30, "expr");acc$7.push(temp$12);
                                              }xs$0 = acc$7;xs$0.push($it$8.translate(send(args$3, args$3.length - 1), mode$2));acc$8 = [];temp$13 = null;m$26 = null;$13: for (var _iterator3 = xs$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                                                m$26 = _step3.value;
                                                var x$31 = undefined;x$31 = m$26;if (x$31 !== "") {
                                                  temp$13 = x$31;acc$8.push(temp$13);
                                                } else {
                                                  false;
                                                }
                                              }xs$0 = acc$8;rval$1 = ENode(["splice"], {}, ["(", join$0(xs$0, ","), ")"]);
                                            } else {
                                              rval$1 = $it$8.body(["multi"].concat(args$3), mode$2);
                                            }
                                          }
                                        } else {
                                          if ($$11440$0 && m$10$0[0] === "splice") {
                                            args$5 = Array.prototype.slice.call(m$10$0, 1);rval$1 = $it$8.translate(["multi"].concat(args$5), mode$2);
                                          } else {
                                            if ($$11438$0 && (t0$8 === 2 && m$10$0[0] === "variable")) {
                                              s$2 = m$10$0[1];if ($it$8.globvar && expr$0.top && !__in__(s$2, ["this", "arguments", "typeof"])) {
                                                x$32 = $it$8.globvar + "." + $it$8.mangle(s$2);
                                              } else {
                                                x$32 = $it$8.mangle(s$2);
                                              }rval$1 = $it$8.expr(x$32, mode$2);
                                            } else {
                                              if ($$11438$0 && (t0$8 === 3 && m$10$0[0] === "scope")) {
                                                vars$0 = m$10$0[1];body$1 = m$10$0[2];acc$9 = [];temp$14 = null;m$27 = null;$14: for (var _iterator4 = vars$0[Symbol.iterator](), _step4; !(_step4 = _iterator4.next()).done;) {
                                                  m$27 = _step4.value;
                                                  var v$4 = undefined;v$4 = m$27;temp$14 = ["declare", v$4, ["value", undefined]];acc$9.push(temp$14);
                                                }decls$0 = acc$9;rval$1 = $it$8.translate(["multi"].concat(decls$0).concat([body$1]), mode$2);
                                              } else {
                                                if ($$11438$0 && (t0$8 === 2 && m$10$0[0] === "js_new")) {
                                                  value$2 = m$10$0[1];x$33 = ENode(["splice"], {}, ["(new ", $it$8.translate(value$2, "expr"), ")"]);rval$1 = $it$8.expr(x$33, mode$2);
                                                } else {
                                                  if ($$11438$0 && (($$11440$0 = t0$8 >= 1 && t0$8 <= 2) && (m$10$0[0] === "js_break" && (t1$4 = 1 >= t0$8 ? ["value", null] : m$10$0[1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "value"))))) {
                                                    label$0 = t1$4[1];rval$1 = ENode(["splice"], {}, ["break", label$0 ? " " + label$0 : "", ";"]);
                                                  } else {
                                                    if ($$11440$0 && (m$10$0[0] === "js_continue" && (t1$4 = 1 >= t0$8 ? ["value", null] : m$10$0[1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "value")))) {
                                                      label$1 = t1$4[1];rval$1 = ENode(["splice"], {}, ["continue", label$1 ? " " + label$1 : "", ";"]);
                                                    } else {
                                                      if ($$11438$0 && (t0$8 === 2 && m$10$0[0] === "js_return")) {
                                                        value$3 = m$10$0[1];rval$1 = ENode(["splice"], {}, ["return ", $it$8.translate(value$3, "expr"), ";"]);
                                                      } else {
                                                        if ($$11438$0 && (t0$8 === 3 && (m$10$0[0] === "js_yield" && (value$4 = m$10$0[1], t1$4 = m$10$0[2], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "value"))))) {
                                                          all$0 = t1$4[1];x$34 = ENode(["splice"], {}, ["(yield", all$0 ? "*" : "", " ", $it$8.translate(value$4, "expr"), ")"]);rval$1 = $it$8.expr(x$34, mode$2);
                                                        } else {
                                                          if ($$11438$0 && (($$11440$0 = t0$8 === 2) && m$10$0[0] === "js_delete")) {
                                                            ph$6$0 = m$10$0[1];t0$20 = ph$6$0;if (Array.isArray(t0$20) && (t1$10 = t0$20.length, t1$10 === 3 && t0$20[0] === "send")) {
                                                              x$35 = t0$20[1];y$3 = t0$20[2];rval$1 = ENode(["splice"], {}, ["delete ", $it$8.translate(x$35, "expr"), "[", $it$8.translate(y$3, "expr"), "];"]);
                                                            } else {
                                                              throw ErrorFactory(["translate", "delete"]).create("Invalid argument for delete");
                                                            }
                                                          } else {
                                                            if ($$11440$0 && m$10$0[0] === "js_throw") {
                                                              value$5 = m$10$0[1];m$28$0 = mode$2;if (m$28$0 === "expr") {
                                                                rval$1 = ENode(["splice"], {}, ["(function(){throw ", $it$8.translate(value$5, "expr"), ";})()"]);
                                                              } else {
                                                                rval$1 = ENode(["splice"], {}, ["throw ", $it$8.translate(value$5, "expr"), ";"]);
                                                              }
                                                            } else {
                                                              if ($$11438$0 && (($$11440$0 = t0$8 === 3) && (m$10$0[0] === "js_label" && (t1$4 = m$10$0[1], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 2 && t1$4[0] === "value"))))) {
                                                                label$2 = t1$4[1];body$2 = m$10$0[2];ph$7$0 = mode$2;if (ph$7$0 === "expr") {
                                                                  rval$1 = $it$8.body(expr$0, "expr");
                                                                } else {
                                                                  other$10 = ph$7$0;rval$1 = ENode(["splice"], {}, [label$2, ":", $it$8.translate(body$2, other$10)]);
                                                                }
                                                              } else {
                                                                if ($$11440$0 && m$10$0[0] === "js_while") {
                                                                  test$2 = m$10$0[1];body$3 = m$10$0[2];ph$8$0 = mode$2;if (ph$8$0 === "expr") {
                                                                    rval$1 = $it$8.body(expr$0, "expr");
                                                                  } else {
                                                                    other$11 = ph$8$0;rval$1 = ENode(["splice"], {}, ["while(", $it$8.translate(test$2, "expr"), "){", $it$8.translate(body$3, "stmt"), "}"]);
                                                                  }
                                                                } else {
                                                                  if ($$11438$0 && (t0$8 === 5 && m$10$0[0] === "js_for")) {
                                                                    x$36 = m$10$0[1];y$4 = m$10$0[2];z$0 = m$10$0[3];body$4 = m$10$0[4];ph$9$0 = mode$2;if (ph$9$0 === "expr") {
                                                                      rval$1 = $it$8.body(expr$0, "expr");
                                                                    } else {
                                                                      other$12 = ph$9$0;rval$1 = ENode(["splice"], {}, ["for(", $it$8.translate(x$36, "expr"), ";", $it$8.translate(y$4, "expr"), ";", $it$8.translate(z$0, "expr"), "){", $it$8.translate(body$4, "stmt"), "}"]);
                                                                    }
                                                                  } else {
                                                                    if ($$11438$0 && (($$11440$0 = t0$8 === 4) && m$10$0[0] === "js_for_in")) {
                                                                      x$37 = m$10$0[1];y$5 = m$10$0[2];body$5 = m$10$0[3];ph$10$0 = mode$2;if (ph$10$0 === "expr") {
                                                                        rval$1 = $it$8.body(expr$0, "expr");
                                                                      } else {
                                                                        other$13 = ph$10$0;rval$1 = ENode(["splice"], {}, ["for(", $it$8.translate(x$37, "expr"), " in ", $it$8.translate(y$5, "expr"), "){", $it$8.translate(body$5, "stmt"), "}"]);
                                                                      }
                                                                    } else {
                                                                      if ($$11440$0 && m$10$0[0] === "js_for_of") {
                                                                        x$38 = m$10$0[1];y$6 = m$10$0[2];body$6 = m$10$0[3];ph$11$0 = mode$2;if (ph$11$0 === "expr") {
                                                                          rval$1 = $it$8.body(expr$0, "expr");
                                                                        } else {
                                                                          other$14 = ph$11$0;rval$1 = ENode(["splice"], {}, ["for(", $it$8.translate(x$38, "expr"), " of ", $it$8.translate(y$6, "expr"), "){", $it$8.translate(body$6, "stmt"), "}"]);
                                                                        }
                                                                      } else {
                                                                        if ($$11440$0 && (m$10$0[0] === "js_try" && (attempt$0 = m$10$0[1], t1$4 = m$10$0[2], Array.isArray(t1$4) && (t2$2 = t1$4.length, t2$2 === 4 && (t1$4[0] === "lambda" && (t3$0 = t1$4[1], Array.isArray(t3$0) && (t4$0 = t3$0.length, t4$0 === 1 && (bridge$$11435$0 = t3$0[0], Array.isArray(bridge$$11435$0) && (t0$21 = bridge$$11435$0.length, t0$21 === 2 && (bridge$$11435$0[0] === "symbol" && (v$5 = bridge$$11435$0[1], true))) || Array.isArray(bridge$$11435$0) && (t0$22 = bridge$$11435$0.length, t0$22 === 2 && (bridge$$11435$0[0] === "variable" && (v$5 = bridge$$11435$0[1], true))))))))))) {
                                                                          body$7 = t1$4[2];t1$4[3];finally$1 = m$10$0[3];m$30$0 = mode$2;if (m$30$0 === "expr") {
                                                                            r$5 = $it$8.body(expr$0, "expr");
                                                                          } else {
                                                                            other$15 = m$30$0;r$5 = ENode(["splice"], {}, ["try{", $it$8.translate(attempt$0, "stmt"), "}catch(", v$5, "){", $it$8.translate(body$7, "stmt"), "}"]);
                                                                          }m$29$0 = finally$1;if (Array.isArray(m$29$0) && (t0$23 = m$29$0.length, t0$23 === 1 && m$29$0[0] === "void")) {
                                                                            rval$1 = r$5;
                                                                          } else {
                                                                            other$16 = m$29$0;rval$1 = ENode(["splice"], {}, [r$5, "finally{", $it$8.translate(other$16, "stmt"), "}"]);
                                                                          }
                                                                        } else {
                                                                          if ($$11438$0 && (t0$8 === 2 && m$10$0[0] === "raw")) {
                                                                            x$39 = m$10$0[1];rval$1 = x$39;
                                                                          } else {
                                                                            other$17 = m$10$0;throw other$17;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }m$9$0 = rval$1;if (getChecker(ENode)(m$9$0)) {
      n$0 = m$9$0;if (!n$0.props.origin) {
        $targ$6 = expr$0;n$0.props.origin = $targ$6;void 0;
      }return n$0;
    } else {
      if (typeof m$9$0 === "string") {
        return ENode(["splice"], { origin: expr$0 }, rval$1);
      } else {
        return ___match_error(m$9$0, "String? ");
      }
    }
  } else {
    return ___match_error(m$8$0, "{expr, mode, called = if{expr.called, .send, false}}");
  }
};__amp____colon__(Translator$0, __amp____colon__(($targ$7 = "Translator", accum$0 = {}, accum$0["::name"] = $targ$7, accum$0), ($targ$8 = true, accum$1 = {}, accum$1["::egclass"] = $targ$8, accum$1)));$targ$9 = Translator$0;exports.Translator = $targ$9;void 0;
//# sourceMappingURL=translate-js.js.map


},{"./expand":104,"./pp":122,"./util":126,"earlgrey-runtime/5":446}],126:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var f$2 = undefined;var f$3 = undefined;var f$4 = undefined;var f$5 = undefined;var f$6 = undefined;var f$7 = undefined;var f$8 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var $targ$15 = undefined;var $targ$16 = undefined;var $targ$17 = undefined;var GenSym$0 = undefined;var gensym$0 = undefined;var identity$0 = undefined;var binsearch$0 = undefined;var classify$0 = undefined;var classify_contiguous$0 = undefined;var partition$0 = undefined;var construct$0 = undefined;var mkset$0 = undefined;var Body$0 = undefined;var camelCase$0 = undefined;var invCamelCase$0 = undefined;var mac1$0 = undefined;var __chk_ncache$0 = undefined;var __chk_scache$0 = undefined;var checker_db$0 = undefined;GenSym$0 = function GenSym(prefix$0) {
  var id$0 = undefined;id$0 = 0;return function () {
    var r$0 = undefined;var pfx$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 0 && t0$0 <= 1) {
      if (0 >= t0$0) {
        pfx$0 = "";
      } else {
        pfx$0 = m$0$0[0];
      }r$0 = pfx$0 + prefix$0 + [true, String(id$0)][1];id$0++;return r$0;
    } else {
      return ___match_error(m$0$0, "{pfx = \"\"}");
    }
  };
};gensym$0 = GenSym$0("$$");identity$0 = function identity(x$0) {
  return x$0;
};binsearch$0 = function binsearch(xs$0, x$1) {
  var lo$0 = undefined;var hi$0 = undefined;lo$0 = 0;hi$0 = xs$0.length - 1;$0: while (lo$0 <= hi$0) {
    var m$1$0 = undefined;var mid$0 = undefined;var v$0 = undefined;mid$0 = lo$0 + (hi$0 - lo$0 >> 1);v$0 = send(xs$0, mid$0);m$1$0 = send(xs$0, mid$0);if (m$1$0 < x$1) {
      lo$0 = mid$0 + 1;lo$0;
    } else {
      if (m$1$0 > x$1) {
        hi$0 = mid$0 - 1;hi$0;
      } else {
        return mid$0 + 1;
      }
    }
  }return lo$0;
};classify$0 = function classify() {
  var m$3 = undefined;var results$0 = undefined;var xs$1 = undefined;var classes$0 = undefined;var t0$1 = undefined;var m$2$0 = undefined;m$2$0 = arguments;t0$1 = m$2$0.length;if (t0$1 >= 1) {
    classes$0 = Array.prototype.slice.call(m$2$0, 0, -1);xs$1 = m$2$0[t0$1 - 1];results$0 = { rest: [] };m$3 = null;$1: for (var _iterator = classes$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$3 = _step.value;
      var $targ$0 = undefined;var cls$0 = undefined;cls$0 = m$3;$targ$0 = [];results$0[cls$0] = $targ$0;void 0;
    }$2: while (xs$1.length) {
      var x$2 = undefined;var other$0 = undefined;var cls$1 = undefined;var x$3 = undefined;var newxs$0 = undefined;var t0$2 = undefined;var m$4$0 = undefined;m$4$0 = xs$1.shift();if (Array.isArray(m$4$0) && (t0$2 = m$4$0.length, t0$2 >= 1 && m$4$0[0] === "splice")) {
        newxs$0 = Array.prototype.slice.call(m$4$0, 1);xs$1 = newxs$0.concat(xs$1);xs$1;
      } else {
        if ((x$2 = m$4$0, x$2 instanceof Array && x$2[0] === "ignore")) {
          null;
        } else {
          if (Array.isArray(m$4$0) && (t0$2 = m$4$0.length, t0$2 === 2 && (cls$1 = m$4$0[0], x$3 = m$4$0[1], send(results$0, cls$1)))) {
            send(results$0, cls$1).push(x$3);
          } else {
            other$0 = m$4$0;results$0.rest.push(other$0);
          }
        }
      }
    }return results$0;
  } else {
    return ___match_error(m$2$0, "{*classes, var xs}");
  }
};classify_contiguous$0 = function classify_contiguous(xs$2, classifier$0) {
  var m$5 = undefined;var groups$0 = undefined;var currcls$0 = undefined;var curr$0 = undefined;groups$0 = [];currcls$0 = null;curr$0 = null;m$5 = null;$3: for (var _iterator = xs$2[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$5 = _step.value;
    var cls$2 = undefined;var x$4 = undefined;x$4 = m$5;cls$2 = classifier$0(x$4);if (cls$2 === currcls$0) {
      curr$0.push(x$4);
    } else {
      if (curr$0) {
        groups$0.push(curr$0);
      }curr$0 = [cls$2, x$4];currcls$0 = cls$2;currcls$0;
    }
  }if (curr$0) {
    groups$0.push(curr$0);
  }return groups$0;
};partition$0 = function partition(xs$3, predicate$0) {
  var m$6 = undefined;var t$0 = undefined;var f$0 = undefined;t$0 = [];f$0 = [];m$6 = null;$4: for (var _iterator = xs$3[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$6 = _step.value;
    var x$6 = undefined;var x$5 = undefined;x$5 = m$6;if (predicate$0(x$5)) {
      t$0.push(x$5);
    } else {
      x$6 = m$6;f$0.push(x$6);
    }
  }return [t$0, f$0];
};construct$0 = function construct(ph$0$0, fn$0, zero$0) {
  var x$8 = undefined;var rest$0 = undefined;var x$7 = undefined;var $$280$0 = undefined;var $$281$0 = undefined;var t0$3 = undefined;var t1$0 = undefined;t0$3 = ph$0$0;t1$0 = t0$3.length;if (t1$0 === 0) {
    return zero$0;
  } else {
    if (t1$0 === 1) {
      x$7 = t0$3[0];return x$7;
    } else {
      if (t1$0 >= 1) {
        x$8 = t0$3[0];rest$0 = Array.prototype.slice.call(t0$3, 1);return fn$0(x$8, construct$0(rest$0, fn$0, zero$0));
      } else {
        return ___match_error(ph$0$0, "{x, *rest}");
      }
    }
  }
};mkset$0 = function mkset(xs$4) {
  var m$7 = undefined;var rval$0 = undefined;rval$0 = {};m$7 = null;$5: for (var _iterator = xs$4[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
    m$7 = _step.value;
    var $targ$1 = undefined;var x$9 = undefined;x$9 = m$7;$targ$1 = true;rval$0[x$9] = $targ$1;void 0;
  }return rval$0;
};Body$0 = function Body(temp$0$0) {
  var t0$4 = undefined;var xs$5 = undefined;var t0$5 = undefined;var t1$1 = undefined;var x$10 = undefined;var ph$1$0 = undefined;t0$4 = temp$0$0;x$10 = t0$4;ph$1$0 = t0$4;t0$5 = ph$1$0;t1$1 = t0$5.length;if (t1$1 >= 1 && t0$5[0] === "multi") {
    xs$5 = Array.prototype.slice.call(t0$5, 1);return xs$5;
  } else {
    return [x$10];
  }
};camelCase$0 = function camelCase(x$11) {
  if (equal(x$11.indexOf("-"), -1)) {
    return x$11;
  } else {
    return x$11.replace(RegExp("-([A-Za-z0-9_])", "g"), function (temp$1$0, m$8) {
      return m$8.toUpperCase();
    });
  }
};invCamelCase$0 = function invCamelCase(x$12) {
  return x$12.replace(RegExp("([a-z0-9])([A-Z]+)", "g"), function (temp$2$0, m1$0, m2$0) {
    return m1$0 + "-" + m2$0.toLowerCase();
  });
};mac1$0 = function mac1() {
  var f$1 = undefined;var name$0 = undefined;var t0$6 = undefined;var m$9$0 = undefined;m$9$0 = arguments;t0$6 = m$9$0.length;if (t0$6 >= 1 && t0$6 <= 2) {
    f$1 = m$9$0[0];if (1 >= t0$6) {
      name$0 = null;
    } else {
      name$0 = m$9$0[1];
    }return ["macro", function (context$0, scope$0, form$0, ph$2$0) {
      var expr$0 = undefined;var $$409$0 = undefined;var t0$7 = undefined;var t1$2 = undefined;t0$7 = ph$2$0;t1$2 = t0$7.length;if (t1$2 === 2 && t0$7[0] === "data") {
        expr$0 = t0$7[1];return f$1(expr$0);
      } else {
        if (Array.isArray(t0$7) && (t1$2 = t0$7.length, t1$2 === 1 && (t0$7[0] === "void" && name$0))) {
          return ["variable", name$0];
        } else {
          return ___match_error(ph$2$0, "#void{} when name");
        }
      }
    }];
  } else {
    return ___match_error(m$9$0, "{f, name = null}");
  }
};__chk_ncache$0 = {};__chk_scache$0 = {};checker_db$0 = function checker_db(ph$3$0) {
  var v$1 = undefined;var $targ$2 = undefined;var v$2 = undefined;var $targ$3 = undefined;var s$0 = undefined;var n$0 = undefined;var $$453$0 = undefined;var t0$8 = undefined;if (ph$3$0 === null) {
    return checker_db$0["null"];
  } else {
    if (ph$3$0 === void 0) {
      return checker_db$0.undefined;
    } else {
      if (ph$3$0 === true) {
        return checker_db$0["true"];
      } else {
        if (ph$3$0 === false) {
          return checker_db$0["false"];
        } else {
          t0$8 = ph$3$0;if (typeof t0$8 === "number") {
            n$0 = t0$8;if (send(__chk_ncache$0, n$0)) {
              return send(__chk_ncache$0, n$0);
            } else {
              v$1 = mac1$0(function (x$13) {
                return ["send", ["symbol", "==="], ["data", x$13, ["value", n$0]]];
              });$targ$2 = v$1;__chk_ncache$0[n$0] = $targ$2;return v$1;
            }
          } else {
            if (typeof t0$8 === "string") {
              s$0 = t0$8;if (Object.prototype.hasOwnProperty.call(__chk_scache$0, s$0)) {
                return send(__chk_scache$0, s$0);
              } else {
                v$2 = mac1$0(function (x$14) {
                  return ["send", ["symbol", "==="], ["data", x$14, ["value", s$0]]];
                });$targ$3 = v$2;__chk_scache$0[s$0] = $targ$3;return v$2;
              }
            } else {
              return ___match_error(ph$3$0, "String? s");
            }
          }
        }
      }
    }
  }
};__amp____colon__(checker_db$0, { String: (f$2 = function f(x$15) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$15]], ["value", "string"]]];
  }, mac1$0(f$2, "String")), Number: (f$3 = function f(x$16) {
    return ["send", ["symbol", "==="], ["data", ["send", ["symbol", "typeof"], ["data", x$16]], ["value", "number"]]];
  }, mac1$0(f$3, "Number")), Array: (f$4 = function f(x$17) {
    return ["send", ["send", ["symbol", "Array"], ["send", ["symbol", "."], ["data", ["void"], ["symbol", "isArray"]]]], ["data", x$17]];
  }, mac1$0(f$4, "Array")), "true": (f$5 = function f(x$18) {
    return x$18;
  }, mac1$0(f$5, "true")), "false": (f$6 = function f(x$19) {
    return ["send", ["symbol", "not"], ["data", ["void"], x$19]];
  }, mac1$0(f$6, "false")), "null": (f$7 = function f(x$20) {
    return ["send", ["symbol", "==="], ["data", x$20, ["value", null]]];
  }, mac1$0(f$7, "null")), undefined: (f$8 = function f(x$21) {
    return ["send", ["symbol", "==="], ["data", x$21, ["value", undefined]]];
  }, mac1$0(f$8, "undefined")) });$targ$4 = GenSym$0;exports.GenSym = $targ$4;$targ$5 = gensym$0;exports.gensym = $targ$5;$targ$6 = identity$0;exports.identity = $targ$6;$targ$7 = binsearch$0;exports.binsearch = $targ$7;$targ$8 = classify$0;exports.classify = $targ$8;$targ$9 = classify_contiguous$0;exports.classify_contiguous = $targ$9;$targ$10 = partition$0;exports.partition = $targ$10;$targ$11 = construct$0;exports.construct = $targ$11;$targ$12 = mkset$0;exports.mkset = $targ$12;$targ$13 = Body$0;exports.Body = $targ$13;$targ$14 = camelCase$0;exports.camelCase = $targ$14;$targ$15 = invCamelCase$0;exports.invCamelCase = $targ$15;$targ$16 = mac1$0;exports.mac1 = $targ$16;$targ$17 = checker_db$0;exports.checker_db = $targ$17;void 0;
//# sourceMappingURL=util.js.map


},{"earlgrey-runtime/5":446}],127:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var package$1 = undefined;var version$0 = undefined;package$1 = require("../package");version$0 = getProperty(package$1, "version", "package");$targ$0 = version$0;exports.version = $targ$0;void 0;
//# sourceMappingURL=version.js.map


},{"../package":584,"earlgrey-runtime/5":446}],128:[function(require,module,exports){
"use strict";

var isFunction = require("lodash/lang/isFunction");
var transform = require("../transformation");
var util = require("../util");
var fs = require("fs");

exports.version = require("../../../package").version;

exports.buildExternalHelpers = require("../build-external-helpers");

exports.types = require("../types");

exports.register = function (opts) {
  var register = require("./register/node");
  if (opts != null) register(opts);
  return register;
};

exports.polyfill = function () {
  require("../polyfill");
};

exports.canCompile = util.canCompile;

// do not use this - this is for use by official maintained babel plugins
exports._util = util;

exports.transform = transform;

exports.transformFile = function (filename, opts, callback) {
  if (isFunction(opts)) {
    callback = opts;
    opts = {};
  }

  opts.filename = filename;

  fs.readFile(filename, function (err, code) {
    if (err) return callback(err);

    var result;

    try {
      result = transform(code, opts);
    } catch (err) {
      return callback(err);
    }

    callback(null, result);
  });
};

exports.transformFileSync = function (filename, opts) {
  if (!opts) opts = {};

  opts.filename = filename;
  return transform(fs.readFileSync(filename), opts);
};
},{"../../../package":444,"../build-external-helpers":130,"../polyfill":159,"../transformation":173,"../types":251,"../util":253,"./register/node":129,"fs":697,"lodash/lang/isFunction":392}],129:[function(require,module,exports){
"use strict";

// required to safely use babel/register within a browserify codebase

module.exports = function () {};

require("../../polyfill");
},{"../../polyfill":159}],130:[function(require,module,exports){
"use strict";

var buildHelpers = require("./build-helpers");
var generator = require("./generation");
var util = require("./util");
var t = require("./types");

module.exports = function (whitelist) {
  var namespace = t.identifier("babelHelpers");

  var body = [];
  var container = t.functionExpression(null, [t.identifier("global")], t.blockStatement(body));
  var tree = t.program([t.expressionStatement(t.callExpression(container, [util.template("self-global")]))]);

  body.push(t.variableDeclaration("var", [t.variableDeclarator(namespace, t.assignmentExpression("=", t.memberExpression(t.identifier("global"), namespace), t.objectExpression([])))]));

  buildHelpers(body, namespace, whitelist);

  return generator(tree).code;
};
},{"./build-helpers":131,"./generation":145,"./types":251,"./util":253}],131:[function(require,module,exports){
"use strict";

var File = require("./transformation/file");
var util = require("./util");
var each = require("lodash/collection/each");
var t = require("./types");

module.exports = function (body, namespace) {
  var whitelist = arguments[2] === undefined ? [] : arguments[2];

  each(File.helpers, function (name) {
    if (whitelist.length && whitelist.indexOf(name) == -1) return;

    var key = t.identifier(t.toIdentifier(name));
    body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(namespace, key), util.template(name))));
  });
};
},{"./transformation/file":160,"./types":251,"./util":253,"lodash/collection/each":303}],132:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var repeating = require("repeating");
var trimRight = require("trim-right");
var isBoolean = require("lodash/lang/isBoolean");
var includes = require("lodash/collection/includes");
var isNumber = require("lodash/lang/isNumber");

var Buffer = (function () {
  function Buffer(position, format) {
    _classCallCheck(this, Buffer);

    this.position = position;
    this._indent = format.indent.base;
    this.format = format;
    this.buf = "";
  }

  Buffer.prototype.get = function get() {
    return trimRight(this.buf);
  };

  Buffer.prototype.getIndent = function getIndent() {
    if (this.format.compact || this.format.concise) {
      return "";
    } else {
      return repeating(this.format.indent.style, this._indent);
    }
  };

  Buffer.prototype.indentSize = function indentSize() {
    return this.getIndent().length;
  };

  Buffer.prototype.indent = function indent() {
    this._indent++;
  };

  Buffer.prototype.dedent = function dedent() {
    this._indent--;
  };

  Buffer.prototype.semicolon = function semicolon() {
    this.push(";");
  };

  Buffer.prototype.ensureSemicolon = function ensureSemicolon() {
    if (!this.isLast(";")) this.semicolon();
  };

  Buffer.prototype.rightBrace = function rightBrace() {
    this.newline(true);
    this.push("}");
  };

  Buffer.prototype.keyword = function keyword(name) {
    this.push(name);
    this.space();
  };

  Buffer.prototype.space = function space() {
    if (this.format.compact) return;
    if (this.buf && !this.isLast(" ") && !this.isLast("\n")) {
      this.push(" ");
    }
  };

  Buffer.prototype.removeLast = function removeLast(cha) {
    if (this.format.compact) return;
    if (!this.isLast(cha)) return;

    this.buf = this.buf.substr(0, this.buf.length - 1);
    this.position.unshift(cha);
  };

  Buffer.prototype.newline = function newline(i, removeLast) {
    if (this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    if (!removeLast) removeLast = false;

    if (isNumber(i)) {
      i = Math.min(2, i);

      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      while (i > 0) {
        this._newline(removeLast);
        i--;
      }
      return;
    }

    if (isBoolean(i)) {
      removeLast = i;
    }

    this._newline(removeLast);
  };

  Buffer.prototype._newline = function _newline(removeLast) {
    // never allow more than two lines
    if (this.endsWith("\n\n")) return;

    // remove the last newline
    if (removeLast && this.isLast("\n")) this.removeLast("\n");

    this.removeLast(" ");
    this._removeSpacesAfterLastNewline();
    this._push("\n");
  };

  /**
   * If buffer ends with a newline and some spaces after it, trim those spaces.
   */

  Buffer.prototype._removeSpacesAfterLastNewline = function _removeSpacesAfterLastNewline() {
    var lastNewlineIndex = this.buf.lastIndexOf("\n");
    if (lastNewlineIndex === -1) return;

    var index = this.buf.length - 1;
    while (index > lastNewlineIndex) {
      if (this.buf[index] !== " ") {
        break;
      }

      index--;
    }

    if (index === lastNewlineIndex) {
      this.buf = this.buf.substring(0, index + 1);
    }
  };

  Buffer.prototype.push = function push(str, noIndent) {
    if (!this.format.compact && this._indent && !noIndent && str !== "\n") {
      // we have an indent level and we aren't pushing a newline
      var indent = this.getIndent();

      // replace all newlines with newlines with the indentation
      str = str.replace(/\n/g, "\n" + indent);

      // we've got a newline before us so prepend on the indentation
      if (this.isLast("\n")) this._push(indent);
    }

    this._push(str);
  };

  Buffer.prototype._push = function _push(str) {
    this.position.push(str);
    this.buf += str;
  };

  Buffer.prototype.endsWith = function endsWith(str) {
    return this.buf.slice(-str.length) === str;
  };

  Buffer.prototype.isLast = function isLast(cha) {
    if (this.format.compact) return false;

    var buf = this.buf;
    var last = buf[buf.length - 1];

    if (Array.isArray(cha)) {
      return includes(cha, last);
    } else {
      return cha === last;
    }
  };

  return Buffer;
})();

module.exports = Buffer;
},{"lodash/collection/includes":306,"lodash/lang/isBoolean":390,"lodash/lang/isNumber":394,"repeating":427,"trim-right":443}],133:[function(require,module,exports){
"use strict";

exports.File = function (node, print) {
  print(node.program);
};

exports.Program = function (node, print) {
  print.sequence(node.body);
};

exports.BlockStatement = function (node, print) {
  if (node.body.length === 0) {
    this.push("{}");
  } else {
    this.push("{");
    this.newline();
    print.sequence(node.body, { indent: true });
    this.removeLast("\n");
    this.rightBrace();
  }
};
},{}],134:[function(require,module,exports){
"use strict";

exports.ClassExpression = exports.ClassDeclaration = function (node, print) {
  this.push("class");

  if (node.id) {
    this.space();
    print(node.id);
  }

  if (node.superClass) {
    this.push(" extends ");
    print(node.superClass);
  }

  this.space();
  print(node.body);
};

exports.ClassBody = function (node, print) {
  if (node.body.length === 0) {
    this.push("{}");
  } else {
    this.push("{");
    this.newline();

    this.indent();
    print.sequence(node.body);
    this.dedent();

    this.rightBrace();
  }
};

exports.MethodDefinition = function (node, print) {
  if (node["static"]) {
    this.push("static ");
  }

  this._method(node, print);
};
},{}],135:[function(require,module,exports){
"use strict";

exports.ComprehensionBlock = function (node, print) {
  this.keyword("for");
  this.push("(");
  print(node.left);
  this.push(" of ");
  print(node.right);
  this.push(")");
};

exports.ComprehensionExpression = function (node, print) {
  this.push(node.generator ? "(" : "[");

  print.join(node.blocks, { separator: " " });
  this.space();

  if (node.filter) {
    this.keyword("if");
    this.push("(");
    print(node.filter);
    this.push(")");
    this.space();
  }

  print(node.body);

  this.push(node.generator ? ")" : "]");
};
},{}],136:[function(require,module,exports){
"use strict";

var isInteger = require("is-integer");
var isNumber = require("lodash/lang/isNumber");
var t = require("../../types");

exports.UnaryExpression = function (node, print) {
  var hasSpace = /[a-z]$/.test(node.operator);
  var arg = node.argument;

  if (t.isUpdateExpression(arg) || t.isUnaryExpression(arg)) {
    hasSpace = true;
  }

  if (t.isUnaryExpression(arg) && arg.operator === "!") {
    hasSpace = false;
  }

  this.push(node.operator);
  if (hasSpace) this.push(" ");
  print(node.argument);
};

exports.UpdateExpression = function (node, print) {
  if (node.prefix) {
    this.push(node.operator);
    print(node.argument);
  } else {
    print(node.argument);
    this.push(node.operator);
  }
};

exports.ConditionalExpression = function (node, print) {
  print(node.test);
  this.space();
  this.push("?");
  this.space();
  print(node.consequent);
  this.space();
  this.push(":");
  this.space();
  print(node.alternate);
};

exports.NewExpression = function (node, print) {
  this.push("new ");
  print(node.callee);
  this.push("(");
  print.list(node.arguments);
  this.push(")");
};

exports.SequenceExpression = function (node, print) {
  print.list(node.expressions);
};

exports.ThisExpression = function () {
  this.push("this");
};

exports.CallExpression = function (node, print) {
  print(node.callee);

  this.push("(");

  var separator = ",";

  if (node._prettyCall) {
    separator += "\n";
    this.newline();
    this.indent();
  } else {
    separator += " ";
  }

  print.list(node.arguments, { separator: separator });

  if (node._prettyCall) {
    this.newline();
    this.dedent();
  }

  this.push(")");
};

var buildYieldAwait = function buildYieldAwait(keyword) {
  return function (node, print) {
    this.push(keyword);

    if (node.delegate || node.all) {
      this.push("*");
    }

    if (node.argument) {
      this.space();
      print(node.argument);
    }
  };
};

exports.YieldExpression = buildYieldAwait("yield");
exports.AwaitExpression = buildYieldAwait("await");

exports.EmptyStatement = function () {
  this.semicolon();
};

exports.ExpressionStatement = function (node, print) {
  print(node.expression);
  this.semicolon();
};

exports.BinaryExpression = exports.LogicalExpression = exports.AssignmentPattern = exports.AssignmentExpression = function (node, print) {
  // todo: add cases where the spaces can be dropped when in compact mode
  print(node.left);
  this.push(" ");
  this.push(node.operator);
  this.push(" ");
  print(node.right);
};

var SCIENTIFIC_NOTATION = /e/i;

exports.MemberExpression = function (node, print) {
  var obj = node.object;
  print(obj);

  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;
  if (t.isLiteral(node.property) && isNumber(node.property.value)) {
    computed = true;
  }

  if (computed) {
    this.push("[");
    print(node.property);
    this.push("]");
  } else {
    // 5..toFixed(2);
    if (t.isLiteral(obj) && isInteger(obj.value) && !SCIENTIFIC_NOTATION.test(obj.value.toString())) {
      this.push(".");
    }

    this.push(".");
    print(node.property);
  }
};
},{"../../types":251,"is-integer":290,"lodash/lang/isNumber":394}],137:[function(require,module,exports){
"use strict";

exports.AnyTypeAnnotation = exports.ArrayTypeAnnotation = exports.BooleanTypeAnnotation = exports.ClassProperty = exports.DeclareClass = exports.DeclareFunction = exports.DeclareModule = exports.DeclareVariable = exports.FunctionTypeAnnotation = exports.FunctionTypeParam = exports.GenericTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.IntersectionTypeAnnotation = exports.NullableTypeAnnotation = exports.NumberTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringTypeAnnotation = exports.TupleTypeAnnotation = exports.TypeofTypeAnnotation = exports.TypeAlias = exports.TypeAnnotation = exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = exports.ObjectTypeAnnotation = exports.ObjectTypeCallProperty = exports.ObjectTypeIndexer = exports.ObjectTypeProperty = exports.QualifiedTypeIdentifier = exports.UnionTypeAnnotation = exports.TypeCastExpression = exports.VoidTypeAnnotation = function () {};

// todo: implement these once we have a `--keep-types` option
},{}],138:[function(require,module,exports){
"use strict";

var t = require("../../types");
var each = require("lodash/collection/each");

exports.JSXAttribute = function (node, print) {
  print(node.name);
  if (node.value) {
    this.push("=");
    print(node.value);
  }
};

exports.JSXIdentifier = function (node) {
  this.push(node.name);
};

exports.JSXNamespacedName = function (node, print) {
  print(node.namespace);
  this.push(":");
  print(node.name);
};

exports.JSXMemberExpression = function (node, print) {
  print(node.object);
  this.push(".");
  print(node.property);
};

exports.JSXSpreadAttribute = function (node, print) {
  this.push("{...");
  print(node.argument);
  this.push("}");
};

exports.JSXExpressionContainer = function (node, print) {
  this.push("{");
  print(node.expression);
  this.push("}");
};

exports.JSXElement = function (node, print) {
  var _this = this;

  var open = node.openingElement;
  print(open);
  if (open.selfClosing) return;

  this.indent();
  each(node.children, function (child) {
    if (t.isLiteral(child)) {
      _this.push(child.value);
    } else {
      print(child);
    }
  });
  this.dedent();

  print(node.closingElement);
};

exports.JSXOpeningElement = function (node, print) {
  this.push("<");
  print(node.name);
  if (node.attributes.length > 0) {
    this.push(" ");
    print.join(node.attributes, { separator: " " });
  }
  this.push(node.selfClosing ? " />" : ">");
};

exports.JSXClosingElement = function (node, print) {
  this.push("</");
  print(node.name);
  this.push(">");
};

exports.JSXEmptyExpression = function () {};
},{"../../types":251,"lodash/collection/each":303}],139:[function(require,module,exports){
"use strict";

var t = require("../../types");

exports._params = function (node, print) {
  this.push("(");
  print.list(node.params);
  this.push(")");
};

exports._method = function (node, print) {
  var value = node.value;
  var kind = node.kind;
  var key = node.key;

  if (!kind || kind === "init") {
    if (value.generator) {
      this.push("*");
    }
  } else {
    this.push(kind + " ");
  }

  if (value.async) this.push("async ");

  if (node.computed) {
    this.push("[");
    print(key);
    this.push("]");
  } else {
    print(key);
  }

  this._params(value, print);
  this.push(" ");
  print(value.body);
};

exports.FunctionDeclaration = exports.FunctionExpression = function (node, print) {
  if (node.async) this.push("async ");
  this.push("function");
  if (node.generator) this.push("*");

  if (node.id) {
    this.push(" ");
    print(node.id);
  } else {
    this.space();
  }

  this._params(node, print);
  this.space();
  print(node.body);
};

exports.ArrowFunctionExpression = function (node, print) {
  if (node.async) this.push("async ");

  if (node.params.length === 1 && t.isIdentifier(node.params[0])) {
    print(node.params[0]);
  } else {
    this._params(node, print);
  }

  this.push(" => ");
  print(node.body);
};
},{"../../types":251}],140:[function(require,module,exports){
"use strict";

var t = require("../../types");
var each = require("lodash/collection/each");

exports.ImportSpecifier = function (node, print) {
  if (t.isSpecifierDefault(node)) {
    print(t.getSpecifierName(node));
  } else {
    return exports.ExportSpecifier.apply(this, arguments);
  }
};

exports.ExportSpecifier = function (node, print) {
  print(node.id);
  if (node.name) {
    this.push(" as ");
    print(node.name);
  }
};

exports.ExportBatchSpecifier = function () {
  this.push("*");
};

exports.ExportDeclaration = function (node, print) {
  this.push("export ");

  var specifiers = node.specifiers;

  if (node["default"]) {
    this.push("default ");
  }

  if (node.declaration) {
    print(node.declaration);
    if (t.isStatement(node.declaration)) return;
  } else {
    if (specifiers.length === 1 && t.isExportBatchSpecifier(specifiers[0])) {
      print(specifiers[0]);
    } else {
      this.push("{");
      if (specifiers.length) {
        this.space();
        print.join(specifiers, { separator: ", " });
        this.space();
      }
      this.push("}");
    }

    if (node.source) {
      this.push(" from ");
      print(node.source);
    }
  }

  this.ensureSemicolon();
};

exports.ImportDeclaration = function (node, print) {
  var _this = this;

  this.push("import ");

  if (node.isType) {
    this.push("type ");
  }

  var specfiers = node.specifiers;
  if (specfiers && specfiers.length) {
    var foundImportSpecifier = false;

    each(node.specifiers, function (spec, i) {
      if (+i > 0) {
        _this.push(", ");
      }

      var isDefault = t.isSpecifierDefault(spec);

      if (!isDefault && spec.type !== "ImportBatchSpecifier" && !foundImportSpecifier) {
        foundImportSpecifier = true;
        _this.push("{ ");
      }

      print(spec);
    });

    if (foundImportSpecifier) {
      this.push(" }");
    }

    this.push(" from ");
  }

  print(node.source);
  this.semicolon();
};

exports.ImportBatchSpecifier = function (node, print) {
  this.push("* as ");
  print(node.name);
};
},{"../../types":251,"lodash/collection/each":303}],141:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

each(["BindMemberExpression", "BindFunctionExpression"], function (type) {
  exports[type] = function () {
    throw new ReferenceError("Trying to render non-standard playground node " + JSON.stringify(type));
  };
});
},{"lodash/collection/each":303}],142:[function(require,module,exports){
"use strict";

var repeating = require("repeating");
var t = require("../../types");

exports.WithStatement = function (node, print) {
  this.keyword("with");
  this.push("(");
  print(node.object);
  this.push(")");
  print.block(node.body);
};

exports.IfStatement = function (node, print) {
  this.keyword("if");
  this.push("(");
  print(node.test);
  this.push(")");
  this.space();

  print.indentOnComments(node.consequent);

  if (node.alternate) {
    if (this.isLast("}")) this.space();
    this.push("else ");
    print.indentOnComments(node.alternate);
  }
};

exports.ForStatement = function (node, print) {
  this.keyword("for");
  this.push("(");

  print(node.init);
  this.push(";");

  if (node.test) {
    this.push(" ");
    print(node.test);
  }
  this.push(";");

  if (node.update) {
    this.push(" ");
    print(node.update);
  }

  this.push(")");
  print.block(node.body);
};

exports.WhileStatement = function (node, print) {
  this.keyword("while");
  this.push("(");
  print(node.test);
  this.push(")");
  print.block(node.body);
};

var buildForXStatement = function buildForXStatement(op) {
  return function (node, print) {
    this.keyword("for");
    this.push("(");
    print(node.left);
    this.push(" " + op + " ");
    print(node.right);
    this.push(")");
    print.block(node.body);
  };
};

exports.ForInStatement = buildForXStatement("in");
exports.ForOfStatement = buildForXStatement("of");

exports.DoWhileStatement = function (node, print) {
  this.keyword("do");
  print(node.body);
  this.space();
  this.keyword("while");
  this.push("(");
  print(node.test);
  this.push(");");
};

var buildLabelStatement = function buildLabelStatement(prefix, key) {
  return function (node, print) {
    this.push(prefix);

    var label = node[key || "label"];
    if (label) {
      this.push(" ");
      print(label);
    }

    this.semicolon();
  };
};

exports.ContinueStatement = buildLabelStatement("continue");
exports.ReturnStatement = buildLabelStatement("return", "argument");
exports.BreakStatement = buildLabelStatement("break");

exports.LabeledStatement = function (node, print) {
  print(node.label);
  this.push(": ");
  print(node.body);
};

exports.TryStatement = function (node, print) {
  this.keyword("try");
  print(node.block);
  this.space();

  // Esprima bug puts the catch clause in a `handlers` array.
  // see https://code.google.com/p/esprima/issues/detail?id=433
  // We run into this from regenerator generated ast.
  if (node.handlers) {
    print(node.handlers[0]);
  } else {
    print(node.handler);
  }

  if (node.finalizer) {
    this.space();
    this.push("finally ");
    print(node.finalizer);
  }
};

exports.CatchClause = function (node, print) {
  this.keyword("catch");
  this.push("(");
  print(node.param);
  this.push(") ");
  print(node.body);
};

exports.ThrowStatement = function (node, print) {
  this.push("throw ");
  print(node.argument);
  this.semicolon();
};

exports.SwitchStatement = function (node, print) {
  this.keyword("switch");
  this.push("(");
  print(node.discriminant);
  this.push(")");
  this.space();
  this.push("{");

  print.sequence(node.cases, {
    indent: true,
    addNewlines: function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    }
  });

  this.push("}");
};

exports.SwitchCase = function (node, print) {
  if (node.test) {
    this.push("case ");
    print(node.test);
    this.push(":");
  } else {
    this.push("default:");
  }

  if (node.consequent.length) {
    this.newline();
    print.sequence(node.consequent, { indent: true });
  }
};

exports.DebuggerStatement = function () {
  this.push("debugger;");
};

exports.VariableDeclaration = function (node, print, parent) {
  this.push(node.kind + " ");

  var hasInits = false;
  // don't add whitespace to loop heads
  if (!t.isFor(parent)) {
    for (var i = 0; i < node.declarations.length; i++) {
      if (node.declarations[i].init) {
        // has an init so let's split it up over multiple lines
        hasInits = true;
      }
    }
  }

  var sep = ",";
  if (!this.format.compact && hasInits) {
    sep += "\n" + repeating(" ", node.kind.length + 1);
  } else {
    sep += " ";
  }

  print.list(node.declarations, { separator: sep });

  if (!t.isFor(parent)) {
    this.semicolon();
  }
};

exports.PrivateDeclaration = function (node, print) {
  this.push("private ");
  print.join(node.declarations, { separator: ", " });
  this.semicolon();
};

exports.VariableDeclarator = function (node, print) {
  if (node.init) {
    print(node.id);
    this.space();
    this.push("=");
    this.space();
    print(node.init);
  } else {
    print(node.id);
  }
};
},{"../../types":251,"repeating":427}],143:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

exports.TaggedTemplateExpression = function (node, print) {
  print(node.tag);
  print(node.quasi);
};

exports.TemplateElement = function (node) {
  this._push(node.value.raw);
};

exports.TemplateLiteral = function (node, print) {
  var _this = this;

  this.push("`");

  var quasis = node.quasis;
  var len = quasis.length;

  each(quasis, function (quasi, i) {
    print(quasi);

    if (i + 1 < len) {
      _this.push("${ ");
      print(node.expressions[i]);
      _this.push(" }");
    }
  });

  this._push("`");
};
},{"lodash/collection/each":303}],144:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

exports.Identifier = function (node) {
  this.push(node.name);
};

exports.RestElement = exports.SpreadElement = exports.SpreadProperty = function (node, print) {
  this.push("...");
  print(node.argument);
};

exports.VirtualPropertyExpression = function (node, print) {
  print(node.object);
  this.push("::");
  print(node.property);
};

exports.ObjectExpression = exports.ObjectPattern = function (node, print) {
  var props = node.properties;

  if (props.length) {
    this.push("{");
    this.space();

    print.list(props, { indent: true });

    this.space();
    this.push("}");
  } else {
    this.push("{}");
  }
};

exports.Property = function (node, print) {
  if (node.method || node.kind === "get" || node.kind === "set") {
    this._method(node, print);
  } else {
    if (node.computed) {
      this.push("[");
      print(node.key);
      this.push("]");
    } else {
      print(node.key);
      if (node.shorthand) return;
    }

    this.push(":");
    this.space();
    print(node.value);
  }
};

exports.ArrayExpression = exports.ArrayPattern = function (node, print) {
  var _this = this;

  var elems = node.elements;
  var len = elems.length;

  this.push("[");

  each(elems, function (elem, i) {
    if (!elem) {
      // If the array expression ends with a hole, that hole
      // will be ignored by the interpreter, but if it ends with
      // two (or more) holes, we need to write out two (or more)
      // commas so that the resulting code is interpreted with
      // both (all) of the holes.
      _this.push(",");
    } else {
      if (i > 0) _this.push(" ");
      print(elem);
      if (i < len - 1) _this.push(",");
    }
  });

  this.push("]");
};

exports.Literal = function (node) {
  var val = node.value;
  var type = typeof val;

  if (type === "string") {
    val = JSON.stringify(val);

    // escape illegal js but valid json unicode characters
    val = val.replace(/[\u000A\u000D\u2028\u2029]/g, function (c) {
      return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    });

    this.push(val);
  } else if (type === "number") {
    this.push(val + "");
  } else if (type === "boolean") {
    this.push(val ? "true" : "false");
  } else if (node.regex) {
    this.push("/" + node.regex.pattern + "/" + node.regex.flags);
  } else if (val === null) {
    this.push("null");
  }
};
},{"lodash/collection/each":303}],145:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var detectIndent = require("detect-indent");
var Whitespace = require("./whitespace");
var repeating = require("repeating");
var SourceMap = require("./source-map");
var Position = require("./position");
var messages = require("../messages");
var Buffer = require("./buffer");
var extend = require("lodash/object/extend");
var each = require("lodash/collection/each");
var n = require("./node");
var t = require("../types");

var CodeGenerator = (function () {
  function CodeGenerator(ast, opts, code) {
    _classCallCheck(this, CodeGenerator);

    if (!opts) opts = {};

    this.comments = ast.comments || [];
    this.tokens = ast.tokens || [];
    this.format = CodeGenerator.normalizeOptions(code, opts);
    this.opts = opts;
    this.ast = ast;

    this.whitespace = new Whitespace(this.tokens, this.comments, this.format);
    this.position = new Position();
    this.map = new SourceMap(this.position, opts, code);
    this.buffer = new Buffer(this.position, this.format);
  }

  CodeGenerator.normalizeOptions = function normalizeOptions(code, opts) {
    var style = "  ";
    if (code) {
      var indent = detectIndent(code).indent;
      if (indent && indent !== " ") style = indent;
    }

    var format = {
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      indent: {
        adjustMultilineComment: true,
        style: style,
        base: 0
      }
    };

    if (format.compact === "auto") {
      format.compact = code.length > 100000; // 100KB

      if (format.compact) {
        console.error(messages.get("codeGeneratorDeopt", opts.filename, "100KB"));
      }
    }

    return format;
  };

  CodeGenerator.generators = {
    templateLiterals: require("./generators/template-literals"),
    comprehensions: require("./generators/comprehensions"),
    expressions: require("./generators/expressions"),
    statements: require("./generators/statements"),
    playground: require("./generators/playground"),
    classes: require("./generators/classes"),
    methods: require("./generators/methods"),
    modules: require("./generators/modules"),
    types: require("./generators/types"),
    flow: require("./generators/flow"),
    base: require("./generators/base"),
    jsx: require("./generators/jsx")
  };

  CodeGenerator.prototype.generate = function generate() {
    var ast = this.ast;

    this.print(ast);

    var comments = [];
    each(ast.comments, function (comment) {
      if (!comment._displayed) comments.push(comment);
    });
    this._printComments(comments);

    return {
      map: this.map.get(),
      code: this.buffer.get()
    };
  };

  CodeGenerator.prototype.buildPrint = function buildPrint(parent) {
    var _this = this;

    var print = function (node, opts) {
      return _this.print(node, parent, opts);
    };

    print.sequence = function (nodes, opts) {
      if (!opts) opts = {};

      opts.statement = true;
      return _this.printJoin(print, nodes, opts);
    };

    print.join = function (nodes, opts) {
      return _this.printJoin(print, nodes, opts);
    };

    print.list = function (items, opts) {
      if (!opts) opts = {};
      var _opts = opts;
      if (!_opts.separator) _opts.separator = ", ";

      print.join(items, opts);
    };

    print.block = function (node) {
      return _this.printBlock(print, node);
    };

    print.indentOnComments = function (node) {
      return _this.printAndIndentOnComments(print, node);
    };

    return print;
  };

  CodeGenerator.prototype.print = function print(node, parent, opts) {
    var _this = this;

    if (!node) return "";

    if (parent && parent._compact) {
      node._compact = true;
    }

    var oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }

    if (!opts) opts = {};

    var newline = function (leading) {
      if (!opts.statement && !n.isUserWhitespacable(node, parent)) {
        return;
      }

      var lines = 0;

      if (node.start != null && !node._ignoreUserWhitespace) {
        // user node
        if (leading) {
          lines = _this.whitespace.getNewlinesBefore(node);
        } else {
          lines = _this.whitespace.getNewlinesAfter(node);
        }
      } else {
        // generated node
        if (!leading) lines++; // always include at least a single line after
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;

        var needs = n.needsWhitespaceAfter;
        if (leading) needs = n.needsWhitespaceBefore;
        if (needs(node, parent)) lines++;

        // generated nodes can't add starting file whitespace
        if (!_this.buffer.buf) lines = 0;
      }

      _this.newline(lines);
    };

    if (this[node.type]) {
      var needsNoLineTermParens = n.needsParensNoLineTerminator(node, parent);
      var needsParens = needsNoLineTermParens || n.needsParens(node, parent);

      if (needsParens) this.push("(");
      if (needsNoLineTermParens) this.indent();

      this.printLeadingComments(node, parent);

      newline(true);

      if (opts.before) opts.before();
      this.map.mark(node, "start");

      this[node.type](node, this.buildPrint(node), parent);

      if (needsNoLineTermParens) {
        this.newline();
        this.dedent();
      }
      if (needsParens) this.push(")");

      this.map.mark(node, "end");
      if (opts.after) opts.after();

      newline(false);

      this.printTrailingComments(node, parent);
    } else {
      throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
    }

    this.format.concise = oldConcise;
  };

  CodeGenerator.prototype.printJoin = function printJoin(print, nodes, opts) {
    var _this = this;

    if (!nodes || !nodes.length) return;

    if (!opts) opts = {};

    var len = nodes.length;

    if (opts.indent) this.indent();

    each(nodes, function (node, i) {
      print(node, {
        statement: opts.statement,
        addNewlines: opts.addNewlines,
        after: function () {
          if (opts.iterator) {
            opts.iterator(node, i);
          }

          if (opts.separator && i < len - 1) {
            _this.push(opts.separator);
          }
        }
      });
    });

    if (opts.indent) this.dedent();
  };

  CodeGenerator.prototype.printAndIndentOnComments = function printAndIndentOnComments(print, node) {
    var indent = !!node.leadingComments;
    if (indent) this.indent();
    print(node);
    if (indent) this.dedent();
  };

  CodeGenerator.prototype.printBlock = function printBlock(print, node) {
    if (t.isEmptyStatement(node)) {
      this.semicolon();
    } else {
      this.push(" ");
      print(node);
    }
  };

  CodeGenerator.prototype.generateComment = function generateComment(comment) {
    var val = comment.value;
    if (comment.type === "Line") {
      val = "//" + val;
    } else {
      val = "/*" + val + "*/";
    }
    return val;
  };

  CodeGenerator.prototype.printTrailingComments = function printTrailingComments(node, parent) {
    this._printComments(this.getComments("trailingComments", node, parent));
  };

  CodeGenerator.prototype.printLeadingComments = function printLeadingComments(node, parent) {
    this._printComments(this.getComments("leadingComments", node, parent));
  };

  CodeGenerator.prototype.getComments = function getComments(key, node, parent) {
    var _this = this;

    if (t.isExpressionStatement(parent)) {
      return [];
    }

    var comments = [];
    var nodes = [node];

    if (t.isExpressionStatement(node)) {
      nodes.push(node.argument);
    }

    each(nodes, function (node) {
      comments = comments.concat(_this._getComments(key, node));
    });

    return comments;
  };

  CodeGenerator.prototype._getComments = function _getComments(key, node) {
    return node && node[key] || [];
  };

  CodeGenerator.prototype._printComments = function _printComments(comments) {
    var _this = this;

    if (this.format.compact) return;

    if (!this.format.comments) return;
    if (!comments || !comments.length) return;

    each(comments, function (comment) {
      var skip = false;

      // find the original comment in the ast and set it as displayed
      each(_this.ast.comments, function (origComment) {
        if (origComment.start === comment.start) {
          // comment has already been output
          if (origComment._displayed) skip = true;

          origComment._displayed = true;
          return false;
        }
      });

      if (skip) return;

      // whitespace before
      _this.newline(_this.whitespace.getNewlinesBefore(comment));

      var column = _this.position.column;
      var val = _this.generateComment(comment);

      if (column && !_this.isLast(["\n", " ", "[", "{"])) {
        _this._push(" ");
        column++;
      }

      //

      if (comment.type === "Block" && _this.format.indent.adjustMultilineComment) {
        var offset = comment.loc.start.column;
        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indent = Math.max(_this.indentSize(), column);
        val = val.replace(/\n/g, "\n" + repeating(" ", indent));
      }

      if (column === 0) {
        val = _this.getIndent() + val;
      }

      //

      _this._push(val);

      // whitespace after
      _this.newline(_this.whitespace.getNewlinesAfter(comment));
    });
  };

  return CodeGenerator;
})();

each(Buffer.prototype, function (fn, key) {
  CodeGenerator.prototype[key] = function () {
    return fn.apply(this.buffer, arguments);
  };
});

each(CodeGenerator.generators, function (generator) {
  extend(CodeGenerator.prototype, generator);
});

module.exports = function (ast, opts, code) {
  var gen = new CodeGenerator(ast, opts, code);
  return gen.generate();
};

module.exports.CodeGenerator = CodeGenerator;
},{"../messages":157,"../types":251,"./buffer":132,"./generators/base":133,"./generators/classes":134,"./generators/comprehensions":135,"./generators/expressions":136,"./generators/flow":137,"./generators/jsx":138,"./generators/methods":139,"./generators/modules":140,"./generators/playground":141,"./generators/statements":142,"./generators/template-literals":143,"./generators/types":144,"./node":146,"./position":149,"./source-map":150,"./whitespace":151,"detect-indent":282,"lodash/collection/each":303,"lodash/object/extend":401,"repeating":427}],146:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var whitespace = require("./whitespace");
var parens = require("./parentheses");
var each = require("lodash/collection/each");
var some = require("lodash/collection/some");
var t = require("../../types");

var find = function find(obj, node, parent) {
  if (!obj) return;
  var result;

  var types = Object.keys(obj);
  for (var i = 0; i < types.length; i++) {
    var type = types[i];

    if (t.is(type, node)) {
      var fn = obj[type];
      result = fn(node, parent);
      if (result != null) break;
    }
  }

  return result;
};

var Node = (function () {
  function Node(node, parent) {
    _classCallCheck(this, Node);

    this.parent = parent;
    this.node = node;
  }

  Node.isUserWhitespacable = function isUserWhitespacable(node) {
    return t.isUserWhitespacable(node);
  };

  Node.needsWhitespace = function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (t.isExpressionStatement(node)) {
      node = node.expression;
    }

    var linesInfo = find(whitespace.nodes, node, parent);

    if (!linesInfo) {
      var items = find(whitespace.list, node, parent);
      if (items) {
        for (var i = 0; i < items.length; i++) {
          linesInfo = Node.needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    return linesInfo && linesInfo[type] || 0;
  };

  Node.needsWhitespaceBefore = function needsWhitespaceBefore(node, parent) {
    return Node.needsWhitespace(node, parent, "before");
  };

  Node.needsWhitespaceAfter = function needsWhitespaceAfter(node, parent) {
    return Node.needsWhitespace(node, parent, "after");
  };

  Node.needsParens = function needsParens(node, parent) {
    if (!parent) return false;

    if (t.isNewExpression(parent) && parent.callee === node) {
      if (t.isCallExpression(node)) return true;

      var hasCall = some(node, function (val) {
        return t.isCallExpression(val);
      });
      if (hasCall) return true;
    }

    return find(parens, node, parent);
  };

  Node.needsParensNoLineTerminator = function needsParensNoLineTerminator(node, parent) {
    if (!parent) return false;

    // no comments
    if (!node.leadingComments || !node.leadingComments.length) {
      return false;
    }

    if (t.isYieldExpression(parent) || t.isAwaitExpression(parent)) {
      return true;
    }

    if (t.isContinueStatement(parent) || t.isBreakStatement(parent) || t.isReturnStatement(parent) || t.isThrowStatement(parent)) {
      return true;
    }

    return false;
  };

  return Node;
})();

module.exports = Node;

each(Node, function (fn, key) {
  Node.prototype[key] = function () {
    // Avoid leaking arguments to prevent deoptimization
    var args = new Array(arguments.length + 2);

    args[0] = this.node;
    args[1] = this.parent;

    for (var i = 0; i < args.length; i++) {
      args[i + 2] = arguments[i];
    }

    return Node[key].apply(null, args);
  };
});
},{"../../types":251,"./parentheses":147,"./whitespace":148,"lodash/collection/each":303,"lodash/collection/some":309}],147:[function(require,module,exports){
"use strict";

var t = require("../../types");
var each = require("lodash/collection/each");

var PRECEDENCE = {};

each([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]], function (tier, i) {
  each(tier, function (op) {
    PRECEDENCE[op] = i;
  });
});

exports.UpdateExpression = function (node, parent) {
  if (t.isMemberExpression(parent) && parent.object === node) {
    // (foo++).test()
    return true;
  }
};

exports.ObjectExpression = function (node, parent) {
  if (t.isExpressionStatement(parent)) {
    // ({ foo: "bar" });
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    // ({ foo: "bar" }).foo
    return true;
  }

  return false;
};

exports.Binary = function (node, parent) {
  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {
    return true;
  }

  if (t.isUnaryLike(parent)) {
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  if (t.isBinary(parent)) {
    var parentOp = parent.operator;
    var parentPos = PRECEDENCE[parentOp];

    var nodeOp = node.operator;
    var nodePos = PRECEDENCE[nodeOp];

    if (parentPos > nodePos) {
      return true;
    }

    if (parentPos === nodePos && parent.right === node) {
      return true;
    }
  }
};

exports.BinaryExpression = function (node, parent) {
  if (node.operator === "in") {
    // var i = (1 in []);
    if (t.isVariableDeclarator(parent)) {
      return true;
    }

    // for ((1 in []);;);
    if (t.isFor(parent)) {
      return true;
    }
  }
};

exports.SequenceExpression = function (node, parent) {
  if (t.isForStatement(parent)) {
    // Although parentheses wouldn't hurt around sequence
    // expressions in the head of for loops, traditional style
    // dictates that e.g. i++, j++ should not be wrapped with
    // parentheses.
    return false;
  }

  if (t.isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  // Otherwise err on the side of overparenthesization, adding
  // explicit exceptions above if this proves overzealous.
  return true;
};

exports.YieldExpression = function (node, parent) {
  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) || t.isYieldExpression(parent);
};

exports.ClassExpression = function (node, parent) {
  return t.isExpressionStatement(parent);
};

exports.UnaryLike = function (node, parent) {
  return t.isMemberExpression(parent) && parent.object === node;
};

exports.FunctionExpression = function (node, parent) {
  // function () {};
  if (t.isExpressionStatement(parent)) {
    return true;
  }

  // (function test() {}).name;
  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  // (function () {})();
  if (t.isCallExpression(parent) && parent.callee === node) {
    return true;
  }
};

exports.AssignmentExpression = exports.ConditionalExpression = function (node, parent) {
  if (t.isUnaryLike(parent)) {
    return true;
  }

  if (t.isBinary(parent)) {
    return true;
  }

  if (t.isCallExpression(parent) || t.isNewExpression(parent)) {
    if (parent.callee === node) {
      return true;
    }
  }

  if (t.isConditionalExpression(parent) && parent.test === node) {
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  return false;
};
},{"../../types":251,"lodash/collection/each":303}],148:[function(require,module,exports){
"use strict";

var isBoolean = require("lodash/lang/isBoolean");
var each = require("lodash/collection/each");
var map = require("lodash/collection/map");
var t = require("../../types");

var crawl = (function (_crawl) {
  var _crawlWrapper = function crawl() {
    return _crawl.apply(this, arguments);
  };

  _crawlWrapper.toString = function () {
    return _crawl.toString();
  };

  return _crawlWrapper;
})(function (node, state) {
  if (!state) state = {};

  if (t.isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t.isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t.isFunction(node)) {
    state.hasFunction = true;
  } else if (t.isIdentifier(node)) {
    var _state = state;
    if (!_state.hasHelper) _state.hasHelper = isHelper(node.callee);
  }

  return state;
});

var isHelper = (function (_isHelper) {
  var _isHelperWrapper = function isHelper() {
    return _isHelper.apply(this, arguments);
  };

  _isHelperWrapper.toString = function () {
    return _isHelper.toString();
  };

  return _isHelperWrapper;
})(function (node) {
  if (t.isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t.isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t.isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
  } else {
    return false;
  }
});

var isType = function isType(node) {
  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
};

exports.nodes = {
  AssignmentExpression: function AssignmentExpression(node) {
    var state = crawl(node.right);
    if (state.hasCall && state.hasHelper || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true
      };
    }
  },

  SwitchCase: function SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node
    };
  },

  LogicalExpression: function LogicalExpression(node) {
    if (t.isFunction(node.left) || t.isFunction(node.right)) {
      return {
        after: true
      };
    }
  },

  Literal: function Literal(node) {
    if (node.value === "use strict") {
      return {
        after: true
      };
    }
  },

  CallExpression: function CallExpression(node) {
    if (t.isFunction(node.callee) || isHelper(node)) {
      return {
        before: true,
        after: true
      };
    }
  },

  VariableDeclaration: function VariableDeclaration(node) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];

      var enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled) {
        var state = crawl(declar.init);
        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
      }

      if (enabled) {
        return {
          before: true,
          after: true
        };
      }
    }
  },

  IfStatement: function IfStatement(node) {
    if (t.isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true
      };
    }
  }
};

exports.nodes.Property = exports.nodes.SpreadProperty = function (node, parent) {
  if (parent.properties[0] === node) {
    return {
      before: true
    };
  }
};

exports.list = {
  VariableDeclaration: function VariableDeclaration(node) {
    return map(node.declarations, "init");
  },

  ArrayExpression: function ArrayExpression(node) {
    return node.elements;
  },

  ObjectExpression: function ObjectExpression(node) {
    return node.properties;
  }
};

each({
  Function: true,
  Class: true,
  Loop: true,
  LabeledStatement: true,
  SwitchStatement: true,
  TryStatement: true
}, function (amounts, type) {
  if (isBoolean(amounts)) {
    amounts = { after: amounts, before: amounts };
  }

  each([type].concat(t.FLIPPED_ALIAS_KEYS[type] || []), function (type) {
    exports.nodes[type] = function () {
      return amounts;
    };
  });
});
},{"../../types":251,"lodash/collection/each":303,"lodash/collection/map":307,"lodash/lang/isBoolean":390}],149:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Position = (function () {
  function Position() {
    _classCallCheck(this, Position);

    this.line = 1;
    this.column = 0;
  }

  Position.prototype.push = function push(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this.line++;
        this.column = 0;
      } else {
        this.column++;
      }
    }
  };

  Position.prototype.unshift = function unshift(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this.line--;
      } else {
        this.column--;
      }
    }
  };

  return Position;
})();

module.exports = Position;
},{}],150:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var sourceMap = require("source-map");
var t = require("../types");

var SourceMap = (function () {
  function SourceMap(position, opts, code) {
    _classCallCheck(this, SourceMap);

    this.position = position;
    this.opts = opts;

    if (opts.sourceMap) {
      this.map = new sourceMap.SourceMapGenerator({
        file: opts.sourceMapName,
        sourceRoot: opts.sourceRoot
      });

      this.map.setSourceContent(opts.sourceFileName, code);
    } else {
      this.map = null;
    }
  }

  SourceMap.prototype.get = function get() {
    var map = this.map;
    if (map) {
      return map.toJSON();
    } else {
      return map;
    }
  };

  SourceMap.prototype.mark = function mark(node, type) {
    var loc = node.loc;
    if (!loc) return; // no location info

    var map = this.map;
    if (!map) return; // no source map

    if (t.isProgram(node) || t.isFile(node)) return; // illegal mapping nodes

    var position = this.position;

    var generated = {
      line: position.line,
      column: position.column
    };

    var original = loc[type];

    map.addMapping({
      source: this.opts.sourceFileName,
      generated: generated,
      original: original
    });
  };

  return SourceMap;
})();

module.exports = SourceMap;
},{"../types":251,"source-map":432}],151:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var sortBy = require("lodash/collection/sortBy");

/**
 * Returns `i`th number from `base`, continuing from 0 when `max` is reached.
 * Useful for shifting `for` loop by a fixed number but going over all items.
 *
 * @param {Number} i Current index in the loop
 * @param {Number} base Start index for which to return 0
 * @param {Number} max Array length
 * @returns {Number} shiftedIndex
 */

function getLookupIndex(i, base, max) {
  i += base;

  if (i >= max) {
    i -= max;
  }

  return i;
}

var Whitespace = (function () {
  function Whitespace(tokens, comments) {
    _classCallCheck(this, Whitespace);

    this.tokens = sortBy(tokens.concat(comments), "start");
    this.used = {};

    // Profiling this code shows that while generator passes over it, indexes
    // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.

    // We use this implementation detail for an optimization: instead of always
    // starting to look from `this.tokens[0]`, we will start `for` loops from the
    // previous successful match. We will enumerate all tokens—but the common
    // case will be much faster.

    this._lastFoundIndex = 0;
  }

  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {
    var startToken;
    var endToken;
    var tokens = this.tokens;
    var token;

    for (var j = 0; j < tokens.length; j++) {
      // optimize for forward traversal by shifting for loop index
      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
      token = tokens[i];

      // this is the token this node starts with
      if (node.start === token.start) {
        startToken = tokens[i - 1];
        endToken = token;

        this._lastFoundIndex = i;
        break;
      }
    }

    return this.getNewlinesBetween(startToken, endToken);
  };

  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {
    var startToken;
    var endToken;
    var tokens = this.tokens;
    var token;

    for (var j = 0; j < tokens.length; j++) {
      // optimize for forward traversal by shifting for loop index
      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
      token = tokens[i];

      // this is the token this node ends with
      if (node.end === token.end) {
        startToken = token;
        endToken = tokens[i + 1];

        this._lastFoundIndex = i;
        break;
      }
    }

    if (endToken && endToken.type.type === "eof") {
      return 1;
    } else {
      var lines = this.getNewlinesBetween(startToken, endToken);
      if (node.type === "Line" && !lines) {
        // line comment
        return 1;
      } else {
        return lines;
      }
    }
  };

  Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {
    if (!endToken || !endToken.loc) return 0;

    var start = startToken ? startToken.loc.end.line : 1;
    var end = endToken.loc.start.line;
    var lines = 0;

    for (var line = start; line < end; line++) {
      if (typeof this.used[line] === "undefined") {
        this.used[line] = true;
        lines++;
      }
    }

    return lines;
  };

  return Whitespace;
})();

module.exports = Whitespace;
},{"lodash/collection/sortBy":310}],152:[function(require,module,exports){
"use strict";

var lineNumbers = require("line-numbers");
var repeating = require("repeating");
var jsTokens = require("js-tokens");
var esutils = require("esutils");
var chalk = require("chalk");
var ary = require("lodash/function/ary");

var defs = {
  string: chalk.red,
  punctuation: chalk.white.bold,
  operator: chalk.white.bold,
  curly: chalk.green,
  parens: chalk.blue.bold,
  square: chalk.yellow,
  name: chalk.white,
  keyword: chalk.cyan,
  number: chalk.magenta,
  regex: chalk.magenta,
  comment: chalk.grey,
  invalid: chalk.inverse
};

var newline = /\r\n|[\n\r\u2028\u2029]/;

var highlight = function highlight(text) {
  var tokenType = function tokenType(match) {
    var token = jsTokens.matchToToken(match);
    if (token.type === "name" && esutils.keyword.isKeywordES6(token.value)) {
      return "keyword";
    }

    if (token.type === "punctuation") {
      switch (token.value) {
        case "{":
        case "}":
          return "curly";
        case "(":
        case ")":
          return "parens";
        case "[":
        case "]":
          return "square";
      }
    }

    return token.type;
  };

  return text.replace(jsTokens, function (match) {
    var type = tokenType(arguments);
    if (type in defs) {
      var colorize = ary(defs[type], 1);
      return match.split(newline).map(colorize).join("\n");
    }
    return match;
  });
};

module.exports = function (lines, lineNumber, colNumber) {
  colNumber = Math.max(colNumber, 0);

  if (chalk.supportsColor) {
    lines = highlight(lines);
  }

  lines = lines.split(newline);

  var start = Math.max(lineNumber - 3, 0);
  var end = Math.min(lines.length, lineNumber + 3);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  return "\n" + lineNumbers(lines.slice(start, end), {
    start: start + 1,
    before: "  ",
    after: " | ",
    transform: function transform(params) {
      if (params.number !== lineNumber) {
        return;
      }
      if (colNumber) {
        params.line += "\n" + params.before + repeating(" ", params.width) + params.after + repeating(" ", colNumber - 1) + "^";
      }
      params.before = params.before.replace(/^./, ">");
    }
  }).join("\n");
};
},{"chalk":269,"esutils":287,"js-tokens":293,"line-numbers":295,"lodash/function/ary":312,"repeating":427}],153:[function(require,module,exports){
"use strict";

var t = require("../types");

module.exports = function (ast, comments, tokens) {
  if (ast && ast.type === "Program") {
    return t.file(ast, comments || [], tokens || []);
  } else {
    throw new Error("Not a valid ast?");
  }
};
},{"../types":251}],154:[function(require,module,exports){
"use strict";

module.exports = function () {
  return Object.create(null);
};
},{}],155:[function(require,module,exports){
"use strict";

var normalizeAst = require("./normalize-ast");
var estraverse = require("estraverse");
var codeFrame = require("./code-frame");
var acorn = require("acorn-babel");

module.exports = function (opts, code, callback) {
  try {
    var comments = [];
    var tokens = [];

    var ast = acorn.parse(code, {
      allowImportExportEverywhere: opts.allowImportExportEverywhere,
      allowReturnOutsideFunction: !opts._anal,
      ecmaVersion: opts.experimental ? 7 : 6,
      playground: opts.playground,
      strictMode: opts.strictMode,
      onComment: comments,
      locations: true,
      onToken: tokens,
      ranges: true
    });

    estraverse.attachComments(ast, comments, tokens);

    ast = normalizeAst(ast, comments, tokens);

    if (callback) {
      return callback(ast);
    } else {
      return ast;
    }
  } catch (err) {
    if (!err._babel) {
      err._babel = true;
      var message = opts.filename + ": " + err.message;

      var loc = err.loc;
      if (loc) {
        var frame = codeFrame(code, loc.line, loc.column + 1);
        message += frame;
      }

      if (err.stack) err.stack = err.stack.replace(err.message, message);
      err.message = message;
    }

    throw err;
  }
};
},{"./code-frame":152,"./normalize-ast":153,"acorn-babel":254,"estraverse":283}],156:[function(require,module,exports){
"use strict";

/**
 * A trick from Bluebird to force V8 to use fast properties for an object.
 * Read more: http://stackoverflow.com/questions/24987896/
 *
 * Use %HasFastProperties(obj) and --allow-natives-syntax to check whether
 * a particular object already has fast properties.
 */

module.exports = function toFastProperties(obj) {
  /*jshint -W027*/
  function f() {}
  f.prototype = obj;
  return f;
  eval(obj);
};
},{}],157:[function(require,module,exports){
"use strict";

var util = require("util");

exports.messages = {
  tailCallReassignmentDeopt: "Function reference has been reassigned so it's probably be dereferenced so we can't optimise this with confidence",
  JSXNamespacedTags: "Namespace tags are not supported. ReactJSX is not XML.",
  classesIllegalBareSuper: "Illegal use of bare super",
  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
  classesIllegalConstructorKind: "Illegal kind for constructor method",
  scopeDuplicateDeclaration: "Duplicate declaration $1",
  undeclaredVariable: "Reference to undeclared variable $1",
  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
  settersInvalidParamLength: "Setters must have exactly one parameter",
  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
  expectedMemberExpressionOrIdentifier: "Expected type MemeberExpression or Identifier",
  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
  readOnly: "$1 is read-only",
  modulesIllegalExportName: "Illegal export $1",
  unknownForHead: "Unknown node type $1 in ForStatement",
  didYouMean: "Did you mean $1?",
  evalInStrictMode: "eval is not allowed in strict mode",
  codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2."
};

exports.get = function (key) {
  var msg = exports.messages[key];
  if (!msg) throw new ReferenceError("Unknown message `" + key + "`");

  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }
  args = exports.parseArgs(args);

  return msg.replace(/\$(\d+)/g, function (str, i) {
    return args[--i];
  });
};

exports.parseArgs = function (args) {
  return args.map(function (val) {
    if (val != null && val.inspect) {
      return val.inspect();
    } else {
      try {
        return JSON.stringify(val) || val + "";
      } catch (e) {
        return util.inspect(val);
      }
    }
  });
};
},{"util":723}],158:[function(require,module,exports){
"use strict";

var extend = require("lodash/object/extend");
var t = require("./types");

// estraverse

var estraverse = require("estraverse");
extend(estraverse.VisitorKeys, t.VISITOR_KEYS);

// regenerator-babel/ast-types

var types = require("ast-types");
var def = types.Type.def;
var or = types.Type.or;

def("File").bases("Node").build("program").field("program", def("Program"));

def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));

// Acorn - Same as ImportNamespaceSpecifier but `id` is `name`
def("ImportBatchSpecifier").bases("Specifier").build("name").field("name", def("Identifier"));

def("RestElement").bases("Pattern").build("argument").field("argument", def("expression"));

// Abstract references
def("VirtualPropertyExpression").bases("Expression").build("object", "property").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression")));

def("PrivateDeclaration").bases("Declaration").build("declarations").field("declarations", [def("Identifier")]);

// Playground
def("BindMemberExpression").bases("Expression").build("object", "property", "arguments").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("arguments", [def("Expression")]);

def("BindFunctionExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);

types.finalize();
},{"./types":251,"ast-types":268,"estraverse":283,"lodash/object/extend":401}],159:[function(require,module,exports){
(function (global){
"use strict";

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;

require("core-js/shim");
require("regenerator-babel/runtime");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/shim":278,"regenerator-babel/runtime":420}],160:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var sourceMapToComment = require("source-map-to-comment");
var shebangRegex = require("shebang-regex");
var isFunction = require("lodash/lang/isFunction");
var transform = require("./index");
var generate = require("../generation");
var defaults = require("lodash/object/defaults");
var includes = require("lodash/collection/includes");
var assign = require("lodash/object/assign");
var parse = require("../helpers/parse");
var Scope = require("../traversal/scope");
var slash = require("slash");
var util = require("../util");
var path = require("path");
var each = require("lodash/collection/each");
var t = require("../types");

var checkTransformerVisitor = {
  enter: function enter(node, parent, scope, state) {
    checkNode(state.stack, node, scope);
  }
};

var checkNode = function checkNode(stack, node, scope) {
  each(stack, function (pass) {
    if (pass.shouldRun) return;
    pass.checkNode(node, scope);
  });
};

var File = (function () {
  function File(opts) {
    _classCallCheck(this, File);

    this.dynamicImportedNoDefault = [];
    this.dynamicImportIds = {};
    this.dynamicImported = [];
    this.dynamicImports = [];

    this.usedHelpers = {};
    this.dynamicData = {};
    this.data = {};

    this.lastStatements = [];
    this.opts = this.normalizeOptions(opts);
    this.ast = {};

    this.buildTransformers();
  }

  File.helpers = ["inherits", "defaults", "prototype-properties", "apply-constructor", "tagged-template-literal", "tagged-template-literal-loose", "interop-require", "to-array", "to-consumable-array", "sliced-to-array", "object-without-properties", "has-own", "slice", "bind", "define-property", "async-to-generator", "interop-require-wildcard", "typeof", "extends", "get", "set", "class-call-check", "object-destructuring-empty", "temporal-undefined", "temporal-assert-defined", "self-global"];
  File.validOptions = ["filename", "filenameRelative", "blacklist", "whitelist", "loose", "optional", "modules", "sourceMap", "sourceMapName", "sourceFileName", "sourceRoot", "moduleRoot", "moduleIds", "comments", "reactCompat", "keepModuleIdExtensions", "code", "ast", "playground", "experimental", "externalHelpers", "auxiliaryComment", "compact", "returnUsedHelpers", "resolveModuleSource", "moduleId",

  // legacy
  "format",

  // these are used by plugins
  "ignore", "only", "extensions", "accept"];

  File.prototype.normalizeOptions = function normalizeOptions(opts) {
    opts = assign({}, opts);

    for (var key in opts) {
      if (key[0] !== "_" && File.validOptions.indexOf(key) < 0) {
        throw new ReferenceError("Unknown option: " + key);
      }
    }

    defaults(opts, {
      keepModuleIdExtensions: false,
      resolveModuleSource: null,
      returnUsedHelpers: false,
      externalHelpers: false,
      auxilaryComment: "",
      experimental: false,
      reactCompat: false,
      playground: false,
      moduleIds: false,
      blacklist: [],
      whitelist: [],
      sourceMap: false,
      optional: [],
      comments: true,
      filename: "unknown",
      modules: "common",
      compact: "auto",
      loose: [],
      code: true,
      ast: true
    });

    // normalize windows path separators to unix
    opts.filename = slash(opts.filename);
    if (opts.sourceRoot) {
      opts.sourceRoot = slash(opts.sourceRoot);
    }

    if (opts.moduleId) {
      opts.moduleIds = true;
    }

    opts.basename = path.basename(opts.filename, path.extname(opts.filename));

    opts.blacklist = util.arrayify(opts.blacklist);
    opts.whitelist = util.arrayify(opts.whitelist);
    opts.optional = util.arrayify(opts.optional);
    opts.compact = util.booleanify(opts.compact);
    opts.loose = util.arrayify(opts.loose);

    if (includes(opts.loose, "all") || includes(opts.loose, true)) {
      opts.loose = Object.keys(transform.transformers);
    }

    defaults(opts, {
      moduleRoot: opts.sourceRoot
    });

    defaults(opts, {
      sourceRoot: opts.moduleRoot
    });

    defaults(opts, {
      filenameRelative: opts.filename
    });

    defaults(opts, {
      sourceFileName: opts.filenameRelative,
      sourceMapName: opts.filenameRelative
    });

    if (opts.playground) {
      opts.experimental = true;
    }

    if (opts.externalHelpers) {
      this.set("helpersNamespace", t.identifier("babelHelpers"));
    }

    opts.blacklist = transform._ensureTransformerNames("blacklist", opts.blacklist);
    opts.whitelist = transform._ensureTransformerNames("whitelist", opts.whitelist);
    opts.optional = transform._ensureTransformerNames("optional", opts.optional);
    opts.loose = transform._ensureTransformerNames("loose", opts.loose);

    if (opts.reactCompat) {
      opts.optional.push("reactCompat");
      console.error("The reactCompat option has been moved into the optional transformer `reactCompat`");
    }

    var ensureEnabled = function ensureEnabled(key) {
      var namespace = transform.transformerNamespaces[key];
      if (namespace === "es7") opts.experimental = true;
      if (namespace === "playground") opts.playground = true;
    };

    each(opts.whitelist, ensureEnabled);
    each(opts.optional, ensureEnabled);

    return opts;
  };

  File.prototype.isLoose = function isLoose(key) {
    return includes(this.opts.loose, key);
  };

  File.prototype.buildTransformers = function buildTransformers() {
    var file = this;

    var transformers = {};

    var secondaryStack = [];
    var stack = [];

    each(transform.transformers, function (transformer, key) {
      var pass = transformers[key] = transformer.buildPass(file);

      if (pass.canRun(file)) {
        stack.push(pass);

        if (transformer.secondPass) {
          secondaryStack.push(pass);
        }

        if (transformer.manipulateOptions) {
          transformer.manipulateOptions(file.opts, file);
        }
      }
    });

    this.transformerStack = stack.concat(secondaryStack);
    this.transformers = transformers;
  };

  File.prototype.debug = function debug(msg) {
    var parts = this.opts.filename;
    if (msg) parts += ": " + msg;
    util.debug(parts);
  };

  File.prototype.getModuleFormatter = function getModuleFormatter(type) {
    var ModuleFormatter = isFunction(type) ? type : transform.moduleFormatters[type];

    if (!ModuleFormatter) {
      var loc = util.resolve(type);
      if (loc) ModuleFormatter = require(loc);
    }

    if (!ModuleFormatter) {
      throw new ReferenceError("Unknown module formatter type " + JSON.stringify(type));
    }

    return new ModuleFormatter(this);
  };

  File.prototype.parseShebang = function parseShebang(code) {
    var shebangMatch = shebangRegex.exec(code);

    if (shebangMatch) {
      this.shebang = shebangMatch[0];

      // remove shebang
      code = code.replace(shebangRegex, "");
    }

    return code;
  };

  File.prototype.set = function set(key, val) {
    return this.data[key] = val;
  };

  File.prototype.setDynamic = function setDynamic(key, fn) {
    this.dynamicData[key] = fn;
  };

  File.prototype.get = function get(key) {
    var data = this.data[key];
    if (data) {
      return data;
    } else {
      var dynamic = this.dynamicData[key];
      if (dynamic) {
        return this.set(key, dynamic());
      }
    }
  };

  File.prototype.addImport = function addImport(source, name, noDefault) {
    if (!name) name = source;

    var id = this.dynamicImportIds[name];

    if (!id) {
      id = this.dynamicImportIds[name] = this.scope.generateUidIdentifier(name);

      var specifiers = [t.importSpecifier(t.identifier("default"), id)];
      var declar = t.importDeclaration(specifiers, t.literal(source));
      declar._blockHoist = 3;

      this.dynamicImported.push(declar);
      if (noDefault) this.dynamicImportedNoDefault.push(declar);

      this.moduleFormatter.importSpecifier(specifiers[0], declar, this.dynamicImports);
    }

    return id;
  };

  File.prototype.isConsequenceExpressionStatement = function isConsequenceExpressionStatement(node) {
    return t.isExpressionStatement(node) && this.lastStatements.indexOf(node) >= 0;
  };

  File.prototype.attachAuxiliaryComment = function attachAuxiliaryComment(node) {
    var comment = this.opts.auxiliaryComment;
    if (comment) {
      var _node = node;
      if (!_node.leadingComments) _node.leadingComments = [];

      node.leadingComments.push({
        type: "Line",
        value: " " + comment
      });
    }
    return node;
  };

  File.prototype.addHelper = function addHelper(name) {
    if (!includes(File.helpers, name)) {
      throw new ReferenceError("Unknown helper " + name);
    }

    var program = this.ast.program;

    var declar = program._declarations && program._declarations[name];
    if (declar) return declar.id;

    this.usedHelpers[name] = true;

    var runtime = this.get("helpersNamespace");
    if (runtime) {
      name = t.identifier(t.toIdentifier(name));
      return t.memberExpression(runtime, name);
    } else {
      var ref = util.template(name);
      ref._compact = true;
      var uid = this.scope.generateUidIdentifier(name);
      this.scope.push({
        key: name,
        id: uid,
        init: ref
      });
      return uid;
    }
  };

  File.prototype.logDeopt = function logDeopt() {};

  File.prototype.errorWithNode = function errorWithNode(node, msg, Error) {
    if (!Error) Error = SyntaxError;

    var loc = node.loc.start;
    var err = new Error("Line " + loc.line + ": " + msg);
    err.loc = loc;
    return err;
  };

  File.prototype.addCode = function addCode(code) {
    code = (code || "") + "";
    this.code = code;
    return this.parseShebang(code);
  };

  File.prototype.parse = (function (_parse) {
    var _parseWrapper = function parse() {
      return _parse.apply(this, arguments);
    };

    _parseWrapper.toString = function () {
      return _parse.toString();
    };

    return _parseWrapper;
  })(function (code) {
    var _this = this;

    code = this.addCode(code);

    var opts = this.opts;

    opts.allowImportExportEverywhere = this.isLoose("es6.modules");
    opts.strictMode = this.transformers.useStrict.canRun();

    return parse(opts, code, function (tree) {
      _this.transform(tree);
      return _this.generate();
    });
  });

  File.prototype.transform = function transform(ast) {
    this.debug();

    this.ast = ast;
    this.lastStatements = t.getLastStatements(ast.program);
    this.scope = new Scope(ast.program, ast, null, this);

    var modFormatter = this.moduleFormatter = this.getModuleFormatter(this.opts.modules);
    if (modFormatter.init && this.transformers["es6.modules"].canRun()) {
      modFormatter.init();
    }

    this.checkNode(ast);

    this.call("pre");

    each(this.transformerStack, function (pass) {
      pass.transform();
    });

    this.call("post");
  };

  File.prototype.call = function call(key) {
    var stack = this.transformerStack;
    for (var i = 0; i < stack.length; i++) {
      var transformer = stack[i].transformer;
      if (transformer[key]) {
        transformer[key](this);
      }
    }
  };

  File.prototype.checkNode = (function (_checkNode) {
    var _checkNodeWrapper = function checkNode() {
      return _checkNode.apply(this, arguments);
    };

    _checkNodeWrapper.toString = function () {
      return _checkNode.toString();
    };

    return _checkNodeWrapper;
  })(function (node, scope) {
    var stack = this.transformerStack;
    if (!scope) scope = this.scope;

    checkNode(stack, node, scope);

    scope.traverse(node, checkTransformerVisitor, {
      stack: stack
    });
  });

  File.prototype.generate = (function (_generate) {
    var _generateWrapper = function generate() {
      return _generate.apply(this, arguments);
    };

    _generateWrapper.toString = function () {
      return _generate.toString();
    };

    return _generateWrapper;
  })(function () {
    var opts = this.opts;
    var ast = this.ast;

    var result = {
      code: "",
      map: null,
      ast: null
    };

    if (this.opts.returnUsedHelpers) {
      result.usedHelpers = Object.keys(this.usedHelpers);
    }

    if (opts.ast) result.ast = ast;
    if (!opts.code) return result;

    var _result = generate(ast, opts, this.code);
    result.code = _result.code;
    result.map = _result.map;

    if (this.shebang) {
      // add back shebang
      result.code = this.shebang + "\n" + result.code;
    }

    if (opts.sourceMap === "inline") {
      result.code += "\n" + sourceMapToComment(result.map);
      result.map = null;
    }

    return result;
  });

  return File;
})();

module.exports = File;

// todo, (node, msg)
},{"../generation":145,"../helpers/parse":155,"../traversal/scope":248,"../types":251,"../util":253,"./index":173,"lodash/collection/each":303,"lodash/collection/includes":306,"lodash/lang/isFunction":392,"lodash/object/assign":399,"lodash/object/defaults":400,"path":706,"shebang-regex":429,"slash":430,"source-map-to-comment":431}],161:[function(require,module,exports){
"use strict";

var explode = require("./explode-assignable-expression");
var t = require("../../types");

module.exports = function (exports, opts) {
  var isAssignment = function isAssignment(node) {
    return node.operator === opts.operator + "=";
  };

  var buildAssignment = function buildAssignment(left, right) {
    return t.assignmentExpression("=", left, right);
  };

  exports.ExpressionStatement = function (node, parent, scope, file) {
    // hit the `AssignmentExpression` one below
    if (file.isConsequenceExpressionStatement(node)) return;

    var expr = node.expression;
    if (!isAssignment(expr)) return;

    var nodes = [];
    var exploded = explode(expr.left, nodes, file, scope, true);

    nodes.push(t.expressionStatement(buildAssignment(exploded.ref, opts.build(exploded.uid, expr.right))));

    return nodes;
  };

  exports.AssignmentExpression = function (node, parent, scope, file) {
    if (!isAssignment(node)) return;

    var nodes = [];
    var exploded = explode(node.left, nodes, file, scope);
    nodes.push(buildAssignment(exploded.ref, opts.build(exploded.uid, node.right)));

    return t.toSequenceExpression(nodes, scope);
  };

  exports.BinaryExpression = function (node) {
    if (node.operator !== opts.operator) return;
    return opts.build(node.left, node.right);
  };
};
},{"../../types":251,"./explode-assignable-expression":166}],162:[function(require,module,exports){
"use strict";

var t = require("../../types");

module.exports = function build(node, buildBody) {
  var self = node.blocks.shift();
  if (!self) return;

  var child = build(node, buildBody);
  if (!child) {
    // last item
    child = buildBody();

    // add a filter as this is our final stop
    if (node.filter) {
      child = t.ifStatement(node.filter, t.blockStatement([child]));
    }
  }

  return t.forOfStatement(t.variableDeclaration("let", [t.variableDeclarator(self.left)]), self.right, t.blockStatement([child]));
};
},{"../../types":251}],163:[function(require,module,exports){
"use strict";

var explode = require("./explode-assignable-expression");
var t = require("../../types");

module.exports = function (exports, opts) {
  var buildAssignment = function buildAssignment(left, right) {
    return t.assignmentExpression("=", left, right);
  };

  exports.ExpressionStatement = function (node, parent, scope, file) {
    // hit the `AssignmentExpression` one below
    if (file.isConsequenceExpressionStatement(node)) return;

    var expr = node.expression;
    if (!opts.is(expr, file)) return;

    var nodes = [];

    var exploded = explode(expr.left, nodes, file, scope);

    nodes.push(t.ifStatement(opts.build(exploded.uid, file), t.expressionStatement(buildAssignment(exploded.ref, expr.right))));

    return nodes;
  };

  exports.AssignmentExpression = function (node, parent, scope, file) {
    if (!opts.is(node, file)) return;

    var nodes = [];
    var exploded = explode(node.left, nodes, file, scope);

    nodes.push(t.logicalExpression("&&", opts.build(exploded.uid, file), buildAssignment(exploded.ref, node.right)));

    // todo: duplicate expression node
    nodes.push(exploded.ref);

    return t.toSequenceExpression(nodes, scope);
  };
};
},{"../../types":251,"./explode-assignable-expression":166}],164:[function(require,module,exports){
"use strict";

// Based upon the excellent jsx-transpiler by Ingvar Stepanyan (RReverser)
// https://github.com/RReverser/jsx-transpiler

// jsx

var isString = require("lodash/lang/isString");
var messages = require("../../messages");
var esutils = require("esutils");
var react = require("./react");
var t = require("../../types");

module.exports = function (exports, opts) {
  exports.check = function (node) {
    if (t.isJSX(node)) return true;
    if (react.isCreateClass(node)) return true;
    return false;
  };

  exports.JSXIdentifier = function (node, parent) {
    if (node.name === "this" && t.isReferenced(node, parent)) {
      return t.thisExpression();
    } else if (esutils.keyword.isIdentifierName(node.name)) {
      node.type = "Identifier";
    } else {
      return t.literal(node.name);
    }
  };

  exports.JSXNamespacedName = function (node, parent, scope, file) {
    throw file.errorWithNode(node, messages.get("JSXNamespacedTags"));
  };

  exports.JSXMemberExpression = {
    exit: function exit(node) {
      node.computed = t.isLiteral(node.property);
      node.type = "MemberExpression";
    }
  };

  exports.JSXExpressionContainer = function (node) {
    return node.expression;
  };

  exports.JSXAttribute = {
    enter: function enter(node) {
      var value = node.value;
      if (t.isLiteral(value) && isString(value.value)) {
        value.value = value.value.replace(/\n\s+/g, " ");
      }
    },

    exit: function exit(node) {
      var value = node.value || t.literal(true);
      return t.inherits(t.property("init", node.name, value), node);
    }
  };

  exports.JSXOpeningElement = {
    exit: function exit(node, parent, scope, file) {
      var tagExpr = node.name;
      var args = [];

      var tagName;
      if (t.isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (t.isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      var attribs = node.attributes;
      if (attribs.length) {
        attribs = buildJSXOpeningElementAttributes(attribs, file);
      } else {
        attribs = t.literal(null);
      }

      args.push(attribs);

      if (opts.post) {
        opts.post(state, file);
      }

      return state.call || t.callExpression(state.callee, args);
    }
  };

  /**
   * The logic for this is quite terse. It's because we need to
   * support spread elements. We loop over all attributes,
   * breaking on spreads, we then push a new object containg
   * all prior attributes to an array for later processing.
   */

  var buildJSXOpeningElementAttributes = function buildJSXOpeningElementAttributes(attribs, file) {
    var _props = [];
    var objs = [];

    var pushProps = function pushProps() {
      if (!_props.length) return;

      objs.push(t.objectExpression(_props));
      _props = [];
    };

    while (attribs.length) {
      var prop = attribs.shift();
      if (t.isJSXSpreadAttribute(prop)) {
        pushProps();
        objs.push(prop.argument);
      } else {
        _props.push(prop);
      }
    }

    pushProps();

    if (objs.length === 1) {
      // only one object
      attribs = objs[0];
    } else {
      // looks like we have multiple objects
      if (!t.isObjectExpression(objs[0])) {
        objs.unshift(t.objectExpression([]));
      }

      // spread it
      attribs = t.callExpression(file.addHelper("extends"), objs);
    }

    return attribs;
  };

  exports.JSXElement = {
    exit: function exit(node) {
      var callExpr = node.openingElement;

      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];

        if (t.isLiteral(child) && typeof child.value === "string") {
          cleanJSXElementLiteralChild(child, callExpr.arguments);
          continue;
        } else if (t.isJSXEmptyExpression(child)) {
          continue;
        }

        callExpr.arguments.push(child);
      }

      callExpr.arguments = flatten(callExpr.arguments);

      if (callExpr.arguments.length >= 3) {
        callExpr._prettyCall = true;
      }

      return t.inherits(callExpr, node);
    }
  };

  var isStringLiteral = function isStringLiteral(node) {
    return t.isLiteral(node) && isString(node.value);
  };

  var flatten = function flatten(args) {
    var flattened = [];
    var last;

    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (isStringLiteral(arg) && isStringLiteral(last)) {
        last.value += arg.value;
      } else {
        last = arg;
        flattened.push(arg);
      }
    }

    return flattened;
  };

  var cleanJSXElementLiteralChild = function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);

    var lastNonEmptyLine = 0;
    var i;

    for (i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    for (i = 0; i < lines.length; i++) {
      var line = lines[i];

      var isFirstLine = i === 0;
      var isLastLine = i === lines.length - 1;
      var isLastNonEmptyLine = i === lastNonEmptyLine;

      // replace rendered whitespace tabs with spaces
      var trimmedLine = line.replace(/\t/g, " ");

      // trim whitespace touching a newline
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      // trim whitespace touching an endline
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        args.push(t.literal(trimmedLine));
      }
    }
  };

  // display names

  var addDisplayName = function addDisplayName(id, call) {
    var props = call.arguments[0].properties;
    var safe = true;

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (t.isIdentifier(prop.key, { name: "displayName" })) {
        safe = false;
        break;
      }
    }

    if (safe) {
      props.unshift(t.property("init", t.identifier("displayName"), t.literal(id)));
    }
  };

  exports.ExportDeclaration = function (node, parent, scope, file) {
    if (node["default"] && react.isCreateClass(node.declaration)) {
      addDisplayName(file.opts.basename, node.declaration);
    }
  };

  exports.AssignmentExpression = exports.Property = exports.VariableDeclarator = function (node) {
    var left, right;

    if (t.isAssignmentExpression(node)) {
      left = node.left;
      right = node.right;
    } else if (t.isProperty(node)) {
      left = node.key;
      right = node.value;
    } else if (t.isVariableDeclarator(node)) {
      left = node.id;
      right = node.init;
    }

    if (t.isMemberExpression(left)) {
      left = left.property;
    }

    if (t.isIdentifier(left) && react.isCreateClass(right)) {
      addDisplayName(left.name, right);
    }
  };
};
},{"../../messages":157,"../../types":251,"./react":169,"esutils":287,"lodash/lang/isString":397}],165:[function(require,module,exports){
"use strict";

var cloneDeep = require("lodash/lang/cloneDeep");
var traverse = require("../../traversal");
var clone = require("lodash/lang/clone");
var each = require("lodash/collection/each");
var has = require("lodash/object/has");
var t = require("../../types");

exports.push = function (mutatorMap, key, kind, computed, value) {
  var alias;

  if (t.isIdentifier(key)) {
    alias = key.name;
    if (computed) alias = "computed:" + alias;
  } else if (t.isLiteral(key)) {
    alias = String(key.value);
  } else {
    alias = JSON.stringify(traverse.removeProperties(cloneDeep(key)));
  }

  var map;
  if (has(mutatorMap, alias)) {
    map = mutatorMap[alias];
  } else {
    map = {};
  }
  mutatorMap[alias] = map;

  map._key = key;
  if (computed) {
    map._computed = true;
  }

  map[kind] = value;
};

exports.build = function (mutatorMap) {
  var objExpr = t.objectExpression([]);

  each(mutatorMap, function (map) {
    var mapNode = t.objectExpression([]);

    var propNode = t.property("init", map._key, mapNode, map._computed);

    if (!map.get && !map.set) {
      map.writable = t.literal(true);
    }

    if (map.enumerable === false) {
      delete map.enumerable;
    } else {
      map.enumerable = t.literal(true);
    }

    map.configurable = t.literal(true);

    each(map, function (node, key) {
      if (key[0] === "_") return;

      node = clone(node);
      var inheritNode = node;
      if (t.isMethodDefinition(node)) node = node.value;

      var prop = t.property("init", t.identifier(key), node);
      t.inheritsComments(prop, inheritNode);
      t.removeComments(inheritNode);
      mapNode.properties.push(prop);
    });

    objExpr.properties.push(propNode);
  });

  return objExpr;
};
},{"../../traversal":246,"../../types":251,"lodash/collection/each":303,"lodash/lang/clone":386,"lodash/lang/cloneDeep":387,"lodash/object/has":402}],166:[function(require,module,exports){
"use strict";

var t = require("../../types");

var getObjRef = function getObjRef(node, nodes, file, scope) {
  var ref;
  if (t.isIdentifier(node)) {
    if (scope.hasBinding(node.name)) {
      // this variable is declared in scope so we can be 100% sure
      // that evaluating it multiple times wont trigger a getter
      // or something else
      return node;
    } else {
      // could possibly trigger a getter so we need to only evaluate
      // it once
      ref = node;
    }
  } else if (t.isMemberExpression(node)) {
    ref = node.object;

    if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {
      // the object reference that we need to save is locally declared
      // so as per the previous comment we can be 100% sure evaluating
      // it multiple times will be safe
      return ref;
    }
  } else {
    throw new Error("We can't explode this node type " + node.type);
  }

  var temp = scope.generateUidBasedOnNode(ref);
  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, ref)]));
  return temp;
};

var getPropRef = function getPropRef(node, nodes, file, scope) {
  var prop = node.property;
  var key = t.toComputedKey(node, prop);
  if (t.isLiteral(key)) return key;

  var temp = scope.generateUidBasedOnNode(prop);
  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(temp, prop)]));
  return temp;
};

module.exports = function (node, nodes, file, scope, allowedSingleIdent) {
  var obj;
  if (t.isIdentifier(node) && allowedSingleIdent) {
    obj = node;
  } else {
    obj = getObjRef(node, nodes, file, scope);
  }

  var ref, uid;

  if (t.isIdentifier(node)) {
    ref = node;
    uid = obj;
  } else {
    var prop = getPropRef(node, nodes, file, scope);
    var computed = node.computed || t.isLiteral(prop);
    uid = ref = t.memberExpression(obj, prop, computed);
  }

  return {
    uid: uid,
    ref: ref
  };
};
},{"../../types":251}],167:[function(require,module,exports){
"use strict";

var t = require("../../types");

module.exports = function (node) {
  var lastNonDefault = 0;
  for (var i = 0; i < node.params.length; i++) {
    if (!t.isAssignmentPattern(node.params[i])) lastNonDefault = i + 1;
  }
  return lastNonDefault;
};
},{"../../types":251}],168:[function(require,module,exports){
"use strict";

var getFunctionArity = require("./get-function-arity");
var util = require("../../util");
var t = require("../../types");

var visitor = {
  enter: function enter(node, parent, scope, state) {
    // check if this node is a referenced identifier that matches the same as our
    // function id
    if (!t.isReferencedIdentifier(node, parent, { name: state.name })) return;

    // check that we don't have a local variable declared as that removes the need
    // for the wrapper
    var localDeclar = scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;

    state.selfReference = true;
    this.stop();
  }
};

var wrap = function wrap(state, method, id, scope) {
  if (state.selfReference) {
    var templateName = "property-method-assignment-wrapper";
    if (method.generator) templateName += "-generator";
    var template = util.template(templateName, {
      FUNCTION: method,
      FUNCTION_ID: id,
      FUNCTION_KEY: scope.generateUidIdentifier(id.name),
      WRAPPER_KEY: scope.generateUidIdentifier(id.name + "Wrapper")
    });

    // shim in dummy params to retain function arity, if you try to read the
    // source then you'll get the original since it's proxied so it's all good
    var params = template.callee.body.body[0].declarations[0].init.params;
    for (var i = 0, len = getFunctionArity(method); i < len; i++) {
      params.push(scope.generateUidIdentifier("x"));
    }

    return template;
  } else {
    method.id = id;
    return method;
  }
};

var visit = function visit(node, name, scope) {
  var state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    references: [],
    name: name };

  // check to see if we have a local binding of the id we're setting inside of
  // the function, this is important as there are caveats associated

  var bindingInfo = null; // todo: proper scope not being passed in es6/classes // scope.getOwnBindingInfo(name);

  if (bindingInfo) {
    if (bindingInfo.kind === "param") {
      // safari will blow up in strict mode with code like:
      //
      //   var t = function t(t) {};
      //
      // with the error:
      //
      //   Cannot declare a parameter named 't' as it shadows the name of a
      //   strict mode function.
      //
      // this isn't to the spec and they've invented this behaviour which is
      // **extremely** annoying so we avoid setting the name if it has a param
      // with the same id
      state.selfReference = true;
    } else {}
  } else {
    scope.traverse(node, visitor, state);
  }

  return state;
};

exports.property = function (node, file, scope) {
  var key = t.toComputedKey(node, node.key);
  if (!t.isLiteral(key)) return node; // we can't set a function id with this

  var name = t.toIdentifier(key.value);
  var id = t.identifier(name);

  var method = node.value;
  var state = visit(method, name, scope);
  node.value = wrap(state, method, id, scope);
};

exports.bare = function (node, parent, scope) {
  // has an `id` so we don't need to infer one
  if (node.id) return;

  var id;
  if (t.isProperty(parent) && parent.kind === "init" && !parent.computed) {
    // { foo() {} };
    id = parent.key;
  } else if (t.isVariableDeclarator(parent)) {
    // var foo = function () {};
    id = parent.id;
  } else {
    return;
  }

  if (!t.isIdentifier(id)) return;

  var name = t.toIdentifier(id.name);
  id = t.identifier(name);

  var state = visit(node, name, scope);
  return wrap(state, node, id, scope);
};

// otherwise it's defined somewhere in scope like:
//
//   var t = function () {
//     var t = 2;
//   };
//
// so we can safely just set the id and move along as it shadows the
// bound function id
},{"../../types":251,"../../util":253,"./get-function-arity":167}],169:[function(require,module,exports){
"use strict";

var t = require("../../types");

var isCreateClassCallExpression = t.buildMatchMemberExpression("React.createClass");

exports.isCreateClass = function (node) {
  if (!node || !t.isCallExpression(node)) return false;

  // not React.createClass call member object
  if (!isCreateClassCallExpression(node.callee)) return false;

  // no call arguments
  var args = node.arguments;
  if (args.length !== 1) return false;

  // first node arg is not an object
  var first = args[0];
  if (!t.isObjectExpression(first)) return false;

  return true;
};

exports.isReactComponent = t.buildMatchMemberExpression("React.Component");

exports.isCompatTag = function (tagName) {
  return tagName && /^[a-z]|\-/.test(tagName);
};
},{"../../types":251}],170:[function(require,module,exports){
"use strict";

var t = require("../../types");

var visitor = {
  enter: function enter(node) {
    if (t.isFunction(node)) this.skip();

    if (t.isAwaitExpression(node)) {
      node.type = "YieldExpression";

      if (node.all) {
        // await* foo; -> yield Promise.all(foo);
        node.all = false;
        node.argument = t.callExpression(t.memberExpression(t.identifier("Promise"), t.identifier("all")), [node.argument]);
      }
    }
  }
};

module.exports = function (node, callId, scope) {
  node.async = false;
  node.generator = true;

  scope.traverse(node, visitor);

  var call = t.callExpression(callId, [node]);
  var id = node.id;
  delete node.id;

  if (t.isFunctionDeclaration(node)) {
    var declar = t.variableDeclaration("let", [t.variableDeclarator(id, call)]);
    declar._blockHoist = true;
    return declar;
  } else {
    return call;
  }
};
},{"../../types":251}],171:[function(require,module,exports){
"use strict";

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

module.exports = ReplaceSupers;

var messages = require("../../messages");
var t = require("../../types");

var isIllegalBareSuper = function isIllegalBareSuper(node, parent) {
  if (!isSuper(node, parent)) return false;
  if (t.isMemberExpression(parent, { computed: false })) return false;
  if (t.isCallExpression(parent, { callee: node })) return false;
  return true;
};

var isSuper = function isSuper(node, parent) {
  return t.isIdentifier(node, { name: "super" }) && t.isReferenced(node, parent);
};

var visitor = {
  enter: function enter(node, parent, scope, state) {
    var topLevel = state.topLevel;
    var self = state.self;

    if (t.isFunction(node) && !t.isArrowFunctionExpression(node)) {
      // we need to call traverseLevel again so we're context aware
      self.traverseLevel(node, false);
      return this.skip();
    }

    if (t.isProperty(node, { method: true }) || t.isMethodDefinition(node)) {
      // break on object methods
      return this.skip();
    }

    var getThisReference = topLevel ?
    // top level so `this` is the instance
    t.thisExpression :
    // not in the top level so we need to create a reference
    self.getThisReference.bind(self);

    var callback = self.specHandle;
    if (self.isLoose) callback = self.looseHandle;
    return callback.call(self, getThisReference, node, parent);
  }
};

var ReplaceSupers = (function () {

  /**
   * Description
   *
   * @param {Object} opts
   * @param {Boolean} [inClass]
   */

  function ReplaceSupers(opts, inClass) {
    _classCallCheck(this, ReplaceSupers);

    this.topLevelThisReference = opts.topLevelThisReference;
    this.methodNode = opts.methodNode;
    this.className = opts.className;
    this.superName = opts.superName;
    this.isStatic = opts.isStatic;
    this.hasSuper = false;
    this.inClass = inClass;
    this.isLoose = opts.isLoose;
    this.scope = opts.scope;
    this.file = opts.file;
  }

  /**
   * Sets a super class value of the named property.
   *
   * @example
   *
   *   _set(Object.getPrototypeOf(CLASS.prototype), "METHOD", "VALUE", this)
   *
   * @param {Node} property
   * @param {Node} value
   * @param {Boolean} isComputed
   * @param {Node} thisExpression
   *
   * @returns {Node}
   */

  ReplaceSupers.prototype.setSuperProperty = function setSuperProperty(property, value, isComputed, thisExpression) {
    return t.callExpression(this.file.addHelper("set"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.className : t.memberExpression(this.className, t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), value, thisExpression]);
  };

  /**
   * Gets a node representing the super class value of the named property.
   *
   * @example
   *
   *   _get(Object.getPrototypeOf(CLASS.prototype), "METHOD", this)
   *
   * @param {Node} property
   * @param {Boolean} isComputed
   * @param {Node} thisExpression
   *
   * @returns {Node}
   */

  ReplaceSupers.prototype.getSuperProperty = function getSuperProperty(property, isComputed, thisExpression) {
    return t.callExpression(this.file.addHelper("get"), [t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")), [this.isStatic ? this.className : t.memberExpression(this.className, t.identifier("prototype"))]), isComputed ? property : t.literal(property.name), thisExpression]);
  };

  /**
   * Description
   */

  ReplaceSupers.prototype.replace = function replace() {
    this.traverseLevel(this.methodNode.value, true);
  };

  /**
   * Description
   *
   * @param {Object} node
   * @param {Boolean} topLevel
   */

  ReplaceSupers.prototype.traverseLevel = function traverseLevel(node, topLevel) {
    var state = { self: this, topLevel: topLevel };
    this.scope.traverse(node, visitor, state);
  };

  /**
   * Description
   */

  ReplaceSupers.prototype.getThisReference = function getThisReference() {
    if (this.topLevelThisReference) {
      return this.topLevelThisReference;
    } else {
      var ref = this.topLevelThisReference = this.scope.generateUidIdentifier("this");
      this.methodNode.value.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(this.topLevelThisReference, t.thisExpression())]));
      return ref;
    }
  };

  /**
   * Description
   *
   * @param {Object} node
   * @param {Object} id
   * @param {Object} parent
   * @returns {Object}
   */

  ReplaceSupers.prototype.getLooseSuperProperty = function getLooseSuperProperty(id, parent) {
    var methodNode = this.methodNode;
    var methodName = methodNode.key;
    var superName = this.superName || t.identifier("Function");

    if (parent.property === id) {
      return;
    } else if (t.isCallExpression(parent, { callee: id })) {
      // super(); -> ClassName.prototype.MethodName.call(this);
      parent.arguments.unshift(t.thisExpression());

      if (methodName.name === "constructor") {
        // constructor() { super(); }
        return t.memberExpression(superName, t.identifier("call"));
      } else {
        id = superName;

        // foo() { super(); }
        if (!methodNode["static"]) {
          id = t.memberExpression(id, t.identifier("prototype"));
        }

        id = t.memberExpression(id, methodName, methodNode.computed);
        return t.memberExpression(id, t.identifier("call"));
      }
    } else if (t.isMemberExpression(parent) && !methodNode["static"]) {
      // super.test -> ClassName.prototype.test
      return t.memberExpression(superName, t.identifier("prototype"));
    } else {
      return superName;
    }
  };

  /**
   * Description
   *
   * @param {Function} getThisReference
   * @param {Object} node
   * @param {Object} parent
   */

  ReplaceSupers.prototype.looseHandle = function looseHandle(getThisReference, node, parent) {
    if (t.isIdentifier(node, { name: "super" })) {
      this.hasSuper = true;
      return this.getLooseSuperProperty(node, parent);
    } else if (t.isCallExpression(node)) {
      var callee = node.callee;
      if (!t.isMemberExpression(callee)) return;
      if (callee.object.name !== "super") return;

      // super.test(); -> ClassName.prototype.MethodName.call(this);
      this.hasSuper = true;
      t.appendToMemberExpression(callee, t.identifier("call"));
      node.arguments.unshift(getThisReference());
    }
  };

  /**
   * Description
   *
   * @param {Function} getThisReference
   * @param {Object} node
   * @param {Object} parent
   */

  ReplaceSupers.prototype.specHandle = function specHandle(getThisReference, node, parent) {
    var methodNode = this.methodNode;
    var property;
    var computed;
    var args;
    var thisReference;

    if (isIllegalBareSuper(node, parent)) {
      throw this.file.errorWithNode(node, messages.get("classesIllegalBareSuper"));
    }

    if (t.isCallExpression(node)) {
      var callee = node.callee;
      if (isSuper(callee, node)) {
        // super(); -> _get(Object.getPrototypeOf(ClassName), "MethodName", this).call(this);
        property = methodNode.key;
        computed = methodNode.computed;
        args = node.arguments;

        // bare `super` call is illegal inside non-constructors
        //  - https://esdiscuss.org/topic/super-call-in-methods
        //  - https://twitter.com/wycats/status/544553184396836864
        if (methodNode.key.name !== "constructor" || !this.inClass) {
          var methodName = methodNode.key.name || "METHOD_NAME";
          throw this.file.errorWithNode(node, messages.get("classesIllegalSuperCall", methodName));
        }
      } else if (t.isMemberExpression(callee) && isSuper(callee.object, callee)) {
        // super.test(); -> _get(Object.getPrototypeOf(ClassName.prototype), "test", this).call(this);
        property = callee.property;
        computed = callee.computed;
        args = node.arguments;
      }
    } else if (t.isMemberExpression(node) && isSuper(node.object, node)) {
      // super.name; -> _get(Object.getPrototypeOf(ClassName.prototype), "name", this);
      property = node.property;
      computed = node.computed;
    } else if (t.isAssignmentExpression(node) && isSuper(node.left.object, node.left) && methodNode.kind === "set") {
      // super.name = "val"; -> _set(Object.getPrototypeOf(ClassName.prototype), "name", this);
      this.hasSuper = true;
      return this.setSuperProperty(node.left.property, node.right, node.left.computed, getThisReference());
    }

    if (!property) return;

    this.hasSuper = true;

    thisReference = getThisReference();
    var superProperty = this.getSuperProperty(property, computed, thisReference);
    if (args) {
      if (args.length === 1 && t.isSpreadElement(args[0])) {
        // super(...arguments);
        return t.callExpression(t.memberExpression(superProperty, t.identifier("apply")), [thisReference, args[0].argument]);
      } else {
        return t.callExpression(t.memberExpression(superProperty, t.identifier("call")), [thisReference].concat(_toConsumableArray(args)));
      }
    } else {
      return superProperty;
    }
  };

  return ReplaceSupers;
})();

module.exports = ReplaceSupers;
},{"../../messages":157,"../../types":251}],172:[function(require,module,exports){
"use strict";

var t = require("../../types");

exports.has = function (node) {
  var first = node.body[0];
  return t.isExpressionStatement(first) && t.isLiteral(first.expression, { value: "use strict" });
};

exports.wrap = function (node, callback) {
  var useStrictNode;
  if (exports.has(node)) {
    useStrictNode = node.body.shift();
  }

  callback();

  if (useStrictNode) {
    node.body.unshift(useStrictNode);
  }
};
},{"../../types":251}],173:[function(require,module,exports){
"use strict";

module.exports = transform;

var normalizeAst = require("../helpers/normalize-ast");
var Transformer = require("./transformer");
var object = require("../helpers/object");
var File = require("./file");
var each = require("lodash/collection/each");

function transform(code, opts) {
  var file = new File(opts);
  return file.parse(code);
}

transform.fromAst = function (ast, code, opts) {
  ast = normalizeAst(ast);

  var file = new File(opts);
  file.addCode(code);
  file.transform(ast);
  return file.generate();
};

transform._ensureTransformerNames = function (type, rawKeys) {
  var keys = [];

  for (var i = 0; i < rawKeys.length; i++) {
    var key = rawKeys[i];

    var deprecatedKey = transform.deprecatedTransformerMap[key];
    if (deprecatedKey) {
      // deprecated key, remap it to the new one
      console.error("The transformer " + key + " has been renamed to " + deprecatedKey);
      rawKeys.push(deprecatedKey);
    } else if (transform.transformers[key]) {
      // valid key
      keys.push(key);
    } else if (transform.namespaces[key]) {
      // namespace, append all transformers within this namespace
      keys = keys.concat(transform.namespaces[key]);
    } else {
      // invalid key
      throw new ReferenceError("Unknown transformer " + key + " specified in " + type);
    }
  }

  return keys;
};

transform.transformerNamespaces = object();
transform.transformers = object();
transform.namespaces = object();

transform.deprecatedTransformerMap = require("./transformers/deprecated");
transform.moduleFormatters = require("./modules");

var rawTransformers = require("./transformers");

each(rawTransformers, function (transformer, key) {
  var namespace = key.split(".")[0];

  var _transform$namespaces = transform.namespaces;
  var _namespace = namespace;
  if (!_transform$namespaces[_namespace]) _transform$namespaces[_namespace] = [];

  transform.namespaces[namespace].push(key);
  transform.transformerNamespaces[key] = namespace;

  transform.transformers[key] = new Transformer(key, transformer);
});
},{"../helpers/normalize-ast":153,"../helpers/object":154,"./file":160,"./modules":181,"./transformer":186,"./transformers":212,"./transformers/deprecated":187,"lodash/collection/each":303}],174:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var messages = require("../../messages");
var extend = require("lodash/object/extend");
var object = require("../../helpers/object");
var util = require("../../util");
var t = require("../../types");

var remapVisitor = {
  enter: function enter(node, parent, scope, formatter) {
    if (t.isUpdateExpression(node) && formatter.isLocalReference(node.argument, scope)) {
      this.skip();

      // expand to long file assignment expression
      var assign = t.assignmentExpression(node.operator[0] + "=", node.argument, t.literal(1));

      // remap this assignment expression
      var remapped = formatter.remapExportAssignment(assign);

      // we don't need to change the result
      if (t.isExpressionStatement(parent) || node.prefix) {
        return remapped;
      }

      var nodes = [];
      nodes.push(remapped);

      var operator;
      if (node.operator === "--") {
        operator = "+";
      } else {
        // "++"
        operator = "-";
      }
      nodes.push(t.binaryExpression(operator, node.argument, t.literal(1)));

      return t.sequenceExpression(nodes);
    }

    if (t.isAssignmentExpression(node) && formatter.isLocalReference(node.left, scope)) {
      this.skip();
      return formatter.remapExportAssignment(node);
    }
  }
};

var importsVisitor = {
  enter: function enter(node, parent, scope, formatter) {
    if (t.isImportDeclaration(node)) {
      formatter.hasLocalImports = true;
      extend(formatter.localImports, t.getBindingIdentifiers(node));
      formatter.bumpImportOccurences(node);
    }
  }
};

var exportsVisitor = {
  enter: function enter(node, parent, scope, formatter) {
    var declar = node && node.declaration;
    if (t.isExportDeclaration(node)) {
      formatter.hasLocalImports = true;

      if (declar && t.isStatement(declar)) {
        extend(formatter.localExports, t.getBindingIdentifiers(declar));
      }

      if (!node["default"]) {
        formatter.hasNonDefaultExports = true;
      }

      if (node.source) {
        formatter.bumpImportOccurences(node);
      }
    }
  }
};

var DefaultFormatter = (function () {
  function DefaultFormatter(file) {
    _classCallCheck(this, DefaultFormatter);

    this.scope = file.scope;
    this.file = file;
    this.ids = object();

    this.hasNonDefaultExports = false;

    this.hasLocalExports = false;
    this.hasLocalImports = false;

    this.localImportOccurences = object();
    this.localExports = object();
    this.localImports = object();

    this.getLocalExports();
    this.getLocalImports();

    this.remapAssignments();
  }

  DefaultFormatter.prototype.doDefaultExportInterop = function doDefaultExportInterop(node) {
    return node["default"] && !this.noInteropRequireExport && !this.hasNonDefaultExports;
  };

  DefaultFormatter.prototype.bumpImportOccurences = function bumpImportOccurences(node) {
    var source = node.source.value;
    var occurs = this.localImportOccurences;
    var _occurs = occurs;
    var _source = source;
    if (!_occurs[_source]) _occurs[_source] = 0;

    occurs[source] += node.specifiers.length;
  };

  DefaultFormatter.prototype.getLocalExports = function getLocalExports() {
    this.file.scope.traverse(this.file.ast, exportsVisitor, this);
  };

  DefaultFormatter.prototype.getLocalImports = function getLocalImports() {
    this.file.scope.traverse(this.file.ast, importsVisitor, this);
  };

  DefaultFormatter.prototype.remapAssignments = function remapAssignments() {
    if (this.hasLocalImports) {
      this.file.scope.traverse(this.file.ast, remapVisitor, this);
    }
  };

  DefaultFormatter.prototype.isLocalReference = function isLocalReference(node) {
    var localImports = this.localImports;
    return t.isIdentifier(node) && localImports[node.name] && localImports[node.name] !== node;
  };

  DefaultFormatter.prototype.remapExportAssignment = function remapExportAssignment(node) {
    return t.assignmentExpression("=", node.left, t.assignmentExpression(node.operator, t.memberExpression(t.identifier("exports"), node.left), node.right));
  };

  DefaultFormatter.prototype.isLocalReference = function isLocalReference(node, scope) {
    var localExports = this.localExports;
    var name = node.name;
    return t.isIdentifier(node) && localExports[name] && localExports[name] === scope.getBindingIdentifier(name);
  };

  DefaultFormatter.prototype.getModuleName = function getModuleName() {
    var opts = this.file.opts;
    if (opts.moduleId) return opts.moduleId;

    var filenameRelative = opts.filenameRelative;
    var moduleName = "";

    if (opts.moduleRoot) {
      moduleName = opts.moduleRoot + "/";
    }

    if (!opts.filenameRelative) {
      return moduleName + opts.filename.replace(/^\//, "");
    }

    if (opts.sourceRoot) {
      // remove sourceRoot from filename
      var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "/?");
      filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
    }

    if (!opts.keepModuleIdExtensions) {
      // remove extension
      filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");
    }

    moduleName += filenameRelative;

    // normalize path separators
    moduleName = moduleName.replace(/\\/g, "/");

    return moduleName;
  };

  DefaultFormatter.prototype._pushStatement = function _pushStatement(ref, nodes) {
    if (t.isClass(ref) || t.isFunction(ref)) {
      if (ref.id) {
        nodes.push(t.toStatement(ref));
        ref = ref.id;
      }
    }

    return ref;
  };

  DefaultFormatter.prototype._hoistExport = function _hoistExport(declar, assign, priority) {
    if (t.isFunctionDeclaration(declar)) {
      assign._blockHoist = priority || 2;
    }

    return assign;
  };

  DefaultFormatter.prototype.getExternalReference = function getExternalReference(node, nodes) {
    var ids = this.ids;
    var id = node.source.value;

    if (ids[id]) {
      return ids[id];
    } else {
      return this.ids[id] = this._getExternalReference(node, nodes);
    }
  };

  DefaultFormatter.prototype.checkExportIdentifier = function checkExportIdentifier(node) {
    if (t.isIdentifier(node, { name: "__esModule" })) {
      throw this.file.errorWithNode(node, messages.get("modulesIllegalExportName", node.name));
    }
  };

  DefaultFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {
    if (node.source) {
      var ref = this.getExternalReference(node, nodes);

      if (t.isExportBatchSpecifier(specifier)) {
        // export * from "foo";
        nodes.push(this.buildExportsWildcard(ref, node));
      } else {
        if (t.isSpecifierDefault(specifier) && !this.noInteropRequireExport) {
          // importing a default so we need to normalize it
          ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
        } else {
          ref = t.memberExpression(ref, t.getSpecifierId(specifier));
        }

        // export { foo } from "test";
        nodes.push(this.buildExportsAssignment(t.getSpecifierName(specifier), ref, node));
      }
    } else {
      // export { foo };
      nodes.push(this.buildExportsAssignment(t.getSpecifierName(specifier), specifier.id, node));
    }
  };

  DefaultFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier) {
    return t.expressionStatement(t.callExpression(this.file.addHelper("defaults"), [t.identifier("exports"), t.callExpression(this.file.addHelper("interop-require-wildcard"), [objectIdentifier])]));
  };

  DefaultFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init) {
    this.checkExportIdentifier(id);
    return util.template("exports-assign", {
      VALUE: init,
      KEY: id
    }, true);
  };

  DefaultFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
    var declar = node.declaration;

    var id = declar.id;

    if (node["default"]) {
      id = t.identifier("default");
    }

    var assign;

    if (t.isVariableDeclaration(declar)) {
      for (var i = 0; i < declar.declarations.length; i++) {
        var decl = declar.declarations[i];

        decl.init = this.buildExportsAssignment(decl.id, decl.init, node).expression;

        var newDeclar = t.variableDeclaration(declar.kind, [decl]);
        if (i === 0) t.inherits(newDeclar, declar);
        nodes.push(newDeclar);
      }
    } else {
      var ref = declar;

      if (t.isFunctionDeclaration(declar) || t.isClassDeclaration(declar)) {
        ref = declar.id;
        nodes.push(declar);
      }

      assign = this.buildExportsAssignment(id, ref, node);

      nodes.push(assign);

      this._hoistExport(declar, assign);
    }
  };

  return DefaultFormatter;
})();

module.exports = DefaultFormatter;
},{"../../helpers/object":154,"../../messages":157,"../../types":251,"../../util":253,"lodash/object/extend":401}],175:[function(require,module,exports){
"use strict";

var util = require("../../util");

module.exports = function (Parent) {
  var Constructor = function Constructor() {
    this.noInteropRequireImport = true;
    this.noInteropRequireExport = true;
    Parent.apply(this, arguments);
  };

  util.inherits(Constructor, Parent);

  return Constructor;
};
},{"../../util":253}],176:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./amd"));
},{"./_strict":175,"./amd":177}],177:[function(require,module,exports){
"use strict";

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var DefaultFormatter = require("./_default");
var CommonFormatter = require("./common");
var includes = require("lodash/collection/includes");
var values = require("lodash/object/values");
var util = require("../../util");
var t = require("../../types");

var AMDFormatter = (function (DefaultFormatter) {
  function AMDFormatter() {
    this.init = CommonFormatter.prototype.init;

    _classCallCheck(this, AMDFormatter);

    if (DefaultFormatter != null) {
      DefaultFormatter.apply(this, arguments);
    }
  }

  _inherits(AMDFormatter, DefaultFormatter);

  AMDFormatter.prototype.buildDependencyLiterals = function buildDependencyLiterals() {
    var names = [];
    for (var name in this.ids) {
      names.push(t.literal(name));
    }
    return names;
  };

  /**
   * Wrap the entire body in a `define` wrapper.
   */

  AMDFormatter.prototype.transform = function transform(program) {
    var body = program.body;

    // build an array of module names

    var names = [t.literal("exports")];
    if (this.passModuleArg) names.push(t.literal("module"));
    names = names.concat(this.buildDependencyLiterals());
    names = t.arrayExpression(names);

    // build up define container

    var params = values(this.ids);
    if (this.passModuleArg) params.unshift(t.identifier("module"));
    params.unshift(t.identifier("exports"));

    var container = t.functionExpression(null, params, t.blockStatement(body));

    var defineArgs = [names, container];
    var moduleName = this.getModuleName();
    if (moduleName) defineArgs.unshift(t.literal(moduleName));

    var call = t.callExpression(t.identifier("define"), defineArgs);

    program.body = [t.expressionStatement(call)];
  };

  /**
   * Get the AMD module name that we'll prepend to the wrapper
   * to define this module
   */

  AMDFormatter.prototype.getModuleName = function getModuleName() {
    if (this.file.opts.moduleIds) {
      return DefaultFormatter.prototype.getModuleName.apply(this, arguments);
    } else {
      return null;
    }
  };

  AMDFormatter.prototype._getExternalReference = function _getExternalReference(node) {
    return this.scope.generateUidIdentifier(node.source.value);
  };

  AMDFormatter.prototype.importDeclaration = function importDeclaration(node) {
    this.getExternalReference(node);
  };

  AMDFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
    var key = t.getSpecifierName(specifier);
    var ref = this.getExternalReference(node);

    if (includes(this.file.dynamicImportedNoDefault, node)) {
      // Prevent unnecessary renaming of dynamic imports.
      this.ids[node.source.value] = ref;
    } else if (t.isImportBatchSpecifier(specifier)) {} else if (!includes(this.file.dynamicImported, node) && t.isSpecifierDefault(specifier) && !this.noInteropRequireImport) {
      // import foo from "foo";
      ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
    } else {
      // import {foo} from "foo";
      ref = t.memberExpression(ref, t.getSpecifierId(specifier), false);
    }

    nodes.push(t.variableDeclaration("var", [t.variableDeclarator(key, ref)]));
  };

  AMDFormatter.prototype.exportDeclaration = function exportDeclaration(node) {
    if (this.doDefaultExportInterop(node)) {
      this.passModuleArg = true;
    }

    CommonFormatter.prototype.exportDeclaration.apply(this, arguments);
  };

  return AMDFormatter;
})(DefaultFormatter);

module.exports = AMDFormatter;

// import * as bar from "foo";
},{"../../types":251,"../../util":253,"./_default":174,"./common":179,"lodash/collection/includes":306,"lodash/object/values":405}],178:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./common"));
},{"./_strict":175,"./common":179}],179:[function(require,module,exports){
"use strict";

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var DefaultFormatter = require("./_default");
var includes = require("lodash/collection/includes");
var util = require("../../util");
var t = require("../../types");

var CommonJSFormatter = (function (DefaultFormatter) {
  function CommonJSFormatter() {
    _classCallCheck(this, CommonJSFormatter);

    if (DefaultFormatter != null) {
      DefaultFormatter.apply(this, arguments);
    }
  }

  _inherits(CommonJSFormatter, DefaultFormatter);

  CommonJSFormatter.prototype.init = function init() {
    var file = this.file;
    var scope = file.scope;

    scope.rename("module");

    if (!this.noInteropRequireImport && this.hasNonDefaultExports) {
      var templateName = "exports-module-declaration";
      if (this.file.isLoose("es6.modules")) templateName += "-loose";
      file.ast.program.body.push(util.template(templateName, true));
    }
  };

  CommonJSFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
    var variableName = t.getSpecifierName(specifier);

    var ref = this.getExternalReference(node, nodes);

    // import foo from "foo";
    if (t.isSpecifierDefault(specifier)) {
      if (!includes(this.file.dynamicImportedNoDefault, node)) {
        if (this.noInteropRequireImport || includes(this.file.dynamicImported, node)) {
          ref = t.memberExpression(ref, t.identifier("default"));
        } else {
          ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
        }
      }
      nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, ref)]));
    } else {
      if (specifier.type === "ImportBatchSpecifier") {

        if (!this.noInteropRequireImport) {
          ref = t.callExpression(this.file.addHelper("interop-require-wildcard"), [ref]);
        }

        // import * as bar from "foo";
        nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, ref)]));
      } else {
        // import { foo } from "foo";
        nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, t.memberExpression(ref, t.getSpecifierId(specifier)))]));
      }
    }
  };

  CommonJSFormatter.prototype.importDeclaration = function importDeclaration(node, nodes) {
    // import "foo";
    nodes.push(util.template("require", {
      MODULE_NAME: node.source
    }, true));
  };

  CommonJSFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
    if (this.doDefaultExportInterop(node)) {
      var declar = node.declaration;
      var assign = util.template("exports-default-assign", {
        VALUE: this._pushStatement(declar, nodes)
      }, true);

      if (t.isFunctionDeclaration(declar)) {
        // we can hoist this assignment to the top of the file
        assign._blockHoist = 3;
      }

      nodes.push(assign);
      return;
    }

    DefaultFormatter.prototype.exportDeclaration.apply(this, arguments);
  };

  CommonJSFormatter.prototype._getExternalReference = function _getExternalReference(node, nodes) {
    var source = node.source.value;
    var call = t.callExpression(t.identifier("require"), [node.source]);

    if (this.localImportOccurences[source] > 1) {
      var uid = this.scope.generateUidIdentifier(source);
      nodes.push(t.variableDeclaration("var", [t.variableDeclarator(uid, call)]));
      return uid;
    } else {
      return call;
    }
  };

  return CommonJSFormatter;
})(DefaultFormatter);

module.exports = CommonJSFormatter;
},{"../../types":251,"../../util":253,"./_default":174,"lodash/collection/includes":306}],180:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var t = require("../../types");

var IgnoreFormatter = (function () {
  function IgnoreFormatter() {
    _classCallCheck(this, IgnoreFormatter);
  }

  IgnoreFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {
    var declar = t.toStatement(node.declaration, true);
    if (declar) nodes.push(t.inherits(declar, node));
  };

  IgnoreFormatter.prototype.importDeclaration = function importDeclaration() {};

  IgnoreFormatter.prototype.importSpecifier = function importSpecifier() {};

  IgnoreFormatter.prototype.exportSpecifier = function exportSpecifier() {};

  return IgnoreFormatter;
})();

module.exports = IgnoreFormatter;
},{"../../types":251}],181:[function(require,module,exports){
"use strict";

module.exports = {
  commonStrict: require("./common-strict"),
  amdStrict: require("./amd-strict"),
  umdStrict: require("./umd-strict"),
  common: require("./common"),
  system: require("./system"),
  ignore: require("./ignore"),
  amd: require("./amd"),
  umd: require("./umd")
};
},{"./amd":177,"./amd-strict":176,"./common":179,"./common-strict":178,"./ignore":180,"./system":182,"./umd":184,"./umd-strict":183}],182:[function(require,module,exports){
"use strict";

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var DefaultFormatter = require("./_default");
var AMDFormatter = require("./amd");
var util = require("../../util");
var last = require("lodash/array/last");
var each = require("lodash/collection/each");
var map = require("lodash/collection/map");
var t = require("../../types");

var hoistVariablesVisitor = {
  enter: function enter(node, parent, scope, hoistDeclarators) {
    if (t.isFunction(node)) {
      // nothing inside is accessible
      return this.skip();
    }

    if (t.isVariableDeclaration(node)) {
      if (node.kind !== "var" && !t.isProgram(parent)) {
        // let, const
        // can't be accessed
        return;
      }

      // ignore block hoisted nodes as these can be left in
      if (node._blockHoist) return;

      var nodes = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        hoistDeclarators.push(t.variableDeclarator(declar.id));
        if (declar.init) {
          // no initializer so we can just hoist it as-is
          var assign = t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init));
          nodes.push(assign);
        }
      }

      // for (var i in test)
      // for (var i = 0;;)
      if (t.isFor(parent)) {
        if (parent.left === node) {
          return node.declarations[0].id;
        }

        if (parent.init === node) {
          return t.toSequenceExpression(nodes, scope);
        }
      }

      return nodes;
    }
  }
};

var hoistFunctionsVisitor = {
  enter: function enter(node, parent, scope, handlerBody) {
    if (t.isFunction(node)) this.skip();

    if (t.isFunctionDeclaration(node) || node._blockHoist) {
      handlerBody.push(node);
      this.remove();
    }
  }
};

var runnerSettersVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (node._importSource === state.source) {
      if (t.isVariableDeclaration(node)) {
        each(node.declarations, function (declar) {
          state.hoistDeclarators.push(t.variableDeclarator(declar.id));
          state.nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
        });
      } else {
        state.nodes.push(node);
      }

      this.remove();
    }
  }
};

var SystemFormatter = (function (AMDFormatter) {
  function SystemFormatter(file) {
    _classCallCheck(this, SystemFormatter);

    this.exportIdentifier = file.scope.generateUidIdentifier("export");
    this.noInteropRequireExport = true;
    this.noInteropRequireImport = true;

    DefaultFormatter.apply(this, arguments);
  }

  _inherits(SystemFormatter, AMDFormatter);

  SystemFormatter.prototype.init = function init() {};

  SystemFormatter.prototype._addImportSource = function _addImportSource(node, exportNode) {
    node._importSource = exportNode.source && exportNode.source.value;
    return node;
  };

  SystemFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier, node) {
    var leftIdentifier = this.scope.generateUidIdentifier("key");
    var valIdentifier = t.memberExpression(objectIdentifier, leftIdentifier, true);

    var left = t.variableDeclaration("var", [t.variableDeclarator(leftIdentifier)]);

    var right = objectIdentifier;

    var block = t.blockStatement([t.expressionStatement(this.buildExportCall(leftIdentifier, valIdentifier))]);

    return this._addImportSource(t.forInStatement(left, right, block), node);
  };

  SystemFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init, node) {
    var call = this.buildExportCall(t.literal(id.name), init, true);
    return this._addImportSource(call, node);
  };

  SystemFormatter.prototype.remapExportAssignment = function remapExportAssignment(node) {
    return this.buildExportCall(t.literal(node.left.name), node);
  };

  SystemFormatter.prototype.buildExportCall = function buildExportCall(id, init, isStatement) {
    var call = t.callExpression(this.exportIdentifier, [id, init]);
    if (isStatement) {
      return t.expressionStatement(call);
    } else {
      return call;
    }
  };

  SystemFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {
    AMDFormatter.prototype.importSpecifier.apply(this, arguments);
    this._addImportSource(last(nodes), node);
  };

  SystemFormatter.prototype.buildRunnerSetters = function buildRunnerSetters(block, hoistDeclarators) {
    var scope = this.file.scope;

    return t.arrayExpression(map(this.ids, function (uid, source) {
      var state = {
        source: source,
        nodes: [],
        hoistDeclarators: hoistDeclarators
      };

      scope.traverse(block, runnerSettersVisitor, state);

      return t.functionExpression(null, [uid], t.blockStatement(state.nodes));
    }));
  };

  SystemFormatter.prototype.transform = function transform(program) {
    var hoistDeclarators = [];
    var moduleName = this.getModuleName();
    var moduleNameLiteral = t.literal(moduleName);

    var block = t.blockStatement(program.body);

    var runner = util.template("system", {
      MODULE_NAME: moduleNameLiteral,
      MODULE_DEPENDENCIES: t.arrayExpression(this.buildDependencyLiterals()),
      EXPORT_IDENTIFIER: this.exportIdentifier,
      SETTERS: this.buildRunnerSetters(block, hoistDeclarators),
      EXECUTE: t.functionExpression(null, [], block)
    }, true);

    var handlerBody = runner.expression.arguments[2].body.body;
    if (!moduleName) runner.expression.arguments.shift();

    var returnStatement = handlerBody.pop();

    // hoist up all variable declarations
    this.file.scope.traverse(block, hoistVariablesVisitor, hoistDeclarators);

    if (hoistDeclarators.length) {
      var hoistDeclar = t.variableDeclaration("var", hoistDeclarators);
      hoistDeclar._blockHoist = true;
      handlerBody.unshift(hoistDeclar);
    }

    // hoist up function declarations for circular references
    this.file.scope.traverse(block, hoistFunctionsVisitor, handlerBody);

    handlerBody.push(returnStatement);

    program.body = [runner];
  };

  return SystemFormatter;
})(AMDFormatter);

module.exports = SystemFormatter;
},{"../../types":251,"../../util":253,"./_default":174,"./amd":177,"lodash/array/last":299,"lodash/collection/each":303,"lodash/collection/map":307}],183:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./umd"));
},{"./_strict":175,"./umd":184}],184:[function(require,module,exports){
"use strict";

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var AMDFormatter = require("./amd");
var values = require("lodash/object/values");
var util = require("../../util");
var t = require("../../types");

var UMDFormatter = (function (AMDFormatter) {
  function UMDFormatter() {
    _classCallCheck(this, UMDFormatter);

    if (AMDFormatter != null) {
      AMDFormatter.apply(this, arguments);
    }
  }

  _inherits(UMDFormatter, AMDFormatter);

  UMDFormatter.prototype.transform = function transform(program) {
    var body = program.body;

    // build an array of module names

    var names = [];
    for (var name in this.ids) {
      names.push(t.literal(name));
    }

    // factory

    var ids = values(this.ids);
    var args = [t.identifier("exports")];
    if (this.passModuleArg) args.push(t.identifier("module"));
    args = args.concat(ids);

    var factory = t.functionExpression(null, args, t.blockStatement(body));

    // amd

    var defineArgs = [t.literal("exports")];
    if (this.passModuleArg) defineArgs.push(t.literal("module"));
    defineArgs = defineArgs.concat(names);
    defineArgs = [t.arrayExpression(defineArgs)];

    // common

    var testExports = util.template("test-exports");
    var testModule = util.template("test-module");
    var commonTests = this.passModuleArg ? t.logicalExpression("&&", testExports, testModule) : testExports;

    var commonArgs = [t.identifier("exports")];
    if (this.passModuleArg) commonArgs.push(t.identifier("module"));
    commonArgs = commonArgs.concat(names.map(function (name) {
      return t.callExpression(t.identifier("require"), [name]);
    }));

    // globals

    //var umdArgs = [];

    //

    var moduleName = this.getModuleName();
    if (moduleName) defineArgs.unshift(t.literal(moduleName));

    var runner = util.template("umd-runner-body", {
      AMD_ARGUMENTS: defineArgs,
      COMMON_TEST: commonTests,
      COMMON_ARGUMENTS: commonArgs
    });

    //

    var call = t.callExpression(runner, [factory]);
    program.body = [t.expressionStatement(call)];
  };

  return UMDFormatter;
})(AMDFormatter);

module.exports = UMDFormatter;
},{"../../types":251,"../../util":253,"./amd":177,"lodash/object/values":405}],185:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var includes = require("lodash/collection/includes");

/**
 * This class is responsible for traversing over the provided `File`s
 * AST and running it's parent transformers handlers over it.
 */

var TransformerPass = (function () {
  function TransformerPass(file, transformer) {
    _classCallCheck(this, TransformerPass);

    this.transformer = transformer;
    this.shouldRun = !transformer.check;
    this.handlers = transformer.handlers;
    this.file = file;
  }

  TransformerPass.prototype.canRun = function canRun() {
    var transformer = this.transformer;

    var opts = this.file.opts;
    var key = transformer.key;

    // internal
    if (key[0] === "_") return true;

    // blacklist
    var blacklist = opts.blacklist;
    if (blacklist.length && includes(blacklist, key)) return false;

    // whitelist
    var whitelist = opts.whitelist;
    if (whitelist.length) return includes(whitelist, key);

    // optional
    if (transformer.optional && !includes(opts.optional, key)) return false;

    // experimental
    if (transformer.experimental && !opts.experimental) return false;

    // playground
    if (transformer.playground && !opts.playground) return false;

    return true;
  };

  TransformerPass.prototype.checkNode = function checkNode(node) {
    var check = this.transformer.check;
    if (check) {
      return this.shouldRun = check(node);
    } else {
      return true;
    }
  };

  TransformerPass.prototype.transform = function transform() {
    if (!this.shouldRun) return;

    var file = this.file;

    file.debug("Running transformer " + this.transformer.key);

    file.scope.traverse(file.ast, this.handlers, file);
  };

  return TransformerPass;
})();

module.exports = TransformerPass;
},{"lodash/collection/includes":306}],186:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var TransformerPass = require("./transformer-pass");
var isFunction = require("lodash/lang/isFunction");
var traverse = require("../traversal");
var isObject = require("lodash/lang/isObject");
var assign = require("lodash/object/assign");
var each = require("lodash/collection/each");

/**
 * This is the class responsible for normalising a transformers handlers
 * as well as constructing a `TransformerPass` that is repsonsible for
 * actually running the transformer over the provided `File`.
 */

var Transformer = (function () {
  function Transformer(key, transformer, opts) {
    _classCallCheck(this, Transformer);

    transformer = assign({}, transformer);

    var take = function take(key) {
      var val = transformer[key];
      delete transformer[key];
      return val;
    };

    this.manipulateOptions = take("manipulateOptions");
    this.check = take("check");
    this.post = take("post");
    this.pre = take("pre");

    this.experimental = !!take("experimental");
    this.playground = !!take("playground");
    this.secondPass = !!take("secondPass");
    this.optional = !!take("optional");

    this.handlers = this.normalize(transformer);

    var _ref = this;

    if (!_ref.opts) _ref.opts = {};

    this.key = key;
  }

  Transformer.prototype.normalize = function normalize(transformer) {
    var _this = this;

    if (isFunction(transformer)) {
      transformer = { ast: transformer };
    }

    traverse.explode(transformer);

    each(transformer, function (fns, type) {
      // hidden property
      if (type[0] === "_") {
        _this[type] = fns;
        return;
      }

      if (type === "enter" || type === "exit") return;

      if (isFunction(fns)) fns = { enter: fns };

      if (!isObject(fns)) return;

      if (!fns.enter) fns.enter = function () {};
      if (!fns.exit) fns.exit = function () {};

      transformer[type] = fns;
    });

    return transformer;
  };

  Transformer.prototype.buildPass = function buildPass(file) {
    return new TransformerPass(file, this);
  };

  return Transformer;
})();

module.exports = Transformer;
},{"../traversal":246,"./transformer-pass":185,"lodash/collection/each":303,"lodash/lang/isFunction":392,"lodash/lang/isObject":395,"lodash/object/assign":399}],187:[function(require,module,exports){
module.exports={
  "selfContained": "runtime"
}

},{}],188:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.MemberExpression = function (node) {
  var prop = node.property;
  if (node.computed && t.isLiteral(prop) && t.isValidIdentifier(prop.value)) {
    // foo["bar"] => foo.bar
    node.property = t.identifier(prop.value);
    node.computed = false;
  } else if (!node.computed && t.isIdentifier(prop) && !t.isValidIdentifier(prop.name)) {
    // foo.default -> foo["default"]
    node.property = t.literal(prop.name);
    node.computed = true;
  }
};
},{"../../../types":251}],189:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.Property = function (node) {
  var key = node.key;
  if (t.isLiteral(key) && t.isValidIdentifier(key.value)) {
    // "foo": "bar" -> foo: "bar"
    node.key = t.identifier(key.value);
    node.computed = false;
  } else if (!node.computed && t.isIdentifier(key) && !t.isValidIdentifier(key.name)) {
    // default: "bar" -> "default": "bar"
    node.key = t.literal(key.name);
  }
};
},{"../../../types":251}],190:[function(require,module,exports){
"use strict";

var defineMap = require("../../helpers/define-map");
var t = require("../../../types");

exports.check = function (node) {
  return t.isProperty(node) && (node.kind === "get" || node.kind === "set");
};

exports.ObjectExpression = function (node) {
  var mutatorMap = {};
  var hasAny = false;

  node.properties = node.properties.filter(function (prop) {
    if (prop.kind === "get" || prop.kind === "set") {
      hasAny = true;
      defineMap.push(mutatorMap, prop.key, prop.kind, prop.computed, prop.value);
      return false;
    } else {
      return true;
    }
  });

  if (!hasAny) return;

  return t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("defineProperties")), [node, defineMap.build(mutatorMap)]);
};
},{"../../../types":251,"../../helpers/define-map":165}],191:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = t.isArrowFunctionExpression;

exports.ArrowFunctionExpression = function (node) {
  t.ensureBlock(node);

  node._aliasFunction = "arrow";
  node.expression = false;
  node.type = "FunctionExpression";

  return node;
};
},{"../../../types":251}],192:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var visitor = {
  enter: function enter(node, parent, scope, state) {
    if (!t.isReferencedIdentifier(node, parent)) return;

    var declared = state.letRefs[node.name];
    if (!declared) return;

    // declared node is different in this scope
    if (scope.getBindingIdentifier(node.name) !== declared) return;

    var assert = t.callExpression(state.file.addHelper("temporal-assert-defined"), [node, t.literal(node.name), state.file.addHelper("temporal-undefined")]);

    this.skip();

    if (t.isAssignmentExpression(parent) || t.isUpdateExpression(parent)) {
      if (parent._ignoreBlockScopingTDZ) return;
      this.parentPath.node = t.sequenceExpression([assert, parent]);
    } else {
      return t.logicalExpression("&&", assert, node);
    }
  }
};

exports.optional = true;

exports.Loop = exports.Program = exports.BlockStatement = function (node, parent, scope, file) {
  var letRefs = node._letReferences;
  if (!letRefs) return;

  var state = {
    letRefs: letRefs,
    file: file
  };

  scope.traverse(node, visitor, state);
};
},{"../../../types":251}],193:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var traverse = require("../../../traversal");
var object = require("../../../helpers/object");
var util = require("../../../util");
var t = require("../../../types");
var values = require("lodash/object/values");
var extend = require("lodash/object/extend");

exports.check = function (node) {
  return t.isVariableDeclaration(node) && (node.kind === "let" || node.kind === "const");
};

var isLet = function isLet(node, parent) {
  if (!t.isVariableDeclaration(node)) return false;
  if (node._let) return true;
  if (node.kind !== "let") return false;

  // https://github.com/babel/babel/issues/255
  if (isLetInitable(node, parent)) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];
      var _declar = declar;
      if (!_declar.init) _declar.init = t.identifier("undefined");
    }
  }

  node._let = true;
  node.kind = "var";
  return true;
};

var isLetInitable = function isLetInitable(node, parent) {
  return !t.isFor(parent) || !t.isFor(parent, { left: node });
};

var isVar = function isVar(node, parent) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !isLet(node, parent);
};

var standardizeLets = function standardizeLets(declars) {
  for (var i = 0; i < declars.length; i++) {
    delete declars[i]._let;
  }
};

exports.VariableDeclaration = function (node, parent, scope, file) {
  if (!isLet(node, parent)) return;

  if (isLetInitable(node) && file.transformers["es6.blockScopingTDZ"].canRun()) {
    var nodes = [node];

    for (var i = 0; i < node.declarations.length; i++) {
      var decl = node.declarations[i];
      if (decl.init) {
        var assign = t.assignmentExpression("=", decl.id, decl.init);
        assign._ignoreBlockScopingTDZ = true;
        nodes.push(t.expressionStatement(assign));
      }
      decl.init = file.addHelper("temporal-undefined");
    }

    node._blockHoist = 2;

    return nodes;
  }
};

exports.Loop = function (node, parent, scope, file) {
  var init = node.left || node.init;
  if (isLet(init, node)) {
    t.ensureBlock(node);
    node.body._letDeclarators = [init];
  }
  var blockScoping = new BlockScoping(node, node.body, parent, scope, file);
  blockScoping.run();
};

exports.Program = exports.BlockStatement = function (block, parent, scope, file) {
  if (!t.isLoop(parent)) {
    var blockScoping = new BlockScoping(false, block, parent, scope, file);
    blockScoping.run();
  }
};

function replace(node, parent, scope, remaps) {
  if (!t.isReferencedIdentifier(node, parent)) return;

  var remap = remaps[node.name];
  if (!remap) return;

  var ownBinding = scope.getBindingIdentifier(node.name);
  if (ownBinding === remap.binding) {
    node.name = remap.uid;
  } else {
    // scope already has it's own binding that doesn't
    // match the one we have a stored replacement for
    if (this) this.skip();
  }
}

var replaceVisitor = {
  enter: replace
};

function traverseReplace(node, parent, scope, remaps) {
  replace(node, parent, scope, remaps);
  scope.traverse(node, replaceVisitor, remaps);
}

var letReferenceBlockVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isFunction(node)) {
      scope.traverse(node, letReferenceFunctionVisitor, state);
      return this.skip();
    }
  }
};

var letReferenceFunctionVisitor = {
  enter: function enter(node, parent, scope, state) {
    // not a direct reference
    if (!t.isReferencedIdentifier(node, parent)) return;

    // this scope has a variable with the same name so it couldn't belong
    // to our let scope
    if (scope.hasOwnBinding(node.name)) return;

    // not a part of our scope
    if (!state.letReferences[node.name]) return;

    state.closurify = true;
  }
};

var hoistVarDeclarationsVisitor = {
  enter: function enter(node, parent, scope, self) {
    if (t.isForStatement(node)) {
      if (isVar(node.init, node)) {
        node.init = t.sequenceExpression(self.pushDeclar(node.init));
      }
    } else if (t.isFor(node)) {
      if (isVar(node.left, node)) {
        node.left = node.left.declarations[0].id;
      }
    } else if (isVar(node, parent)) {
      return self.pushDeclar(node).map(t.expressionStatement);
    } else if (t.isFunction(node)) {
      return this.skip();
    }
  }
};

var loopLabelVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isLabeledStatement(node)) {
      state.innerLabels.push(node.label.name);
    }
  }
};

var loopNodeTo = function loopNodeTo(node) {
  if (t.isBreakStatement(node)) {
    return "break";
  } else if (t.isContinueStatement(node)) {
    return "continue";
  }
};

var loopVisitor = {
  enter: function enter(node, parent, scope, state) {
    var replace;

    if (t.isLoop(node)) {
      state.ignoreLabeless = true;
      scope.traverse(node, loopVisitor, state);
      state.ignoreLabeless = false;
    }

    if (t.isFunction(node) || t.isLoop(node)) {
      return this.skip();
    }

    var loopText = loopNodeTo(node);

    if (loopText) {
      if (node.label) {
        // we shouldn't be transforming this because it exists somewhere inside
        if (state.innerLabels.indexOf(node.label.name) >= 0) {
          return;
        }

        loopText = loopText + "|" + node.label.name;
      } else {
        // we shouldn't be transforming these statements because
        // they don't refer to the actual loop we're scopifying
        if (state.ignoreLabeless) return;

        // break statements mean something different in this context
        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;
      }

      state.hasBreakContinue = true;
      state.map[loopText] = node;
      replace = t.literal(loopText);
    }

    if (t.isReturnStatement(node)) {
      state.hasReturn = true;
      replace = t.objectExpression([t.property("init", t.identifier("v"), node.argument || t.identifier("undefined"))]);
    }

    if (replace) {
      replace = t.returnStatement(replace);
      return t.inherits(replace, node);
    }
  }
};

var BlockScoping = (function () {

  /**
   * Description
   *
   * @param {Boolean|Node} loopParent
   * @param {Node} block
   * @param {Node} parent
   * @param {Scope} scope
   * @param {File} file
   */

  function BlockScoping(loopParent, block, parent, scope, file) {
    _classCallCheck(this, BlockScoping);

    this.loopParent = loopParent;
    this.parent = parent;
    this.scope = scope;
    this.block = block;
    this.file = file;

    this.outsideLetReferences = object();
    this.hasLetReferences = false;
    this.letReferences = block._letReferences = object();
    this.body = [];
  }

  /**
   * Start the ball rolling.
   */

  BlockScoping.prototype.run = function run() {
    var block = this.block;
    if (block._letDone) return;
    block._letDone = true;

    var needsClosure = this.getLetReferences();

    // this is a block within a `Function/Program` so we can safely leave it be
    if (t.isFunction(this.parent) || t.isProgram(this.block)) return;

    // we can skip everything
    if (!this.hasLetReferences) return;

    if (needsClosure) {
      this.wrapClosure();
    } else {
      this.remap();
    }
  };

  /**
   * Description
   */

  BlockScoping.prototype.remap = function remap() {
    var hasRemaps = false;
    var letRefs = this.letReferences;
    var scope = this.scope;

    // alright, so since we aren't wrapping this block in a closure
    // we have to check if any of our let variables collide with
    // those in upper scopes and then if they do, generate a uid
    // for them and replace all references with it
    var remaps = object();

    for (var key in letRefs) {
      // just an Identifier node we collected in `getLetReferences`
      // this is the defining identifier of a declaration
      var ref = letRefs[key];

      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
        var uid = scope.generateUidIdentifier(ref.name).name;
        ref.name = uid;

        hasRemaps = true;
        remaps[key] = remaps[uid] = {
          binding: ref,
          uid: uid
        };
      }
    }

    if (!hasRemaps) return;

    //

    var loopParent = this.loopParent;
    if (loopParent) {
      traverseReplace(loopParent.right, loopParent, scope, remaps);
      traverseReplace(loopParent.test, loopParent, scope, remaps);
      traverseReplace(loopParent.update, loopParent, scope, remaps);
    }

    scope.traverse(this.block, replaceVisitor, remaps);
  };

  /**
   * Description
   */

  BlockScoping.prototype.wrapClosure = function wrapClosure() {
    var block = this.block;

    var outsideRefs = this.outsideLetReferences;

    // remap loop heads with colliding variables
    if (this.loopParent) {
      for (var name in outsideRefs) {
        var id = outsideRefs[name];

        if (this.scope.hasGlobal(id.name)) {
          delete outsideRefs[id.name];
          delete this.letReferences[id.name];

          this.scope.rename(id.name);

          this.letReferences[id.name] = id;
          outsideRefs[id.name] = id;
        }
      }
    }

    // if we're inside of a for loop then we search to see if there are any
    // `break`s, `continue`s, `return`s etc
    this.has = this.checkLoop();

    // hoist var references to retain scope
    this.hoistVarDeclarations();

    // turn outsideLetReferences into an array
    var params = values(outsideRefs);

    // build the closure that we're going to wrap the block with
    var fn = t.functionExpression(null, params, t.blockStatement(block.body));
    fn._aliasFunction = true;

    // replace the current block body with the one we're going to build
    block.body = this.body;

    // build a call and a unique id that we can assign the return value to
    var call = t.callExpression(fn, params);
    var ret = this.scope.generateUidIdentifier("ret");

    // handle generators
    var hasYield = traverse.hasType(fn.body, this.scope, "YieldExpression", t.FUNCTION_TYPES);
    if (hasYield) {
      fn.generator = true;
      call = t.yieldExpression(call, true);
    }

    // handlers async functions
    var hasAsync = traverse.hasType(fn.body, this.scope, "AwaitExpression", t.FUNCTION_TYPES);
    if (hasAsync) {
      fn.async = true;
      call = t.awaitExpression(call, true);
    }

    this.build(ret, call);
  };

  /**
   * Description
   */

  BlockScoping.prototype.getLetReferences = function getLetReferences() {
    var block = this.block;

    var declarators = block._letDeclarators || [];
    var declar;

    //
    for (var i = 0; i < declarators.length; i++) {
      declar = declarators[i];
      extend(this.outsideLetReferences, t.getBindingIdentifiers(declar));
    }

    //
    if (block.body) {
      for (i = 0; i < block.body.length; i++) {
        declar = block.body[i];
        if (isLet(declar, block)) {
          declarators = declarators.concat(declar.declarations);
        }
      }
    }

    //
    for (i = 0; i < declarators.length; i++) {
      declar = declarators[i];
      var keys = t.getBindingIdentifiers(declar);
      extend(this.letReferences, keys);
      this.hasLetReferences = true;
    }

    // no let references so we can just quit
    if (!this.hasLetReferences) return;

    // set let references to plain var references
    standardizeLets(declarators);

    var state = {
      letReferences: this.letReferences,
      closurify: false
    };

    // traverse through this block, stopping on functions and checking if they
    // contain any local let references
    this.scope.traverse(this.block, letReferenceBlockVisitor, state);

    return state.closurify;
  };

  /**
   * If we're inside of a loop then traverse it and check if it has one of
   * the following node types `ReturnStatement`, `BreakStatement`,
   * `ContinueStatement` and replace it with a return value that we can track
   * later on.
   *
   * @returns {Object}
   */

  BlockScoping.prototype.checkLoop = function checkLoop() {
    var state = {
      hasBreakContinue: false,
      ignoreLabeless: false,
      innerLabels: [],
      hasReturn: false,
      isLoop: !!this.loopParent,
      map: {}
    };

    this.scope.traverse(this.block, loopLabelVisitor, state);
    this.scope.traverse(this.block, loopVisitor, state);

    return state;
  };

  /**
   * Hoist all var declarations in this block to before it so they retain scope
   * once we wrap everything in a closure.
   */

  BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() {
    traverse(this.block, hoistVarDeclarationsVisitor, this.scope, this);
  };

  /**
   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with
   * their declarations hoisted to before the closure wrapper.
   *
   * @param {Node} node VariableDeclaration
   * @returns {Array}
   */

  BlockScoping.prototype.pushDeclar = function pushDeclar(node) {
    this.body.push(t.variableDeclaration(node.kind, node.declarations.map(function (declar) {
      return t.variableDeclarator(declar.id);
    })));

    var replace = [];

    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];
      if (!declar.init) continue;

      var expr = t.assignmentExpression("=", declar.id, declar.init);
      replace.push(t.inherits(expr, declar));
    }

    return replace;
  };

  /**
   * Push the closure to the body.
   *
   * @param {Node} ret Identifier
   * @param {Node} call CallExpression
   */

  BlockScoping.prototype.build = function build(ret, call) {
    var has = this.has;
    if (has.hasReturn || has.hasBreakContinue) {
      this.buildHas(ret, call);
    } else {
      this.body.push(t.expressionStatement(call));
    }
  };

  /**
   * Description
   *
   * @param {Node} ret Identifier
   * @param {Node} call CallExpression
   */

  BlockScoping.prototype.buildHas = function buildHas(ret, call) {
    var body = this.body;

    body.push(t.variableDeclaration("var", [t.variableDeclarator(ret, call)]));

    var loopParent = this.loopParent;
    var retCheck;
    var has = this.has;
    var cases = [];

    if (has.hasReturn) {
      // typeof ret === "object"
      retCheck = util.template("let-scoping-return", {
        RETURN: ret
      });
    }

    if (has.hasBreakContinue) {
      if (!loopParent) {
        throw new Error("Has no loop parent but we're trying to reassign breaks " + "and continues, something is going wrong here.");
      }

      for (var key in has.map) {
        cases.push(t.switchCase(t.literal(key), [has.map[key]]));
      }

      if (has.hasReturn) {
        cases.push(t.switchCase(null, [retCheck]));
      }

      if (cases.length === 1) {
        var single = cases[0];
        body.push(this.file.attachAuxiliaryComment(t.ifStatement(t.binaryExpression("===", ret, single.test), single.consequent[0])));
      } else {
        body.push(this.file.attachAuxiliaryComment(t.switchStatement(ret, cases)));
      }
    } else {
      if (has.hasReturn) {
        body.push(this.file.attachAuxiliaryComment(retCheck));
      }
    }
  };

  return BlockScoping;
})();
},{"../../../helpers/object":154,"../../../traversal":246,"../../../types":251,"../../../util":253,"lodash/object/extend":401,"lodash/object/values":405}],194:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var ReplaceSupers = require("../../helpers/replace-supers");
var nameMethod = require("../../helpers/name-method");
var defineMap = require("../../helpers/define-map");
var messages = require("../../../messages");
var util = require("../../../util");
var t = require("../../../types");

exports.check = t.isClass;

exports.ClassDeclaration = function (node, parent, scope, file) {
  return new ClassTransformer(node, file, scope, true).run();
};

exports.ClassExpression = function (node, parent, scope, file) {
  if (!node.id) {
    if (t.isProperty(parent) && parent.value === node && !parent.computed && t.isIdentifier(parent.key)) {
      // var o = { foo: class {} };
      node.id = parent.key;
    }

    if (t.isVariableDeclarator(parent) && t.isIdentifier(parent.id)) {
      // var foo = class {};
      node.id = parent.id;
    }
  }

  return new ClassTransformer(node, file, scope, false).run();
};

var ClassTransformer = (function () {

  /**
   * Description
   *
   * @param {Node} node
   * @param {File} file
   * @param {Scope} scope
   * @param {Boolean} isStatement
   */

  function ClassTransformer(node, file, scope, isStatement) {
    _classCallCheck(this, ClassTransformer);

    this.isStatement = isStatement;
    this.scope = scope;
    this.node = node;
    this.file = file;

    this.hasInstanceMutators = false;
    this.hasStaticMutators = false;

    this.instanceMutatorMap = {};
    this.staticMutatorMap = {};
    this.hasConstructor = false;
    this.className = node.id || scope.generateUidIdentifier("class");
    this.superName = node.superClass || t.identifier("Function");
    this.hasSuper = !!node.superClass;
    this.isLoose = file.isLoose("es6.classes");
  }

  /**
   * Description
   *
   * @returns {Array}
   */

  ClassTransformer.prototype.run = function run() {
    var superName = this.superName;
    var className = this.className;
    var classBody = this.node.body.body;
    var file = this.file;

    //

    var body = this.body = [];

    var constructorBody = t.blockStatement([t.expressionStatement(t.callExpression(file.addHelper("class-call-check"), [t.thisExpression(), className]))]);

    var constructor;
    if (this.node.id) {
      constructor = t.functionDeclaration(className, [], constructorBody);
      body.push(constructor);
    } else {
      var constructorName = null;
      // when a class has no parent and there is only a constructor or no body
      // then the constructor is not wrapped in a closure and needs to be named
      var containsOnlyConstructor = classBody.length === 1 && classBody[0].key.name === "constructor";
      if (!this.hasSuper && (classBody.length === 0 || containsOnlyConstructor)) {
        constructorName = className;
      }

      constructor = t.functionExpression(constructorName, [], constructorBody);
      body.push(t.variableDeclaration("var", [t.variableDeclarator(className, constructor)]));
    }
    this.constructor = constructor;

    var closureParams = [];
    var closureArgs = [];

    //

    if (this.hasSuper) {
      closureArgs.push(superName);

      if (!t.isIdentifier(superName)) {
        superName = this.scope.generateUidBasedOnNode(superName, this.file);
      }

      closureParams.push(superName);

      this.superName = superName;
      body.push(t.expressionStatement(t.callExpression(file.addHelper("inherits"), [className, superName])));
    }

    this.buildBody();

    t.inheritsComments(body[0], this.node);

    var init;

    if (body.length === 1) {
      // only a constructor so no need for a closure container
      init = t.toExpression(constructor);
    } else {
      body.push(t.returnStatement(className));
      init = t.callExpression(t.functionExpression(null, closureParams, t.blockStatement(body)), closureArgs);
    }

    if (this.isStatement) {
      return t.variableDeclaration("let", [t.variableDeclarator(className, init)]);
    } else {
      return init;
    }
  };

  /**
   * Description
   */

  ClassTransformer.prototype.buildBody = function buildBody() {
    var constructor = this.constructor;
    var className = this.className;
    var superName = this.superName;
    var classBody = this.node.body.body;
    var body = this.body;

    for (var i = 0; i < classBody.length; i++) {
      var node = classBody[i];
      if (t.isMethodDefinition(node)) {
        var replaceSupers = new ReplaceSupers({
          methodNode: node,
          className: this.className,
          superName: this.superName,
          isStatic: node["static"],
          isLoose: this.isLoose,
          scope: this.scope,
          file: this.file
        }, true);
        replaceSupers.replace();

        if (!node.computed && t.isIdentifier(node.key, { name: "constructor" }) || t.isLiteral(node.key, { value: "constructor" })) {
          this.pushConstructor(node);
        } else {
          this.pushMethod(node);
        }
      } else if (t.isPrivateDeclaration(node)) {
        this.closure = true;
        body.unshift(node);
      } else if (t.isClassProperty(node)) {
        this.pushProperty(node);
      }
    }

    // we have no constructor, we have a super, and the super doesn't appear to be falsy
    if (!this.hasConstructor && this.hasSuper && !t.isFalsyExpression(superName)) {
      var helperName = "class-super-constructor-call";
      if (this.isLoose) helperName += "-loose";
      constructor.body.body.push(util.template(helperName, {
        CLASS_NAME: className,
        SUPER_NAME: this.superName
      }, true));
    }

    var instanceProps;
    var staticProps;

    if (this.hasInstanceMutators) {
      instanceProps = defineMap.build(this.instanceMutatorMap);
    }

    if (this.hasStaticMutators) {
      staticProps = defineMap.build(this.staticMutatorMap);
    }

    if (instanceProps || staticProps) {
      if (!staticProps) staticProps = t.literal(null);

      var args = [className, staticProps];
      if (instanceProps) args.push(instanceProps);

      body.push(t.expressionStatement(t.callExpression(this.file.addHelper("prototype-properties"), args)));
    }
  };

  /**
   * Push a method to its respective mutatorMap.
   *
   * @param {Node} node MethodDefinition
   */

  ClassTransformer.prototype.pushMethod = function pushMethod(node) {
    var methodName = node.key;

    var kind = node.kind;

    if (kind === "") {
      nameMethod.property(node, this.file, this.scope);

      if (this.isLoose) {
        // use assignments instead of define properties for loose classes

        var className = this.className;
        if (!node["static"]) className = t.memberExpression(className, t.identifier("prototype"));
        methodName = t.memberExpression(className, methodName, node.computed);

        var expr = t.expressionStatement(t.assignmentExpression("=", methodName, node.value));
        t.inheritsComments(expr, node);
        this.body.push(expr);
        return;
      }

      kind = "value";
    }

    var mutatorMap = this.instanceMutatorMap;
    if (node["static"]) {
      this.hasStaticMutators = true;
      mutatorMap = this.staticMutatorMap;
    } else {
      this.hasInstanceMutators = true;
    }

    defineMap.push(mutatorMap, methodName, kind, node.computed, node);
    defineMap.push(mutatorMap, methodName, "enumerable", node.computed, false);
  };

  /**
   * Description
   *
   * @param {Node} node
   */

  ClassTransformer.prototype.pushProperty = function pushProperty(node) {
    if (!node.value) return;

    var key;

    if (node["static"]) {
      key = t.memberExpression(this.className, node.key);
      this.body.push(t.expressionStatement(t.assignmentExpression("=", key, node.value)));
    } else {
      key = t.memberExpression(t.thisExpression(), node.key);
      this.constructor.body.body.unshift(t.expressionStatement(t.assignmentExpression("=", key, node.value)));
    }
  };

  /**
   * Replace the constructor body of our class.
   *
   * @param {Node} method MethodDefinition
   */

  ClassTransformer.prototype.pushConstructor = function pushConstructor(method) {
    if (method.kind) {
      throw this.file.errorWithNode(method, messages.get("classesIllegalConstructorKind"));
    }

    var construct = this.constructor;
    var fn = method.value;

    this.hasConstructor = true;

    t.inherits(construct, fn);
    t.inheritsComments(construct, method);

    construct._ignoreUserWhitespace = true;
    construct.params = fn.params;
    construct.body.body = construct.body.body.concat(fn.body.body);
  };

  return ClassTransformer;
})();
},{"../../../messages":157,"../../../types":251,"../../../util":253,"../../helpers/define-map":165,"../../helpers/name-method":168,"../../helpers/replace-supers":171}],195:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t = require("../../../types");

exports.check = function (node) {
  return t.isVariableDeclaration(node, { kind: "const" });
};

var visitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isAssignmentExpression(node) || t.isUpdateExpression(node)) {
      var ids = t.getBindingIdentifiers(node);

      for (var name in ids) {
        var id = ids[name];

        var constant = state.constants[name];

        // no constant exists
        if (!constant) continue;

        var constantIdentifier = constant.identifier;

        // check if the assignment id matches the constant declaration id
        // if it does then it was the id used to initially declare the
        // constant so we can just ignore it
        if (id === constantIdentifier) continue;

        // check if there's been a local binding that shadows this constant
        if (!scope.bindingIdentifierEquals(name, constantIdentifier)) continue;

        throw state.file.errorWithNode(id, messages.get("readOnly", name));
      }
    } else if (t.isScope(node, parent)) {
      this.skip();
    }
  }
};

exports.Scopable = function (node, parent, scope, file) {
  scope.traverse(node, visitor, {
    constants: scope.getAllBindingsOfKind("const"),
    file: file
  });
};

exports.VariableDeclaration = function (node) {
  if (node.kind === "const") node.kind = "let";
};
},{"../../../messages":157,"../../../types":251}],196:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var messages = require("../../../messages");
var t = require("../../../types");

exports.check = t.isPattern;

exports.ForInStatement = exports.ForOfStatement = function (node, parent, scope, file) {
  var left = node.left;

  if (t.isPattern(left)) {
    // for ({ length: k } in { abc: 3 });

    var temp = scope.generateUidIdentifier("ref");

    node.left = t.variableDeclaration("var", [t.variableDeclarator(temp)]);

    t.ensureBlock(node);

    node.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(left, temp)]));

    return;
  }

  if (!t.isVariableDeclaration(left)) return;

  var pattern = left.declarations[0].id;
  if (!t.isPattern(pattern)) return;

  var key = scope.generateUidIdentifier("ref");
  node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);

  var nodes = [];

  var destructuring = new DestructuringTransformer({
    kind: left.kind,
    file: file,
    scope: scope,
    nodes: nodes
  });

  destructuring.init(pattern, key);

  t.ensureBlock(node);

  var block = node.body;
  block.body = nodes.concat(block.body);
};

exports.Function = function (node, parent, scope, file) {
  var nodes = [];

  var hasDestructuringTransformer = false;

  node.params = node.params.map(function (pattern, i) {
    if (!t.isPattern(pattern)) return pattern;

    hasDestructuringTransformer = true;
    var ref = scope.generateUidIdentifier("ref");

    var destructuring = new DestructuringTransformer({
      blockHoist: node.params.length - i,
      nodes: nodes,
      scope: scope,
      file: file,
      kind: "var" });
    destructuring.init(pattern, ref);

    return ref;
  });

  if (!hasDestructuringTransformer) return;

  t.ensureBlock(node);

  var block = node.body;
  block.body = nodes.concat(block.body);
};

exports.CatchClause = function (node, parent, scope, file) {
  var pattern = node.param;
  if (!t.isPattern(pattern)) return;

  var ref = scope.generateUidIdentifier("ref");
  node.param = ref;

  var nodes = [];

  var destructuring = new DestructuringTransformer({
    kind: "let",
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(pattern, ref);

  node.body.body = nodes.concat(node.body.body);

  return node;
};

exports.ExpressionStatement = function (node, parent, scope, file) {
  var expr = node.expression;
  if (expr.type !== "AssignmentExpression") return;
  if (!t.isPattern(expr.left)) return;
  if (file.isConsequenceExpressionStatement(node)) return;

  var nodes = [];

  var ref = scope.generateUidIdentifier("ref");
  nodes.push(t.variableDeclaration("var", [t.variableDeclarator(ref, expr.right)]));

  var destructuring = new DestructuringTransformer({
    operator: expr.operator,
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(expr.left, ref);

  return nodes;
};

exports.AssignmentExpression = function (node, parent, scope, file) {
  if (!t.isPattern(node.left)) return;

  var ref = scope.generateUidIdentifier("temp");
  scope.push({
    key: ref.name,
    id: ref
  });

  var nodes = [];
  nodes.push(t.assignmentExpression("=", ref, node.right));

  var destructuring = new DestructuringTransformer({
    operator: node.operator,
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(node.left, ref);

  nodes.push(ref);

  return t.toSequenceExpression(nodes, scope);
};

var variableDeclarationHasPattern = function variableDeclarationHasPattern(node) {
  for (var i = 0; i < node.declarations.length; i++) {
    if (t.isPattern(node.declarations[i].id)) {
      return true;
    }
  }
  return false;
};

exports.VariableDeclaration = function (node, parent, scope, file) {
  if (t.isForInStatement(parent) || t.isForOfStatement(parent)) return;
  if (!variableDeclarationHasPattern(node)) return;

  var nodes = [];
  var declar;

  for (var i = 0; i < node.declarations.length; i++) {
    declar = node.declarations[i];

    var patternId = declar.init;
    var pattern = declar.id;

    var destructuring = new DestructuringTransformer({
      nodes: nodes,
      scope: scope,
      kind: node.kind,
      file: file
    });

    if (t.isPattern(pattern) && patternId) {
      destructuring.init(pattern, patternId);

      if (+i !== node.declarations.length - 1) {
        // we aren't the last declarator so let's just make the
        // last transformed node inherit from us
        t.inherits(nodes[nodes.length - 1], declar);
      }
    } else {
      nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));
    }
  }

  if (!t.isProgram(parent) && !t.isBlockStatement(parent)) {
    // https://github.com/babel/babel/issues/113
    // for (let [x] = [0]; false;) {}

    declar = null;

    for (i = 0; i < nodes.length; i++) {
      node = nodes[i];
      if (!declar) declar = t.variableDeclaration(node.kind, []);

      if (!t.isVariableDeclaration(node) && declar.kind !== node.kind) {
        throw file.errorWithNode(node, messages.get("invalidParentForThisNode"));
      }

      declar.declarations = declar.declarations.concat(node.declarations);
    }

    return declar;
  }

  return nodes;
};

var hasRest = function hasRest(pattern) {
  for (var i = 0; i < pattern.elements.length; i++) {
    if (t.isRestElement(pattern.elements[i])) {
      return true;
    }
  }
  return false;
};

var DestructuringTransformer = (function () {
  function DestructuringTransformer(opts) {
    _classCallCheck(this, DestructuringTransformer);

    this.blockHoist = opts.blockHoist;
    this.operator = opts.operator;
    this.nodes = opts.nodes;
    this.scope = opts.scope;
    this.file = opts.file;
    this.kind = opts.kind;
  }

  DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {
    var op = this.operator;
    if (t.isMemberExpression(id)) op = "=";

    var node;

    if (op) {
      node = t.expressionStatement(t.assignmentExpression(op, id, init));
    } else {
      node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);
    }

    node._blockHoist = this.blockHoist;

    return node;
  };

  DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
    var declar = t.variableDeclaration("var", [t.variableDeclarator(id, init)]);
    declar._blockHoist = this.blockHoist;
    return declar;
  };

  DestructuringTransformer.prototype.push = function push(id, init) {
    if (t.isObjectPattern(id)) {
      this.pushObjectPattern(id, init);
    } else if (t.isArrayPattern(id)) {
      this.pushArrayPattern(id, init);
    } else if (t.isAssignmentPattern(id)) {
      this.pushAssignmentPattern(id, init);
    } else {
      this.nodes.push(this.buildVariableAssignment(id, init));
    }
  };

  DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {
    // we need to assign the current value of the assignment to avoid evaluating
    // it more than once

    var tempValueRef = this.scope.generateUidBasedOnNode(valueRef);

    var declar = t.variableDeclaration("var", [t.variableDeclarator(tempValueRef, valueRef)]);
    declar._blockHoist = this.blockHoist;
    this.nodes.push(declar);

    //

    this.nodes.push(this.buildVariableAssignment(pattern.left, t.conditionalExpression(t.binaryExpression("===", tempValueRef, t.identifier("undefined")), pattern.right, tempValueRef)));
  };

  DestructuringTransformer.prototype.pushObjectSpread = function pushObjectSpread(pattern, objRef, spreadProp, spreadPropIndex) {
    // get all the keys that appear in this object before the current spread

    var keys = [];

    for (var i = 0; i < pattern.properties.length; i++) {
      var prop = pattern.properties[i];

      // we've exceeded the index of the spread property to all properties to the
      // right need to be ignored
      if (i >= spreadPropIndex) break;

      // ignore other spread properties
      if (t.isSpreadProperty(prop)) continue;

      var key = prop.key;
      if (t.isIdentifier(key)) key = t.literal(prop.key.name);
      keys.push(key);
    }

    keys = t.arrayExpression(keys);

    //

    var value = t.callExpression(this.file.addHelper("object-without-properties"), [objRef, keys]);
    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
  };

  DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {
    if (t.isLiteral(prop.key)) prop.computed = true;

    var pattern = prop.value;
    var objRef = t.memberExpression(propRef, prop.key, prop.computed);

    if (t.isPattern(pattern)) {
      this.push(pattern, objRef);
    } else {
      this.nodes.push(this.buildVariableAssignment(pattern, objRef));
    }
  };

  DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
    // https://github.com/babel/babel/issues/681

    if (!pattern.properties.length) {
      this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper("object-destructuring-empty"), [objRef])));
    }

    // if we have more than one properties in this pattern and the objectRef is a
    // member expression then we need to assign it to a temporary variable so it's
    // only evaluated once

    if (pattern.properties.length > 1 && t.isMemberExpression(objRef)) {
      var temp = this.scope.generateUidBasedOnNode(objRef, this.file);
      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
      objRef = temp;
    }

    //

    for (var i = 0; i < pattern.properties.length; i++) {
      var prop = pattern.properties[i];
      if (t.isSpreadProperty(prop)) {
        this.pushObjectSpread(pattern, objRef, prop, i);
      } else {
        this.pushObjectProperty(prop, objRef);
      }
    }
  };

  DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
    // not an array so there's no way we can deal with this
    if (!t.isArrayExpression(arr)) return false;

    // pattern has less elements than the array and doesn't have a rest so some
    // elements wont be evaluated
    if (pattern.elements.length > arr.elements.length) return;
    if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;

    // deopt on holes
    for (var i = 0; i < pattern.elements.length; i++) {
      if (!pattern.elements[i]) return false;
    }

    return true;
  };

  DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
    for (var i = 0; i < pattern.elements.length; i++) {
      var elem = pattern.elements[i];
      if (t.isRestElement(elem)) {
        this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));
      } else {
        this.push(elem, arr.elements[i]);
      }
    }
  };

  DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
    if (!pattern.elements) return;

    // optimise basic array destructuring of an array expression
    //
    // we can't do this to a pattern of unequal size to it's right hand
    // array expression as then there will be values that wont be evaluated
    //
    // eg: var [a, b] = [1, 2];

    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
      return this.pushUnpackedArrayPattern(pattern, arrayRef);
    }

    // if we have a rest then we need all the elements so don't tell
    // `scope.toArray` to only get a certain amount

    var count = !hasRest(pattern) && pattern.elements.length;

    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will
    // return a locally bound identifier if it's been inferred to be an array,
    // otherwise it'll be a call to a helper that will ensure it's one

    var toArray = this.scope.toArray(arrayRef, count);

    if (t.isIdentifier(toArray)) {
      // we've been given an identifier so it must have been inferred to be an
      // array
      arrayRef = toArray;
    } else {
      arrayRef = this.scope.generateUidBasedOnNode(arrayRef);
      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
      this.scope.assignTypeGeneric(arrayRef.name, "Array");
    }

    //

    for (var i = 0; i < pattern.elements.length; i++) {
      var elem = pattern.elements[i];

      // hole
      if (!elem) continue;

      var elemRef;

      if (t.isRestElement(elem)) {
        elemRef = this.scope.toArray(arrayRef);

        if (i > 0) {
          elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier("slice")), [t.literal(i)]);
        }

        // set the element to the rest element argument since we've dealt with it
        // being a rest already
        elem = elem.argument;
      } else {
        elemRef = t.memberExpression(arrayRef, t.literal(i), true);
      }

      this.push(elem, elemRef);
    }
  };

  DestructuringTransformer.prototype.init = function init(pattern, ref) {
    // trying to destructure a value that we can't evaluate more than once so we
    // need to save it to a variable

    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref) && !t.isIdentifier(ref)) {
      var key = this.scope.generateUidBasedOnNode(ref);
      this.nodes.push(this.buildVariableDeclaration(key, ref));
      ref = key;
    }

    //

    this.push(pattern, ref);
  };

  return DestructuringTransformer;
})();
},{"../../../messages":157,"../../../types":251}],197:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var util = require("../../../util");
var t = require("../../../types");

exports.check = t.isForOfStatement;

exports.ForOfStatement = function (node, parent, scope, file) {
  var callback = spec;
  if (file.isLoose("es6.forOf")) callback = loose;

  var build = callback(node, parent, scope, file);
  var declar = build.declar;
  var loop = build.loop;
  var block = loop.body;

  // inherit comments from the original loop
  t.inheritsComments(loop, node);

  // ensure that it's a block so we can take all its statements
  t.ensureBlock(node);

  // add the value declaration to the new loop body
  if (declar) {
    block.body.push(declar);
  }

  // push the rest of the original loop body onto our new body
  block.body = block.body.concat(node.body.body);

  t.inherits(loop, node);

  // todo: find out why this is necessary? #538
  loop._scopeInfo = node._scopeInfo;

  return loop;
};

var breakVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isLoop(node)) {
      state.ignoreLabeless = true;
      scope.traverse(node, breakVisitor, state);
      state.ignoreLabeless = false;
      return this.skip();
    }

    if (t.isBreakStatement(node)) {
      if (!node.label && state.ignoreLabeless) return;
      if (node.label && node.label.name !== state.label) return;

      var ret = t.expressionStatement(t.callExpression(t.memberExpression(state.iteratorKey, t.identifier("return")), []));
      ret = state.wrapReturn(ret);

      this.skip();
      return [ret, node];
    }
  }
};

var loose = function loose(node, parent, scope, file) {
  var left = node.left;
  var declar, id;

  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
    // for (i of test), for ({ i } of test)
    id = left;
  } else if (t.isVariableDeclaration(left)) {
    // for (var i of test)
    id = scope.generateUidIdentifier("ref");
    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]);
  } else {
    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
  }

  var iteratorKey = scope.generateUidIdentifier("iterator");
  var isArrayKey = scope.generateUidIdentifier("isArray");

  var loop = util.template("for-of-loose", {
    LOOP_OBJECT: iteratorKey,
    IS_ARRAY: isArrayKey,
    OBJECT: node.right,
    INDEX: scope.generateUidIdentifier("i"),
    ID: id
  });

  if (!declar) {
    // no declaration so we need to remove the variable declaration at the top of
    // the for-of-loose template
    loop.body.body.shift();
  }

  //

  scope.traverse(node, breakVisitor, {
    iteratorKey: iteratorKey,
    wrapReturn: function wrapReturn(node) {
      return t.ifStatement(t.logicalExpression("&&", t.unaryExpression("!", isArrayKey, true), t.memberExpression(iteratorKey, t.identifier("return"))), node);
    },
    label: t.isLabeledStatement(parent) && parent.label.name
  });

  //

  return {
    declar: declar,
    loop: loop
  };
};

var spec = function spec(node, parent, scope, file) {
  var left = node.left;
  var declar;

  var stepKey = scope.generateUidIdentifier("step");
  var stepValue = t.memberExpression(stepKey, t.identifier("value"));

  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {
    // for (i of test), for ({ i } of test)
    declar = t.expressionStatement(t.assignmentExpression("=", left, stepValue));
  } else if (t.isVariableDeclaration(left)) {
    // for (var i of test)
    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);
  } else {
    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
  }

  //

  var iteratorKey = scope.generateUidIdentifier("iterator");

  var loop = util.template("for-of", {
    ITERATOR_KEY: iteratorKey,
    STEP_KEY: stepKey,
    OBJECT: node.right
  });

  //

  scope.traverse(node, breakVisitor, {
    iteratorKey: iteratorKey,
    wrapReturn: function wrapReturn(node) {
      return t.ifStatement(t.memberExpression(iteratorKey, t.identifier("return")), node);
    },
    label: t.isLabeledStatement(parent) && parent.label.name
  });

  //

  return {
    declar: declar,
    loop: loop
  };
};
},{"../../../messages":157,"../../../types":251,"../../../util":253}],198:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = require("../internal/modules").check;

exports.ImportDeclaration = function (node, parent, scope, file) {
  // flow type
  if (node.isType) return;

  var nodes = [];

  if (node.specifiers.length) {
    for (var i = 0; i < node.specifiers.length; i++) {
      file.moduleFormatter.importSpecifier(node.specifiers[i], node, nodes, parent);
    }
  } else {
    file.moduleFormatter.importDeclaration(node, nodes, parent);
  }

  if (nodes.length === 1) {
    // inherit `_blockHoist` - this is for `_blockHoist` in File.prototype.addImport
    nodes[0]._blockHoist = node._blockHoist;
  }

  return nodes;
};

exports.ExportDeclaration = function (node, parent, scope, file) {
  // flow type
  if (t.isTypeAlias(node.declaration)) return;

  var nodes = [];
  var i;

  if (node.declaration) {
    // make sure variable exports have an initializer
    // this is done here to avoid duplicating it in the module formatters
    if (t.isVariableDeclaration(node.declaration)) {
      var declar = node.declaration.declarations[0];
      declar.init = declar.init || t.identifier("undefined");
    }

    file.moduleFormatter.exportDeclaration(node, nodes, parent);
  } else if (node.specifiers) {
    for (i = 0; i < node.specifiers.length; i++) {
      file.moduleFormatter.exportSpecifier(node.specifiers[i], node, nodes, parent);
    }
  }

  if (node._blockHoist) {
    for (i = 0; i < nodes.length; i++) {
      nodes[i]._blockHoist = node._blockHoist;
    }
  }

  return nodes;
};
},{"../../../types":251,"../internal/modules":218}],199:[function(require,module,exports){
"use strict";

var ReplaceSupers = require("../../helpers/replace-supers");
var t = require("../../../types");

exports.check = function (node) {
  return t.isIdentifier(node, { name: "super" });
};

exports.Property = function (node, parent, scope, file) {
  if (!node.method) return;

  var value = node.value;
  var thisExpr = scope.generateUidIdentifier("this");

  var replaceSupers = new ReplaceSupers({
    topLevelThisReference: thisExpr,
    methodNode: node,
    className: thisExpr,
    isStatic: true,
    scope: scope,
    file: file
  });

  replaceSupers.replace();

  if (replaceSupers.hasSuper) {
    value.body.body.unshift(t.variableDeclaration("var", [t.variableDeclarator(thisExpr, t.thisExpression())]));
  }
};
},{"../../../types":251,"../../helpers/replace-supers":171}],200:[function(require,module,exports){
"use strict";

var util = require("../../../util");
var t = require("../../../types");

exports.check = function (node) {
  return t.isFunction(node) && hasDefaults(node);
};

var hasDefaults = function hasDefaults(node) {
  for (var i = 0; i < node.params.length; i++) {
    if (!t.isIdentifier(node.params[i])) return true;
  }
  return false;
};

var iifeVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (!t.isReferencedIdentifier(node, parent)) return;
    if (!state.scope.hasOwnBinding(node.name)) return;
    if (state.scope.bindingIdentifierEquals(node.name, node)) return;

    state.iife = true;
    this.stop();
  }
};

exports.Function = function (node, parent, scope, file) {
  if (!hasDefaults(node)) return;

  t.ensureBlock(node);

  var body = [];

  var argsIdentifier = t.identifier("arguments");
  argsIdentifier._ignoreAliasFunctions = true;

  var lastNonDefaultParam = 0;

  var state = { iife: false, scope: scope };

  var pushDefNode = function pushDefNode(left, right, i) {
    var defNode = util.template("default-parameter", {
      VARIABLE_NAME: left,
      DEFAULT_VALUE: right,
      ARGUMENT_KEY: t.literal(i),
      ARGUMENTS: argsIdentifier
    }, true);
    file.checkNode(defNode);
    defNode._blockHoist = node.params.length - i;
    body.push(defNode);
  };

  for (var i = 0; i < node.params.length; i++) {
    var param = node.params[i];

    if (!t.isAssignmentPattern(param)) {
      if (!t.isRestElement(param)) {
        lastNonDefaultParam = i + 1;
      }

      if (!t.isIdentifier(param)) {
        scope.traverse(param, iifeVisitor, state);
      }

      if (file.transformers["es6.blockScopingTDZ"].canRun()) {
        pushDefNode(param, t.identifier("undefined"), i);
      }

      continue;
    }

    var left = param.left;
    var right = param.right;

    var placeholder = scope.generateUidIdentifier("x");
    placeholder._isDefaultPlaceholder = true;
    node.params[i] = placeholder;

    if (!state.iife) {
      if (t.isIdentifier(right) && scope.hasOwnBinding(right.name)) {
        state.iife = true;
      } else {
        scope.traverse(right, iifeVisitor, state);
      }
    }

    pushDefNode(left, right, i);
  }

  // we need to cut off all trailing default parameters
  node.params = node.params.slice(0, lastNonDefaultParam);

  if (state.iife) {
    var container = t.functionExpression(null, [], node.body, node.generator);
    container._aliasFunction = true;

    body.push(t.returnStatement(t.callExpression(container, [])));

    node.body = t.blockStatement(body);
  } else {
    node.body.body = body.concat(node.body.body);
  }
};
},{"../../../types":251,"../../../util":253}],201:[function(require,module,exports){
"use strict";

var util = require("../../../util");
var t = require("../../../types");

exports.check = t.isRestElement;

var hasRest = function hasRest(node) {
  return t.isRestElement(node.params[node.params.length - 1]);
};

exports.Function = function (node, parent, scope) {
  if (!hasRest(node)) return;

  var rest = node.params.pop().argument;

  var argsId = t.identifier("arguments");

  // otherwise `arguments` will be remapped in arrow functions
  argsId._ignoreAliasFunctions = true;

  var start = t.literal(node.params.length);
  var key = scope.generateUidIdentifier("key");
  var len = scope.generateUidIdentifier("len");

  var arrKey = key;
  var arrLen = len;
  if (node.params.length) {
    // this method has additional params, so we need to subtract
    // the index of the current argument position from the
    // position in the array that we want to populate
    arrKey = t.binaryExpression("-", key, start);

    // we need to work out the size of the array that we're
    // going to store all the rest parameters
    //
    // we need to add a check to avoid constructing the array
    // with <0 if there are less arguments than params as it'll
    // cause an error
    arrLen = t.conditionalExpression(t.binaryExpression(">", len, start), t.binaryExpression("-", len, start), t.literal(0));
  }

  // support patterns
  if (t.isPattern(rest)) {
    var pattern = rest;
    rest = scope.generateUidIdentifier("ref");

    // let the destructuring transformer handle this
    var restDeclar = t.variableDeclaration("var", [t.variableDeclarator(pattern, rest)]);

    // retain evaluation position
    restDeclar._blockHoist = node.params.length + 1;

    node.body.body.unshift(restDeclar);
  }

  scope.assignTypeGeneric(rest.name, "Array");

  var loop = util.template("rest", {
    ARGUMENTS: argsId,
    ARRAY_KEY: arrKey,
    ARRAY_LEN: arrLen,
    START: start,
    ARRAY: rest,
    KEY: key,
    LEN: len });
  loop._blockHoist = node.params.length + 1;
  node.body.body.unshift(loop);
};
},{"../../../types":251,"../../../util":253}],202:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = function (node) {
  return t.isProperty(node) && node.computed;
};

exports.ObjectExpression = function (node, parent, scope, file) {
  var hasComputed = false;

  for (var i = 0; i < node.properties.length; i++) {
    hasComputed = t.isProperty(node.properties[i], { computed: true, kind: "init" });
    if (hasComputed) break;
  }

  if (!hasComputed) return;

  var initProps = [];
  var objId = scope.generateUidBasedOnNode(parent);

  //

  var body = [];
  var container = t.functionExpression(null, [], t.blockStatement(body));
  container._aliasFunction = true;

  //

  var callback = spec;
  if (file.isLoose("es6.properties.computed")) callback = loose;

  var result = callback(node, body, objId, initProps, file);
  if (result) return result;

  //

  body.unshift(t.variableDeclaration("var", [t.variableDeclarator(objId, t.objectExpression(initProps))]));

  body.push(t.returnStatement(objId));

  return t.callExpression(container, []);
};

var loose = function loose(node, body, objId) {
  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];

    body.push(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)), prop.value)));
  }
};

var spec = function spec(node, body, objId, initProps, file) {
  var props = node.properties;
  var prop, key;

  // normalize key

  for (var i = 0; i < props.length; i++) {
    prop = props[i];
    if (prop.kind !== "init") continue;

    key = prop.key;

    if (!prop.computed && t.isIdentifier(key)) {
      prop.key = t.literal(key.name);
    }
  }

  // add all non-computed properties and `__proto__` properties to the initializer

  var broken = false;

  for (i = 0; i < props.length; i++) {
    prop = props[i];

    if (prop.computed) {
      broken = true;
    }

    if (prop.kind !== "init" || !broken || t.isLiteral(t.toComputedKey(prop, prop.key), { value: "__proto__" })) {
      initProps.push(prop);
      props[i] = null;
    }
  }

  // add a simple assignment for all Symbol member expressions due to symbol polyfill limitations
  // otherwise use Object.defineProperty

  for (i = 0; i < props.length; i++) {
    prop = props[i];
    if (!prop) continue;

    key = prop.key;
    var bodyNode;

    if (prop.computed && t.isMemberExpression(key) && t.isIdentifier(key.object, { name: "Symbol" })) {
      // { [Symbol.iterator]: "foo" }
      bodyNode = t.assignmentExpression("=", t.memberExpression(objId, key, true), prop.value);
    } else {
      bodyNode = t.callExpression(file.addHelper("define-property"), [objId, key, prop.value]);
    }

    body.push(t.expressionStatement(bodyNode));
  }

  // only one node and it's a Object.defineProperty that returns the object

  if (body.length === 1) {
    var first = body[0].expression;

    if (t.isCallExpression(first)) {
      first.arguments[0] = t.objectExpression(initProps);
      return first;
    }
  }
};
},{"../../../types":251}],203:[function(require,module,exports){
"use strict";

var clone = require("lodash/lang/clone");
var t = require("../../../types");

exports.check = function (node) {
  return t.isProperty(node) && (node.method || node.shorthand);
};

exports.Property = function (node) {
  if (node.method) {
    node.method = false;
  }

  if (node.shorthand) {
    node.shorthand = false;
    node.key = t.removeComments(clone(node.key));
  }
};
},{"../../../types":251,"lodash/lang/clone":386}],204:[function(require,module,exports){
"use strict";

var includes = require("lodash/collection/includes");
var t = require("../../../types");

exports.check = t.isSpreadElement;

var getSpreadLiteral = function getSpreadLiteral(spread, scope) {
  return scope.toArray(spread.argument, true);
};

var hasSpread = function hasSpread(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (t.isSpreadElement(nodes[i])) {
      return true;
    }
  }
  return false;
};

var build = function build(props, scope) {
  var nodes = [];

  var _props = [];

  var push = function push() {
    if (!_props.length) return;
    nodes.push(t.arrayExpression(_props));
    _props = [];
  };

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    if (t.isSpreadElement(prop)) {
      push();
      nodes.push(getSpreadLiteral(prop, scope));
    } else {
      _props.push(prop);
    }
  }

  push();

  return nodes;
};

exports.ArrayExpression = function (node, parent, scope) {
  var elements = node.elements;
  if (!hasSpread(elements)) return;

  var nodes = build(elements, scope);
  var first = nodes.shift();

  if (!t.isArrayExpression(first)) {
    nodes.unshift(first);
    first = t.arrayExpression([]);
  }

  return t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
};

exports.CallExpression = function (node, parent, scope) {
  var args = node.arguments;
  if (!hasSpread(args)) return;

  var contextLiteral = t.identifier("undefined");

  node.arguments = [];

  var nodes;
  if (args.length === 1 && args[0].argument.name === "arguments") {
    nodes = [args[0].argument];
  } else {
    nodes = build(args, scope);
  }

  var first = nodes.shift();
  if (nodes.length) {
    node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes));
  } else {
    node.arguments.push(first);
  }

  var callee = node.callee;

  if (t.isMemberExpression(callee)) {
    var temp = scope.generateTempBasedOnNode(callee.object);
    if (temp) {
      callee.object = t.assignmentExpression("=", temp, callee.object);
      contextLiteral = temp;
    } else {
      contextLiteral = callee.object;
    }
    t.appendToMemberExpression(callee, t.identifier("apply"));
  } else {
    node.callee = t.memberExpression(node.callee, t.identifier("apply"));
  }

  node.arguments.unshift(contextLiteral);
};

exports.NewExpression = function (node, parent, scope, file) {
  var args = node.arguments;
  if (!hasSpread(args)) return;

  var nativeType = t.isIdentifier(node.callee) && includes(t.NATIVE_TYPE_NAMES, node.callee.name);

  var nodes = build(args, scope);

  if (nativeType) {
    nodes.unshift(t.arrayExpression([t.literal(null)]));
  }

  var first = nodes.shift();

  if (nodes.length) {
    args = t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
  } else {
    args = first;
  }

  if (nativeType) {
    return t.newExpression(t.callExpression(t.memberExpression(file.addHelper("bind"), t.identifier("apply")), [node.callee, args]), []);
  } else {
    return t.callExpression(file.addHelper("apply-constructor"), [node.callee, args]);
  }
};
},{"../../../types":251,"lodash/collection/includes":306}],205:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var reduceRight = require("lodash/collection/reduceRight");
var messages = require("../../../messages");
var flatten = require("lodash/array/flatten");
var util = require("../../../util");
var map = require("lodash/collection/map");
var t = require("../../../types");

exports.Function = function (node, parent, scope, file) {
  var tailCall = new TailCallTransformer(node, scope, file);
  tailCall.run();
};

function returnBlock(expr) {
  return t.blockStatement([t.returnStatement(expr)]);
}

// looks for and replaces tail recursion calls
var firstPass = {
  enter: function enter(node, parent, scope, state) {
    if (t.isIfStatement(node)) {
      if (t.isReturnStatement(node.alternate)) {
        t.ensureBlock(node, "alternate");
      }

      if (t.isReturnStatement(node.consequent)) {
        t.ensureBlock(node, "consequent");
      }
    } else if (t.isReturnStatement(node)) {
      this.skip();
      return state.subTransform(node.argument);
    } else if (t.isTryStatement(parent)) {
      if (node === parent.block) {
        this.skip();
      } else if (parent.finalizer && node !== parent.finalizer) {
        this.skip();
      }
    } else if (t.isFunction(node)) {
      this.skip();
    } else if (t.isVariableDeclaration(node)) {
      this.skip();
      state.vars.push(node);
    }
  }
};

// hoists up function declarations, replaces `this` and `arguments` and marks
// them as needed
var secondPass = {
  enter: function enter(node, parent, scope, state) {
    if (t.isThisExpression(node)) {
      state.needsThis = true;
      return state.getThisId();
    } else if (t.isReferencedIdentifier(node, parent, { name: "arguments" })) {
      state.needsArguments = true;
      return state.getArgumentsId();
    } else if (t.isFunction(node)) {
      this.skip();
      if (t.isFunctionDeclaration(node)) {
        node = t.variableDeclaration("var", [t.variableDeclarator(node.id, t.toExpression(node))]);
        node._blockHoist = 2;
        return node;
      }
    }
  }
};

// optimizes recursion by removing `this` and `arguments` if they aren't used
var thirdPass = {
  enter: function enter(node, parent, scope, state) {
    if (!t.isExpressionStatement(node)) return;

    var expr = node.expression;
    if (!t.isAssignmentExpression(expr)) return;

    if (!state.needsThis && expr.left === state.getThisId()) {
      this.remove();
    } else if (!state.needsArguments && expr.left === state.getArgumentsId() && t.isArrayExpression(expr.right)) {
      return map(expr.right.elements, function (elem) {
        return t.expressionStatement(elem);
      });
    }
  }
};

var TailCallTransformer = (function () {
  function TailCallTransformer(node, scope, file) {
    _classCallCheck(this, TailCallTransformer);

    this.hasTailRecursion = false;
    this.needsArguments = false;
    this.setsArguments = false;
    this.needsThis = false;
    this.ownerId = node.id;
    this.vars = [];

    this.scope = scope;
    this.file = file;
    this.node = node;
  }

  TailCallTransformer.prototype.getArgumentsId = function getArgumentsId() {
    var _ref;

    return (_ref = this, !_ref.argumentsId && (_ref.argumentsId = this.scope.generateUidIdentifier("arguments")), _ref.argumentsId);
  };

  TailCallTransformer.prototype.getThisId = function getThisId() {
    var _ref;

    return (_ref = this, !_ref.thisId && (_ref.thisId = this.scope.generateUidIdentifier("this")), _ref.thisId);
  };

  TailCallTransformer.prototype.getLeftId = function getLeftId() {
    var _ref;

    return (_ref = this, !_ref.leftId && (_ref.leftId = this.scope.generateUidIdentifier("left")), _ref.leftId);
  };

  TailCallTransformer.prototype.getFunctionId = function getFunctionId() {
    var _ref;

    return (_ref = this, !_ref.functionId && (_ref.functionId = this.scope.generateUidIdentifier("function")), _ref.functionId);
  };

  TailCallTransformer.prototype.getAgainId = function getAgainId() {
    var _ref;

    return (_ref = this, !_ref.againId && (_ref.againId = this.scope.generateUidIdentifier("again")), _ref.againId);
  };

  TailCallTransformer.prototype.getParams = function getParams() {
    var params = this.params;

    if (!params) {
      params = this.node.params;
      this.paramDecls = [];

      for (var i = 0; i < params.length; i++) {
        var param = params[i];
        if (!param._isDefaultPlaceholder) {
          this.paramDecls.push(t.variableDeclarator(param, params[i] = this.scope.generateUidIdentifier("x")));
        }
      }
    }

    return this.params = params;
  };

  TailCallTransformer.prototype.hasDeopt = function hasDeopt() {
    // check if the ownerId has been reassigned, if it has then it's not safe to
    // perform optimisations
    var ownerIdInfo = this.scope.getBindingInfo(this.ownerId.name);
    return ownerIdInfo && ownerIdInfo.reassigned;
  };

  TailCallTransformer.prototype.run = function run() {
    var scope = this.scope;
    var node = this.node;

    // only tail recursion can be optimized as for now, so we can skip anonymous
    // functions entirely
    var ownerId = this.ownerId;
    if (!ownerId) return;

    // traverse the function and look for tail recursion
    scope.traverse(node, firstPass, this);

    if (!this.hasTailRecursion) return;

    if (this.hasDeopt()) {
      this.file.logDeopt(node, messages.get("tailCallReassignmentDeopt"));
      return;
    }

    //

    scope.traverse(node, secondPass, this);

    if (!this.needsThis || !this.needsArguments) {
      scope.traverse(node, thirdPass, this);
    }

    var body = t.ensureBlock(node).body;

    if (this.vars.length > 0) {
      var declarations = flatten(map(this.vars, function (decl) {
        return decl.declarations;
      }, this));
      var statement = reduceRight(declarations, function (expr, decl) {
        return t.assignmentExpression("=", decl.id, expr);
      }, t.identifier("undefined"));
      body.unshift(t.expressionStatement(statement));
    }

    var paramDecls = this.paramDecls;
    if (paramDecls.length > 0) {
      body.unshift(t.variableDeclaration("var", paramDecls));
    }

    body.unshift(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(false))));

    node.body = util.template("tail-call-body", {
      AGAIN_ID: this.getAgainId(),
      THIS_ID: this.thisId,
      ARGUMENTS_ID: this.argumentsId,
      FUNCTION_ID: this.getFunctionId(),
      BLOCK: node.body
    });

    var topVars = [];

    if (this.needsThis) {
      topVars.push(t.variableDeclarator(this.getThisId(), t.thisExpression()));
    }

    if (this.needsArguments || this.setsArguments) {
      var decl = t.variableDeclarator(this.getArgumentsId());
      if (this.needsArguments) {
        decl.init = t.identifier("arguments");
      }
      topVars.push(decl);
    }

    var leftId = this.leftId;
    if (leftId) {
      topVars.push(t.variableDeclarator(leftId));
    }

    if (topVars.length > 0) {
      node.body.body.unshift(t.variableDeclaration("var", topVars));
    }
  };

  TailCallTransformer.prototype.subTransform = function subTransform(node) {
    if (!node) return;

    var handler = this["subTransform" + node.type];
    if (handler) return handler.call(this, node);
  };

  TailCallTransformer.prototype.subTransformConditionalExpression = function subTransformConditionalExpression(node) {
    var callConsequent = this.subTransform(node.consequent);
    var callAlternate = this.subTransform(node.alternate);
    if (!callConsequent && !callAlternate) {
      return;
    }

    // if ternary operator had tail recursion in value, convert to optimized if-statement
    node.type = "IfStatement";
    node.consequent = callConsequent ? t.toBlock(callConsequent) : returnBlock(node.consequent);

    if (callAlternate) {
      node.alternate = t.isIfStatement(callAlternate) ? callAlternate : t.toBlock(callAlternate);
    } else {
      node.alternate = returnBlock(node.alternate);
    }

    return [node];
  };

  TailCallTransformer.prototype.subTransformLogicalExpression = function subTransformLogicalExpression(node) {
    // only call in right-value of can be optimized
    var callRight = this.subTransform(node.right);
    if (!callRight) return;

    // cache left value as it might have side-effects
    var leftId = this.getLeftId();
    var testExpr = t.assignmentExpression("=", leftId, node.left);

    if (node.operator === "&&") {
      testExpr = t.unaryExpression("!", testExpr);
    }

    return [t.ifStatement(testExpr, returnBlock(leftId))].concat(callRight);
  };

  TailCallTransformer.prototype.subTransformSequenceExpression = function subTransformSequenceExpression(node) {
    var seq = node.expressions;

    // only last element can be optimized
    var lastCall = this.subTransform(seq[seq.length - 1]);
    if (!lastCall) {
      return;
    }

    // remove converted expression from sequence
    // and convert to regular expression if needed
    if (--seq.length === 1) {
      node = seq[0];
    }

    return [t.expressionStatement(node)].concat(lastCall);
  };

  TailCallTransformer.prototype.subTransformCallExpression = function subTransformCallExpression(node) {
    var callee = node.callee,
        thisBinding,
        args;

    if (t.isMemberExpression(callee, { computed: false }) && t.isIdentifier(callee.property)) {
      switch (callee.property.name) {
        case "call":
          args = t.arrayExpression(node.arguments.slice(1));
          break;

        case "apply":
          args = node.arguments[1] || t.identifier("undefined");
          break;

        default:
          return;
      }

      thisBinding = node.arguments[0];
      callee = callee.object;
    }

    // only tail recursion can be optimized as for now
    if (!t.isIdentifier(callee) || !this.scope.bindingIdentifierEquals(callee.name, this.ownerId)) {
      return;
    }

    this.hasTailRecursion = true;

    if (this.hasDeopt()) return;

    var body = [];

    if (!t.isThisExpression(thisBinding)) {
      body.push(t.expressionStatement(t.assignmentExpression("=", this.getThisId(), thisBinding || t.identifier("undefined"))));
    }

    if (!args) {
      args = t.arrayExpression(node.arguments);
    }

    var argumentsId = this.getArgumentsId();
    var params = this.getParams();

    body.push(t.expressionStatement(t.assignmentExpression("=", argumentsId, args)));

    var i, param;

    if (t.isArrayExpression(args)) {
      var elems = args.elements;
      for (i = 0; i < elems.length && i < params.length; i++) {
        param = params[i];
        var elem = elems[i] || (elems[i] = t.identifier("undefined"));
        if (!param._isDefaultPlaceholder) {
          elems[i] = t.assignmentExpression("=", param, elem);
        }
      }
    } else {
      this.setsArguments = true;
      for (i = 0; i < params.length; i++) {
        param = params[i];
        if (!param._isDefaultPlaceholder) {
          body.push(t.expressionStatement(t.assignmentExpression("=", param, t.memberExpression(argumentsId, t.literal(i), true))));
        }
      }
    }

    body.push(t.expressionStatement(t.assignmentExpression("=", this.getAgainId(), t.literal(true))));
    body.push(t.continueStatement(this.getFunctionId()));

    return body;
  };

  return TailCallTransformer;
})();
},{"../../../messages":157,"../../../types":251,"../../../util":253,"lodash/array/flatten":298,"lodash/collection/map":307,"lodash/collection/reduceRight":308}],206:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var buildBinaryExpression = function buildBinaryExpression(left, right) {
  return t.binaryExpression("+", left, right);
};

exports.check = function (node) {
  return t.isTemplateLiteral(node) || t.isTaggedTemplateExpression(node);
};

exports.TaggedTemplateExpression = function (node, parent, scope, file) {
  var args = [];
  var quasi = node.quasi;

  var strings = [];
  var raw = [];

  for (var i = 0; i < quasi.quasis.length; i++) {
    var elem = quasi.quasis[i];
    strings.push(t.literal(elem.value.cooked));
    raw.push(t.literal(elem.value.raw));
  }

  strings = t.arrayExpression(strings);
  raw = t.arrayExpression(raw);

  var templateName = "tagged-template-literal";
  if (file.isLoose("es6.templateLiterals")) templateName += "-loose";
  args.push(t.callExpression(file.addHelper(templateName), [strings, raw]));

  args = args.concat(quasi.expressions);

  return t.callExpression(node.tag, args);
};

exports.TemplateLiteral = function (node) {
  var nodes = [];
  var i;

  for (i = 0; i < node.quasis.length; i++) {
    var elem = node.quasis[i];

    nodes.push(t.literal(elem.value.cooked));

    var expr = node.expressions.shift();
    if (expr) nodes.push(expr);
  }

  if (nodes.length > 1) {
    // remove redundant '' at the end of the expression
    var last = nodes[nodes.length - 1];
    if (t.isLiteral(last, { value: "" })) nodes.pop();

    var root = buildBinaryExpression(nodes.shift(), nodes.shift());

    for (i = 0; i < nodes.length; i++) {
      root = buildBinaryExpression(root, nodes[i]);
    }

    return root;
  } else {
    return nodes[0];
  }
};
},{"../../../types":251}],207:[function(require,module,exports){
"use strict";

var rewritePattern = require("regexpu/rewrite-pattern");
var pull = require("lodash/array/pull");
var t = require("../../../types");

exports.check = function (node) {
  return t.isLiteral(node) && node.regex && node.regex.flags.indexOf("u") >= 0;
};

exports.Literal = function (node) {
  var regex = node.regex;
  if (!regex) return;

  var flags = regex.flags.split("");
  if (regex.flags.indexOf("u") < 0) return;
  pull(flags, "u");

  regex.pattern = rewritePattern(regex.pattern, regex.flags);
  regex.flags = flags.join("");
};
},{"../../../types":251,"lodash/array/pull":300,"regexpu/rewrite-pattern":426}],208:[function(require,module,exports){
"use strict";

// https://github.com/zenparsing/es-abstract-refs

var util = require("../../../util");
var t = require("../../../types");

exports.experimental = true;

var container = function container(parent, call, ret, file) {
  if (t.isExpressionStatement(parent) && !file.isConsequenceExpressionStatement(parent)) {
    // we don't need to worry about return values
    return call;
  } else {
    var exprs = [];
    if (t.isSequenceExpression(call)) {
      exprs = call.expressions;
    } else {
      exprs.push(call);
    }
    exprs.push(ret);
    return t.sequenceExpression(exprs);
  }
};

exports.AssignmentExpression = function (node, parent, scope, file) {
  var left = node.left;
  if (!t.isVirtualPropertyExpression(left)) return;

  var value = node.right;
  var temp;

  // we need to return `node.right`
  if (!t.isExpressionStatement(parent)) {
    temp = scope.generateTempBasedOnNode(node.right);
    if (temp) value = temp;
  }

  if (node.operator !== "=") {
    value = t.binaryExpression(node.operator[0], util.template("abstract-expression-get", {
      PROPERTY: node.property,
      OBJECT: node.object
    }), value);
  }

  var call = util.template("abstract-expression-set", {
    PROPERTY: left.property,
    OBJECT: left.object,
    VALUE: value
  });

  if (temp) {
    call = t.sequenceExpression([t.assignmentExpression("=", temp, node.right), call]);
  }

  return container(parent, call, value, file);
};

exports.UnaryExpression = function (node, parent, scope, file) {
  var arg = node.argument;
  if (!t.isVirtualPropertyExpression(arg)) return;
  if (node.operator !== "delete") return;

  var call = util.template("abstract-expression-delete", {
    PROPERTY: arg.property,
    OBJECT: arg.object
  });

  return container(parent, call, t.literal(true), file);
};

exports.CallExpression = function (node, parent, scope) {
  var callee = node.callee;
  if (!t.isVirtualPropertyExpression(callee)) return;

  var temp = scope.generateTempBasedOnNode(callee.object);

  var call = util.template("abstract-expression-call", {
    PROPERTY: callee.property,
    OBJECT: temp || callee.object
  });

  call.arguments = call.arguments.concat(node.arguments);

  if (temp) {
    return t.sequenceExpression([t.assignmentExpression("=", temp, callee.object), call]);
  } else {
    return call;
  }
};

exports.VirtualPropertyExpression = function (node) {
  return util.template("abstract-expression-get", {
    PROPERTY: node.property,
    OBJECT: node.object
  });
};

exports.PrivateDeclaration = function (node) {
  return t.variableDeclaration("const", node.declarations.map(function (id) {
    return t.variableDeclarator(id, t.newExpression(t.identifier("WeakMap"), []));
  }));
};
},{"../../../types":251,"../../../util":253}],209:[function(require,module,exports){
"use strict";

var buildComprehension = require("../../helpers/build-comprehension");
var traverse = require("../../../traversal");
var util = require("../../../util");
var t = require("../../../types");

exports.experimental = true;

exports.ComprehensionExpression = function (node, parent, scope, file) {
  var callback = array;
  if (node.generator) callback = generator;
  return callback(node, parent, scope, file);
};

var generator = function generator(node) {
  var body = [];
  var container = t.functionExpression(null, [], t.blockStatement(body), true);
  container._aliasFunction = true;

  body.push(buildComprehension(node, function () {
    return t.expressionStatement(t.yieldExpression(node.body));
  }));

  return t.callExpression(container, []);
};

var array = function array(node, parent, scope, file) {
  var uid = scope.generateUidBasedOnNode(parent, file);

  var container = util.template("array-comprehension-container", {
    KEY: uid
  });
  container.callee._aliasFunction = true;

  var block = container.callee.body;
  var body = block.body;

  if (traverse.hasType(node, scope, "YieldExpression", t.FUNCTION_TYPES)) {
    container.callee.generator = true;
    container = t.yieldExpression(container, true);
  }

  var returnStatement = body.pop();

  body.push(buildComprehension(node, function () {
    return util.template("array-push", {
      STATEMENT: node.body,
      KEY: uid
    }, true);
  }));
  body.push(returnStatement);

  return container;
};
},{"../../../traversal":246,"../../../types":251,"../../../util":253,"../../helpers/build-comprehension":162}],210:[function(require,module,exports){
"use strict";

// https://github.com/rwaldron/exponentiation-operator

exports.experimental = true;

var build = require("../../helpers/build-binary-assignment-operator-transformer");
var t = require("../../../types");

var MATH_POW = t.memberExpression(t.identifier("Math"), t.identifier("pow"));

build(exports, {
  operator: "**",

  build: function build(left, right) {
    return t.callExpression(MATH_POW, [left, right]);
  }
});
},{"../../../types":251,"../../helpers/build-binary-assignment-operator-transformer":161}],211:[function(require,module,exports){
"use strict";

// https://github.com/sebmarkbage/ecmascript-rest-spread

var t = require("../../../types");

exports.experimental = true;

exports.manipulateOptions = function (opts) {
  if (opts.whitelist.length) opts.whitelist.push("es6.destructuring");
};

var hasSpread = function hasSpread(node) {
  for (var i = 0; i < node.properties.length; i++) {
    if (t.isSpreadProperty(node.properties[i])) {
      return true;
    }
  }
  return false;
};

exports.ObjectExpression = function (node, parent, scope, file) {
  if (!hasSpread(node)) return;

  var args = [];
  var props = [];

  var push = function push() {
    if (!props.length) return;
    args.push(t.objectExpression(props));
    props = [];
  };

  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];
    if (t.isSpreadProperty(prop)) {
      push();
      args.push(prop.argument);
    } else {
      props.push(prop);
    }
  }

  push();

  if (!t.isObjectExpression(args[0])) {
    args.unshift(t.objectExpression([]));
  }

  return t.callExpression(file.addHelper("extends"), args);
};
},{"../../../types":251}],212:[function(require,module,exports){
"use strict";

module.exports = {
  useStrict: require("./other/use-strict"),

  "validation.undeclaredVariableCheck": require("./validation/undeclared-variable-check"),
  "validation.noForInOfAssignment": require("./validation/no-for-in-of-assignment"),
  "validation.setters": require("./validation/setters"),
  "validation.react": require("./validation/react"),

  // this goes at the start so we only transform the original user code
  "spec.functionName": require("./spec/function-name"),

  "spec.blockScopedFunctions": require("./spec/block-scoped-functions"),

  // needs to be before `_aliasFunction`
  "es6.arrowFunctions": require("./es6/arrow-functions"),

  "playground.malletOperator": require("./playground/mallet-operator"),
  "playground.methodBinding": require("./playground/method-binding"),
  "playground.memoizationOperator": require("./playground/memoization-operator"),
  "playground.objectGetterMemoization": require("./playground/object-getter-memoization"),

  reactCompat: require("./other/react-compat"),
  flow: require("./other/flow"),
  react: require("./other/react"),

  _modules: require("./internal/modules"),

  // needs to be before `regenerator` due to generator comprehensions
  // needs to be before `_aliasFunction`
  "es7.comprehensions": require("./es7/comprehensions"),

  "es6.classes": require("./es6/classes"),

  asyncToGenerator: require("./other/async-to-generator"),
  bluebirdCoroutines: require("./other/bluebird-coroutines"),

  "es6.objectSuper": require("./es6/object-super"),
  "es7.objectRestSpread": require("./es7/object-rest-spread"),
  "es7.exponentiationOperator": require("./es7/exponentiation-operator"),
  "es6.templateLiterals": require("./es6/template-literals"),

  "es5.properties.mutators": require("./es5/properties.mutators"),
  "es6.properties.shorthand": require("./es6/properties.shorthand"),

  // needs to be before `_aliasFunction` due to define property closure
  "es6.properties.computed": require("./es6/properties.computed"),

  "es6.forOf": require("./es6/for-of"),

  "es6.unicodeRegex": require("./es6/unicode-regex"),
  "es7.abstractReferences": require("./es7/abstract-references"),

  "es6.constants": require("./es6/constants"),

  // needs to be before `es6.parameters.default` as default parameters will destroy the rest param
  "es6.parameters.rest": require("./es6/parameters.rest"),

  // needs to be after `es6.parameters.rest` as we use `toArray` and avoid turning an already known array into one
  "es6.spread": require("./es6/spread"),

  // needs to be before `es6.blockScoping` as default parameters have a TDZ
  "es6.parameters.default": require("./es6/parameters.default"),

  // needs to be before `es6.blockScoping` as let variables may be produced
  "es6.destructuring": require("./es6/destructuring"),

  // needs to be before `_aliasFunction` due to block scopes sometimes being wrapped in a
  // closure
  "es6.blockScoping": require("./es6/block-scoping"),

  // needs to be after `es6.blockScoping` due to needing `letReferences` set on blocks
  "es6.blockScopingTDZ": require("./es6/block-scoping-tdz"),

  // needs to be after `es6.parameters.*` and `es6.blockScoping` due to needing pure
  // identifiers in parameters and variable declarators
  "es6.tailCall": require("./es6/tail-call"),

  regenerator: require("./other/regenerator"),

  // needs to be after `regenerator` due to needing `regeneratorRuntime` references
  // needs to be after `es6.forOf` due to needing `Symbol.iterator` references
  // needs to be before `es6.modules` due to dynamic imports
  runtime: require("./other/runtime"),

  // needs to be before `_blockHoist` due to function hoisting etc
  "es6.modules": require("./es6/modules"),

  _blockHoist: require("./internal/block-hoist"),

  "spec.protoToAssign": require("./spec/proto-to-assign"),

  _declarations: require("./internal/declarations"),

  _aliasFunctions: require("./internal/alias-functions"),

  "spec.typeofSymbol": require("./spec/typeof-symbol"),
  "spec.undefinedToVoid": require("./spec/undefined-to-void"),

  _useStrict: require("./internal/use-strict"),
  _moduleFormatter: require("./internal/module-formatter"),

  "es3.propertyLiterals": require("./es3/property-literals"),
  "es3.memberExpressionLiterals": require("./es3/member-expression-literals"),

  "minification.removeDebugger": require("./minification/remove-debugger"),
  "minification.removeConsoleCalls": require("./minification/remove-console-calls"),
  "minification.deadCodeElimination": require("./minification/dead-code-elimination"),
  "minification.renameLocalVariables": require("./minification/rename-local-variables"),

  _cleanUp: require("./internal/cleanup")
};
},{"./es3/member-expression-literals":188,"./es3/property-literals":189,"./es5/properties.mutators":190,"./es6/arrow-functions":191,"./es6/block-scoping":193,"./es6/block-scoping-tdz":192,"./es6/classes":194,"./es6/constants":195,"./es6/destructuring":196,"./es6/for-of":197,"./es6/modules":198,"./es6/object-super":199,"./es6/parameters.default":200,"./es6/parameters.rest":201,"./es6/properties.computed":202,"./es6/properties.shorthand":203,"./es6/spread":204,"./es6/tail-call":205,"./es6/template-literals":206,"./es6/unicode-regex":207,"./es7/abstract-references":208,"./es7/comprehensions":209,"./es7/exponentiation-operator":210,"./es7/object-rest-spread":211,"./internal/alias-functions":213,"./internal/block-hoist":214,"./internal/cleanup":215,"./internal/declarations":216,"./internal/module-formatter":217,"./internal/modules":218,"./internal/use-strict":219,"./minification/dead-code-elimination":220,"./minification/remove-console-calls":221,"./minification/remove-debugger":222,"./minification/rename-local-variables":223,"./other/async-to-generator":224,"./other/bluebird-coroutines":225,"./other/flow":226,"./other/react":228,"./other/react-compat":227,"./other/regenerator":229,"./other/runtime":230,"./other/use-strict":231,"./playground/mallet-operator":232,"./playground/memoization-operator":233,"./playground/method-binding":234,"./playground/object-getter-memoization":235,"./spec/block-scoped-functions":236,"./spec/function-name":237,"./spec/proto-to-assign":238,"./spec/typeof-symbol":239,"./spec/undefined-to-void":240,"./validation/no-for-in-of-assignment":241,"./validation/react":242,"./validation/setters":243,"./validation/undeclared-variable-check":244}],213:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var functionChildrenVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isFunction(node) && !node._aliasFunction) {
      return this.skip();
    }

    if (node._ignoreAliasFunctions) return this.skip();

    var getId;

    if (t.isIdentifier(node) && node.name === "arguments") {
      getId = state.getArgumentsId;
    } else if (t.isThisExpression(node)) {
      getId = state.getThisId;
    } else {
      return;
    }

    if (t.isReferenced(node, parent)) return getId();
  }
};

var functionVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (!node._aliasFunction) {
      if (t.isFunction(node)) {
        // stop traversal of this node as it'll be hit again by this transformer
        return this.skip();
      } else {
        return;
      }
    }

    // traverse all child nodes of this function and find `arguments` and `this`
    scope.traverse(node, functionChildrenVisitor, state);

    return this.skip();
  }
};

var go = function go(getBody, node, scope) {
  var argumentsId;
  var thisId;

  var state = {
    getArgumentsId: function getArgumentsId() {
      return (!argumentsId && (argumentsId = scope.generateUidIdentifier("arguments")), argumentsId);
    },

    getThisId: function getThisId() {
      return (!thisId && (thisId = scope.generateUidIdentifier("this")), thisId);
    }
  };

  // traverse the function and find all alias functions so we can alias
  // `arguments` and `this` if necessary
  scope.traverse(node, functionVisitor, state);

  var body;

  var pushDeclaration = function pushDeclaration(id, init) {
    if (!body) body = getBody();

    body.unshift(t.variableDeclaration("var", [t.variableDeclarator(id, init)]));
  };

  if (argumentsId) {
    pushDeclaration(argumentsId, t.identifier("arguments"));
  }

  if (thisId) {
    pushDeclaration(thisId, t.thisExpression());
  }
};

exports.Program = function (node, parent, scope) {
  go(function () {
    return node.body;
  }, node, scope);
};

exports.FunctionDeclaration = exports.FunctionExpression = function (node, parent, scope) {
  go(function () {
    t.ensureBlock(node);
    return node.body.body;
  }, node, scope);
};
},{"../../../types":251}],214:[function(require,module,exports){
"use strict";

var groupBy = require("lodash/collection/groupBy");
var flatten = require("lodash/array/flatten");
var values = require("lodash/object/values");

// Priority:
//
//  - 0 We want this to be at the **very** bottom
//  - 1 Default node position
//  - 2 Priority over normal nodes
//  - 3 We want this to be at the **very** top

exports.BlockStatement = exports.Program = {
  exit: function exit(node) {
    var hasChange = false;
    for (var i = 0; i < node.body.length; i++) {
      var bodyNode = node.body[i];
      if (bodyNode && bodyNode._blockHoist != null) hasChange = true;
    }
    if (!hasChange) return;

    var nodePriorities = groupBy(node.body, function (bodyNode) {
      var priority = bodyNode._blockHoist;
      if (priority == null) priority = 1;
      if (priority === true) priority = 2;
      return priority;
    });

    node.body = flatten(values(nodePriorities).reverse());
  }
};
},{"lodash/array/flatten":298,"lodash/collection/groupBy":305,"lodash/object/values":405}],215:[function(require,module,exports){
"use strict";

exports.SequenceExpression = function (node) {
  if (node.expressions.length === 1) {
    return node.expressions[0];
  }
};
},{}],216:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");
var t = require("../../../types");

exports.secondPass = true;

exports.BlockStatement = exports.Program = function (node, parent, scope, file) {
  if (!node._declarations) return;

  useStrict.wrap(node, function () {
    var kinds = {};
    var kind;

    for (var i in node._declarations) {
      var declar = node._declarations[i];

      kind = declar.kind || "var";
      var declarNode = t.variableDeclarator(declar.id, declar.init);

      if (declar.init) {
        node.body.unshift(file.attachAuxiliaryComment(t.variableDeclaration(kind, [declarNode])));
      } else {
        var _kinds = kinds;
        var _kind = kind;
        if (!_kinds[_kind]) _kinds[_kind] = [];

        kinds[kind].push(declarNode);
      }
    }

    for (kind in kinds) {
      node.body.unshift(file.attachAuxiliaryComment(t.variableDeclaration(kind, kinds[kind])));
    }

    node._declarations = null;
  });
};
},{"../../../types":251,"../../helpers/use-strict":172}],217:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");

exports.Program = function (program, parent, scope, file) {
  if (!file.transformers["es6.modules"].canRun()) return;

  useStrict.wrap(program, function () {
    program.body = file.dynamicImports.concat(program.body);
  });

  if (file.moduleFormatter.transform) {
    file.moduleFormatter.transform(program);
  }
};
},{"../../helpers/use-strict":172}],218:[function(require,module,exports){
"use strict";

// in this transformer we have to split up classes and function declarations
// from their exports. why? because sometimes we need to replace classes with
// nodes that aren't allowed in the same contexts. also, if you're exporting
// a generator function as a default then regenerator will destroy the export
// declaration and leave a variable declaration in it's place... yeah, handy.

var t = require("../../../types");

var resolveModuleSource = (function (_resolveModuleSource) {
  var _resolveModuleSourceWrapper = function resolveModuleSource() {
    return _resolveModuleSource.apply(this, arguments);
  };

  _resolveModuleSourceWrapper.toString = function () {
    return _resolveModuleSource.toString();
  };

  return _resolveModuleSourceWrapper;
})(function (node, parent, scope, file) {
  var resolveModuleSource = file.opts.resolveModuleSource;
  if (node.source && resolveModuleSource) {
    node.source.value = resolveModuleSource(node.source.value);
  }
});

exports.check = function (node) {
  return t.isImportDeclaration(node) || t.isExportDeclaration(node);
};

exports.ImportDeclaration = resolveModuleSource;

exports.ExportDeclaration = function (node, parent, scope) {
  resolveModuleSource.apply(null, arguments);

  // flow type
  if (node.isType) return;

  var declar = node.declaration;

  if (node["default"]) {
    if (t.isClassDeclaration(declar)) {
      node.declaration = declar.id;
      return [declar, node];
    } else if (t.isClassExpression(declar)) {
      var temp = scope.generateUidIdentifier("default");
      declar = t.variableDeclaration("var", [t.variableDeclarator(temp, declar)]);
      node.declaration = temp;
      return [declar, node];
    } else if (t.isFunctionDeclaration(declar)) {
      node._blockHoist = 2;
      node.declaration = declar.id;
      return [declar, node];
    }
  } else {
    if (t.isFunctionDeclaration(declar)) {
      node.specifiers = [t.importSpecifier(declar.id, declar.id)];
      node.declaration = null;
      node._blockHoist = 2;
      return [declar, node];
    }
  }
};
},{"../../../types":251}],219:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.Program = function (program, parent, scope, file) {
  if (file.transformers.useStrict.canRun()) {
    program.body.unshift(t.expressionStatement(t.literal("use strict")));
  }
};
},{"../../../types":251}],220:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.ExpressionStatement = function (node) {
  // remove consequence-less expressions such as local variables and literals
  // note: will remove directives
  //
  //   var foo = true; foo; -> var foo = true;
  //   "foo"; ->
  //

  var expr = node.expression;
  if (t.isLiteral(expr) || t.isIdentifier(node) && t.hasBinding(node.name)) {
    this.remove();
  }
};

exports.IfStatement = {
  exit: function exit(node) {
    // todo: in scenarios where we can just return the consequent or
    // alternate we should drop the block statement if it contains no
    // block scoped variables

    var consequent = node.consequent;
    var alternate = node.alternate;
    var test = node.test;

    // we can check if a test will be truthy 100% and if so then we can inline
    // the consequent and completely ignore the alternate
    //
    //   if (true) { foo; } -> { foo; }
    //   if ("foo") { foo; } -> { foo; }
    //

    if (t.isLiteral(test) && test.value) {
      return consequent;
    }

    // we can check if a test will be falsy 100% and if so we can inline the
    // alternate if there is one and completely remove the consequent
    //
    //   if ("") { bar; } else { foo; } -> { foo; }
    //   if ("") { bar; } ->
    //

    if (t.isFalsyExpression(test)) {
      if (alternate) {
        return alternate;
      } else {
        return this.remove();
      }
    }

    // remove alternate blocks that are empty
    //
    //   if (foo) { foo; } else {} -> if (foo) { foo; }
    //

    if (t.isBlockStatement(alternate) && !alternate.body.length) {
      alternate = node.alternate = null;
    }

    // if the consequent block is empty turn alternate blocks into a consequent
    // and flip the test
    //
    //   if (foo) {} else { bar; } -> if (!foo) { bar; }
    //

    if (t.blockStatement(consequent) && !consequent.body.length && t.isBlockStatement(alternate) && alternate.body.length) {
      node.consequent = node.alternate;
      node.alternate = null;
      node.test = t.unaryExpression("!", test, true);
    }
  }
};
},{"../../../types":251}],221:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var isConsole = t.buildMatchMemberExpression("console", true);

exports.optional = true;

exports.CallExpression = function (node, parent) {
  if (isConsole(node.callee)) {
    if (t.isExpressionStatement(parent)) {
      this.parentPath.remove();
    } else {
      this.remove();
    }
  }
};
},{"../../../types":251}],222:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.ExpressionStatement = function (node) {
  if (t.isIdentifier(node.expression, { name: "debugger" })) {
    this.remove();
  }
};
},{"../../../types":251}],223:[function(require,module,exports){
"use strict";

//var t = require("../../../types");

exports.optional = true;

exports.Scopable = function () {};

//for (var name in scope.bindings) {
//  scope.rename(name, scope.generateUidIdentifier("a").name);
//}
},{}],224:[function(require,module,exports){
"use strict";

var remapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
var bluebirdCoroutines = require("./bluebird-coroutines");

exports.optional = true;

exports.manipulateOptions = bluebirdCoroutines.manipulateOptions;

exports.Function = function (node, parent, scope, file) {
  if (!node.async || node.generator) return;

  return remapAsyncToGenerator(node, file.addHelper("async-to-generator"), scope);
};
},{"../../helpers/remap-async-to-generator":170,"./bluebird-coroutines":225}],225:[function(require,module,exports){
"use strict";

var remapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
var t = require("../../../types");

exports.manipulateOptions = function (opts) {
  opts.experimental = true;
  opts.blacklist.push("regenerator");
};

exports.optional = true;

exports.Function = function (node, parent, scope, file) {
  if (!node.async || node.generator) return;

  return remapAsyncToGenerator(node, t.memberExpression(file.addImport("bluebird", null, true), t.identifier("coroutine")), scope);
};
},{"../../../types":251,"../../helpers/remap-async-to-generator":170}],226:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.TypeCastExpression = function (node) {
  return node.expression;
};

exports.ImportDeclaration = function (node) {
  if (node.isType) this.remove();
};

exports.ExportDeclaration = function (node) {
  if (t.isTypeAlias(node.declaration)) this.remove();
};
},{"../../../types":251}],227:[function(require,module,exports){
"use strict";

var react = require("../../helpers/react");
var t = require("../../../types");

exports.manipulateOptions = function (opts) {
  opts.blacklist.push("react");
};

exports.optional = true;

require("../../helpers/build-react-transformer")(exports, {
  pre: function pre(state) {
    state.callee = state.tagExpr;
  },

  post: function post(state) {
    if (react.isCompatTag(state.tagName)) {
      state.call = t.callExpression(t.memberExpression(t.memberExpression(t.identifier("React"), t.identifier("DOM")), state.tagExpr, t.isLiteral(state.tagExpr)), state.args);
    }
  }
});
},{"../../../types":251,"../../helpers/build-react-transformer":164,"../../helpers/react":169}],228:[function(require,module,exports){
"use strict";

var react = require("../../helpers/react");
var t = require("../../../types");

var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;

exports.Program = function (node, parent, scope, file) {
  var id = "React.createElement";

  for (var i = 0; i < file.ast.comments.length; i++) {
    var comment = file.ast.comments[i];
    var matches = JSX_ANNOTATION_REGEX.exec(comment.value);
    if (matches) {
      id = matches[1];
      if (id === "React.DOM") {
        throw file.errorWithNode(comment, "The @jsx React.DOM pragma has been deprecated as of React 0.12");
      } else {
        break;
      }
    }
  }

  file.set("jsxIdentifier", id.split(".").map(t.identifier).reduce(function (object, property) {
    return t.memberExpression(object, property);
  }));
};

require("../../helpers/build-react-transformer")(exports, {
  pre: function pre(state) {
    var tagName = state.tagName;
    var args = state.args;
    if (react.isCompatTag(tagName)) {
      args.push(t.literal(tagName));
    } else {
      args.push(state.tagExpr);
    }
  },

  post: function post(state, file) {
    state.callee = file.get("jsxIdentifier");
  }
});
},{"../../../types":251,"../../helpers/build-react-transformer":164,"../../helpers/react":169}],229:[function(require,module,exports){
"use strict";

var regenerator = require("regenerator-babel");
var t = require("../../../types");

exports.check = function (node) {
  return t.isFunction(node) && (node.async || node.generator);
};

exports.Program = {
  enter: function enter(ast) {
    regenerator.transform(ast);
    this.stop();
  }
};
},{"../../../types":251,"regenerator-babel":418}],230:[function(require,module,exports){
"use strict";

var includes = require("lodash/collection/includes");
var util = require("../../../util");
var core = require("core-js/library");
var has = require("lodash/object/has");
var t = require("../../../types");

var isSymboliterator = t.buildMatchMemberExpression("Symbol.iterator");

var coreHas = function coreHas(node) {
  return node.name !== "_" && has(core, node.name);
};

var ALIASABLE_CONSTRUCTORS = ["Symbol", "Promise", "Map", "WeakMap", "Set", "WeakSet"];

var astVisitor = {
  enter: function enter(node, parent, scope, file) {
    var prop;

    if (t.isMemberExpression(node) && t.isReferenced(node, parent)) {
      // Array.from -> _core.Array.from
      var obj = node.object;
      prop = node.property;

      if (!t.isReferenced(obj, node)) return;

      if (!node.computed && coreHas(obj) && has(core[obj.name], prop.name) && !scope.getBindingIdentifier(obj.name)) {
        this.skip();
        return t.prependToMemberExpression(node, file.get("coreIdentifier"));
      }
    } else if (t.isReferencedIdentifier(node, parent) && !t.isMemberExpression(parent) && includes(ALIASABLE_CONSTRUCTORS, node.name) && !scope.getBindingIdentifier(node.name)) {
      // Symbol() -> _core.Symbol(); new Promise -> new _core.Promise
      return t.memberExpression(file.get("coreIdentifier"), node);
    } else if (t.isCallExpression(node)) {
      // arr[Symbol.iterator]() -> _core.$for.getIterator(arr)

      var callee = node.callee;
      if (node.arguments.length) return false;

      if (!t.isMemberExpression(callee)) return false;
      if (!callee.computed) return false;

      prop = callee.property;
      if (!isSymboliterator(prop)) return false;

      return util.template("corejs-iterator", {
        CORE_ID: file.get("coreIdentifier"),
        VALUE: callee.object
      });
    } else if (t.isBinaryExpression(node)) {
      // Symbol.iterator in arr -> core.$for.isIterable(arr)

      if (node.operator !== "in") return;

      var left = node.left;
      if (!isSymboliterator(left)) return;

      return util.template("corejs-is-iterator", {
        CORE_ID: file.get("coreIdentifier"),
        VALUE: node.right
      });
    }
  }
};

exports.optional = true;

exports.manipulateOptions = function (opts) {
  if (opts.whitelist.length) opts.whitelist.push("es6.modules");
};

exports.Program = function (node, parent, scope, file) {
  scope.traverse(node, astVisitor, file);
};

exports.pre = function (file) {
  file.setDynamic("helpersNamespace", function () {
    return file.addImport("babel-runtime/helpers", "babelHelpers");
  });

  file.setDynamic("coreIdentifier", function () {
    return file.addImport("babel-runtime/core-js", "core");
  });

  file.setDynamic("regeneratorIdentifier", function () {
    return file.addImport("babel-runtime/regenerator", "regeneratorRuntime");
  });
};

exports.Identifier = function (node, parent, scope, file) {
  if (t.isReferencedIdentifier(node, parent, { name: "regeneratorRuntime" })) {
    return file.get("regeneratorIdentifier");
  }
};
},{"../../../types":251,"../../../util":253,"core-js/library":277,"lodash/collection/includes":306,"lodash/object/has":402}],231:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t = require("../../../types");

exports.Program = function (program) {
  var first = program.body[0];
  if (t.isExpressionStatement(first) && t.isLiteral(first.expression, { value: "use strict" })) {
    program.body.shift();
  }
};

exports.FunctionDeclaration = exports.FunctionExpression = function () {
  this.skip();
};

exports.ThisExpression = function () {
  return t.identifier("undefined");
};

exports.CallExpression = function (node, parent, scope, file) {
  if (t.isIdentifier(node.callee, { name: "eval" })) {
    throw file.errorWithNode(node, messages.get("evalInStrictMode"));
  }
};
},{"../../../messages":157,"../../../types":251}],232:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var build = require("../../helpers/build-conditional-assignment-operator-transformer");
var t = require("../../../types");

exports.playground = true;

build(exports, {
  is: (function (_is) {
    var _isWrapper = function is() {
      return _is.apply(this, arguments);
    };

    _isWrapper.toString = function () {
      return _is.toString();
    };

    return _isWrapper;
  })(function (node, file) {
    var is = t.isAssignmentExpression(node) && node.operator === "||=";
    if (is) {
      var left = node.left;
      if (!t.isMemberExpression(left) && !t.isIdentifier(left)) {
        throw file.errorWithNode(left, messages.get("expectedMemberExpressionOrIdentifier"));
      }
      return true;
    }
  }),

  build: function build(node) {
    return t.unaryExpression("!", node, true);
  }
});
},{"../../../messages":157,"../../../types":251,"../../helpers/build-conditional-assignment-operator-transformer":163}],233:[function(require,module,exports){
"use strict";

var build = require("../../helpers/build-conditional-assignment-operator-transformer");
var t = require("../../../types");

exports.playground = true;

build(exports, {
  is: (function (_is) {
    var _isWrapper = function is() {
      return _is.apply(this, arguments);
    };

    _isWrapper.toString = function () {
      return _is.toString();
    };

    return _isWrapper;
  })(function (node) {
    var is = t.isAssignmentExpression(node) && node.operator === "?=";
    if (is) t.assertMemberExpression(node.left);
    return is;
  }),

  build: function build(node, file) {
    return t.unaryExpression("!", t.callExpression(t.memberExpression(file.addHelper("has-own"), t.identifier("call")), [node.object, node.property]), true);
  }
});
},{"../../../types":251,"../../helpers/build-conditional-assignment-operator-transformer":163}],234:[function(require,module,exports){
"use strict";

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var t = require("../../../types");

exports.playground = true;

exports.BindMemberExpression = function (node, parent, scope) {
  var object = node.object;
  var prop = node.property;

  var temp = scope.generateTempBasedOnNode(node.object);
  if (temp) object = temp;

  var call = t.callExpression(t.memberExpression(t.memberExpression(object, prop), t.identifier("bind")), [object].concat(_toConsumableArray(node.arguments)));

  if (temp) {
    return t.sequenceExpression([t.assignmentExpression("=", temp, node.object), call]);
  } else {
    return call;
  }
};

exports.BindFunctionExpression = function (node, parent, scope) {
  var buildCall = function buildCall(args) {
    var param = scope.generateUidIdentifier("val");
    return t.functionExpression(null, [param], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(param, node.callee), args))]));
  };

  var temp = scope.generateTemp("args");

  return t.sequenceExpression([t.assignmentExpression("=", temp, t.arrayExpression(node.arguments)), buildCall(node.arguments.map(function (node, i) {
    return t.memberExpression(temp, t.literal(i), true);
  }))]);
};
},{"../../../types":251}],235:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.playground = true;

var visitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isFunction(node)) return this.skip();

    if (t.isReturnStatement(node) && node.argument) {
      node.argument = t.memberExpression(t.callExpression(state.file.addHelper("define-property"), [t.thisExpression(), state.key, node.argument]), state.key, true);
    }
  }
};

exports.Property = exports.MethodDefinition = function (node, parent, scope, file) {
  if (node.kind !== "memo") return;
  node.kind = "get";

  var value = node.value;
  t.ensureBlock(value);

  var key = node.key;

  if (t.isIdentifier(key) && !node.computed) {
    key = t.literal(key.name);
  }

  var state = {
    key: key,
    file: file
  };

  scope.traverse(value, visitor, state);

  return node;
};
},{"../../../types":251}],236:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.BlockStatement = function (node, parent, scope, file) {
  if (t.isFunction(parent) && parent.body === node || t.isExportDeclaration(parent)) {
    return;
  }

  for (var i = 0; i < node.body.length; i++) {
    var func = node.body[i];
    if (!t.isFunctionDeclaration(func)) continue;

    var declar = t.variableDeclaration("let", [t.variableDeclarator(func.id, t.toExpression(func))]);

    // hoist it up above everything else
    declar._blockHoist = 2;

    // todo: name this
    func.id = null;

    node.body[i] = declar;

    file.checkNode(declar);
  }
};
},{"../../../types":251}],237:[function(require,module,exports){
"use strict";

var nameMethod = require("../../helpers/name-method");

exports.FunctionExpression = nameMethod.bare;
},{"../../helpers/name-method":168}],238:[function(require,module,exports){
"use strict";

var t = require("../../../types");
var pull = require("lodash/array/pull");

var isProtoKey = function isProtoKey(node) {
  return t.isLiteral(t.toComputedKey(node, node.key), { value: "__proto__" });
};

var isProtoAssignmentExpression = function isProtoAssignmentExpression(node) {
  var left = node.left;
  return t.isMemberExpression(left) && t.isLiteral(t.toComputedKey(left, left.property), { value: "__proto__" });
};

var buildDefaultsCallExpression = function buildDefaultsCallExpression(expr, ref, file) {
  return t.expressionStatement(t.callExpression(file.addHelper("defaults"), [ref, expr.right]));
};

exports.optional = true;
exports.secondPass = true;

exports.AssignmentExpression = function (node, parent, scope, file) {
  if (!isProtoAssignmentExpression(node)) return;

  var nodes = [];
  var left = node.left.object;
  var temp = scope.generateTempBasedOnNode(node.left.object);

  nodes.push(t.expressionStatement(t.assignmentExpression("=", temp, left)));
  nodes.push(buildDefaultsCallExpression(node, temp, file));
  if (temp) nodes.push(temp);

  return t.toSequenceExpression(nodes);
};

exports.ExpressionStatement = function (node, parent, scope, file) {
  var expr = node.expression;
  if (!t.isAssignmentExpression(expr, { operator: "=" })) return;

  if (isProtoAssignmentExpression(expr)) {
    return buildDefaultsCallExpression(expr, expr.left.object, file);
  }
};

exports.ObjectExpression = function (node, parent, scope, file) {
  var proto;

  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];

    if (isProtoKey(prop)) {
      proto = prop.value;
      pull(node.properties, prop);
    }
  }

  if (proto) {
    var args = [t.objectExpression([]), proto];
    if (node.properties.length) args.push(node);
    return t.callExpression(file.addHelper("extends"), args);
  }
};
},{"../../../types":251,"lodash/array/pull":300}],239:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.UnaryExpression = function (node, parent, scope, file) {
  this.skip();

  if (node.operator === "typeof") {
    var call = t.callExpression(file.addHelper("typeof"), [node.argument]);
    if (t.isIdentifier(node.argument)) {
      var undefLiteral = t.literal("undefined");
      return t.conditionalExpression(t.binaryExpression("===", t.unaryExpression("typeof", node.argument), undefLiteral), undefLiteral, call);
    } else {
      return call;
    }
  }
};
},{"../../../types":251}],240:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.Identifier = function (node, parent) {
  if (node.name === "undefined" && t.isReferenced(node, parent)) {
    return t.unaryExpression("void", t.literal(0), true);
  }
};
},{"../../../types":251}],241:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t = require("../../../types");

exports.check = t.isFor;

exports.ForInStatement = exports.ForOfStatement = function (node, parent, scope, file) {
  var left = node.left;
  if (t.isVariableDeclaration(left)) {
    var declar = left.declarations[0];
    if (declar.init) throw file.errorWithNode(declar, messages.get("noAssignmentsInForHead"));
  }
};
},{"../../../messages":157,"../../../types":251}],242:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t = require("../../../types");

// check if the input Literal `source` is an alternate casing of "react"
var check = function check(source, file) {
  if (t.isLiteral(source)) {
    var name = source.value;
    var lower = name.toLowerCase();

    if (lower === "react" && name !== lower) {
      throw file.errorWithNode(source, messages.get("didYouMean", "react"));
    }
  }
};

exports.CallExpression = function (node, parent, scope, file) {
  if (t.isIdentifier(node.callee, { name: "require" }) && node.arguments.length === 1) {
    check(node.arguments[0], file);
  }
};

exports.ImportDeclaration = exports.ExportDeclaration = function (node, parent, scope, file) {
  check(node.source, file);
};
},{"../../../messages":157,"../../../types":251}],243:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");

exports.check = function (node) {
  return node.kind === "set";
};

exports.MethodDefinition = exports.Property = function (node, parent, scope, file) {
  if (node.kind === "set" && node.value.params.length !== 1) {
    throw file.errorWithNode(node.value, messages.get("settersInvalidParamLength"));
  }
};
},{"../../../messages":157}],244:[function(require,module,exports){
"use strict";

var levenshtein = require("leven");
var messages = require("../../../messages");
var t = require("../../../types");

exports.optional = true;

exports.Identifier = function (node, parent, scope, file) {
  if (!t.isReferenced(node, parent)) return;
  if (scope.hasBinding(node.name)) return;

  // get the closest declaration to offer as a suggestion
  // the variable name may have just been mistyped

  var bindings = scope.getAllBindings();

  var closest;
  var shortest = -1;

  for (var name in bindings) {
    var distance = levenshtein(node.name, name);
    if (distance <= 0 || distance > 3) continue;
    if (distance <= shortest) continue;

    closest = name;
    shortest = distance;
  }

  var msg;
  if (closest) {
    msg = messages.get("undeclaredVariableSuggestion", node.name, closest);
  } else {
    msg = messages.get("undeclaredVariable", node.name);
  }

  //

  throw file.errorWithNode(node, msg, ReferenceError);
};
},{"../../../messages":157,"../../../types":251,"leven":294}],245:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var TraversalPath = require("./path");
var flatten = require("lodash/array/flatten");
var compact = require("lodash/array/compact");

var TraversalConext = (function () {
  function TraversalConext(scope, opts, state, parentPath) {
    _classCallCheck(this, TraversalConext);

    this.shouldFlatten = false;
    this.parentPath = parentPath;

    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  TraversalConext.prototype.flatten = function flatten() {
    this.shouldFlatten = true;
  };

  TraversalConext.prototype.visitNode = function visitNode(node, obj, key) {
    var iteration = new TraversalPath(this, node, obj, key);
    return iteration.visit();
  };

  TraversalConext.prototype.visit = function visit(node, key) {
    var nodes = node[key];
    if (!nodes) return;

    if (!Array.isArray(nodes)) {
      return this.visitNode(node, node, key);
    }

    // nothing to traverse!
    if (nodes.length === 0) {
      return;
    }

    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] && this.visitNode(node, nodes, i)) {
        return true;
      }
    }

    if (this.shouldFlatten) {
      node[key] = flatten(node[key]);

      if (key === "body") {
        // we can safely compact this
        node[key] = compact(node[key]);
      }
    }
  };

  return TraversalConext;
})();

module.exports = TraversalConext;
},{"./path":247,"lodash/array/compact":297,"lodash/array/flatten":298}],246:[function(require,module,exports){
"use strict";

module.exports = traverse;

var TraversalContext = require("./context");
var includes = require("lodash/collection/includes");
var t = require("../types");

function traverse(parent, opts, scope, state) {
  if (!parent) return;

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("Must pass a scope unless traversing a Program/File got a " + parent.type + " node");
    }
  }

  if (!opts) opts = {};
  if (!opts.enter) opts.enter = function () {};
  if (!opts.exit) opts.exit = function () {};

  // array of nodes
  if (Array.isArray(parent)) {
    for (var i = 0; i < parent.length; i++) {
      traverse.node(parent[i], opts, scope, state);
    }
  } else {
    traverse.node(parent, opts, scope, state);
  }
}

traverse.node = function (node, opts, scope, state, parentPath) {
  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  var context = new TraversalContext(scope, opts, state, parentPath);
  for (var i = 0; i < keys.length; i++) {
    if (context.visit(node, keys[i])) {
      return;
    }
  }
};

function clearNode(node) {
  node._declarations = null;
  node.extendedRange = null;
  node._scopeInfo = null;
  node.tokens = null;
  node.range = null;
  node.start = null;
  node.end = null;
  node.loc = null;
  node.raw = null;

  if (Array.isArray(node.trailingComments)) {
    clearComments(node.trailingComments);
  }

  if (Array.isArray(node.leadingComments)) {
    clearComments(node.leadingComments);
  }
}

var clearVisitor = {
  noScope: true,
  enter: clearNode
};

function clearComments(comments) {
  for (var i = 0; i < comments.length; i++) {
    clearNode(comments[i]);
  }
}

traverse.removeProperties = function (tree) {
  clearNode(tree);
  traverse(tree, clearVisitor);

  return tree;
};

traverse.explode = function (obj) {
  for (var type in obj) {
    var fns = obj[type];

    var aliases = t.FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (var i = 0; i < aliases.length; i++) {
        obj[aliases[i]] = fns;
      }
    }
  }
  return obj;
};

function hasBlacklistedType(node, parent, scope, state) {
  if (node.type === state.type) {
    state.has = true;
    this.skip();
  }
}

traverse.hasType = function (tree, scope, type, blacklistTypes) {
  // the node we're searching in is blacklisted
  if (includes(blacklistTypes, tree.type)) return false;

  // the type we're looking for is the same as the passed node
  if (tree.type === type) return true;

  var state = {
    has: false,
    type: type
  };

  traverse(tree, {
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, scope, state);

  return state.has;
};
},{"../types":251,"./context":245,"lodash/collection/includes":306}],247:[function(require,module,exports){
"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var traverse = require("./index");
var includes = require("lodash/collection/includes");
var Scope = require("./scope");
var t = require("../types");

var TraversalPath = (function () {
  function TraversalPath(context, parent, container, key) {
    _classCallCheck(this, TraversalPath);

    this.shouldRemove = false;
    this.shouldSkip = false;
    this.shouldStop = false;

    this.parentPath = context.parentPath;
    this.context = context;
    this.state = this.context.state;
    this.opts = this.context.opts;

    this.container = container;
    this.key = key;

    this.parent = parent;
    this.state = context.state;

    this.setScope();
  }

  TraversalPath.getScope = function getScope(node, parent, scope) {
    var ourScope = scope;

    // we're entering a new scope so let's construct it!
    if (t.isScope(node, parent)) {
      ourScope = new Scope(node, parent, scope);
    }

    return ourScope;
  };

  TraversalPath.prototype.setScope = function setScope() {
    this.scope = TraversalPath.getScope(this.node, this.parent, this.context.scope);
  };

  TraversalPath.prototype.remove = function remove() {
    this.shouldRemove = true;
    this.shouldSkip = true;
  };

  TraversalPath.prototype.skip = function skip() {
    this.shouldSkip = true;
  };

  TraversalPath.prototype.stop = function stop() {
    this.shouldStop = true;
    this.shouldSkip = true;
  };

  TraversalPath.prototype.flatten = function flatten() {
    this.context.flatten();
  };

  TraversalPath.prototype.call = function call(key) {
    var node = this.node;
    if (!node) return;

    var opts = this.opts;
    var fn = opts[key] || opts;
    if (opts[node.type]) fn = opts[node.type][key] || fn;

    var replacement = fn.call(this, node, this.parent, this.scope, this.state);

    if (replacement) {
      this.node = replacement;
    }

    if (this.shouldRemove) {
      this.container[this.key] = null;
      this.flatten();
    }
  };

  TraversalPath.prototype.visit = function visit() {
    var opts = this.opts;
    var node = this.node;

    // type is blacklisted
    if (opts.blacklist && opts.blacklist.indexOf(node.type) > -1) {
      return;
    }

    this.call("enter");

    if (this.shouldSkip) {
      return this.shouldStop;
    }

    node = this.node;

    if (Array.isArray(node)) {
      // traverse over these replacement nodes we purposely don't call exitNode
      // as the original node has been destroyed
      for (var i = 0; i < node.length; i++) {
        traverse.node(node[i], opts, this.scope, this.state, this);
      }
    } else {
      traverse.node(node, opts, this.scope, this.state, this);
      this.call("exit");
    }

    return this.shouldStop;
  };

  TraversalPath.prototype.isReferencedIdentifier = function isReferencedIdentifier() {
    return t.isReferencedIdentifier(this.node);
  };

  _prototypeProperties(TraversalPath, null, {
    node: {
      get: function () {
        return this.container[this.key];
      },
      set: function (replacement) {
        var isArray = Array.isArray(replacement);

        // inherit comments from original node to the first replacement node
        var inheritTo = replacement;
        if (isArray) inheritTo = replacement[0];
        if (inheritTo) t.inheritsComments(inheritTo, this.node);

        // replace the node
        this.container[this.key] = replacement;
        this.setScope();

        var file = this.scope && this.scope.file;
        if (file) {
          if (isArray) {
            for (var i = 0; i < replacement.length; i++) {
              file.checkNode(replacement[i], this.scope);
            }
          } else {
            file.checkNode(replacement, this.scope);
          }
        }

        // we're replacing a statement or block node with an array of statements so we better
        // ensure that it's a block
        if (isArray) {
          if (includes(t.STATEMENT_OR_BLOCK_KEYS, this.key) && !t.isBlockStatement(this.container)) {
            t.ensureBlock(this.container, this.key);
          }

          this.flatten();
        }
      },
      configurable: true
    }
  });

  return TraversalPath;
})();

module.exports = TraversalPath;
},{"../types":251,"./index":246,"./scope":248,"lodash/collection/includes":306}],248:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var includes = require("lodash/collection/includes");
var traverse = require("./index");
var defaults = require("lodash/object/defaults");
var messages = require("../messages");
var globals = require("globals");
var flatten = require("lodash/array/flatten");
var extend = require("lodash/object/extend");
var object = require("../helpers/object");
var each = require("lodash/collection/each");
var t = require("../types");

var functionVariableVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isFor(node)) {
      each(t.FOR_INIT_KEYS, function (key) {
        var declar = node[key];
        if (t.isVar(declar)) state.scope.registerBinding("var", declar);
      });
    }

    // this block is a function so we'll stop since none of the variables
    // declared within are accessible
    if (t.isFunction(node)) return this.skip();

    // function identifier doesn't belong to this scope
    if (state.blockId && node === state.blockId) return;

    // delegate block scope handling to the `blockVariableVisitor`
    if (t.isBlockScoped(node)) return;

    // this will be hit again once we traverse into it after this iteration
    if (t.isExportDeclaration(node) && t.isDeclaration(node.declaration)) return;

    // we've ran into a declaration!
    if (t.isDeclaration(node)) state.scope.registerDeclaration(node);
  }
};

var programReferenceVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isReferencedIdentifier(node, parent) && !scope.hasBinding(node.name)) {
      state.addGlobal(node);
    } else if (t.isLabeledStatement(node)) {
      state.addGlobal(node);
    } else if (t.isAssignmentExpression(node) || t.isUpdateExpression(node) || t.isUnaryExpression(node) && node.operator === "delete") {
      scope.registerBindingReassignment(node);
    }
  }
};

var blockVariableVisitor = {
  enter: function enter(node, parent, scope, state) {
    if (t.isFunctionDeclaration(node) || t.isBlockScoped(node)) {
      state.registerDeclaration(node);
    } else if (t.isScope(node, parent)) {
      this.skip();
    }
  }
};

var Scope = (function () {

  /**
   * This searches the current "scope" and collects all references/bindings
   * within.
   *
   * @param {Node} block
   * @param {Node} parentBlock
   * @param {Scope} [parent]
   * @param {File} [file]
   */

  function Scope(block, parentBlock, parent, file) {
    _classCallCheck(this, Scope);

    this.parent = parent;
    this.file = parent ? parent.file : file;

    this.parentBlock = parentBlock;
    this.block = block;

    this.crawl();
  }

  Scope.globals = flatten([globals.builtin, globals.browser, globals.node].map(Object.keys));

  /**
   * Description
   *
   * @param {Object} node
   * @param {Object} opts
   * @param [state]
   */

  Scope.prototype.traverse = (function (_traverse) {
    var _traverseWrapper = function traverse() {
      return _traverse.apply(this, arguments);
    };

    _traverseWrapper.toString = function () {
      return _traverse.toString();
    };

    return _traverseWrapper;
  })(function (node, opts, state) {
    traverse(node, opts, this, state);
  });

  /**
   * Description
   *
   * @param {String} [name="temp"]
   */

  Scope.prototype.generateTemp = function generateTemp(name) {
    var id = this.generateUidIdentifier(name || "temp");
    this.push({
      key: id.name,
      id: id
    });
    return id;
  };

  /**
   * Description
   *
   * @param {String} name
   */

  Scope.prototype.generateUidIdentifier = function generateUidIdentifier(name) {
    var id = t.identifier(this.generateUid(name));
    this.getFunctionParent().registerBinding("uid", id);
    return id;
  };

  /**
   * Description
   *
   * @param {String} name
   */

  Scope.prototype.generateUid = function generateUid(name) {
    name = t.toIdentifier(name).replace(/^_+/, "");

    var uid;
    var i = 0;
    do {
      uid = this._generateUid(name, i);
      i++;
    } while (this.hasBinding(uid) || this.hasGlobal(uid));
    return uid;
  };

  Scope.prototype._generateUid = function _generateUid(name, i) {
    var id = name;
    if (i > 1) id += i;
    return "_" + id;
  };

  /*
   * Description
   *
   * @param {Object} parent
   * @returns {Object}
   */

  Scope.prototype.generateUidBasedOnNode = function generateUidBasedOnNode(parent) {
    var node = parent;

    if (t.isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (t.isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (t.isProperty(node)) {
      node = node.key;
    }

    var parts = [];

    var add = (function (_add) {
      var _addWrapper = function add() {
        return _add.apply(this, arguments);
      };

      _addWrapper.toString = function () {
        return _add.toString();
      };

      return _addWrapper;
    })(function (node) {
      if (t.isMemberExpression(node)) {
        add(node.object);
        add(node.property);
      } else if (t.isIdentifier(node)) {
        parts.push(node.name);
      } else if (t.isLiteral(node)) {
        parts.push(node.value);
      } else if (t.isCallExpression(node)) {
        add(node.callee);
      }
    });

    add(node);

    var id = parts.join("$");
    id = id.replace(/^_/, "") || "ref";

    return this.generateUidIdentifier(id);
  };

  /**
   * Description
   *
   * @param {Object} node
   * @returns {Object}
   */

  Scope.prototype.generateTempBasedOnNode = function generateTempBasedOnNode(node) {
    if (t.isIdentifier(node) && this.hasBinding(node.name)) {
      return null;
    }

    var id = this.generateUidBasedOnNode(node);
    this.push({
      key: id.name,
      id: id
    });
    return id;
  };

  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(kind, name, id) {
    var local = this.getOwnBindingInfo(name);
    if (!local) return;

    if (kind === "param") return;
    if (kind === "hoisted" && local.kind === "let") return;

    if (local.kind === "let" || local.kind === "const" || local.kind === "module") {
      throw this.file.errorWithNode(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
    }
  };

  Scope.prototype.rename = function rename(oldName, newName) {
    if (!newName) newName = this.generateUidIdentifier(oldName).name;

    var info = this.getBindingInfo(oldName);
    if (!info) return;

    var binding = info.identifier;
    var scope = info.scope;

    scope.traverse(scope.block, {
      enter: function enter(node, parent, scope) {
        if (t.isReferencedIdentifier(node, parent) && node.name === oldName) {
          node.name = newName;
        } else if (t.isDeclaration(node)) {
          var ids = t.getBindingIdentifiers(node);
          for (var name in ids) {
            if (name === oldName) ids[name].name = newName;
          }
        } else if (t.isScope(node, parent)) {
          if (!scope.bindingIdentifierEquals(oldName, binding)) {
            this.skip();
          }
        }
      }
    });

    this.clearOwnBinding(oldName);
    scope.bindings[newName] = info;

    binding.name = newName;
  };

  Scope.prototype.inferType = function inferType(node) {
    var target;

    if (t.isVariableDeclarator(node)) {
      target = node.init;
    }

    if (t.isArrayExpression(target)) {
      return t.genericTypeAnnotation(t.identifier("Array"));
    }

    if (t.isObjectExpression(target)) {
      return;
    }

    if (t.isLiteral(target)) {
      return;
    }

    if (t.isCallExpression(target) && t.isIdentifier(target.callee)) {
      var funcInfo = this.getBindingInfo(target.callee.name);
      if (funcInfo) {
        var funcNode = funcInfo.node;
        return !funcInfo.reassigned && t.isFunction(funcNode) && node.returnType;
      }
    }

    if (t.isIdentifier(target)) {
      return;
    }
  };

  Scope.prototype.isTypeGeneric = function isTypeGeneric(name, genericName) {
    var info = this.getBindingInfo(name);
    if (!info) return false;

    var type = info.typeAnnotation;
    return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });
  };

  Scope.prototype.assignTypeGeneric = function assignTypeGeneric(name, type) {
    this.assignType(name, t.genericTypeAnnotation(t.identifier(type)));
  };

  Scope.prototype.assignType = function assignType(name, type) {
    var info = this.getBindingInfo(name);
    if (!info) return;

    info.identifier.typeAnnotation = info.typeAnnotation = type;
  };

  Scope.prototype.getTypeAnnotation = function getTypeAnnotation(name, id, node) {
    var info = {
      annotation: null,
      inferred: false
    };

    var type;

    if (id.typeAnnotation) {
      type = id.typeAnnotation;
    }

    if (!type) {
      info.inferred = true;
      type = this.inferType(node);
    }

    if (type) {
      if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
      info.annotation = type;
    }

    return info;
  };

  Scope.prototype.toArray = function toArray(node, i) {
    var file = this.file;

    if (t.isIdentifier(node) && this.isTypeGeneric(node.name, "Array")) {
      return node;
    }

    if (t.isArrayExpression(node)) {
      return node;
    }

    if (t.isIdentifier(node, { name: "arguments" })) {
      return t.callExpression(t.memberExpression(file.addHelper("slice"), t.identifier("call")), [node]);
    }

    var helperName = "to-array";
    var args = [node];
    if (i === true) {
      helperName = "to-consumable-array";
    } else if (i) {
      args.push(t.literal(i));
      helperName = "sliced-to-array";
    }
    return t.callExpression(file.addHelper(helperName), args);
  };

  Scope.prototype.clearOwnBinding = function clearOwnBinding(name) {
    delete this.bindings[name];
  };

  Scope.prototype.registerDeclaration = function registerDeclaration(node) {
    if (t.isFunctionDeclaration(node)) {
      this.registerBinding("hoisted", node);
    } else if (t.isVariableDeclaration(node)) {
      for (var i = 0; i < node.declarations.length; i++) {
        this.registerBinding(node.kind, node.declarations[i]);
      }
    } else if (t.isClassDeclaration(node)) {
      this.registerBinding("let", node);
    } else if (t.isImportDeclaration(node) || t.isExportDeclaration(node)) {
      this.registerBinding("module", node);
    } else {
      this.registerBinding("unknown", node);
    }
  };

  Scope.prototype.registerBindingReassignment = function registerBindingReassignment(node) {
    var ids = t.getBindingIdentifiers(node);
    for (var name in ids) {
      var info = this.getBindingInfo(name);
      if (info) {
        info.reassigned = true;

        if (info.typeAnnotationInferred) {
          // destroy the inferred typeAnnotation
          info.typeAnnotation = null;
        }
      }
    }
  };

  Scope.prototype.registerBinding = function registerBinding(kind, node) {
    if (!kind) throw new ReferenceError("no `kind`");

    var ids = t.getBindingIdentifiers(node);

    for (var name in ids) {
      var id = ids[name];

      this.checkBlockScopedCollisions(kind, name, id);

      var typeInfo = this.getTypeAnnotation(name, id, node);

      this.bindings[name] = {
        typeAnnotationInferred: typeInfo.inferred,
        typeAnnotation: typeInfo.annotation,
        reassigned: false,
        identifier: id,
        scope: this,
        node: node,
        kind: kind
      };
    }
  };

  Scope.prototype.registerVariableDeclaration = function registerVariableDeclaration(declar) {
    var declars = declar.declarations;
    for (var i = 0; i < declars.length; i++) {
      this.registerBinding(declars[i], declar.kind);
    }
  };

  Scope.prototype.addGlobal = function addGlobal(node) {
    this.globals[node.name] = node;
  };

  Scope.prototype.hasGlobal = function hasGlobal(name) {
    var scope = this;

    do {
      if (scope.globals[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.crawl = function crawl() {
    var block = this.block;
    var i;

    //

    var info = block._scopeInfo;
    if (info) {
      extend(this, info);
      return;
    }

    info = block._scopeInfo = {
      bindings: object(),
      globals: object()
    };

    extend(this, info);

    // ForStatement - left, init

    if (t.isLoop(block)) {
      for (i = 0; i < t.FOR_INIT_KEYS.length; i++) {
        var node = block[t.FOR_INIT_KEYS[i]];
        if (t.isBlockScoped(node)) this.registerBinding("let", node);
      }

      if (t.isBlockStatement(block.body)) {
        block = block.body;
      }
    }

    // FunctionExpression - id

    if (t.isFunctionExpression(block) && block.id) {
      if (!t.isProperty(this.parentBlock, { method: true })) {
        this.registerBinding("var", block.id);
      }
    }

    // Function - params, rest

    if (t.isFunction(block)) {
      for (i = 0; i < block.params.length; i++) {
        this.registerBinding("param", block.params[i]);
      }
      this.traverse(block.body, blockVariableVisitor, this);
    }

    // Program, BlockStatement, Function - let variables

    if (t.isBlockStatement(block) || t.isProgram(block)) {
      this.traverse(block, blockVariableVisitor, this);
    }

    // CatchClause - param

    if (t.isCatchClause(block)) {
      this.registerBinding("let", block.param);
    }

    // ComprehensionExpression - blocks

    if (t.isComprehensionExpression(block)) {
      this.registerBinding("let", block);
    }

    // Program, Function - var variables

    if (t.isProgram(block) || t.isFunction(block)) {
      this.traverse(block, functionVariableVisitor, {
        blockId: block.id,
        scope: this
      });
    }

    // Program

    if (t.isProgram(block)) {
      this.traverse(block, programReferenceVisitor, this);
    }
  };

  /**
   * Description
   *
   * @param {Object} opts
   */

  Scope.prototype.push = function push(opts) {
    var block = this.block;

    if (t.isLoop(block) || t.isCatchClause(block) || t.isFunction(block)) {
      t.ensureBlock(block);
      block = block.body;
    }

    if (t.isBlockStatement(block) || t.isProgram(block)) {
      var _block = block;
      if (!_block._declarations) _block._declarations = {};

      block._declarations[opts.key] = {
        kind: opts.kind,
        id: opts.id,
        init: opts.init
      };
    } else {
      throw new TypeError("cannot add a declaration here in node type " + block.type);
    }
  };

  /**
   * Walk up the scope tree until we hit either a Function or reach the
   * very top and hit Program.
   */

  Scope.prototype.getFunctionParent = function getFunctionParent() {
    var scope = this;
    while (scope.parent && !t.isFunction(scope.block)) {
      scope = scope.parent;
    }
    return scope;
  };

  /**
   * Walks the scope tree and gathers **all** bindings.
   *
   * @returns {Object}
   */

  Scope.prototype.getAllBindings = function getAllBindings() {
    var ids = object();

    var scope = this;
    do {
      defaults(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);

    return ids;
  };

  /**
   * Walks the scope tree and gathers all declarations of `kind`.
   *
   * @param {String} kind
   * @returns {Object}
   */

  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(kind) {
    var ids = object();

    var scope = this;
    do {
      for (var name in scope.bindings) {
        var binding = scope.bindings[name];
        if (binding.kind === kind) ids[name] = binding;
      }
      scope = scope.parent;
    } while (scope);

    return ids;
  };

  // misc

  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
    return this.getBindingIdentifier(name) === node;
  };

  // get

  Scope.prototype.getBindingInfo = function getBindingInfo(name) {
    var scope = this;

    do {
      var binding = scope.getOwnBindingInfo(name);
      if (binding) return binding;
    } while (scope = scope.parent);
  };

  Scope.prototype.getOwnBindingInfo = function getOwnBindingInfo(name) {
    return this.bindings[name];
  };

  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
    var info = this.getBindingInfo(name);
    return info && info.identifier;
  };

  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
    var binding = this.bindings[name];
    return binding && binding.identifier;
  };

  // has

  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
    return !!this.getOwnBindingInfo(name);
  };

  Scope.prototype.hasBinding = function hasBinding(name) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name)) return true;
    if (includes(Scope.globals, name)) return true;
    return false;
  };

  Scope.prototype.parentHasBinding = function parentHasBinding(name) {
    return this.parent && this.parent.hasBinding(name);
  };

  return Scope;
})();

module.exports = Scope;
},{"../helpers/object":154,"../messages":157,"../types":251,"./index":246,"globals":289,"lodash/array/flatten":298,"lodash/collection/each":303,"lodash/collection/includes":306,"lodash/object/defaults":400,"lodash/object/extend":401}],249:[function(require,module,exports){
module.exports={
  "ExpressionStatement": ["Statement"],
  "BreakStatement":      ["Statement"],
  "ContinueStatement":   ["Statement"],
  "DebuggerStatement":   ["Statement"],
  "DoWhileStatement":    ["Statement", "Loop", "While", "Scopable"],
  "IfStatement":         ["Statement"],
  "ReturnStatement":     ["Statement"],
  "SwitchStatement":     ["Statement"],
  "ThrowStatement":      ["Statement"],
  "TryStatement":        ["Statement"],
  "WhileStatement":      ["Statement", "Loop", "While", "Scopable"],
  "WithStatement":       ["Statement"],
  "EmptyStatement":      ["Statement"],
  "LabeledStatement":    ["Statement"],
  "VariableDeclaration": ["Statement", "Declaration"],
  "ExportDeclaration":   ["Statement", "Declaration"],
  "ImportDeclaration":   ["Statement", "Declaration"],
  "PrivateDeclaration":  ["Statement", "Declaration"],

  "ArrowFunctionExpression": ["Scopable", "Function", "Expression"],
  "FunctionDeclaration":     ["Scopable", "Function", "Statement", "Declaration"],
  "FunctionExpression":      ["Scopable", "Function", "Expression"],

  "ImportSpecifier": ["ModuleSpecifier"],
  "ExportSpecifier": ["ModuleSpecifier"],

  "BlockStatement": ["Statement", "Scopable"],
  "Program":        ["Scopable"],
  "CatchClause":    ["Scopable"],

  "LogicalExpression": ["Binary", "Expression"],
  "BinaryExpression":  ["Binary", "Expression"],

  "UnaryExpression": ["UnaryLike", "Expression"],
  "SpreadProperty":  ["UnaryLike"],
  "SpreadElement":   ["UnaryLike"],

  "ClassDeclaration": ["Statement", "Declaration", "Class"],
  "ClassExpression":  ["Class", "Expression"],

  "ForOfStatement": ["Scopable", "Statement", "For", "Loop"],
  "ForInStatement": ["Scopable", "Statement", "For", "Loop"],
  "ForStatement":   ["Scopable", "Statement", "For", "Loop"],

  "ObjectPattern":     ["Pattern"],
  "ArrayPattern":      ["Pattern"],
  "AssignmentPattern": ["Pattern"],

  "Property":   ["UserWhitespacable"],

  "ArrayExpression":           ["Expression"],
  "AssignmentExpression":      ["Expression"],
  "AwaitExpression":           ["Expression"],
  "BindFunctionExpression":    ["Expression"],
  "BindMemberExpression":      ["Expression"],
  "CallExpression":            ["Expression"],
  "ComprehensionExpression":   ["Expression", "Scopable"],
  "ConditionalExpression":     ["Expression"],
  "Identifier":                ["Expression"],
  "Literal":                   ["Expression"],
  "MemberExpression":          ["Expression"],
  "NewExpression":             ["Expression"],
  "ObjectExpression":          ["Expression"],
  "SequenceExpression":        ["Expression"],
  "TaggedTemplateExpression":  ["Expression"],
  "ThisExpression":            ["Expression"],
  "UpdateExpression":          ["Expression"],
  "VirtualPropertyExpression": ["Expression"],
  "JSXEmptyExpression":        ["Expression"],
  "JSXMemberExpression":       ["Expression"],
  "YieldExpression":           ["Expression"],

  "JSXAttribute":           ["JSX"],
  "JSXClosingElement":      ["JSX"],
  "JSXElement":             ["JSX", "Expression"],
  "JSXEmptyExpression":     ["JSX"],
  "JSXExpressionContainer": ["JSX"],
  "JSXIdentifier":          ["JSX"],
  "JSXMemberExpression":    ["JSX"],
  "JSXNamespacedName":      ["JSX"],
  "JSXOpeningElement":      ["JSX"],
  "JSXSpreadAttribute":     ["JSX"]
}

},{}],250:[function(require,module,exports){
module.exports={
  "ArrayExpression": {
    "elements": null
  },

  "ArrowFunctionExpression": {
    "params": null,
    "body": null
  },

  "AssignmentExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "BinaryExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "BlockStatement": {
    "body": null
  },

  "CallExpression": {
    "callee": null,
    "arguments": null
  },

  "ConditionalExpression": {
    "test": null,
    "consequent": null,
    "alternate": null
  },

  "ExpressionStatement": {
    "expression": null
  },

  "File": {
    "program": null,
    "comments": null,
    "tokens": null
  },

  "FunctionExpression": {
    "id": null,
    "params": null,
    "body": null,
    "generator": false
  },

  "FunctionDeclaration": {
    "id": null,
    "params": null,
    "body": null,
    "generator": false
  },

  "GenericTypeAnnotation": {
    "id": null,
    "typeParameters": null
  },

  "Identifier": {
    "name": null
  },

  "IfStatement": {
    "test": null,
    "consequent": null,
    "alternate": null
  },

  "ImportDeclaration": {
    "specifiers": null,
    "source": null
  },

  "ImportSpecifier": {
    "id": null,
    "name": null
  },

  "Literal": {
    "value": null
  },

  "LogicalExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "MemberExpression": {
    "object": null,
    "property": null,
    "computed": false
  },

  "MethodDefinition": {
    "key": null,
    "value": null,
    "computed": false,
    "static": false,
    "kind": null
  },

  "NewExpression": {
    "callee": null,
    "arguments": null
  },

  "ObjectExpression": {
    "properties": null
  },

  "Program": {
    "body": null
  },

  "Property": {
    "kind": null,
    "key": null,
    "value": null,
    "computed": false
  },

  "ReturnStatement": {
    "argument": null
  },

  "SequenceExpression": {
    "expressions": null
  },

  "ThrowExpression": {
    "argument": null
  },

  "UnaryExpression": {
    "operator": null,
    "argument": null,
    "prefix": null
  },

  "VariableDeclaration": {
    "kind": null,
    "declarations": null
  },

  "VariableDeclarator": {
    "id": null,
    "init": null
  },

  "WithStatement": {
    "object": null,
    "body": null
  },

  "YieldExpression": {
    "argument": null,
    "delegate": null
  }
}

},{}],251:[function(require,module,exports){
"use strict";

var toFastProperties = require("../helpers/to-fast-properties");
var isString = require("lodash/lang/isString");
var compact = require("lodash/array/compact");
var esutils = require("esutils");
var object = require("../helpers/object");
var each = require("lodash/collection/each");
var uniq = require("lodash/array/uniq");

var t = exports;

/**
 * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.
 * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.
 *
 * @param {String} type
 * @param {Boolean?} skipAliasCheck
 */

function registerType(type, skipAliasCheck) {
  var is = t["is" + type] = function (node, opts) {
    return t.is(type, node, opts, skipAliasCheck);
  };

  t["assert" + type] = function (node, opts) {
    if (!opts) opts = {};

    if (!is(node, opts)) {
      throw new Error("Expected type " + JSON.stringify(type) + " with option " + JSON.stringify(opts));
    }
  };
}

t.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body"];
t.NATIVE_TYPE_NAMES = ["Array", "Object", "Number", "Boolean", "Date", "Array", "String"];
t.FOR_INIT_KEYS = ["left", "init"];

t.VISITOR_KEYS = require("./visitor-keys");
t.ALIAS_KEYS = require("./alias-keys");

t.FLIPPED_ALIAS_KEYS = {};

each(t.VISITOR_KEYS, function (keys, type) {
  registerType(type, true);
});

each(t.ALIAS_KEYS, function (aliases, type) {
  each(aliases, function (alias) {
    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
    types.push(type);
  });
});

each(t.FLIPPED_ALIAS_KEYS, function (types, type) {
  t[type.toUpperCase() + "_TYPES"] = types;
  registerType(type, false);
});

/**
 * Returns whether `node` is of given `type`.
 *
 * For better performance, use this instead of `is[Type]` when `type` is unknown.
 * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.
 *
 * @param {String} type
 * @param {Node} node
 * @param {Object?} opts
 * @param {Boolean?} skipAliasCheck
 * @returns {Boolean} isOfType
 */

t.is = function (type, node, opts, skipAliasCheck) {
  if (!node) return false;

  var typeMatches = type === node.type;

  if (!typeMatches && !skipAliasCheck) {
    var aliases = t.FLIPPED_ALIAS_KEYS[type];

    if (typeof aliases !== "undefined") {
      typeMatches = aliases.indexOf(node.type) > -1;
    }
  }

  if (!typeMatches) {
    return false;
  }

  if (typeof opts !== "undefined") {
    return t.shallowEqual(node, opts);
  }

  return true;
};

//

t.BUILDER_KEYS = require("./builder-keys");

each(t.VISITOR_KEYS, function (keys, type) {
  if (t.BUILDER_KEYS[type]) return;

  var defs = {};
  each(keys, function (key) {
    defs[key] = null;
  });
  t.BUILDER_KEYS[type] = defs;
});

each(t.BUILDER_KEYS, function (keys, type) {
  t[type[0].toLowerCase() + type.slice(1)] = function () {
    var node = {};
    node.start = null;
    node.type = type;

    var i = 0;

    for (var key in keys) {
      var arg = arguments[i++];
      if (arg === undefined) arg = keys[key];
      node[key] = arg;
    }

    return node;
  };
});

/**
 * Description
 *
 * @param {Object} node
 * @returns {Object}
 */

t.toComputedKey = function (node, key) {
  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.literal(key.name);
  }
  return key;
};

/*
 * Shallowly checks to see if the passed `node` is falsy.
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isFalsyExpression = function (node) {
  if (t.isLiteral(node)) {
    return !node.value;
  } else if (t.isIdentifier(node)) {
    return node.name === "undefined";
  }
  return false;
};

/**
 * Turn an array of statement `nodes` into a `SequenceExpression`.
 *
 * Variable declarations are turned into simple assignments and their
 * declarations hoisted to the top of the current scope.
 *
 * Expression statements are just resolved to their standard expression.
 *
 * @param {Array} nodes
 * @param {Scope} scope
 */

t.toSequenceExpression = function (nodes, scope) {
  var exprs = [];

  each(nodes, function (node) {
    if (t.isExpression(node)) {
      exprs.push(node);
    }if (t.isExpressionStatement(node)) {
      exprs.push(node.expression);
    } else if (t.isVariableDeclaration(node)) {
      each(node.declarations, function (declar) {
        scope.push({
          kind: node.kind,
          key: declar.id.name,
          id: declar.id
        });
        exprs.push(t.assignmentExpression("=", declar.id, declar.init));
      });
    }
  });

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return t.sequenceExpression(exprs);
  }
};

/*
 * Description
 *
 * @param {Object} actual
 * @param {Object} expected
 * @returns {Boolean}
 */

t.shallowEqual = function (actual, expected) {
  var keys = Object.keys(expected);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
};

/**
 * Description
 *
 * @param {Object} member
 * @param {Object} append
 * @param {Boolean} [computed]
 * @returns {Object} member
 */

t.appendToMemberExpression = function (member, append, computed) {
  member.object = t.memberExpression(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
};

/**
 * Description
 *
 * @param {Object} member
 * @param {Object} append
 * @returns {Object} member
 */

t.prependToMemberExpression = function (member, append) {
  member.object = t.memberExpression(append, member.object);
  return member;
};

/**
 * Check if the input `node` is a reference to a bound variable.
 *
 * @param {Object} node
 * @param {Object} parent
 * @returns {Boolean}
 */

t.isReferenced = function (node, parent) {
  // yes: PARENT[NODE]
  // yes: NODE.child
  // no: parent.CHILD
  if (t.isMemberExpression(parent)) {
    if (parent.property === node && parent.computed) {
      return true;
    } else if (parent.object === node) {
      return true;
    } else {
      return false;
    }
  }

  // yes: { [NODE]: "" }
  // no: { NODE: "" }
  if (t.isProperty(parent) && parent.key === node) {
    return parent.computed;
  }

  // no: var NODE = init;
  // yes: var id = NODE;
  if (t.isVariableDeclarator(parent)) {
    return parent.id !== node;
  }

  // no: function NODE() {}
  // no: function foo(NODE) {}
  if (t.isFunction(parent)) {
    for (var i = 0; i < parent.params.length; i++) {
      var param = parent.params[i];
      if (param === node) return false;
    }

    return parent.id !== node;
  }

  // no: class NODE {}
  if (t.isClass(parent)) {
    return parent.id !== node;
  }

  // yes: class { [NODE](){} }
  if (t.isMethodDefinition(parent)) {
    return parent.key === node && parent.computed;
  }

  // no: NODE: for (;;) {}
  if (t.isLabeledStatement(parent)) {
    return false;
  }

  // no: try {} catch (NODE) {}
  if (t.isCatchClause(parent)) {
    return parent.param !== node;
  }

  // no: function foo(...NODE) {}
  if (t.isRestElement(parent)) {
    return false;
  }

  // no: [NODE = foo] = [];
  // yes: [foo = NODE] = [];
  if (t.isAssignmentPattern(parent)) {
    return parent.right === node;
  }

  // no: [NODE] = [];
  // no: ({ NODE }) = [];
  if (t.isPattern(parent)) {
    return false;
  }

  // no: import NODE from "bar";
  if (t.isImportSpecifier(parent)) {
    return false;
  }

  // no: import * as NODE from "foo";
  if (t.isImportBatchSpecifier(parent)) {
    return false;
  }

  // no: class Foo { private NODE; }
  if (t.isPrivateDeclaration(parent)) {
    return false;
  }

  return true;
};

/**
 * Check if the input `node` is an `Identifier` and `isReferenced`.
 *
 * @param {Node} node
 * @parma {Node} parent
 * @returns {Boolean}
 */

t.isReferencedIdentifier = function (node, parent, opts) {
  return t.isIdentifier(node, opts) && t.isReferenced(node, parent);
};

/**
 * Check if the input `name` is a valid identifier name
 * and isn't a reserved word.
 *
 * @param {String} name
 * @returns {Boolean}
 */

t.isValidIdentifier = function (name) {
  return isString(name) && esutils.keyword.isIdentifierName(name) && !esutils.keyword.isReservedWordES6(name, true);
};

/*
 * Description
 *
 * @param {String} name
 * @returns {String}
 */

t.toIdentifier = function (name) {
  if (t.isIdentifier(name)) return name.name;

  name = name + "";

  // replace all non-valid identifiers with dashes
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");

  // remove all dashes and numbers from start of name
  name = name.replace(/^[-0-9]+/, "");

  // camel case
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!t.isValidIdentifier(name)) {
    name = "_" + name;
  }

  return name || "_";
};

/**
 * Description
 *
 * @param {Object} node
 * @param {String=} key
 */

t.ensureBlock = function (node, key) {
  if (!key) key = "body";

  return node[key] = t.toBlock(node[key], node);
};

/**
 * Build a function that when called will return whether or not the
 * input `node` `MemberExpression` matches the input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 *
 * @param {String} match Dot-delimited string
 * @param {Boolean} [allowPartial] Allow a partial match
 * @returns {Function}
 */

t.buildMatchMemberExpression = function (match, allowPartial) {
  var parts = match.split(".");

  return function (member) {
    // not a member expression
    if (!t.isMemberExpression(member)) return false;

    var search = [member];
    var i = 0;

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (t.isIdentifier(node)) {
        // this part doesn't match
        if (parts[i] !== node.name) return false;
      } else if (t.isLiteral(node)) {
        // this part doesn't match
        if (parts[i] !== node.value) return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isLiteral(node.property)) {
          // we can't deal with this
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        // we can't deal with this
        return false;
      }

      // too many parts
      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  };
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Boolean} [ignore]
 * @returns {Object|Boolean}
 */

t.toStatement = function (node, ignore) {
  if (t.isStatement(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType;

  if (t.isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (t.isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (t.isAssignmentExpression(node)) {
    return t.expressionStatement(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn " + node.type + " to a statement");
    }
  }

  node.type = newType;

  return node;
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Object}
 */

exports.toExpression = function (node) {
  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  if (t.isClass(node)) {
    node.type = "ClassExpression";
  } else if (t.isFunction(node)) {
    node.type = "FunctionExpression";
  }

  if (t.isExpression(node)) {
    return node;
  } else {
    throw new Error("cannot turn " + node.type + " to an expression");
  }
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Object} parent
 * @returns {Object}
 */

t.toBlock = function (node, parent) {
  if (t.isBlockStatement(node)) {
    return node;
  }

  if (t.isEmptyStatement(node)) {
    node = [];
  }

  if (!Array.isArray(node)) {
    if (!t.isStatement(node)) {
      if (t.isFunction(parent)) {
        node = t.returnStatement(node);
      } else {
        node = t.expressionStatement(node);
      }
    }

    node = [node];
  }

  return t.blockStatement(node);
};

/**
 * Return a list of binding identifiers associated with
 * the input `node`.
 *
 * @param {Object} node
 * @returns {Array|Object}
 */

t.getBindingIdentifiers = function (node) {
  var search = [].concat(node);
  var ids = object();

  while (search.length) {
    var id = search.shift();
    if (!id) continue;

    var keys = t.getBindingIdentifiers.keys[id.type];

    if (t.isIdentifier(id)) {
      ids[id.name] = id;
    } else if (t.isImportSpecifier(id)) {
      search.push(id.name || id.id);
    } else if (t.isExportDeclaration(id)) {
      if (t.isDeclaration(node.declaration)) {
        search.push(node.declaration);
      }
    } else if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        search = search.concat(id[key] || []);
      }
    }
  }

  return ids;
};

t.getBindingIdentifiers.keys = {
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportBatchSpecifier: ["name"],
  VariableDeclarator: ["id"],
  FunctionDeclaration: ["id"],
  ClassDeclaration: ["id"],
  SpreadElement: ["argument"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  SpreadProperty: ["argument"],
  Property: ["value"],
  ComprehensionBlock: ["left"],
  AssignmentPattern: ["left"],
  PrivateDeclaration: ["declarations"],
  ComprehensionExpression: ["blocks"],
  ImportDeclaration: ["specifiers"],
  VariableDeclaration: ["declarations"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"]
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isLet = function (node) {
  return t.isVariableDeclaration(node) && (node.kind !== "var" || node._let);
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isBlockScoped = function (node) {
  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isVar = function (node) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !node._let;
};

//

t.COMMENT_KEYS = ["leadingComments", "trailingComments"];

/**
 * Description
 *
 * @param {Object} child
 * @returns {Object} child
 */

t.removeComments = function (child) {
  each(t.COMMENT_KEYS, function (key) {
    delete child[key];
  });
  return child;
};

/**
 * Description
 *
 * @param {Object} child
 * @param {Object} parent
 * @returns {Object} child
 */

t.inheritsComments = function (child, parent) {
  each(t.COMMENT_KEYS, function (key) {
    child[key] = uniq(compact([].concat(child[key], parent[key])));
  });
  return child;
};

/**
 * Description
 *
 * @param {Object} child
 * @param {Object} parent
 * @returns {Object} child
 */

t.inherits = function (child, parent) {
  child._declarations = parent._declarations;
  child._scopeInfo = parent._scopeInfo;
  child.range = parent.range;
  child.start = parent.start;
  child.loc = parent.loc;
  child.end = parent.end;
  t.inheritsComments(child, parent);
  return child;
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Array}
 */

t.getLastStatements = function (node) {
  var nodes = [];

  var add = function add(node) {
    nodes = nodes.concat(t.getLastStatements(node));
  };

  if (t.isIfStatement(node)) {
    add(node.consequent);
    add(node.alternate);
  } else if (t.isFor(node) || t.isWhile(node)) {
    add(node.body);
  } else if (t.isProgram(node) || t.isBlockStatement(node)) {
    add(node.body[node.body.length - 1]);
  } else if (node) {
    nodes.push(node);
  }

  return nodes;
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {String}
 */

t.getSpecifierName = function (specifier) {
  return specifier.name || specifier.id;
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {String}
 */

t.getSpecifierId = function (specifier) {
  if (specifier["default"]) {
    return t.identifier("default");
  } else {
    return specifier.id;
  }
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {Boolean}
 */

t.isSpecifierDefault = function (specifier) {
  return specifier["default"] || t.isIdentifier(specifier.id) && specifier.id.name === "default";
};

/**
 * Description
 *
 * @param {Node} node
 * @param {Node} parent
 * @returns {Boolean}
 */

t.isScope = function (node, parent) {
  if (t.isBlockStatement(node)) {
    if (t.isLoop(parent.block, { body: node })) {
      return false;
    }

    if (t.isFunction(parent.block, { body: node })) {
      return false;
    }
  }

  return t.isScopable(node);
};

toFastProperties(t);
toFastProperties(t.VISITOR_KEYS);
},{"../helpers/object":154,"../helpers/to-fast-properties":156,"./alias-keys":249,"./builder-keys":250,"./visitor-keys":252,"esutils":287,"lodash/array/compact":297,"lodash/array/uniq":301,"lodash/collection/each":303,"lodash/lang/isString":397}],252:[function(require,module,exports){
module.exports={
  "ArrayExpression":           ["elements"],
  "ArrayPattern":              ["elements"],
  "ArrowFunctionExpression":   ["params", "defaults", "rest", "body"],
  "AssignmentExpression":      ["left", "right"],
  "AssignmentPattern":         ["left", "right"],
  "AwaitExpression":           ["argument"],
  "BinaryExpression":          ["left", "right"],
  "BindFunctionExpression":    ["callee", "arguments"],
  "BindMemberExpression":      ["object", "property", "arguments"],
  "BlockStatement":            ["body"],
  "BreakStatement":            ["label"],
  "CallExpression":            ["callee", "arguments"],
  "CatchClause":               ["param", "body"],
  "ClassBody":                 ["body"],
  "ClassDeclaration":          ["id", "body", "superClass"],
  "ClassExpression":           ["id", "body", "superClass"],
  "ComprehensionBlock":        ["left", "right", "body"],
  "ComprehensionExpression":   ["filter", "blocks", "body"],
  "ConditionalExpression":     ["test", "consequent", "alternate"],
  "ContinueStatement":         ["label"],
  "DebuggerStatement":         [],
  "DoWhileStatement":          ["body", "test"],
  "EmptyStatement":            [],
  "ExportBatchSpecifier":      [],
  "ExportDeclaration":         ["declaration", "specifiers", "source"],
  "ExportSpecifier":           ["id", "name"],
  "ExpressionStatement":       ["expression"],
  "File":                      ["program"],
  "ForInStatement":            ["left", "right", "body"],
  "ForOfStatement":            ["left", "right", "body"],
  "ForStatement":              ["init", "test", "update", "body"],
  "FunctionDeclaration":       ["id", "params", "defaults", "rest", "body"],
  "FunctionExpression":        ["id", "params", "defaults", "rest", "body"],
  "Identifier":                [],
  "IfStatement":               ["test", "consequent", "alternate"],
  "ImportBatchSpecifier":      ["id"],
  "ImportDeclaration":         ["specifiers", "source"],
  "ImportSpecifier":           ["id", "name"],
  "LabeledStatement":          ["label", "body"],
  "Literal":                   [],
  "LogicalExpression":         ["left", "right"],
  "MemberExpression":          ["object", "property"],
  "MethodDefinition":          ["key", "value"],
  "NewExpression":             ["callee", "arguments"],
  "ObjectExpression":          ["properties"],
  "ObjectPattern":             ["properties"],
  "PrivateDeclaration":        ["declarations"],
  "Program":                   ["body"],
  "Property":                  ["key", "value"],
  "RestElement":               ["argument"],
  "ReturnStatement":           ["argument"],
  "SequenceExpression":        ["expressions"],
  "SpreadElement":             ["argument"],
  "SpreadProperty":            ["argument"],
  "SwitchCase":                ["test", "consequent"],
  "SwitchStatement":           ["discriminant", "cases"],
  "TaggedTemplateExpression":  ["tag", "quasi"],
  "TemplateElement":           [],
  "TemplateLiteral":           ["quasis", "expressions"],
  "ThisExpression":            [],
  "ThrowStatement":            ["argument"],
  "TryStatement":              ["block", "handlers", "handler", "guardedHandlers", "finalizer"],
  "UnaryExpression":           ["argument"],
  "UpdateExpression":          ["argument"],
  "VariableDeclaration":       ["declarations"],
  "VariableDeclarator":        ["id", "init"],
  "VirtualPropertyExpression": ["object", "property"],
  "WhileStatement":            ["test", "body"],
  "WithStatement":             ["object", "body"],
  "YieldExpression":           ["argument"],

  "AnyTypeAnnotation":           [],
  "ArrayTypeAnnotation":         [],
  "BooleanTypeAnnotation":       [],
  "ClassProperty":               ["key", "value"],
  "DeclareClass":                [],
  "DeclareFunction":             [],
  "DeclareModule":               [],
  "DeclareVariable":             [],
  "FunctionTypeAnnotation":      [],
  "FunctionTypeParam":           [],
  "GenericTypeAnnotation":       [],
  "InterfaceExtends":            [],
  "InterfaceDeclaration":        [],
  "IntersectionTypeAnnotation":  [],
  "NullableTypeAnnotation":      [],
  "NumberTypeAnnotation":        [],
  "StringLiteralTypeAnnotation": [],
  "StringTypeAnnotation":        [],
  "TupleTypeAnnotation":         [],
  "TypeofTypeAnnotation":        [],
  "TypeAlias":                   [],
  "TypeAnnotation":              [],
  "TypeCastExpression":          ["expression"],
  "TypeParameterDeclaration":    [],
  "TypeParameterInstantiation":  [],
  "ObjectTypeAnnotation":        [],
  "ObjectTypeCallProperty":      [],
  "ObjectTypeIndexer":           [],
  "ObjectTypeProperty":          [],
  "QualifiedTypeIdentifier":     [],
  "UnionTypeAnnotation":         [],
  "VoidTypeAnnotation":          [],

  "JSXAttribute":              ["name", "value"],
  "JSXClosingElement":         ["name"],
  "JSXElement":                ["openingElement", "closingElement", "children"],
  "JSXEmptyExpression":        [],
  "JSXExpressionContainer":    ["expression"],
  "JSXIdentifier":             [],
  "JSXMemberExpression":       ["object", "property"],
  "JSXNamespacedName":         ["namespace", "name"],
  "JSXOpeningElement":         ["name", "attributes"],
  "JSXSpreadAttribute":        ["argument"]
}

},{}],253:[function(require,module,exports){
(function (__dirname){
"use strict";

require("./patch");

var cloneDeep = require("lodash/lang/cloneDeep");
var isBoolean = require("lodash/lang/isBoolean");
var contains = require("lodash/collection/contains");
var traverse = require("./traversal");
var isString = require("lodash/lang/isString");
var isRegExp = require("lodash/lang/isRegExp");
var isEmpty = require("lodash/lang/isEmpty");
var parse = require("./helpers/parse");
var debug = require("debug/node");
var path = require("path");
var util = require("util");
var each = require("lodash/collection/each");
var has = require("lodash/object/has");
var fs = require("fs");
var t = require("./types");

exports.inherits = util.inherits;

exports.debug = debug("babel");

exports.canCompile = function (filename, altExts) {
  var exts = altExts || exports.canCompile.EXTENSIONS;
  var ext = path.extname(filename);
  return contains(exts, ext);
};

exports.canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"];

exports.resolve = function (loc) {
  try {
    return require.resolve(loc);
  } catch (err) {
    return null;
  }
};

exports.list = function (val) {
  return val ? val.split(",") : [];
};

exports.regexify = function (val) {
  if (!val) return new RegExp(/.^/);
  if (Array.isArray(val)) val = val.join("|");
  if (isString(val)) return new RegExp(val);
  if (isRegExp(val)) return val;
  throw new TypeError("illegal type for regexify");
};

exports.arrayify = function (val) {
  if (!val) return [];
  if (isBoolean(val)) return [val];
  if (isString(val)) return exports.list(val);
  if (Array.isArray(val)) return val;
  throw new TypeError("illegal type for arrayify");
};

exports.booleanify = function (val) {
  if (val === "true") return true;
  if (val === "false") return false;
  return val;
};

var templateVisitor = {
  enter: function enter(node, parent, scope, nodes) {
    if (t.isExpressionStatement(node)) {
      node = node.expression;
    }
    if (t.isIdentifier(node) && has(nodes, node.name)) {
      this.skip();
      return nodes[node.name];
    }
  }
};

exports.template = function (name, nodes, keepExpression) {
  var template = exports.templates[name];
  if (!template) throw new ReferenceError("unknown template " + name);

  if (nodes === true) {
    keepExpression = true;
    nodes = null;
  }

  template = cloneDeep(template);

  if (!isEmpty(nodes)) {
    traverse(template, templateVisitor, null, nodes);
  }

  if (template.body.length > 1) return template.body;

  var node = template.body[0];

  if (!keepExpression && t.isExpressionStatement(node)) {
    return node.expression;
  } else {
    return node;
  }
};

exports.parseTemplate = function (loc, code) {
  var ast = parse({ filename: loc }, code).program;
  return traverse.removeProperties(ast);
};

var loadTemplates = function loadTemplates() {
  var templates = {};

  var templatesLoc = __dirname + "/transformation/templates";
  if (!fs.existsSync(templatesLoc)) {
    throw new Error("no templates directory - this is most likely the " + "result of a broken `npm publish`. Please report to " + "https://github.com/babel/babel/issues");
  }

  each(fs.readdirSync(templatesLoc), function (name) {
    if (name[0] === ".") return;

    var key = path.basename(name, path.extname(name));
    var loc = templatesLoc + "/" + name;
    var code = fs.readFileSync(loc, "utf8");

    templates[key] = exports.parseTemplate(loc, code);
  });

  return templates;
};

try {
  exports.templates = require("../../templates.json");
} catch (err) {
  if (err.code !== "MODULE_NOT_FOUND") throw err;

  exports.templates = loadTemplates();
}
}).call(this,"/node_modules/earlgrey/node_modules/babel/lib/babel")
},{"../../templates.json":445,"./helpers/parse":155,"./patch":158,"./traversal":246,"./types":251,"debug/node":280,"fs":697,"lodash/collection/contains":302,"lodash/collection/each":303,"lodash/lang/cloneDeep":387,"lodash/lang/isBoolean":390,"lodash/lang/isEmpty":391,"lodash/lang/isRegExp":396,"lodash/lang/isString":397,"lodash/object/has":402,"path":706,"util":723}],254:[function(require,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke and various contributors and
// released under an MIT license. The Unicode regexps (for identifiers
// and whitespace) were taken from [Esprima](http://esprima.org) by
// Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/marijnh/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
  mod(root.acorn || (root.acorn = {})); // Plain browser env
})(this, function(exports) {
  "use strict";

  exports.version = "0.11.1";

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api], with the caveat that inline XML is not recognized.
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    var startPos = options.locations ? [tokPos, curPosition()] : tokPos;
    initParserState();
    if (options.strictMode) {
      strict = true;
    }
    return parseTopLevel(options.program || startNodeAt(startPos));
  };

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = exports.defaultOptions = {
    strictMode: false,
    playground: false,
    // `ecmaVersion` indicates the ECMAScript version to parse. Must
    // be either 3, or 5, or 6. This influences support for strict
    // mode, the set of reserved words, support for getters and
    // setters and other features.
    ecmaVersion: 5,
    // Turn on `strictSemicolons` to prevent the parser from doing
    // automatic semicolon insertion.
    strictSemicolons: false,
    // When `allowTrailingCommas` is false, the parser will not allow
    // trailing commas in array and object literals.
    allowTrailingCommas: true,
    // By default, reserved words are not enforced. Enable
    // `forbidReserved` to enforce them. When this option has the
    // value "everywhere", reserved words and keywords can also not be
    // used as property names.
    forbidReserved: false,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokenize() returns. Note that you are not
    // allowed to call the parser from the callback—that will
    // corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  exports.parseExpressionAt = function(inpt, pos, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState(pos);
    initParserState();
    return parseExpression();
  };

  var isArray = function (obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  function setOptions(opts) {
    options = {};
    for (var opt in defaultOptions)
      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    sourceFile = options.sourceFile || null;
    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) {
        tokens.push(token);
      };
    }
    if (isArray(options.onComment)) {
      var comments = options.onComment;
      options.onComment = function (block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? 'Block' : 'Line',
          value: text,
          start: start,
          end: end
        };
        if (options.locations) {
          comment.loc = new SourceLocation();
          comment.loc.start = startLoc;
          comment.loc.end = endLoc;
        }
        if (options.ranges)
          comment.range = [start, end];
        comments.push(comment);
      };
    }
    if (options.ecmaVersion >= 6) {
      isKeyword = isEcma6Keyword;
    } else {
      isKeyword = isEcma5AndLessKeyword;
    }
  }

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  var getLineInfo = exports.getLineInfo = function(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreak.lastIndex = cur;
      var match = lineBreak.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else break;
    }
    return {line: line, column: offset - cur};
  };

  function Token() {
    this.type = tokType;
    this.value = tokVal;
    this.start = tokStart;
    this.end = tokEnd;
    if (options.locations) {
      this.loc = new SourceLocation();
      this.loc.end = tokEndLoc;
    }
    if (options.ranges)
      this.range = [tokStart, tokEnd];
  }

  exports.Token = Token;

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenize` export provides an interface to the tokenizer.
  // Because the tokenizer is optimized for being efficiently used by
  // the Acorn parser itself, this interface is somewhat crude and not
  // very modular. Performing another parse or call to `tokenize` will
  // reset the internal state, and invalidate existing tokenizers.

  exports.tokenize = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    skipSpace();

    function getToken() {
      lastEnd = tokEnd;
      readToken();
      return new Token();
    }
    getToken.jumpTo = function(pos, exprAllowed) {
      tokPos = pos;
      if (options.locations) {
        tokCurLine = 1;
        tokLineStart = lineBreak.lastIndex = 0;
        var match;
        while ((match = lineBreak.exec(input)) && match.index < pos) {
          ++tokCurLine;
          tokLineStart = match.index + match[0].length;
        }
      }
      tokExprAllowed = !!exprAllowed;
      skipSpace();
    };
    getToken.current = function() { return new Token(); };
    if (typeof Symbol !== 'undefined') {
      getToken[Symbol.iterator] = function () {
        return {
          next: function () {
            var token = getToken();
            return {
              done: token.type === _eof,
              value: token
            };
          }
        };
      };
    }
    getToken.options = options;
    return getToken;
  };

  // State is kept in (closure-)global variables. We already saw the
  // `options`, `input`, and `inputLen` variables above.

  // The current position of the tokenizer in the input.

  var tokPos;

  // The start and end offsets of the current token.

  var tokStart, tokEnd;

  // When `options.locations` is true, these hold objects
  // containing the tokens start and end line/column pairs.

  var tokStartLoc, tokEndLoc;

  // The type and value of the current token. Token types are objects,
  // named by variables against which they can be compared, and
  // holding properties that describe them (indicating, for example,
  // the precedence of an infix operator, and the original name of a
  // keyword token). The kind of value that's held in `tokVal` depends
  // on the type of the token. For literals, it is the literal value,
  // for operators, the operator name, and so on.

  var tokType, tokVal;

  // Internal state for the tokenizer. To distinguish between division
  // operators and regular expressions, it remembers whether the last
  // token was one that is allowed to be followed by an expression. In
  // some cases, notably after ')' or '}' tokens, the situation
  // depends on the context before the matching opening bracket, so
  // tokContext keeps a stack of information about current bracketed
  // forms.

  var tokContext, tokExprAllowed;

  // When `options.locations` is true, these are used to keep
  // track of the current line, and know when a new line has been
  // entered.

  var tokCurLine, tokLineStart;

  // These store the position of the previous token, which is useful
  // when finishing a node and assigning its `end` position.

  var lastStart, lastEnd, lastEndLoc;

  // This is the parser's state. `inFunction` is used to reject
  // `return` statements outside of functions, `inGenerator` to
  // reject `yield`s outside of generators, `labels` to verify
  // that `break` and `continue` have somewhere to jump to, and
  // `strict` indicates whether strict mode is on.

  var inFunction, inGenerator, inAsync, labels, strict,
    inXJSChild, inXJSTag, inType;

  function initParserState() {
    lastStart = lastEnd = tokPos;
    if (options.locations) lastEndLoc = curPosition();
    inFunction = inGenerator = inAsync = false;
    labels = [];
    skipSpace();
    readToken();
  }

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  function raise(pos, message) {
    var loc = getLineInfo(input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
    throw err;
  }

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // These are the general types. The `type` property is only used to
  // make them recognizeable when debugging.

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};
  var _jsxName = {type: "jsxName"};

  // These are JSX-specific token types

  var _xjsName = {type: "xjsName"}, _xjsText = {type: "xjsText"};

  // Keyword tokens. The `keyword` property (also used in keyword-like
  // operators) indicates that the token originated from an
  // identifier-like word, which is used when parsing property names.
  //
  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _let = {keyword: "let"}, _const = {keyword: "const"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};
  var _class = {keyword: "class"}, _extends = {keyword: "extends", beforeExpr: true};
  var _export = {keyword: "export"}, _import = {keyword: "import"};
  var _yield = {keyword: "yield", beforeExpr: true};

  // The keywords that denote values.

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  // Some keywords are treated as regular operators. `in` sometimes
  // (when parsing `for`) needs to be tested against specifically, so
  // we assign a variable name to it for quick comparing.

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  // Map keyword names to token types.

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                      "continue": _continue, "debugger": _debugger, "default": _default,
                      "do": _do, "else": _else, "finally": _finally, "for": _for,
                      "function": _function, "if": _if, "return": _return, "switch": _switch,
                      "throw": _throw, "try": _try, "var": _var, "let": _let, "const": _const,
                      "while": _while, "with": _with,
                      "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                      "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                      "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                      "void": {keyword: "void", prefix: true, beforeExpr: true},
                      "delete": {keyword: "delete", prefix: true, beforeExpr: true},
                      "class": _class, "extends": _extends,
                      "export": _export, "import": _import, "yield": _yield};

  // Punctuation token types. Again, the `type` property is purely for debugging.

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};
  var _arrow = {type: "=>", beforeExpr: true}, _template = {type: "template"};
  var _ellipsis = {type: "...", beforeExpr: true};
  var _backQuote = {type: "`"}, _dollarBraceL = {type: "${", beforeExpr: true};
  var _jsxText = {type: "jsxText"};
  var _paamayimNekudotayim = { type: "::", beforeExpr: true };
  var _hash = { type: '#' };

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator. `isUpdate` specifies that the node produced by
  // the operator should be of type UpdateExpression rather than
  // simply UnaryExpression (`++` and `--`).
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _modulo = {binop: 10, beforeExpr: true};

  // '*' may be multiply or have special meaning in ES6
  var _star = {binop: 10, beforeExpr: true};
  var _exponent = {binop: 11, beforeExpr: true, rightAssociative: true};

  // JSX tag boundaries
  var _jsxTagStart = {type: "jsxTagStart"}, _jsxTagEnd = {type: "jsxTagEnd"};

  // Provide access to the token types for external users of the
  // tokenizer.

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                      dot: _dot, ellipsis: _ellipsis, question: _question, slash: _slash, eq: _eq,
                      name: _name, eof: _eof, num: _num, regexp: _regexp, string: _string,
                      paamayimNekudotayim: _paamayimNekudotayim, exponent: _exponent, hash: _hash,
                      arrow: _arrow, template: _template, star: _star, assign: _assign,
                      backQuote: _backQuote, dollarBraceL: _dollarBraceL, jsxName: _jsxName,
                      jsxText: _jsxText, jsxTagStart: _jsxTagStart, jsxTagEnd: _jsxTagEnd};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  // This is a trick taken from Esprima. It turns out that, on
  // non-Chrome browsers, to check whether a string is in a set, a
  // predicate containing a big ugly `switch` statement is faster than
  // a regular expression, and on Chrome the two are about on par.
  // This function uses `eval` (non-lexical) to produce such a
  // predicate from a space-separated string of words.
  //
  // It starts by sorting the words by length.

  // Removed to create an eval-free library

  // The ECMAScript 3 reserved word list.

  var isReservedWord3 = function anonymous(str) {
switch(str.length){case 6:switch(str){case "double":case "export":case "import":case "native":case "public":case "static":case "throws":return true}return false;case 4:switch(str){case "byte":case "char":case "enum":case "goto":case "long":return true}return false;case 5:switch(str){case "class":case "final":case "float":case "short":case "super":return true}return false;case 7:switch(str){case "boolean":case "extends":case "package":case "private":return true}return false;case 9:switch(str){case "interface":case "protected":case "transient":return true}return false;case 8:switch(str){case "abstract":case "volatile":return true}return false;case 10:return str === "implements";case 3:return str === "int";case 12:return str === "synchronized";}
};

  // ECMAScript 5 reserved words.

  var isReservedWord5 = function anonymous(str) {
switch(str.length){case 5:switch(str){case "class":case "super":case "const":return true}return false;case 6:switch(str){case "export":case "import":return true}return false;case 4:return str === "enum";case 7:return str === "extends";}
};

  // The additional reserved words in strict mode.

  var isStrictReservedWord = function anonymous(str) {
switch(str.length){case 9:switch(str){case "interface":case "protected":return true}return false;case 7:switch(str){case "package":case "private":return true}return false;case 6:switch(str){case "public":case "static":return true}return false;case 10:return str === "implements";case 3:return str === "let";case 5:return str === "yield";}
};

  // The forbidden variable names in strict mode.

  var isStrictBadIdWord = function anonymous(str) {
switch(str){case "eval":case "arguments":return true}return false;
};

  // And the keywords.

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var isEcma5AndLessKeyword = function anonymous(str) {
switch(str.length){case 4:switch(str){case "case":case "else":case "with":case "null":case "true":case "void":case "this":return true}return false;case 5:switch(str){case "break":case "catch":case "throw":case "while":case "false":return true}return false;case 3:switch(str){case "for":case "try":case "var":case "new":return true}return false;case 6:switch(str){case "return":case "switch":case "typeof":case "delete":return true}return false;case 8:switch(str){case "continue":case "debugger":case "function":return true}return false;case 2:switch(str){case "do":case "if":case "in":return true}return false;case 7:switch(str){case "default":case "finally":return true}return false;case 10:return str === "instanceof";}
};

  var ecma6AndLessKeywords = ecma5AndLessKeywords + " let const class extends export import yield";

  var isEcma6Keyword = function anonymous(str) {
switch(str.length){case 5:switch(str){case "break":case "catch":case "throw":case "while":case "false":case "const":case "class":case "yield":return true}return false;case 4:switch(str){case "case":case "else":case "with":case "null":case "true":case "void":case "this":return true}return false;case 6:switch(str){case "return":case "switch":case "typeof":case "delete":case "export":case "import":return true}return false;case 3:switch(str){case "for":case "try":case "var":case "new":case "let":return true}return false;case 8:switch(str){case "continue":case "debugger":case "function":return true}return false;case 7:switch(str){case "default":case "finally":case "extends":return true}return false;case 2:switch(str){case "do":case "if":case "in":return true}return false;case 10:return str === "instanceof";}
};

  var isKeyword = isEcma5AndLessKeyword;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `tools/generate-identifier-regex.js`.

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19B0-\u19C0\u19C8\u19C9\u19D0-\u19D9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var decimalNumber = /^\d+$/;
  var hexNumber = /^[\da-fA-F]+$/;

  // Whether a single character denotes a newline.

  var newline = /[\n\r\u2028\u2029]/;

  function isNewLine(code) {
    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
  }

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  // Test whether a given character code starts an identifier.

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  // Test whether a given character is part of an identifier.

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  // ## Tokenizer

  // These are used when `options.locations` is on, for the
  // `tokStartLoc` and `tokEndLoc` properties.

  function Position(line, col) {
    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function(n) {
    return new Position(this.line, this.column + n);
  };

  function curPosition() {
    return new Position(tokCurLine, tokPos - tokLineStart);
  }

  // Reset the token state. Used at the start of a parse.

  function initTokenState(pos) {
    if (pos) {
      tokPos = pos;
      tokLineStart = Math.max(0, input.lastIndexOf("\n", pos));
      tokCurLine = input.slice(0, tokLineStart).split(newline).length;
    } else {
      tokCurLine = 1;
      tokPos = tokLineStart = 0;
    }
    tokType = _eof;
    tokContext = [b_stat];
    tokExprAllowed = true;
    inType = strict = false;
    if (tokPos === 0 && options.allowHashBang && input.slice(0, 2) === '#!') {
      skipLineComment(2);
    }
  }

  // The algorithm used to determine whether a regexp can appear at a
  // given point in the program is loosely based on sweet.js' approach.
  // See https://github.com/mozilla/sweet.js/wiki/design

  var b_stat = {token: "{", isExpr: false}, b_expr = {token: "{", isExpr: true}, b_tmpl = {token: "${", isExpr: true};
  var p_stat = {token: "(", isExpr: false}, p_expr = {token: "(", isExpr: true};
  var q_tmpl = {token: "`", isExpr: true}, f_expr = {token: "function", isExpr: true};
  var j_oTag = {token: "<tag", isExpr: false}, j_cTag = {token: "</tag", isExpr: false}, j_expr = {token: "<tag>...</tag>", isExpr: true};

  function curTokContext() {
    return tokContext[tokContext.length - 1];
  }

  function braceIsBlock(prevType) {
    var parent;
    if (prevType === _colon && (parent = curTokContext()).token == "{")
      return !parent.isExpr;
    if (prevType === _return)
      return newline.test(input.slice(lastEnd, tokStart));
    if (prevType === _else || prevType === _semi || prevType === _eof)
      return true;
    if (prevType == _braceL)
      return curTokContext() === b_stat;
    return !tokExprAllowed;
  }

  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
  // maintains `tokContext` and `tokExprAllowed`, and skips the space
  // after the token, so that the next one's `tokStart` will point at
  // the right position.

  function finishToken(type, val) {
    tokEnd = tokPos;
    if (options.locations) tokEndLoc = curPosition();
    var prevType = tokType, preserveSpace = false;
    tokType = type;
    tokVal = val;

    // Update context info
    if (type === _parenR || type === _braceR) {
      var out = tokContext.pop();
      if (out === b_tmpl) {
        preserveSpace = tokExprAllowed = true;
      } else if (out === b_stat && curTokContext() === f_expr) {
        tokContext.pop();
        tokExprAllowed = false;
      } else {
        tokExprAllowed = !(out && out.isExpr);
      }
    } else if (type === _braceL) {
      switch (curTokContext()) {
        case j_oTag: tokContext.push(b_expr); break;
        case j_expr: tokContext.push(b_tmpl); break;
        default: tokContext.push(braceIsBlock(prevType) ? b_stat : b_expr);
      }
      tokExprAllowed = true;
    } else if (type === _dollarBraceL) {
      tokContext.push(b_tmpl);
      tokExprAllowed = true;
    } else if (type == _parenL) {
      var statementParens = prevType === _if || prevType === _for || prevType === _with || prevType === _while;
      tokContext.push(statementParens ? p_stat : p_expr);
      tokExprAllowed = true;
    } else if (type == _incDec) {
      // tokExprAllowed stays unchanged
    } else if (type.keyword && prevType == _dot) {
      tokExprAllowed = false;
    } else if (type == _function) {
      if (curTokContext() !== b_stat) {
        tokContext.push(f_expr);
      }
      tokExprAllowed = false;
    } else if (type === _backQuote) {
      if (curTokContext() === q_tmpl) {
        tokContext.pop();
      } else {
        tokContext.push(q_tmpl);
        preserveSpace = true;
      }
      tokExprAllowed = false;
    } else if (type === _jsxTagStart) {
      tokContext.push(j_expr); // treat as beginning of JSX expression
      tokContext.push(j_oTag); // start opening tag context
      tokExprAllowed = false;
    } else if (type === _jsxTagEnd) {
      var out = tokContext.pop();
      if (out === j_oTag && prevType === _slash || out === j_cTag) {
        tokContext.pop();
        preserveSpace = tokExprAllowed = curTokContext() === j_expr;
      } else {
        preserveSpace = tokExprAllowed = true;
      }
    } else if (type === _jsxText) {
      preserveSpace = tokExprAllowed = true;
    } else if (type === _slash && prevType === _jsxTagStart) {
      tokContext.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
      tokContext.push(j_cTag); // reconsider as closing tag context
      tokExprAllowed = false;
    } else {
      tokExprAllowed = type.beforeExpr;
    }

    if (!preserveSpace) skipSpace();
  }

  function skipBlockComment() {
    var startLoc = options.onComment && options.locations && curPosition();
    var start = tokPos, end = input.indexOf("*/", tokPos += 2);
    if (end === -1) raise(tokPos - 2, "Unterminated comment");
    tokPos = end + 2;
    if (options.locations) {
      lineBreak.lastIndex = start;
      var match;
      while ((match = lineBreak.exec(input)) && match.index < tokPos) {
        ++tokCurLine;
        tokLineStart = match.index + match[0].length;
      }
    }
    if (options.onComment)
      options.onComment(true, input.slice(start + 2, end), start, tokPos,
                        startLoc, options.locations && curPosition());
  }

  function skipLineComment(startSkip) {
    var start = tokPos;
    var startLoc = options.onComment && options.locations && curPosition();
    var ch = input.charCodeAt(tokPos+=startSkip);
    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++tokPos;
      ch = input.charCodeAt(tokPos);
    }
    if (options.onComment)
      options.onComment(false, input.slice(start + startSkip, tokPos), start, tokPos,
                        startLoc, options.locations && curPosition());
  }

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  function skipSpace() {
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (ch === 32) { // ' '
        ++tokPos;
      } else if (ch === 13) {
        ++tokPos;
        var next = input.charCodeAt(tokPos);
        if (next === 10) {
          ++tokPos;
        }
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch === 10 || ch === 8232 || ch === 8233) {
        ++tokPos;
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch > 8 && ch < 14) {
        ++tokPos;
      } else if (ch === 47) { // '/'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 42) { // '*'
          skipBlockComment();
        } else if (next === 47) { // '/'
          skipLineComment(2);
        } else break;
      } else if (ch === 160) { // '\xa0'
        ++tokPos;
      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++tokPos;
      } else {
        break;
      }
    }
  }

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  function readToken_dot() {
    var next = input.charCodeAt(tokPos + 1);
    if (next >= 48 && next <= 57) return readNumber(true);
    var next2 = input.charCodeAt(tokPos + 2);
    if (options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      tokPos += 3;
      return finishToken(_ellipsis);
    } else {
      ++tokPos;
      return finishToken(_dot);
    }
  }

  function readToken_slash() { // '/'
    var next = input.charCodeAt(tokPos + 1);
    if (tokExprAllowed) {++tokPos; return readRegexp();}
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_slash, 1);
  }

  function readToken_modulo() { // '%'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_modulo, 1);
  }

  function readToken_mult() { // '*'
    var type = _star;
    var width = 1;
    var next = input.charCodeAt(tokPos + 1);

    if (options.ecmaVersion >= 7 && next === 42) { // '*'
      width++;
      next = input.charCodeAt(tokPos + 2);
      type = _exponent;
    }

    if (next === 61) { // '='
      width++;
      type = _assign;
    }
    
    return finishOp(type, width);
  }

  function readToken_pipe_amp(code) { // '|&'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) {
      if (options.playground && input.charCodeAt(tokPos + 2) === 61) return finishOp(_assign, 3);
      return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
    }
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() { // '^'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) { // '+-'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) {
      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
          newline.test(input.slice(lastEnd, tokPos))) {
        // A `-->` line comment
        skipLineComment(3);
        skipSpace();
        return readToken();
      }
      return finishOp(_incDec, 2);
    }
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) { // '<>'
    var next = input.charCodeAt(tokPos + 1);
    var size = 1;
    if (!inType && next === code) {
      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
      return finishOp(_bitShift, size);
    }
    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
        input.charCodeAt(tokPos + 3) == 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      skipLineComment(4);
      skipSpace();
      return readToken();
    }
    if (!inType) {
      if (tokExprAllowed && code === 60) {
        ++tokPos;
        return finishToken(_jsxTagStart);
      }
      if (code === 62) {
        var context = curTokContext();
        if (context === j_oTag || context === j_cTag) {
          ++tokPos;
          return finishToken(_jsxTagEnd);
        }
      }
    }
    if (next === 61)
      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
    return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) { // '=!', '=>'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62 && options.ecmaVersion >= 6) { // '=>'
      tokPos += 2;
      return finishToken(_arrow);
    }
    return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  // Get token inside ES6 template (special rules work there).

  function getTemplateToken(code) {
    // '`' and '${' have special meanings, but they should follow
    // string (can be empty)
    if (tokType === _string) {
      if (code === 96) { // '`'
        ++tokPos;
        return finishToken(_bquote);
      } else if (code === 36 && input.charCodeAt(tokPos + 1) === 123) { // '${'
        tokPos += 2;
        return finishToken(_dollarBraceL);
      }
    }
    // anything else is considered string literal
    return readTmplString();
  }

  function getTokenFromCode(code) {
    switch(code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
    case 46: // '.'
      return readToken_dot();

      // Punctuation tokens.
    case 40: ++tokPos; return finishToken(_parenL);
    case 41: ++tokPos; return finishToken(_parenR);
    case 59: ++tokPos; return finishToken(_semi);
    case 44: ++tokPos; return finishToken(_comma);
    case 91: ++tokPos; return finishToken(_bracketL);
    case 93: ++tokPos; return finishToken(_bracketR);
    case 123: ++tokPos; return finishToken(_braceL);
    case 125: ++tokPos; return finishToken(_braceR);
    case 63: ++tokPos; return finishToken(_question);

    case 35:
      if (options.playground) {
        ++tokPos;
        return finishToken(_hash);
      }

    case 58:
      ++tokPos;
      if (options.ecmaVersion >= 7) {
        var next = input.charCodeAt(tokPos);
        if (next === 58) {
          ++tokPos;
          return finishToken(_paamayimNekudotayim);
        }
      }
      return finishToken(_colon);

    case 96: // '`'
      if (options.ecmaVersion >= 6) {
        ++tokPos;
        return finishToken(_backQuote);
      } else {
        return false;
      }

    case 48: // '0'
      var next = input.charCodeAt(tokPos + 1);
      if (next === 120 || next === 88) return readRadixNumber(16); // '0x', '0X' - hex number
      if (options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return readRadixNumber(2); // '0b', '0B' - binary number
      }
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return readNumber(false);

      // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return inXJSTag ? readXJSStringLiteral() : readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return readToken_slash();

    case 37: // '%'
      return readToken_modulo();

    case 42: // '*'
      return readToken_mult();

    case 124: case 38: // '|&'
      return readToken_pipe_amp(code);

    case 94: // '^'
      return readToken_caret();

    case 43: case 45: // '+-'
      return readToken_plus_min(code);

    case 60: case 62: // '<>'
      return readToken_lt_gt(code);

    case 61: case 33: // '=!'
      return readToken_eq_excl(code);

    case 126: // '~'
      return finishOp(_prefix, 1);
    }

    return false;
  }

  function readToken() {
    tokStart = tokPos;
    if (options.locations) tokStartLoc = curPosition();
    if (tokPos >= inputLen) return finishToken(_eof);

    var context = curTokContext();

    if (context === q_tmpl) {
      return readTmplToken();
    }

    if (context === j_expr) {
      return readJSXToken();
    }

    var code = input.charCodeAt(tokPos);
    if (context === j_oTag || context === j_cTag) {
      // JSX identifier
      if (isIdentifierStart(code)) return readJSXWord();
    } else if (context === j_expr) {
      return readJSXToken();
    } else {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();
    }

    var tok = getTokenFromCode(code);

    if (tok === false) {
      // If we are here, we either found a non-ASCII identifier
      // character, or something that's entirely disallowed.
      var ch = String.fromCharCode(code);
      if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
      raise(tokPos, "Unexpected character '" + ch + "'");
    }
    return tok;
  }

  function finishOp(type, size, shouldSkipSpace) {
    var str = input.slice(tokPos, tokPos + size);
    tokPos += size;
    finishToken(type, str, shouldSkipSpace);
  }

  var regexpUnicodeSupport = false;
  try { new RegExp("\uffff", "u"); regexpUnicodeSupport = true; }
  catch(e) {}

  // Parse a regular expression. Some context-awareness is necessary,
  // since a '/' inside a '[]' set does not end the expression.

  function readRegexp() {
    var content = "", escaped, inClass, start = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
      var ch = nextChar();
      if (newline.test(ch)) raise(start, "Unterminated regular expression");
      if (!escaped) {
        if (ch === "[") inClass = true;
        else if (ch === "]" && inClass) inClass = false;
        else if (ch === "/" && !inClass) break;
        escaped = ch === "\\";
      } else escaped = false;
      ++tokPos;
    }
    var content = input.slice(start, tokPos);
    ++tokPos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = readWord1();
    // Detect invalid regular expressions.
    var tmp = content;
    if (mods) {
      var validFlags = /^[gmsiy]*$/;
      if (options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) raise(start, "Invalid regular expression flag");
      if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
        // Replace each astral symbol and every Unicode code point
        // escape sequence that represents such a symbol with a single
        // ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        tmp = tmp
          .replace(/\\u\{([0-9a-fA-F]{5,6})\}/g, "x")
          .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
      }
    }
    // Detect invalid regular expressions.
    try {
      new RegExp(tmp);
    } catch (e) {
      if (e instanceof SyntaxError) raise(start, "Error parsing regular expression: " + e.message);
      raise(e);
    }
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    try {
      var value = new RegExp(content, mods);
    } catch (err) {
      value = null;
  }
    return finishToken(_regexp, {pattern: content, flags: mods, value: value});
  }

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  function readInt(radix, len) {
    var start = tokPos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(tokPos), val;
      if (code >= 97) val = code - 97 + 10; // a
      else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
      else val = Infinity;
      if (val >= radix) break;
      ++tokPos;
      total = total * radix + val;
    }
    if (tokPos === start || len != null && tokPos - start !== len) return null;

    return total;
  }

  function readRadixNumber(radix) {
    tokPos += 2; // 0x
    var val = readInt(radix);
    if (val == null) raise(tokStart + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    return finishToken(_num, val);
  }

  // Read an integer, octal integer, or floating-point number.

  function readNumber(startsWithDot) {
    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
    if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
    if (input.charCodeAt(tokPos) === 46) {
      ++tokPos;
      readInt(10);
      isFloat = true;
    }
    var next = input.charCodeAt(tokPos);
    if (next === 69 || next === 101) { // 'eE'
      next = input.charCodeAt(++tokPos);
      if (next === 43 || next === 45) ++tokPos; // '+-'
      if (readInt(10) === null) raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

    var str = input.slice(start, tokPos), val;
    if (isFloat) val = parseFloat(str);
    else if (!octal || str.length === 1) val = parseInt(str, 10);
    else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
    else val = parseInt(str, 8);
    return finishToken(_num, val);
  }

  // Read a string value, interpreting backslash-escapes.

  function readCodePoint() {
    var ch = input.charCodeAt(tokPos), code;
    
    if (ch === 123) {
      if (options.ecmaVersion < 6) unexpected();
      ++tokPos;
      code = readHexChar(input.indexOf('}', tokPos) - tokPos);
      ++tokPos;
      if (code > 0x10FFFF) unexpected();
    } else {
      code = readHexChar(4);
    }

    // UTF-16 Encoding
    if (code <= 0xFFFF) {
      return String.fromCharCode(code);
    }
    var cu1 = ((code - 0x10000) >> 10) + 0xD800;
    var cu2 = ((code - 0x10000) & 1023) + 0xDC00;
    return String.fromCharCode(cu1, cu2);
  }

  function readString(quote) {
    var isJSX = curTokContext() === j_oTag;
    var out = "", chunkStart = ++tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
      var ch = input.charCodeAt(tokPos);
      if (ch === quote) break;
      if (ch === 92 && !isJSX) { // '\'
        out += input.slice(chunkStart, tokPos);
        out += readEscapedChar();
        chunkStart = tokPos;
      } else if (ch === 38 && isJSX) { // '&'
        out += input.slice(chunkStart, tokPos);
        out += readJSXEntity();
        chunkStart = tokPos;
      } else {
        if (isNewLine(ch) && !isJSX) raise(tokStart, "Unterminated string constant");
        ++tokPos;
      }
    }
    out += input.slice(chunkStart, tokPos++);
    return finishToken(_string, out);
  }

  // Reads template string tokens.

  function readTmplToken() {
    var out = "", chunkStart = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated template");
      var ch = input.charCodeAt(tokPos);
      if (ch === 96 || ch === 36 && input.charCodeAt(tokPos + 1) === 123) { // '`', '${'
        if (tokPos === tokStart && tokType === _template) {
          if (ch === 36) {
            tokPos += 2;
            return finishToken(_dollarBraceL);
          } else {
            ++tokPos;
            return finishToken(_backQuote);
          }
        }
        out += input.slice(chunkStart, tokPos);
        return finishToken(_template, out);
      }
      if (ch === 92) { // '\'
        out += input.slice(chunkStart, tokPos);
        out += readEscapedChar();
        chunkStart = tokPos;
      } else if (isNewLine(ch)) {
        out += input.slice(chunkStart, tokPos);
        ++tokPos;
        if (ch === 13 && input.charCodeAt(tokPos) === 10) {
          ++tokPos;
          out += "\n";
        } else {
          out += String.fromCharCode(ch);
        }
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
        chunkStart = tokPos;
      } else {
        ++tokPos;
      }
    }
  }

  var XHTMLEntities = {
    quot: '\u0022',
    amp: '&',
    apos: '\u0027',
    lt: '<',
    gt: '>',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    'int': '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'
  };

  function readJSXEntity() {
    var str = '', count = 0, entity;
    var ch = input[tokPos];
    if (ch !== '&') raise(tokPos, "Entity must start with an ampersand");
    var startPos = ++tokPos;
    while (tokPos < inputLen && count++ < 10) {
      ch = input[tokPos++];
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 10));
            }
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      tokPos = startPos;
      return '&';
    }
    return entity;
  }

  // Reads inline JSX contents token.

  function readJSXToken() {
    var out = "", chunkStart = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated JSX contents");
      var ch = input.charCodeAt(tokPos);
      switch (ch) {
        case 123: // '{'
        case 60: // '<'
          if (tokPos === tokStart) {
            return getTokenFromCode(ch);
          }
          out += input.slice(chunkStart, tokPos);
          return finishToken(_jsxText, out);

        case 38: // '&'
          out += input.slice(chunkStart, tokPos);
          out += readJSXEntity();
          chunkStart = tokPos;
          break;

        default:
          if (isNewLine(ch)) {
            out += input.slice(chunkStart, tokPos);
            ++tokPos;
            if (ch === 13 && input.charCodeAt(tokPos) === 10) {
              ++tokPos;
              out += "\n";
            } else {
              out += String.fromCharCode(ch);
            }
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
            chunkStart = tokPos;
          } else {
            ++tokPos;
          }
      }
    }
  }

  // Used to read escaped characters

  function readEscapedChar() {
    var ch = input.charCodeAt(++tokPos);
    var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
    if (octal) octal = octal[0];
    while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
    if (octal === "0") octal = null;
    ++tokPos;
    if (octal) {
      if (strict) raise(tokPos - 2, "Octal literal in strict mode");
      tokPos += octal.length - 1;
      return String.fromCharCode(parseInt(octal, 8));
    } else {
      switch (ch) {
        case 110: return "\n"; // 'n' -> '\n'
        case 114: return "\r"; // 'r' -> '\r'
        case 120: return String.fromCharCode(readHexChar(2)); // 'x'
        case 117: return readCodePoint(); // 'u'
        case 116: return "\t"; // 't' -> '\t'
        case 98: return "\b"; // 'b' -> '\b'
        case 118: return "\u000b"; // 'v' -> '\u000b'
        case 102: return "\f"; // 'f' -> '\f'
        case 48: return "\0"; // 0 -> '\0'
        case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
        case 10: // ' \n'
          if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
          return "";
        default: return String.fromCharCode(ch);
      }
    }
  }

  var XHTMLEntities = {
    quot: '\u0022',
    amp: '&',
    apos: '\u0027',
    lt: '<',
    gt: '>',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    'int': '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'
  };

  function readXJSEntity() {
    var str = '', count = 0, entity;
    var ch = nextChar();
    if (ch !== '&') raise(tokPos, "Entity must start with an ampersand");
    var startPos = ++tokPos;
    while (tokPos < inputLen && count++ < 10) {
      ch = nextChar();
      tokPos++;
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 10));
            }
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      tokPos = startPos;
      return '&';
    }
    return entity;
  }

  function readXJSText(stopChars) {
    var str = '';
    while (tokPos < inputLen) {
      var ch = nextChar();
      if (stopChars.indexOf(ch) !== -1) {
        break;
      }
      if (ch === '&') {
        str += readXJSEntity();
      } else {
        ++tokPos;
        if (ch === '\r' && nextChar() === '\n') {
          str += ch;
          ++tokPos;
          ch = '\n';
        }
        if (ch === '\n' && options.locations) {
          tokLineStart = tokPos;
          ++tokCurLine;
        }
        str += ch;
      }
    }
    return finishToken(_xjsText, str);
  }

  function readXJSStringLiteral() {
    var quote = input.charCodeAt(tokPos);

    if (quote !== 34 && quote !== 39) {
      raise("String literal must starts with a quote");
    }

    ++tokPos;

    readXJSText([String.fromCharCode(quote)]);

    if (quote !== input.charCodeAt(tokPos)) {
      unexpected();
    }

    ++tokPos;

    return finishToken(tokType, tokVal);
  }

  // Used to read character escape sequences ('\x', '\u', '\U').

  function readHexChar(len) {
    var n = readInt(16, len);
    if (n === null) raise(tokStart, "Bad character escape sequence");
    return n;
  }

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  var containsEsc;

  // Read an identifier, and return it as a string. Sets `containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  function readWord1() {
    containsEsc = false;
    var word = "", first = true, chunkStart = tokPos;
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (isIdentifierChar(ch)) {
        ++tokPos;
      } else if (ch === 92) { // "\"
        containsEsc = true;
        word += input.slice(chunkStart, tokPos);
        if (input.charCodeAt(++tokPos) != 117) // "u"
          raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
        ++tokPos;
        var esc = readHexChar(4);
        var escStr = String.fromCharCode(esc);
        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
          raise(tokPos - 4, "Invalid Unicode escape");
        word += escStr;
        chunkStart = tokPos;
      } else {
        break;
      }
      first = false;
    }
    return word + input.slice(chunkStart, tokPos);
  }

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  function readWord() {
    var word = readWord1();
    var type = inXJSTag ? _xjsName : _name;
    if (!containsEsc && isKeyword(word))
      type = keywordTypes[word];
    return finishToken(type, word);
  }

  // Read a JSX identifier (valid tag or attribute name).
  //
  // Optimized version since JSX identifiers can't contain
  // escape characters and so can be read as single slice.
  // Also assumes that first character was already checked
  // by isIdentifierStart in readToken.

  function readJSXWord() {
    var ch, start = tokPos;
    do {
      ch = input.charCodeAt(++tokPos);
    } while (isIdentifierChar(ch) || ch === 45); // '-'
    return finishToken(_jsxName, input.slice(start, tokPos));
  }

  // ## Parser

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts — that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary operator node.
  //
  // Acorn uses an [operator precedence parser][opp] to handle binary
  // operator precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

  // ### Parser utilities

  // Continue to the next token.

  function next() {
    if (options.onToken)
      options.onToken(new Token());

    lastStart = tokStart;
    lastEnd = tokEnd;
    lastEndLoc = tokEndLoc;
    readToken();
  }

  // Enter strict mode. Re-reads the next number or string to
  // please pedantic tests ("use strict"; 010; -- should fail).

  function setStrict(strct) {
    strict = strct;
    if (tokType !== _num && tokType !== _string) return;
    tokPos = tokStart;
    if (options.locations) {
      while (tokPos < tokLineStart) {
        tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
        --tokCurLine;
      }
    }
    skipSpace();
    readToken();
  }

  // Start an AST node, attaching a start offset.

  function Node() {
    this.type = null;
    this.start = tokStart;
    this.end = null;
  }
  
  exports.Node = Node;

  function SourceLocation() {
    this.start = tokStartLoc;
    this.end = null;
    if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
    var node = new exports.Node();
    if (options.locations)
      node.loc = new SourceLocation();
    if (options.directSourceFile)
      node.sourceFile = options.directSourceFile;
    if (options.ranges)
      node.range = [tokStart, 0];
    return node;
  }

  // Sometimes, a node is only started *after* the token stream passed
  // its start position. The functions below help storing a position
  // and creating a node from a previous position.

  function storeCurrentPos() {
    return options.locations ? [tokStart, tokStartLoc] : tokStart;
  }

  function startNodeAt(pos) {
    var node = new exports.Node(), start = pos;
    if (options.locations) {
      node.loc = new SourceLocation();
      node.loc.start = start[1];
      start = pos[0];
    }
    node.start = start;
    if (options.directSourceFile)
      node.sourceFile = options.directSourceFile;
    if (options.ranges)
      node.range = [start, 0];

    return node;
  }

  // Finish an AST node, adding `type` and `end` properties.

  function finishNode(node, type) {
    node.type = type;
    node.end = lastEnd;
    if (options.locations)
      node.loc.end = lastEndLoc;
    if (options.ranges)
      node.range[1] = lastEnd;
    return node;
  }

  // Finish node at given position

  function finishNodeAt(node, type, pos) {
    if (options.locations) { node.loc.end = pos[1]; pos = pos[0]; }
    node.type = type;
    node.end = pos;
    if (options.ranges)
      node.range[1] = pos;
    return node;
  }

  // Test whether a statement node is the string literal `"use strict"`.

  function isUseStrict(stmt) {
    return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
      stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  function eat(type) {
    if (tokType === type) {
      next();
      return true;
    } else {
      return false;
    }
  }

  // Tests whether parsed token is a contextual keyword.

  function isContextual(name) {
    return tokType === _name && tokVal === name;
  }

  // Consumes contextual keyword if possible.

  function eatContextual(name) {
    return tokVal === name && eat(_name);
  }

  // Asserts that following token is given contextual keyword.

  function expectContextual(name) {
    if (!eatContextual(name)) unexpected();
  }

  // Test whether a semicolon can be inserted at the current position.

  function canInsertSemicolon() {
    return !options.strictSemicolons &&
      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  function semicolon() {
    if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  function expect(type) {
    eat(type) || unexpected();
  }

  // Get following char.

  function nextChar() {
    return input.charAt(tokPos);
  }

  // Raise an unexpected token error.

  function unexpected(pos) {
    raise(pos != null ? pos : tokStart, "Unexpected token");
  }

  // Checks if hash object has a property.

  function has(obj, propName) {
    return Object.prototype.hasOwnProperty.call(obj, propName);
  }

  // Convert existing expression atom to assignable pattern
  // if possible.

  function toAssignable(node, isBinding) {
    if (options.ecmaVersion >= 6 && node) {
      switch (node.type) {
        case "Identifier":
        case "VirtualPropertyExpression":
        case "MemberExpression":
        case "SpreadProperty":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (var i = 0; i < node.properties.length; i++) {
            var prop = node.properties[i];
            if (prop.type === "SpreadProperty") continue;
            
            if (prop.kind !== "init") raise(prop.key.start, "Object pattern can't contain getter or setter");
            toAssignable(prop.value, isBinding);
          }
          break;

        case "ArrayExpression":
          node.type = "ArrayPattern";
          toAssignableList(node.elements, isBinding);
          break;

        case "AssignmentExpression":
          if (node.operator === "=") {
            node.type = "AssignmentPattern";
          } else {
            raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          }
          break;

        case "MemberExpression":
          if (!isBinding) break;

        default:
          raise(node.start, "Assigning to rvalue");
      }
    }
    return node;
  }

  // Convert list of expression atoms to binding list.

  function toAssignableList(exprList, isBinding) {
    if (exprList.length) {
      for (var i = 0; i < exprList.length - 1; i++) {
        toAssignable(exprList[i], isBinding);
      }
      var last = exprList[exprList.length - 1];
      switch (last.type) {
        case "RestElement":
          break;
        case "SpreadElement":
          last.type = "RestElement";
          var arg = last.argument;
          toAssignable(arg, isBinding);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
            unexpected(arg.start);
          break;
        default:
          toAssignable(last, isBinding);
      }
    }
    return exprList;
  }

  // Parses spread element.

  function parseSpread(refShorthandDefaultPos) {
    var node = startNode();
    next();
    node.argument = parseMaybeAssign(refShorthandDefaultPos);
    return finishNode(node, "SpreadElement");
  }

  function parseRest() {
    var node = startNode();
    next();
    node.argument = tokType === _name || tokType === _bracketL ? parseBindingAtom() : unexpected();
    return finishNode(node, "RestElement");
  }

  // Parses lvalue (assignable) atom.

  function parseBindingAtom() {
    if (options.ecmaVersion < 6) return parseIdent();
    switch (tokType) {
      case _name:
        return parseIdent();

      case _bracketL:
        var node = startNode();
        next();
        node.elements = parseBindingList(_bracketR, true);
        return finishNode(node, "ArrayPattern");

      case _braceL:
        return parseObj(true);

      default:
        unexpected();
    }
  }

  function parseBindingList(close, allowEmpty) {
    var elts = [], first = true;
    while (!eat(close)) {
      first ? first = false : expect(_comma);
      if (tokType === _ellipsis) {
        elts.push(parseAssignableListItemTypes(parseRest()));
        expect(close);
        break;
      }
      var elem;
      if (allowEmpty && tokType === _comma) {
        elem = null;
      } else {
        var left = parseMaybeDefault();
        parseAssignableListItemTypes(left);
        elem = parseMaybeDefault(null, left);
      }
      elts.push(elem);
    }
    return elts;
  }

  function parseAssignableListItemTypes(param) {
    if (eat(_question)) {
      param.optional = true;
    }
    if (tokType === _colon) {
      param.typeAnnotation = parseTypeAnnotation();
    }
    finishNode(param, param.type);
    return param;
  }

  // Parses assignment pattern around given atom if possible.

  function parseMaybeDefault(startPos, left) {
    startPos = startPos || storeCurrentPos();
    left = left || parseBindingAtom();
    if (!eat(_eq)) return left;
    var node = startNodeAt(startPos);
    node.operator = "=";
    node.left = left;
    node.right = parseMaybeAssign();
    return finishNode(node, "AssignmentPattern");
  }

  // Verify that argument names are not repeated, and it does not
  // try to bind the words `eval` or `arguments`.

  function checkFunctionParam(param, nameHash) {
    switch (param.type) {
      case "Identifier":
        if (isStrictReservedWord(param.name) || isStrictBadIdWord(param.name))
          raise(param.start, "Defining '" + param.name + "' in strict mode");
        if (has(nameHash, param.name))
          raise(param.start, "Argument name clash in strict mode");
        nameHash[param.name] = true;
        break;

      case "ObjectPattern":
        for (var i = 0; i < param.properties.length; i++) {
          var param2 = param.properties[i];
          if (param2.type === "SpreadProperty") {
            checkFunctionParam(param2.argument, nameHash);
          } else {
            checkFunctionParam(param2.value, nameHash);
          }
        }
        break;

      case "ArrayPattern":
        for (var i = 0; i < param.elements.length; i++) {
          var elem = param.elements[i];
          if (elem) checkFunctionParam(elem, nameHash);
        }
        break;

      case "RestElement":
        return checkFunctionParam(param.argument, nameHash);
    }
  }

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  function checkPropClash(prop, propHash) {
    if (options.ecmaVersion >= 6) return;
    var key = prop.key, name;
    switch (key.type) {
      case "Identifier": name = key.name; break;
      case "Literal": name = String(key.value); break;
      default: return;
    }
    var kind = prop.kind || "init", other;
    if (has(propHash, name)) {
      other = propHash[name];
      var isGetSet = kind !== "init";
      if ((strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
        raise(key.start, "Redefinition of property");
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  }

  // Verify that a node is an lval — something that can be assigned
  // to.

  function checkLVal(expr, isBinding) {
    switch (expr.type) {
      case "Identifier":
        if (strict && (isStrictBadIdWord(expr.name) || isStrictReservedWord(expr.name)))
          raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        break;
      
      case "MemberExpression":
        if (isBinding) raise(expr.start, "Binding to member expression");
        break;

      case "ObjectPattern":
        for (var i = 0; i < expr.properties.length; i++) {
          var prop = expr.properties[i];
          if (prop.type === "Property") prop = prop.value;
          checkLVal(prop, isBinding);
        }
        break;

      case "ArrayPattern":
        for (var i = 0; i < expr.elements.length; i++) {
          var elem = expr.elements[i];
          if (elem) checkLVal(elem, isBinding);
        }
        break;

      case "AssignmentPattern":
        checkLVal(expr.left);
        break;

      case "SpreadProperty":
      case "VirtualPropertyExpression":
        break;

      case "RestElement":
        checkLVal(expr.argument);
        break;

      default:
      raise(expr.start, "Assigning to rvalue");
  }
  }

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new exports.Node.

  function parseTopLevel(node) {
    var first = true;
    if (!node.body) node.body = [];
    while (tokType !== _eof) {
      var stmt = parseStatement(true, true);
      node.body.push(stmt);
      if (first && isUseStrict(stmt)) setStrict(true);
      first = false;
    }

    next();
    return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
  // does not help.

  function parseStatement(declaration, topLevel) {
    var starttype = tokType, node = startNode();

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case _break: case _continue: return parseBreakContinueStatement(node, starttype.keyword);
    case _debugger: return parseDebuggerStatement(node);
    case _do: return parseDoStatement(node);
    case _for: return parseForStatement(node);
    case _function:
      if (!declaration && options.ecmaVersion >= 6) unexpected();
      return parseFunctionStatement(node);
    case _class:
      if (!declaration) unexpected();
      return parseClass(node, true);
    case _if: return parseIfStatement(node);
    case _return: return parseReturnStatement(node);
    case _switch: return parseSwitchStatement(node);
    case _throw: return parseThrowStatement(node);
    case _try: return parseTryStatement(node);
    case _let: case _const: if (!declaration) unexpected(); // NOTE: falls through to _var
    case _var: return parseVarStatement(node, starttype.keyword);
    case _while: return parseWhileStatement(node);
    case _with: return parseWithStatement(node);
    case _braceL: return parseBlock(); // no point creating a function for this
    case _semi: return parseEmptyStatement(node);
    case _export:
    case _import:
      if (!topLevel && !options.allowImportExportEverywhere)
        raise(tokStart, "'import' and 'export' may only appear at the top level");
      return starttype === _import ? parseImport(node) : parseExport(node);

    case _name:
      if (options.ecmaVersion >= 7 && tokType === _name) {
        if (tokVal === "private") {
          next();
          return parsePrivate(node);
        }

        if (tokVal === "async") {
          // check to see if `function ` appears after this token, this is
          // pretty hacky
          if (input.slice(tokEnd + 1, tokEnd + 10) === "function ") {
            next();
            expect(_function);
            return parseFunction(node, true, true);
          }
        }
      }

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      var maybeName = tokVal, expr = parseExpression();

      if (starttype === _name && expr.type === "Identifier") {
        if (eat(_colon)) {
          return parseLabeledStatement(node, maybeName, expr);
        }

        if (expr.name === "declare") {
          if (tokType === _class || tokType === _name || tokType === _function || tokType === _var) {
            return parseDeclare(node);
          }
        } else if (tokType === _name) {
          if (expr.name === "interface") {
            return parseInterface(node);
          } else if (expr.name === "type") {
            return parseTypeAlias(node);
          }
        }
      }

      return parseExpressionStatement(node, expr);
    }
  }
  
  function parseBreakContinueStatement(node, keyword) {
    var isBreak = keyword == "break";
    next();
    if (eat(_semi) || canInsertSemicolon()) node.label = null;
    else if (tokType !== _name) unexpected();
    else {
      node.label = parseIdent();
      semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    for (var i = 0; i < labels.length; ++i) {
      var lab = labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }
    if (i === labels.length) raise(node.start, "Unsyntactic " + keyword);
    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }
  
  function parseDebuggerStatement(node) {
    next();
    semicolon();
    return finishNode(node, "DebuggerStatement");
  }
  
  function parseDoStatement(node) {
    next();
    labels.push(loopLabel);
    node.body = parseStatement(false);
    labels.pop();
    expect(_while);
    node.test = parseParenExpression();
    if (options.ecmaVersion >= 6)
      eat(_semi);
    else
      semicolon();
    return finishNode(node, "DoWhileStatement");
  }
  
  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.
  
  function parseForStatement(node) {
    next();
    labels.push(loopLabel);
    expect(_parenL);
    if (tokType === _semi) return parseFor(node, null);
    if (tokType === _var || tokType === _let) {
      var init = startNode(), varKind = tokType.keyword, isLet = tokType === _let;
      next();
      parseVar(init, true, varKind);
      finishNode(init, "VariableDeclaration");
      if ((tokType === _in || (options.ecmaVersion >= 6 && isContextual("of"))) && init.declarations.length === 1 &&
          !(isLet && init.declarations[0].init))
        return parseForIn(node, init);
      return parseFor(node, init);
    }
    var refShorthandDefaultPos = {start: 0};
    var init = parseExpression(true, refShorthandDefaultPos);
    if (tokType === _in || (options.ecmaVersion >= 6 && isContextual("of"))) {
      toAssignable(init);
      checkLVal(init);
      return parseForIn(node, init);
    } else if (refShorthandDefaultPos.start) {
      unexpected(refShorthandDefaultPos.start);
    }
    return parseFor(node, init);
  }
  
  function parseFunctionStatement(node) {
    next();
    return parseFunction(node, true, false);
  }
  
  function parseIfStatement(node) {
    next();
    node.test = parseParenExpression();
    node.consequent = parseStatement(false);
    node.alternate = eat(_else) ? parseStatement(false) : null;
    return finishNode(node, "IfStatement");
  }
  
  function parseReturnStatement(node) {
    if (!inFunction && !options.allowReturnOutsideFunction)
      raise(tokStart, "'return' outside of function");
    next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (eat(_semi) || canInsertSemicolon()) node.argument = null;
    else { node.argument = parseExpression(); semicolon(); }
    return finishNode(node, "ReturnStatement");
  }
  
  function parseSwitchStatement(node) {
    next();
    node.discriminant = parseParenExpression();
    node.cases = [];
    expect(_braceL);
    labels.push(switchLabel);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    for (var cur, sawDefault; tokType != _braceR;) {
      if (tokType === _case || tokType === _default) {
        var isCase = tokType === _case;
        if (cur) finishNode(cur, "SwitchCase");
        node.cases.push(cur = startNode());
        cur.consequent = [];
        next();
        if (isCase) cur.test = parseExpression();
        else {
          if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
          cur.test = null;
        }
        expect(_colon);
      } else {
        if (!cur) unexpected();
        cur.consequent.push(parseStatement(true));
      }
    }
    if (cur) finishNode(cur, "SwitchCase");
    next(); // Closing brace
    labels.pop();
    return finishNode(node, "SwitchStatement");
  }
  
  function parseThrowStatement(node) {
    next();
    if (newline.test(input.slice(lastEnd, tokStart)))
      raise(lastEnd, "Illegal newline after throw");
    node.argument = parseExpression();
    semicolon();
    return finishNode(node, "ThrowStatement");
  }
  
  function parseTryStatement(node) {
    next();
    node.block = parseBlock();
    node.handler = null;
    if (tokType === _catch) {
      var clause = startNode();
      next();
      expect(_parenL);
      clause.param = parseBindingAtom();
      checkLVal(clause.param, true);
      expect(_parenR);
      clause.guard = null;
      clause.body = parseBlock();
      node.handler = finishNode(clause, "CatchClause");
    }
    node.guardedHandlers = empty;
    node.finalizer = eat(_finally) ? parseBlock() : null;
    if (!node.handler && !node.finalizer)
      raise(node.start, "Missing catch or finally clause");
    return finishNode(node, "TryStatement");
  }
  
  function parseVarStatement(node, kind) {
    next();
    parseVar(node, false, kind);
    semicolon();
    return finishNode(node, "VariableDeclaration");
  }
  
  function parseWhileStatement(node) {
    next();
    node.test = parseParenExpression();
    labels.push(loopLabel);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, "WhileStatement");
  }
  
  function parseWithStatement(node) {
    if (strict) raise(tokStart, "'with' in strict mode");
    next();
    node.object = parseParenExpression();
    node.body = parseStatement(false);
    return finishNode(node, "WithStatement");
  }
  
  function parseEmptyStatement(node) {
    next();
    return finishNode(node, "EmptyStatement");
  }
  
  function parseLabeledStatement(node, maybeName, expr) {
    for (var i = 0; i < labels.length; ++i)
      if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
    var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
    labels.push({name: maybeName, kind: kind});
    node.body = parseStatement(true);
    labels.pop();
    node.label = expr;
    return finishNode(node, "LabeledStatement");
  }
  
  function parseExpressionStatement(node, expr) {
    node.expression = expr;
    semicolon();
    return finishNode(node, "ExpressionStatement");
  }

  // Used for constructs like `switch` and `if` that insist on
  // parentheses around their expression.

  function parseParenExpression() {
    expect(_parenL);
    var val = parseExpression();
    expect(_parenR);
    return val;
  }

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  function parseBlock(allowStrict) {
    var node = startNode(), first = true, oldStrict;
    node.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      var stmt = parseStatement(true);
      node.body.push(stmt);
      if (first && allowStrict && isUseStrict(stmt)) {
        oldStrict = strict;
        setStrict(strict = true);
      }
      first = false;
    }
    if (oldStrict === false) setStrict(false);
    return finishNode(node, "BlockStatement");
  }

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  function parseFor(node, init) {
    node.init = init;
    expect(_semi);
    node.test = tokType === _semi ? null : parseExpression();
    expect(_semi);
    node.update = tokType === _parenR ? null : parseExpression();
    expect(_parenR);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, "ForStatement");
  }

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  function parseForIn(node, init) {
    var type = tokType === _in ? "ForInStatement" : "ForOfStatement";
    next();
    node.left = init;
    node.right = parseExpression();
    expect(_parenR);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, type);
  }

  // Parse a list of variable declarations.

  function parseVar(node, noIn, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = startNode();
      decl.id = parseBindingAtom();
      checkLVal(decl.id, true);

      if (tokType === _colon) {
        decl.id.typeAnnotation = parseTypeAnnotation();
        finishNode(decl.id, decl.id.type);
      }

      decl.init = eat(_eq) ? parseMaybeAssign(noIn) : (kind === _const.keyword ? unexpected() : null);
      node.declarations.push(finishNode(decl, "VariableDeclarator"));
      if (!eat(_comma)) break;
    }
    return node;
  }

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  function parseExpression(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseMaybeAssign(noIn, refShorthandDefaultPos);
    if (tokType === _comma) {
      var node = startNodeAt(start);
      node.expressions = [expr];
      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn, refShorthandDefaultPos));
      return finishNode(node, "SequenceExpression");
    }
    return expr;
  }

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse) {
    var failOnShorthandAssign;
    if (!refShorthandDefaultPos) {
      refShorthandDefaultPos = {start: 0};
      failOnShorthandAssign = true;
    } else {
      failOnShorthandAssign = false;
    }
    var start = storeCurrentPos();
    var left = parseMaybeConditional(noIn, refShorthandDefaultPos);
    if (afterLeftParse) left = afterLeftParse(left, start);
    if (tokType.isAssign) {
      var node = startNodeAt(start);
      node.operator = tokVal;
      node.left = tokType === _eq ? toAssignable(left) : left;
      refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
      checkLVal(left);
      next();
      node.right = parseMaybeAssign(noIn);
      return finishNode(node, "AssignmentExpression");
    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
      unexpected(refShorthandDefaultPos.start);
    }
    return left;
  }

  // Parse a ternary conditional (`?:`) operator.

  function parseMaybeConditional(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseExprOps(noIn, refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    if (eat(_question)) {
      var node = startNodeAt(start);
      if (options.playground && eat(_eq)) {
        var left = node.left = toAssignable(expr);
        if (left.type !== "MemberExpression") raise(left.start, "You can only use member expressions in memoization assignment");
        node.right = parseMaybeAssign(noIn);
        node.operator = "?=";
        return finishNode(node, "AssignmentExpression");
      }
      node.test = expr;
      node.consequent = parseMaybeAssign();
      expect(_colon);
      node.alternate = parseMaybeAssign(noIn);
      return finishNode(node, "ConditionalExpression");
    }
    return expr;
  }

  // Start the precedence parser.

  function parseExprOps(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseMaybeUnary(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return parseExprOp(expr, start, -1, noIn);
  }

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  function parseExprOp(left, leftStart, minPrec, noIn) {
    var prec = tokType.binop;
    if (prec != null && (!noIn || tokType !== _in)) {
      if (prec > minPrec) {
        var node = startNodeAt(leftStart);
        node.left = left;
        node.operator = tokVal;
        var op = tokType;
        next();
        var start = storeCurrentPos();
        node.right = parseExprOp(parseMaybeUnary(), start, op.rightAssociative ? (prec - 1) : prec, noIn);
        finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
        return parseExprOp(node, leftStart, minPrec, noIn);
      }
    }
    return left;
  }

  // Parse unary operators, both prefix and postfix.

  function parseMaybeUnary(refShorthandDefaultPos) {
    if (tokType.prefix) {
      var node = startNode(), update = tokType.isUpdate;
      node.operator = tokVal;
      node.prefix = true;
      next();
      node.argument = parseMaybeUnary();
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) unexpected(refShorthandDefaultPos.start);
      if (update) checkLVal(node.argument);
      else if (strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        raise(node.start, "Deleting local variable in strict mode");
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var start = storeCurrentPos();
    var expr = parseExprSubscripts(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    while (tokType.postfix && !canInsertSemicolon()) {
      var node = startNodeAt(start);
      node.operator = tokVal;
      node.prefix = false;
      node.argument = expr;
      checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  // Parse call, dot, and `[]`-subscript expressions.

  function parseExprSubscripts(refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseExprAtom(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return parseSubscripts(expr, start);
  }

  function parseSubscripts(base, start, noCalls) {
    if (options.playground && eat(_hash)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      if (eat(_parenL)) {
        node.arguments = parseExprList(_parenR, false);
      } else {
        node.arguments = [];
      }
      return parseSubscripts(finishNode(node, "BindMemberExpression"), start, noCalls);
    } else if (eat(_paamayimNekudotayim)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      return parseSubscripts(finishNode(node, "VirtualPropertyExpression"), start, noCalls);
    } else if (eat(_dot)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      node.computed = false;
      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
    } else if (eat(_bracketL)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseExpression();
      node.computed = true;
      expect(_bracketR);
      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
    } else if (!noCalls && eat(_parenL)) {
      var node = startNodeAt(start);
      node.callee = base;
      node.arguments = parseExprList(_parenR, false);
      return parseSubscripts(finishNode(node, "CallExpression"), start, noCalls);
    } else if (tokType === _backQuote) {
      var node = startNodeAt(start);
      node.tag = base;
      node.quasi = parseTemplate();
      return parseSubscripts(finishNode(node, "TaggedTemplateExpression"), start, noCalls);
    } return base;
  }

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  function parseExprAtom(refShorthandDefaultPos) {
    switch (tokType) {
    case _this:
      var node = startNode();
      next();
      return finishNode(node, "ThisExpression");
    
    case _yield:
      if (inGenerator) return parseYield();

    case _name:
      var start = storeCurrentPos();
      var node = startNode();
      var id = parseIdent(tokType !== _name);

      if (options.ecmaVersion >= 7) {
        // async functions!
        if (id.name === "async") {
          // arrow functions
          if (tokType === _parenL) {
            var expr = parseParenAndDistinguishExpression(start, true);
            if (expr.type === "ArrowFunctionExpression") {
              return expr;
            } else {
              node.callee = id;
              if (expr.type === "SequenceExpression") {
                node.arguments = expr.expressions;
              } else {
                node.arguments = [expr];
              }
              return parseSubscripts(finishNode(node, "CallExpression"), start);
            }
          } else if (tokType === _name) {
            id = parseIdent();
            expect(_arrow);
            return parseArrowExpression(node, [id], true);
          }

          // normal functions
          if (tokType === _function && !canInsertSemicolon()) {
            next();
            return parseFunction(node, false, true);
          }
        } else if (id.name === "await") {
          if (inAsync) return parseAwait(node);
        }
      }

      if (!canInsertSemicolon() && eat(_arrow)) {
        return parseArrowExpression(startNodeAt(start), [id]);
      }
      return id;
      
    case _regexp:
      var node = startNode();
      node.regex = {pattern: tokVal.pattern, flags: tokVal.flags};
      node.value = tokVal.value;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _num: case _string: case _jsxText:
      var node = startNode();
      node.value = tokVal;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _null: case _true: case _false:
      var node = startNode();
      node.value = tokType.atomValue;
      node.raw = tokType.keyword;
      next();
      return finishNode(node, "Literal");

    case _parenL:
      return parseParenAndDistinguishExpression();

    case _bracketL:
      var node = startNode();
      next();
      // check whether this is array comprehension or regular array
      if (options.ecmaVersion >= 7 && tokType === _for) {
        return parseComprehension(node, false);
      }
      node.elements = parseExprList(_bracketR, true, true, refShorthandDefaultPos);
      return finishNode(node, "ArrayExpression");

    case _braceL:
      return parseObj(false, refShorthandDefaultPos);

    case _function:
      var node = startNode();
      next();
      return parseFunction(node, false, false);

    case _class:
      return parseClass(startNode(), false);

    case _new:
      return parseNew();

    case _backQuote:
      return parseTemplate();

    case _hash:
      return parseBindFunctionExpression();

    case _jsxTagStart:
      return parseJSXElement();

    default:
      unexpected();
    }
  }

  function parseBindFunctionExpression() {
    var node = startNode();
    next();

    var start = storeCurrentPos();
    node.callee = parseSubscripts(parseExprAtom(), start, true);

    if (eat(_parenL)) {
      node.arguments = parseExprList(_parenR, false);
    } else {
      node.arguments = [];
    }

    return finishNode(node, "BindFunctionExpression");
  }

  function parseParenAndDistinguishExpression(start, isAsync) {
    start = start || storeCurrentPos();
    var val;
    if (options.ecmaVersion >= 6) {
      next();

      if (options.ecmaVersion >= 7 && tokType === _for) {
        return parseComprehension(startNodeAt(start), true);
      }

      var innerStart = storeCurrentPos(), exprList = [], first = true;
      var refShorthandDefaultPos = {start: 0}, spreadStart, innerParenStart, typeStart;

      var parseParenItem = function (node, start) {
        if (tokType === _colon) {
          var typeCastNode = startNodeAt(start);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = parseTypeAnnotation();
          return finishNode(typeCastNode, "TypeCastExpression");
        } else {
          return node;
        }
      };

      while (tokType !== _parenR) {
        first ? first = false : expect(_comma);
        if (tokType === _ellipsis) {
          var spreadNodeStart = storeCurrentPos();
          spreadStart = tokStart;
          exprList.push(parseParenItem(parseRest(), spreadNodeStart));
          break;
        } else {
          if (tokType === _parenL && !innerParenStart) {
            innerParenStart = tokStart;
          }
          exprList.push(parseMaybeAssign(false, refShorthandDefaultPos, parseParenItem));
        }
      }
      var innerEnd = storeCurrentPos();
      expect(_parenR);

      if (!canInsertSemicolon() && eat(_arrow)) {
        if (innerParenStart) unexpected(innerParenStart);

        for (var i = 0; i < exprList.length; i++) {
          var listItem = exprList[i];
          if (listItem.type === "TypeCastExpression") {
            var expr = listItem.expression;
            expr.returnType = listItem.typeAnnotation;
            exprList[i] = expr;
          }
        }

        return parseArrowExpression(startNodeAt(start), exprList, isAsync);
      }

      if (!exprList.length) unexpected(lastStart);
      if (spreadStart) unexpected(spreadStart);
      if (refShorthandDefaultPos.start) unexpected(refShorthandDefaultPos.start);

      //

      if (exprList.length > 1) {
        val = startNodeAt(innerStart);
        val.expressions = exprList;
        finishNodeAt(val, "SequenceExpression", innerEnd);
      } else {
        val = exprList[0];
      }
    } else {
      val = parseParenExpression();
    }

    if (options.preserveParens) {
      var par = startNodeAt(start);
      par.expression = val;
      return finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  }

  // New's precedence is slightly tricky. It must allow its argument
  // to be a `[]` or dot subscript expression, but not a call — at
  // least, not without wrapping it in parentheses. Thus, it uses the

  function parseNew() {
    var node = startNode();
    next();
    var start = storeCurrentPos();
    node.callee = parseSubscripts(parseExprAtom(), start, true);
    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
    else node.arguments = empty;
    return finishNode(node, "NewExpression");
  }

  // Parse template expression.

  function parseTemplateElement() {
    var elem = startNode();
    elem.value = {
      raw: input.slice(tokStart, tokEnd),
      cooked: tokVal
    };
    next();
    elem.tail = tokType === _backQuote;
    return finishNode(elem, "TemplateElement");
  }

  function parseTemplate() {
    var node = startNode();
    next();
    node.expressions = [];
    var curElt = parseTemplateElement();
    node.quasis = [curElt];
    while (!curElt.tail) {
      expect(_dollarBraceL);
      node.expressions.push(parseExpression());
      expect(_braceR);
      node.quasis.push(curElt = parseTemplateElement());
    }
    next();
    return finishNode(node, "TemplateLiteral");
  }

  // Parse an object literal or binding pattern.

  function parseObj(isPattern, refShorthandDefaultPos) {
    var node = startNode(), first = true, propHash = {};
    node.properties = [];
    next();
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var prop = startNode(), start, isGenerator = false, isAsync = false;
      if (options.ecmaVersion >= 7 && tokType === _ellipsis) {
        prop = parseSpread();
        prop.type = "SpreadProperty";
        node.properties.push(prop);
        continue;
      }
      if (options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refShorthandDefaultPos) {
          start = storeCurrentPos();
        }
        if (!isPattern) {
          isGenerator = eat(_star);
        }
      }
      if (options.ecmaVersion >= 7 && isContextual("async")) {
        var asyncId = parseIdent();
        if (tokType === _colon || tokType === _parenL) {
          prop.key = asyncId;
        } else {
          isAsync = true;
          parsePropertyName(prop);
        }
      } else {
        parsePropertyName(prop);
      }
      var typeParameters
      if (isRelational("<")) {
        typeParameters = parseTypeParameterDeclaration();
        if (tokType !== _parenL) unexpected();
      }
      if (eat(_colon)) {
        prop.value = isPattern ? parseMaybeDefault() : parseMaybeAssign(false, refShorthandDefaultPos);
        prop.kind = "init";
      } else if (options.ecmaVersion >= 6 && tokType === _parenL) {
        if (isPattern) unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = parseMethod(isGenerator, isAsync);
      } else if (options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set" || (options.playground && prop.key.name === "memo")) &&
                 (tokType != _comma && tokType != _braceR)) {
        if (isGenerator || isAsync || isPattern) unexpected();
        prop.kind = prop.key.name;
        parsePropertyName(prop);
        prop.value = parseMethod(false, false);
      } else if (options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        prop.kind = "init";
        if (isPattern) {
          prop.value = parseMaybeDefault(start, prop.key);
        } else if (tokType === _eq && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start)
            refShorthandDefaultPos.start = tokStart;
          prop.value = parseMaybeDefault(start, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else unexpected();

      prop.value.typeParameters = typeParameters;
      checkPropClash(prop, propHash);
      node.properties.push(finishNode(prop, "Property"));
    }
    return finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  }

  function parsePropertyName(prop) {
    if (options.ecmaVersion >= 6) {
      if (eat(_bracketL)) {
        prop.computed = true;
        prop.key = parseExpression();
        expect(_bracketR);
        return;
      } else {
        prop.computed = false;
      }
    }
    prop.key = (tokType === _num || tokType === _string) ? parseExprAtom() : parseIdent(true);
  }

  // Initialize empty function node.

  function initFunction(node, isAsync) {
    node.id = null;
    if (options.ecmaVersion >= 6) {
      node.generator = false;
      node.expression = false;
    }
    if (options.ecmaVersion >= 7) {
      node.async = isAsync;
    }
  }

  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).

  function parseFunction(node, isStatement, isAsync, allowExpressionBody) {
    initFunction(node, isAsync);
    if (options.ecmaVersion >= 6) {
      node.generator = eat(_star);
    }
    if (isStatement || tokType === _name) {
      node.id = parseIdent();
    }
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }
    parseFunctionParams(node);
    parseFunctionBody(node, allowExpressionBody);
    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  // Parse object or class method.

  function parseMethod(isGenerator, isAsync) {
    var node = startNode();
    initFunction(node, isAsync);
    parseFunctionParams(node);
    var allowExpressionBody;
    if (options.ecmaVersion >= 6) {
      node.generator = isGenerator;
      allowExpressionBody = true;
    } else {
      allowExpressionBody = false;
    }
    parseFunctionBody(node, allowExpressionBody);
    return finishNode(node, "FunctionExpression");
  }

  function parseFunctionParams(node) {
    expect(_parenL);
    node.params = parseBindingList(_parenR, false);
    if (tokType === _colon) {
      node.returnType = parseTypeAnnotation();
    }
  }

  // Parse arrow function expression with given parameters.

  function parseArrowExpression(node, params, isAsync) {
    initFunction(node, isAsync);
    node.params = toAssignableList(params, true);
    parseFunctionBody(node, true);
    return finishNode(node, "ArrowFunctionExpression");
  }

  // Parse function body and check parameters.

  function parseFunctionBody(node, allowExpression) {
    var isExpression = allowExpression && tokType !== _braceL;

    var oldInAsync = inAsync;
    inAsync = node.async;
    if (isExpression) {
      node.body = parseMaybeAssign();
      node.expression = true;
    } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
      var oldInFunc = inFunction, oldInGen = inGenerator, oldLabels = labels;
      inFunction = true; inGenerator = node.generator; labels = [];
      node.body = parseBlock(true);
      node.expression = false;
      inFunction = oldInFunc; inGenerator = oldInGen; labels = oldLabels;
    }
    inAsync = oldInAsync;

    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (strict || !isExpression && node.body.body.length && isUseStrict(node.body.body[0])) {
      var nameHash = {};
      if (node.id)
        checkFunctionParam(node.id, {});
      for (var i = 0; i < node.params.length; i++)
        checkFunctionParam(node.params[i], nameHash);
    }
  }

  function parsePrivate(node) {
    node.declarations = [];
    do {
      node.declarations.push(parseIdent());
    } while (eat(_comma));
    semicolon();
    return finishNode(node, "PrivateDeclaration");
  }

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).
  
  function parseClass(node, isStatement) {
    next();
    node.id = tokType === _name ? parseIdent() : isStatement ? unexpected() : null;
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }
    node.superClass = eat(_extends) ? parseExprSubscripts() : null;
    if (node.superClass && isRelational("<")) {
      node.superTypeParameters = parseTypeParameterInstantiation();
    }
    if (isContextual("implements")) {
      next();
      node.implements = parseClassImplements();
    }
    var classBody = startNode();
    classBody.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      if (eat(_semi)) continue;
      var method = startNode();
      if (options.ecmaVersion >= 7 && isContextual("private")) {
        next();
        classBody.body.push(parsePrivate(method));
        continue;
      }
      var isGenerator = eat(_star);
      var isAsync = false;
      parsePropertyName(method);
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          method.key.name === "static") {
        if (isGenerator || isAsync) unexpected();
        method['static'] = true;
        isGenerator = eat(_star);
        parsePropertyName(method);
      } else {
        method['static'] = false;
      }
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          method.key.name === "async") {
        isAsync = true;
        parsePropertyName(method);
      }
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          (method.key.name === "get" || method.key.name === "set") || (options.playground && method.key.name === "memo")) {
        if (isGenerator || isAsync) unexpected();
        method.kind = method.key.name;
        parsePropertyName(method);
      } else {
        method.kind = "";
      }

      var classProperty = false;

      if (tokType === _colon) {
        method.typeAnnotation = parseTypeAnnotation();
        classProperty = true;
      }

      if (options.playground && eat(_eq)) {
        method.value = parseMaybeAssign();
        classProperty = true;
      }

      if (classProperty) {
        semicolon();
        classBody.body.push(finishNode(method, "ClassProperty"));
      } else {
        var typeParameters;
        if (isRelational("<")) {
          typeParameters = parseTypeParameterDeclaration();
        }
        method.value = parseMethod(isGenerator, isAsync);
        method.value.typeParameters = typeParameters;
        classBody.body.push(finishNode(method, "MethodDefinition"));
        eat(_semi);
      }
    }
    node.body = finishNode(classBody, "ClassBody");
    return finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }

  function parseClassImplements() {
      var implemented = [];

      do {
        var node = startNode();
        node.id = parseIdent();
        if (isRelational("<")) {
            node.typeParameters = parseTypeParameterInstantiation();
        } else {
            node.typeParameters = null;
        }
        implemented.push(finishNode(node, "ClassImplements"));
      } while(eat(_comma));

      return implemented;
  }

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  function parseExprList(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
    var elts = [], first = true;
    while (!eat(close)) {
      if (!first) {
        expect(_comma);
        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
      } else first = false;

      if (allowEmpty && tokType === _comma) {
        elts.push(null);
      } else {
        if (tokType === _ellipsis)
          elts.push(parseSpread(refShorthandDefaultPos));
        else
          elts.push(parseMaybeAssign(false, refShorthandDefaultPos));
      }
    }
    return elts;
  }

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  function parseIdent(liberal) {
    var node = startNode();
    if (liberal && options.forbidReserved == "everywhere") liberal = false;
    if (tokType === _name) {
      if (!liberal &&
          (options.forbidReserved &&
           (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
           strict && isStrictReservedWord(tokVal)) &&
          input.slice(tokStart, tokEnd).indexOf("\\") == -1)
        raise(tokStart, "The keyword '" + tokVal + "' is reserved");
      node.name = tokVal;
    } else if (liberal && tokType.keyword) {
      node.name = tokType.keyword;
    } else {
      unexpected();
    }
    next();
    return finishNode(node, "Identifier");
  }

  // Parses module export declaration.

  function parseExport(node) {
    next();
    // export var|const|let|function|class ...;
    if (tokType === _var || tokType === _const || tokType === _let || tokType === _function || tokType === _class || isContextual("async") || isContextual("type")) {
      node.declaration = parseStatement(true);
      node['default'] = false;
      node.specifiers = null;
      node.source = null;
    } else
    // export default ...;
    if (eat(_default)) {
      var expr = parseMaybeAssign();
      if (expr.id) {
        switch (expr.type) {
          case "FunctionExpression": expr.type = "FunctionDeclaration"; break;
          case "ClassExpression": expr.type = "ClassDeclaration"; break;
        }
      }
      node.declaration = expr;
      node['default'] = true;
      node.specifiers = null;
      node.source = null;
      semicolon();
    } else {
      // export * from '...';
      // export { x, y as z } [from '...'];
      var isBatch = tokType === _star;
      node.declaration = null;
      node['default'] = false;
      node.specifiers = parseExportSpecifiers();
      if (eatContextual("from")) {
        node.source = tokType === _string ? parseExprAtom() : unexpected();
      } else {
        if (isBatch) unexpected();
        node.source = null;
      }
      semicolon();
    }
    return finishNode(node, "ExportDeclaration");
  }

  // Parses a comma-separated list of module exports.

  function parseExportSpecifiers() {
    var nodes = [], first = true;
    if (tokType === _star) {
      // export * from '...'
      var node = startNode();
      next();
      nodes.push(finishNode(node, "ExportBatchSpecifier"));
    } else {
      // export { x, y as z } [from '...']
      expect(_braceL);
      while (!eat(_braceR)) {
        if (!first) {
          expect(_comma);
          if (options.allowTrailingCommas && eat(_braceR)) break;
        } else first = false;

        var node = startNode();
        node.id = parseIdent(tokType === _default);
        node.name = eatContextual("as") ? parseIdent(true) : null;
        nodes.push(finishNode(node, "ExportSpecifier"));
      }
    }
    return nodes;
  }

  // Parses import declaration.

  function parseImport(node) {
    next();
    
    node.isType = false;
    node.specifiers = [];

    var typeId;
    if (isContextual('type')) {
      var start = storeCurrentPos();
      typeId = parseIdent();
      if ((tokType === _name && tokVal !== "from") || tokType === _braceL || tokType === _star) {
        node.isType = true;
      } else {
        node.specifiers.push(parseImportSpecifierDefault(typeId, start));
        eat(_comma);
      }
    }

    
    // import '...';
    if (tokType === _string) {
      if (typeId) unexpected(typeId.start);
      node.source = parseExprAtom();
    } else {
      if (!isContextual("from")) parseImportSpecifiers(node.specifiers);
      expectContextual("from");
      node.source = tokType === _string ? parseExprAtom() : unexpected();
    }
    semicolon();
    return finishNode(node, "ImportDeclaration");
  }

  // Parses a comma-separated list of module imports.

  function parseImportSpecifiers(nodes) {
    var first = true;
    if (tokType === _name) {
      // import defaultObj, { x, y as z } from '...'
      var start = storeCurrentPos();
      var id = parseIdent();
      nodes.push(parseImportSpecifierDefault(id, start));
      if (!eat(_comma)) return nodes;
    }
    if (tokType === _star) {
      var node = startNode();
      next();
      expectContextual("as");
      node.name = parseIdent();
      checkLVal(node.name, true);
      nodes.push(finishNode(node, "ImportBatchSpecifier"));
      return nodes;
    }
    expect(_braceL);
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var node = startNode();
      node.id = parseIdent(true);
      node.name = eatContextual("as") ? parseIdent() : null;
      checkLVal(node.name || node.id, true);
      node['default'] = false;
      nodes.push(finishNode(node, "ImportSpecifier"));
    }
    return nodes;
  }

  function parseImportSpecifierDefault(id, start) {
    var node = startNodeAt(start);
    node.id = id;
    checkLVal(node.id, true);
    node.name = null;
    node['default'] = true;
    return finishNode(node, "ImportSpecifier");
  }

  // Parses yield expression inside generator.

  function parseYield() {
    var node = startNode();
    next();
    if (eat(_semi) || canInsertSemicolon()) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = eat(_star);
      node.argument = parseMaybeAssign();
    }
    return finishNode(node, "YieldExpression");
  }

  // Parses await expression inside async function.

  function parseAwait(node) {
    if (eat(_semi) || canInsertSemicolon()) {
      unexpected();
    }
    node.all = eat(_star);
    node.argument = parseMaybeAssign(true);
    return finishNode(node, "AwaitExpression");
  }

  // Parses array and generator comprehensions.

  function parseComprehension(node, isGenerator) {
    node.blocks = [];
    while (tokType === _for) {
      var block = startNode();
      next();
      expect(_parenL);
      block.left = parseBindingAtom();
      checkLVal(block.left, true);
      expectContextual("of");
      block.right = parseExpression();
      expect(_parenR);
      node.blocks.push(finishNode(block, "ComprehensionBlock"));
    }
    node.filter = eat(_if) ? parseParenExpression() : null;
    node.body = parseExpression();
    expect(isGenerator ? _parenR : _bracketR);
    node.generator = isGenerator;
    return finishNode(node, "ComprehensionExpression");
  }

  // Transforms JSX element name to string.

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ':' + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return (
        getQualifiedJSXName(object.object) + '.' +
        getQualifiedJSXName(object.property)
      );
    }
  }

  // Parse next token as JSX identifier

  function parseJSXIdentifier() {
    var node = startNode();
    if (tokType === _jsxName) {
      node.name = tokVal;
    } else if (tokType.keyword) {
      node.name = tokType.keyword;
    } else {
      unexpected();
    }
    next();
    return finishNode(node, "JSXIdentifier");
  }

  // Parse namespaced identifier.

  function parseJSXNamespacedName() {
    var start = storeCurrentPos();
    var name = parseJSXIdentifier();
    if (!eat(_colon)) return name;
    var node = startNodeAt(start);
    node.namespace = name;
    node.name = parseJSXIdentifier();
    return finishNode(node, "JSXNamespacedName");
  }

  // Parses element name in any form - namespaced, member
  // or single identifier.

  function parseJSXElementName() {
    var start = storeCurrentPos();
    var node = parseJSXNamespacedName();
    while (eat(_dot)) {
      var newNode = startNodeAt(start);
      newNode.object = node;
      newNode.property = parseJSXIdentifier();
      node = finishNode(newNode, "JSXMemberExpression");
    }
    return node;
  }

  // Parses any type of JSX attribute value.

  function parseJSXAttributeValue() {
    switch (tokType) {
      case _braceL:
        var node = parseJSXExpressionContainer();
        if (node.expression.type === "JSXEmptyExpression") {
          raise(
            node.start,
              'JSX attributes must only be assigned a non-empty ' +
              'expression'
          );
        }
        return node;

      case _jsxTagStart:
        return parseJSXElement();

      case _jsxText:
      case _string:
        return parseExprAtom();

      default:
        raise(tokStart, "JSX value should be either an expression or a quoted JSX text");
    }
  }

  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
  // and so it should start at the end of last read token (left brace) and finish
  // at the beginning of the next one (right brace).

  function parseJSXEmptyExpression() {
    if (tokType !== _braceR) {
      unexpected();
    }

    var tmp;

    tmp = tokStart;
    tokStart = lastEnd;
    lastEnd = tmp;

    tmp = tokStartLoc;
    tokStartLoc = lastEndLoc;
    lastEndLoc = tmp;

    return finishNode(startNode(), "JSXEmptyExpression");
  }

  // Parses JSX expression enclosed into curly brackets.

  function parseJSXExpressionContainer() {
    var node = startNode();
    next();
    node.expression = tokType === _braceR ? parseJSXEmptyExpression() : parseExpression();
    expect(_braceR);
    return finishNode(node, "JSXExpressionContainer");
  }

  // Parses following JSX attribute name-value pair.

  function parseJSXAttribute() {
    var node = startNode();
    if (eat(_braceL)) {
      expect(_ellipsis);
      node.argument = parseMaybeAssign();
      expect(_braceR);
      return finishNode(node, "JSXSpreadAttribute");
    }
    node.name = parseJSXNamespacedName();
    node.value = eat(_eq) ? parseJSXAttributeValue() : null;
    return finishNode(node, "JSXAttribute");
  }

  // Parses JSX opening tag starting after '<'.

  function parseJSXOpeningElementAt(start) {
    var node = startNodeAt(start);
    node.attributes = [];
    node.name = parseJSXElementName();
    while (tokType !== _slash && tokType !== _jsxTagEnd) {
      node.attributes.push(parseJSXAttribute());
    }
    node.selfClosing = eat(_slash);
    expect(_jsxTagEnd);
    return finishNode(node, "JSXOpeningElement");
  }

  // Parses JSX closing tag starting after '</'.

  function parseJSXClosingElementAt(start) {
    var node = startNodeAt(start);
    node.name = parseJSXElementName();
    expect(_jsxTagEnd);
    return finishNode(node, "JSXClosingElement");
  }

  // Parses entire JSX element, including it's opening tag
  // (starting after '<'), attributes, contents and closing tag.

  function parseJSXElementAt(start) {
    var node = startNodeAt(start);
    var children = [];
    var openingElement = parseJSXOpeningElementAt(start);
    var closingElement = null;

    if (!openingElement.selfClosing) {
      contents:for (;;) {
        switch (tokType) {
          case _jsxTagStart:
            start = storeCurrentPos();
            next();
            if (eat(_slash)) {
              closingElement = parseJSXClosingElementAt(start);
              break contents;
            }
            children.push(parseJSXElementAt(start));
            break;

          case _jsxText:
            children.push(parseExprAtom());
            break;

          case _braceL:
            children.push(parseJSXExpressionContainer());
            break;

          default:
            unexpected();
        }
      }
      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
        raise(
          closingElement.start,
          "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
        );
      }
    }

    node.openingElement = openingElement;
    node.closingElement = closingElement;
    node.children = children;
    return finishNode(node, "JSXElement");
  }

  function isRelational(op) {
    return tokType === _relational && tokVal === op;
  }

  function expectRelational(op) {
    if (isRelational(op)) {
      next();
    } else {
      unexpected();
    }
  }

  // Parses entire JSX element from current position.

  function parseJSXElement() {
    var start = storeCurrentPos();
    next();
    return parseJSXElementAt(start);
  }

  // Declare
  
  function parseDeclareClass(node) {
    next();
    parseInterfaceish(node, true);
    return finishNode(node, "DeclareClass");
  }

  function parseDeclareFunction(node) {
    next();

    var id = node.id = parseIdent();

    var typeNode = startNode();
    var typeContainer = startNode();

    if (isRelational("<")) {
      typeNode.typeParameters = parseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }

    expect(_parenL);
    var tmp = parseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    expect(_parenR);

    expect(_colon);
    typeNode.returnType = parseType();

    typeContainer.typeAnnotation = finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = finishNode(typeContainer, "TypeAnnotation");

    finishNode(id, id.type);

    semicolon();

    return finishNode(node, "DeclareFunction");
  }

  function parseDeclare(node) {
    if (tokType === _class) {
      return parseDeclareClass(node);
    } else if (tokType === _function) {
      return parseDeclareFunction(node);
    } else if (tokType === _var) {
      return parseDeclareVariable(node);
    } else if (isContextual("module")) {
      return parseDeclareModule(node);
    } else {
      unexpected();
    }
  }

  function parseDeclareVariable(node) {
    next();
    node.id = parseTypeAnnotatableIdentifier();
    semicolon();
    return finishNode(node, "DeclareVariable");
  }

  function parseDeclareModule(node) {
    next();

    if (tokType === _string) {
      node.id = parseExprAtom();
    } else {
      node.id = parseIdent();
    }

    var bodyNode = node.body = startNode();
    var body = bodyNode.body = [];
    expect(_braceL);
    while (tokType !== _braceR) {
      var node2 = startNode();

      // todo: declare check
      next();

      body.push(parseDeclare(node2));
    }
    expect(_braceR);

    finishNode(bodyNode, "BlockStatement");
    return finishNode(node, "DeclareModule");
  }


  // Interfaces

  function parseInterfaceish(node, allowStatic) {
    node.id = parseIdent();
    
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.extends = [];

    if (eat(_extends)) {
      do {
        node.extends.push(parseInterfaceExtends());
      } while(eat(_comma));
    }

    node.body = parseObjectType(allowStatic);
  }

  function parseInterfaceExtends() {
    var node = startNode();

    node.id = parseIdent();
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }

    return finishNode(node, "InterfaceExtends");
  }

  function parseInterface(node) {
    parseInterfaceish(node, false);
    return finishNode(node, "InterfaceDeclaration");
  }

  // Type aliases
  
  function parseTypeAlias(node) {
    node.id = parseIdent();

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    expect(_eq);

    node.right = parseType();

    semicolon();

    return finishNode(node, "TypeAlias");
  }

  // Type annotations

  function parseTypeParameterDeclaration() {
    var node = startNode();
    node.params = [];

    expectRelational("<");
    while (!isRelational(">")) {
      node.params.push(parseIdent());
      if (!isRelational(">")) {
        expect(_comma);
      }
    }
    expectRelational(">");

    return finishNode(node, "TypeParameterDeclaration");
  }

  function parseTypeParameterInstantiation() {
    var node = startNode(), oldInType = inType;
    node.params = [];

    inType = true;

    expectRelational("<");
    while (!isRelational(">")) {
      node.params.push(parseType());
      if (!isRelational(">")) {
        expect(_comma);
      }
    }
    expectRelational(">");

    inType = oldInType;

    return finishNode(node, "TypeParameterInstantiation");
  }

  function parseObjectPropertyKey() {
    return (tokType === _num || tokType === _string) ? parseExprAtom() : parseIdent(true);
  }

  function parseObjectTypeIndexer(node, isStatic) {
    node.static = isStatic;

    expect(_bracketL);
    node.id = parseObjectPropertyKey();
    expect(_colon);
    node.key = parseType();
    expect(_bracketR);
    expect(_colon);
    node.value = parseType();

    return finishNode(node, "ObjectTypeIndexer");
  }

  function parseObjectTypeMethodish(node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }

    expect(_parenL);
    while (tokType === _name) {
      node.params.push(parseFunctionTypeParam());
      if (tokType !== _parenR) {
        expect(_comma);
      }
    }

    if (eat(_ellipsis)) {
      node.rest = parseFunctionTypeParam();
    }
    expect(_parenR);
    expect(_colon);
    node.returnType = parseType();

    return finishNode(node, "FunctionTypeAnnotation");
  }

  function parseObjectTypeMethod(start, isStatic, key) {
    var node = startNodeAt(start);
    node.value = parseObjectTypeMethodish(startNodeAt(start));
    node.static = isStatic;
    node.key = key;
    node.optional = false;
    return finishNode(node, "ObjectTypeProperty");
  }

  function parseObjectTypeCallProperty(node, isStatic) {
    var valueNode = startNode();
    node.static = isStatic;
    node.value = parseObjectTypeMethodish(valueNode);
    return finishNode(node, "ObjectTypeCallProperty");
  }

  function parseObjectType(allowStatic) {
    var nodeStart = startNode();
    var node;
    var optional = false;
    var property;
    var propertyKey;
    var propertyTypeAnnotation;
    var token;
    var isStatic;

    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];

    expect(_braceL);

    while (tokType !== _braceR) {
      var start = storeCurrentPos();
      node = startNode();
      if (allowStatic && isContextual("static")) {
        next();
        isStatic = true;
      }

      if (tokType === _bracketL) {
        nodeStart.indexers.push(parseObjectTypeIndexer(node, isStatic));
      } else if (tokType === _parenL || isRelational("<")) {
        nodeStart.callProperties.push(parseObjectTypeCallProperty(node, allowStatic));
      } else {
        if (isStatic && tokType === _colon) {
          propertyKey = parseIdent();
        } else {
          propertyKey = parseObjectPropertyKey();
        }
        if (isRelational("<") || tokType === _parenL) {
          // This is a method property
          nodeStart.properties.push(parseObjectTypeMethod(start, isStatic, propertyKey));
        } else {
          if (eat(_question)) {
            optional = true;
          }
          expect(_colon);
          node.key = propertyKey;
          node.value = parseType();
          node.optional = optional;
          node.static = isStatic;
          nodeStart.properties.push(finishNode(node, "ObjectTypeProperty"));
        }
      }

      if (!eat(_semi) && tokType !== _braceR) {
        unexpected();
      }
    }

    expect(_braceR);

    return finishNode(nodeStart, "ObjectTypeAnnotation")
  }

  function parseGenericType(start, id) {
    var node = startNodeAt(start);

    node.typeParameters = null;
    node.id = id;

    while (eat(_dot)) {
      var node2 = startNodeAt(start);
      node2.qualification = node.id;
      node2.id = parseIdent();
      node.id = finishNode(node2, "QualifiedTypeIdentifier");
    }

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterInstantiation();
    }

    return finishNode(node, "GenericTypeAnnotation");
  }

  function parseVoidType() {
    var node = startNode();
    expect(keywordTypes["void"]);
    return finishNode(node, "VoidTypeAnnotation");
  }

  function parseTypeofType() {
    var node = startNode();
    expect(keywordTypes["typeof"]);
    node.argument = parsePrimaryType();
    return finishNode(node, "TypeofTypeAnnotation");
  }

  function parseTupleType() {
    var node = startNode();
    node.types = [];
    expect(_bracketL);
    // We allow trailing commas
    while (tokPos < inputLen && tokType !== _bracketR) {
      node.types.push(parseType());
      if (tokType === _bracketR) break;
      expect(_comma);
    }
    expect(_bracketR);
    return finishNode(node, "TupleTypeAnnotation");
  }

  function parseFunctionTypeParam() {
    var optional = false;
    var node = startNode();
    node.name = parseIdent();
    if (eat(_question)) {
      optional = true;
    }
    expect(_colon);
    node.optional = optional;
    node.typeAnnotation = parseType();
    return finishNode(node, "FunctionTypeParam");
  }

  function parseFunctionTypeParams() {
    var ret = { params: [], rest: null };
    while (tokType === _name) {
      ret.params.push(parseFunctionTypeParam());
      if (tokType !== _parenR) {
        expect(_comma);
      }
    }

    if (eat(_ellipsis)) {
      ret.rest = parseFunctionTypeParam();
    }
    return ret;
  }

  function identToTypeAnnotation(start, node, id) {
    switch (id.name) {
      case 'any':
        return finishNode(node, "AnyTypeAnnotation");

      case 'bool':
      case 'boolean':
        return finishNode(node, "BooleanTypeAnnotation");

      case 'number':
        return finishNode(node, "NumberTypeAnnotation");

      case 'string':
        return finishNode(node, "StringTypeAnnotation");

      default:
        return parseGenericType(start, id);
    }
  }

  // The parsing of types roughly parallels the parsing of expressions, and
  // primary types are kind of like primary expressions...they're the
  // primitives with which other types are constructed.
  function parsePrimaryType() {
    var typeIdentifier = null;
    var params = null;
    var returnType = null;
    var start = storeCurrentPos();
    var node = startNode();
    var rest = null;
    var tmp;
    var typeParameters;
    var token;
    var type;
    var isGroupedType = false;

    switch (tokType) {
      case _name:
        return identToTypeAnnotation(start, node, parseIdent());

      case _braceL:
        return parseObjectType();

      case _bracketL:
        return parseTupleType();

      case _relational:
        if (tokVal === "<") {
          node.typeParameters = parseTypeParameterDeclaration();
          expect(_parenL);
          tmp = parseFunctionTypeParams();
          node.params = tmp.params;
          node.rest = tmp.rest;
          expect(_parenR);

          expect(_arrow);

          node.returnType = parseType();

          return finishNode(node, "FunctionTypeAnnotation");
        }

      case _parenL:
        next();

        var tmpId;

        // Check to see if this is actually a grouped type
        if (tokType !== _parenR && tokType !== _ellipsis) {
          if (tokType === _name) {
            //raise(tokStart, "Grouped types are currently the only flow feature not supported, request it?");
            //tmpId = identToTypeAnnotation(start, node, parseIdent());
            //next();
            //isGroupedType = tokType !== _question && tokType !== _colon;
          } else {
            isGroupedType = true;
          }
        }

        if (isGroupedType) {
          if (tmpId && _parenR) {
            type = tmpId;
          } else {
            type = parseType();
            expect(_parenR);
          }

          // If we see a => next then someone was probably confused about
          // function types, so we can provide a better error message
          if (eat(_arrow)) {
            raise(node,
              'Unexpected token =>. It looks like ' +
              'you are trying to write a function type, but you ended up ' +
              'writing a grouped type followed by an =>, which is a syntax ' +
              'error. Remember, function type parameters are named so function ' +
              'types look like (name1: type1, name2: type2) => returnType. You ' +
              'probably wrote (type1) => returnType'
            );
          }

          return type;
        }

        tmp = parseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;

        expect(_parenR);

        expect(_arrow);

        node.returnType = parseType();
        node.typeParameters = null;

        return finishNode(node, "FunctionTypeAnnotation");

      case _string:
        node.value = tokVal;
        node.raw = input.slice(tokStart, tokEnd);
        next();
        return finishNode(node, "StringLiteralTypeAnnotation");

      default:
        if (tokType.keyword) {
          switch (tokType.keyword) {
            case 'void':
              return parseVoidType();

            case 'typeof':
              return parseTypeofType();
          }
        }
    }

    unexpected();
  }

  function parsePostfixType() {
    var node = startNode();
    var type = node.elementType = parsePrimaryType();
    if (tokType === _bracketL) {
      expect(_bracketL);
      expect(_bracketR);
      return finishNode(node, "ArrayTypeAnnotation");
    }
    return type;
  }

  function parsePrefixType() {
    var node = startNode();
    if (eat(_question)) {
      node.typeAnnotation = parsePrefixType();
      return finishNode(node, "NullableTypeAnnotation");
    }
    return parsePostfixType();
  }

  function parseIntersectionType() {
    var node = startNode();
    var type = parsePrefixType();
    node.types = [type];
    while (eat(_bitwiseAND)) {
      node.types.push(parsePrefixType());
    }
    return node.types.length === 1 ? type : finishNode(node, "IntersectionTypeAnnotation");
  }

  function parseUnionType() {
    var node = startNode();
    var type = parseIntersectionType();
    node.types = [type];
    while (eat(_bitwiseOR)) {
      node.types.push(parseIntersectionType());
    }
    return node.types.length === 1 ? type : finishNode(node, "UnionTypeAnnotation");
  }

  function parseType() {
    var oldInType = inType;
    inType = true;
    var type = parseUnionType();
    inType = oldInType;
    return type;
  }

  function parseTypeAnnotation() {
    var node = startNode();

    var oldInType = inType;
    inType = true;
    expect(_colon);
    node.typeAnnotation = parseType();
    inType = oldInType;

    return finishNode(node, "TypeAnnotation");
  }

  function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
    var node = startNode();
    var ident = parseIdent();
    var isOptionalParam = false;

    if (canBeOptionalParam && eat(_question)) {
      expect(_question);
      isOptionalParam = true;
    }

    if (requireTypeAnnotation || tokType === _colon) {
      ident.typeAnnotation = parseTypeAnnotation();
      finishNode(ident, ident.type);
    }

    if (isOptionalParam) {
      ident.optional = true;
      finishNode(ident, ident.type);
    }

    return ident;
  }
});

},{}],255:[function(require,module,exports){
var types = require("../lib/types");
var Type = types.Type;
var def = Type.def;
var or = Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isNumber = builtin.number;
var isBoolean = builtin.boolean;
var isRegExp = builtin.RegExp;
var shared = require("../lib/shared");
var defaults = shared.defaults;
var geq = shared.geq;

// Abstract supertype of all syntactic entities that are allowed to have a
// .loc field.
def("Printable")
    .field("loc", or(
        def("SourceLocation"),
        null
    ), defaults["null"], true);

def("Node")
    .bases("Printable")
    .field("type", isString)
    .field("comments", or(
        [def("Comment")],
        null
    ), defaults["null"], true);

def("SourceLocation")
    .build("start", "end", "source")
    .field("start", def("Position"))
    .field("end", def("Position"))
    .field("source", or(isString, null), defaults["null"]);

def("Position")
    .build("line", "column")
    .field("line", geq(1))
    .field("column", geq(0));

def("Program")
    .bases("Node")
    .build("body")
    .field("body", [def("Statement")]);

def("Function")
    .bases("Node")
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("params", [def("Pattern")])
    .field("body", or(def("BlockStatement"), def("Expression")));

def("Statement").bases("Node");

// The empty .build() here means that an EmptyStatement can be constructed
// (i.e. it's not abstract) but that it needs no arguments.
def("EmptyStatement").bases("Statement").build();

def("BlockStatement")
    .bases("Statement")
    .build("body")
    .field("body", [def("Statement")]);

// TODO Figure out how to silently coerce Expressions to
// ExpressionStatements where a Statement was expected.
def("ExpressionStatement")
    .bases("Statement")
    .build("expression")
    .field("expression", def("Expression"));

def("IfStatement")
    .bases("Statement")
    .build("test", "consequent", "alternate")
    .field("test", def("Expression"))
    .field("consequent", def("Statement"))
    .field("alternate", or(def("Statement"), null), defaults["null"]);

def("LabeledStatement")
    .bases("Statement")
    .build("label", "body")
    .field("label", def("Identifier"))
    .field("body", def("Statement"));

def("BreakStatement")
    .bases("Statement")
    .build("label")
    .field("label", or(def("Identifier"), null), defaults["null"]);

def("ContinueStatement")
    .bases("Statement")
    .build("label")
    .field("label", or(def("Identifier"), null), defaults["null"]);

def("WithStatement")
    .bases("Statement")
    .build("object", "body")
    .field("object", def("Expression"))
    .field("body", def("Statement"));

def("SwitchStatement")
    .bases("Statement")
    .build("discriminant", "cases", "lexical")
    .field("discriminant", def("Expression"))
    .field("cases", [def("SwitchCase")])
    .field("lexical", isBoolean, defaults["false"]);

def("ReturnStatement")
    .bases("Statement")
    .build("argument")
    .field("argument", or(def("Expression"), null));

def("ThrowStatement")
    .bases("Statement")
    .build("argument")
    .field("argument", def("Expression"));

def("TryStatement")
    .bases("Statement")
    .build("block", "handler", "finalizer")
    .field("block", def("BlockStatement"))
    .field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
    })
    .field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
    }, true) // Indicates this field is hidden from eachField iteration.
    .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
    .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);

def("CatchClause")
    .bases("Node")
    .build("param", "guard", "body")
    .field("param", def("Pattern"))
    .field("guard", or(def("Expression"), null), defaults["null"])
    .field("body", def("BlockStatement"));

def("WhileStatement")
    .bases("Statement")
    .build("test", "body")
    .field("test", def("Expression"))
    .field("body", def("Statement"));

def("DoWhileStatement")
    .bases("Statement")
    .build("body", "test")
    .field("body", def("Statement"))
    .field("test", def("Expression"));

def("ForStatement")
    .bases("Statement")
    .build("init", "test", "update", "body")
    .field("init", or(
        def("VariableDeclaration"),
        def("Expression"),
        null))
    .field("test", or(def("Expression"), null))
    .field("update", or(def("Expression"), null))
    .field("body", def("Statement"));

def("ForInStatement")
    .bases("Statement")
    .build("left", "right", "body", "each")
    .field("left", or(
        def("VariableDeclaration"),
        def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"))
    .field("each", isBoolean);

def("DebuggerStatement").bases("Statement").build();

def("Declaration").bases("Statement");

def("FunctionDeclaration")
    .bases("Function", "Declaration")
    .build("id", "params", "body")
    .field("id", def("Identifier"));

def("FunctionExpression")
    .bases("Function", "Expression")
    .build("id", "params", "body");

def("VariableDeclaration")
    .bases("Declaration")
    .build("kind", "declarations")
    .field("kind", or("var", "let", "const"))
    .field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier") // TODO Esprima deviation.
    )]);

def("VariableDeclarator")
    .bases("Node")
    .build("id", "init")
    .field("id", def("Pattern"))
    .field("init", or(def("Expression"), null));

// TODO Are all Expressions really Patterns?
def("Expression").bases("Node", "Pattern");

def("ThisExpression").bases("Expression").build();

def("ArrayExpression")
    .bases("Expression")
    .build("elements")
    .field("elements", [or(def("Expression"), null)]);

def("ObjectExpression")
    .bases("Expression")
    .build("properties")
    .field("properties", [def("Property")]);

// TODO Not in the Mozilla Parser API, but used by Esprima.
def("Property")
    .bases("Node") // Want to be able to visit Property Nodes.
    .build("kind", "key", "value")
    .field("kind", or("init", "get", "set"))
    .field("key", or(def("Literal"), def("Identifier")))
    // esprima allows Pattern
    .field("value", or(def("Expression"), def("Pattern")));

def("SequenceExpression")
    .bases("Expression")
    .build("expressions")
    .field("expressions", [def("Expression")]);

var UnaryOperator = or(
    "-", "+", "!", "~",
    "typeof", "void", "delete");

def("UnaryExpression")
    .bases("Expression")
    .build("operator", "argument", "prefix")
    .field("operator", UnaryOperator)
    .field("argument", def("Expression"))
    // TODO Esprima doesn't bother with this field, presumably because
    // it's always true for unary operators.
    .field("prefix", isBoolean, defaults["true"]);

var BinaryOperator = or(
    "==", "!=", "===", "!==",
    "<", "<=", ">", ">=",
    "<<", ">>", ">>>",
    "+", "-", "*", "/", "%",
    "&", // TODO Missing from the Parser API.
    "|", "^", "in",
    "instanceof", "..");

def("BinaryExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", BinaryOperator)
    .field("left", def("Expression"))
    .field("right", def("Expression"));

var AssignmentOperator = or(
    "=", "+=", "-=", "*=", "/=", "%=",
    "<<=", ">>=", ">>>=",
    "|=", "^=", "&=");

def("AssignmentExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", AssignmentOperator)
    .field("left", def("Pattern"))
    .field("right", def("Expression"));

var UpdateOperator = or("++", "--");

def("UpdateExpression")
    .bases("Expression")
    .build("operator", "argument", "prefix")
    .field("operator", UpdateOperator)
    .field("argument", def("Expression"))
    .field("prefix", isBoolean);

var LogicalOperator = or("||", "&&");

def("LogicalExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", LogicalOperator)
    .field("left", def("Expression"))
    .field("right", def("Expression"));

def("ConditionalExpression")
    .bases("Expression")
    .build("test", "consequent", "alternate")
    .field("test", def("Expression"))
    .field("consequent", def("Expression"))
    .field("alternate", def("Expression"));

def("NewExpression")
    .bases("Expression")
    .build("callee", "arguments")
    .field("callee", def("Expression"))
    // The Mozilla Parser API gives this type as [or(def("Expression"),
    // null)], but null values don't really make sense at the call site.
    // TODO Report this nonsense.
    .field("arguments", [def("Expression")]);

def("CallExpression")
    .bases("Expression")
    .build("callee", "arguments")
    .field("callee", def("Expression"))
    // See comment for NewExpression above.
    .field("arguments", [def("Expression")]);

def("MemberExpression")
    .bases("Expression")
    .build("object", "property", "computed")
    .field("object", def("Expression"))
    .field("property", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("Pattern").bases("Node");

def("ObjectPattern")
    .bases("Pattern")
    .build("properties")
    // TODO File a bug to get PropertyPattern added to the interfaces API.
    // esprima uses Property
    .field("properties", [or(def("PropertyPattern"), def("Property"))]);

def("PropertyPattern")
    .bases("Pattern")
    .build("key", "pattern")
    .field("key", or(def("Literal"), def("Identifier")))
    .field("pattern", def("Pattern"));

def("ArrayPattern")
    .bases("Pattern")
    .build("elements")
    .field("elements", [or(def("Pattern"), null)]);

def("SwitchCase")
    .bases("Node")
    .build("test", "consequent")
    .field("test", or(def("Expression"), null))
    .field("consequent", [def("Statement")]);

def("Identifier")
    // But aren't Expressions and Patterns already Nodes? TODO Report this.
    .bases("Node", "Expression", "Pattern")
    .build("name")
    .field("name", isString);

def("Literal")
    // But aren't Expressions already Nodes? TODO Report this.
    .bases("Node", "Expression")
    .build("value")
    .field("value", or(
        isString,
        isBoolean,
        null, // isNull would also work here.
        isNumber,
        isRegExp
    ));

// Abstract (non-buildable) comment supertype. Not a Node.
def("Comment")
    .bases("Printable")
    .field("value", isString)
    // A .leading comment comes before the node, whereas a .trailing
    // comment comes after it. These two fields should not both be true,
    // but they might both be false when the comment falls inside a node
    // and the node has no children for the comment to lead or trail,
    // e.g. { /*dangling*/ }.
    .field("leading", isBoolean, defaults["true"])
    .field("trailing", isBoolean, defaults["false"]);

// Block comment. The .type really should be BlockComment rather than
// Block, but that's what we're stuck with for now.
def("Block")
    .bases("Comment")
    .build("value", /*optional:*/ "leading", "trailing");

// Single line comment. The .type really should be LineComment rather than
// Line, but that's what we're stuck with for now.
def("Line")
    .bases("Comment")
    .build("value", /*optional:*/ "leading", "trailing");

},{"../lib/shared":266,"../lib/types":267}],256:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isBoolean = builtin.boolean;

// Note that none of these types are buildable because the Mozilla Parser
// API doesn't specify any builder functions, and nobody uses E4X anymore.

def("XMLDefaultDeclaration")
    .bases("Declaration")
    .field("namespace", def("Expression"));

def("XMLAnyName").bases("Expression");

def("XMLQualifiedIdentifier")
    .bases("Expression")
    .field("left", or(def("Identifier"), def("XMLAnyName")))
    .field("right", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("XMLFunctionQualifiedIdentifier")
    .bases("Expression")
    .field("right", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("XMLAttributeSelector")
    .bases("Expression")
    .field("attribute", def("Expression"));

def("XMLFilterExpression")
    .bases("Expression")
    .field("left", def("Expression"))
    .field("right", def("Expression"));

def("XMLElement")
    .bases("XML", "Expression")
    .field("contents", [def("XML")]);

def("XMLList")
    .bases("XML", "Expression")
    .field("contents", [def("XML")]);

def("XML").bases("Node");

def("XMLEscape")
    .bases("XML")
    .field("expression", def("Expression"));

def("XMLText")
    .bases("XML")
    .field("text", isString);

def("XMLStartTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLEndTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLPointTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLName")
    .bases("XML")
    .field("contents", or(isString, [def("XML")]));

def("XMLAttribute")
    .bases("XML")
    .field("value", isString);

def("XMLCdata")
    .bases("XML")
    .field("contents", isString);

def("XMLComment")
    .bases("XML")
    .field("contents", isString);

def("XMLProcessingInstruction")
    .bases("XML")
    .field("target", isString)
    .field("contents", or(isString, null));

},{"../lib/types":267,"./core":255}],257:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isBoolean = builtin.boolean;
var isObject = builtin.object;
var isString = builtin.string;
var defaults = require("../lib/shared").defaults;

def("Function")
    .field("generator", isBoolean, defaults["false"])
    .field("expression", isBoolean, defaults["false"])
    .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
    // TODO This could be represented as a SpreadElementPattern in .params.
    .field("rest", or(def("Identifier"), null), defaults["null"]);

def("FunctionDeclaration")
    .build("id", "params", "body", "generator", "expression");

def("FunctionExpression")
    .build("id", "params", "body", "generator", "expression");

// TODO The Parser API calls this ArrowExpression, but Esprima uses
// ArrowFunctionExpression.
def("ArrowFunctionExpression")
    .bases("Function", "Expression")
    .build("params", "body", "expression")
    // The forced null value here is compatible with the overridden
    // definition of the "id" field in the Function interface.
    .field("id", null, defaults["null"])
    // The current spec forbids arrow generators, so I have taken the
    // liberty of enforcing that. TODO Report this.
    .field("generator", false);

def("YieldExpression")
    .bases("Expression")
    .build("argument", "delegate")
    .field("argument", or(def("Expression"), null))
    .field("delegate", isBoolean, defaults["false"]);

def("GeneratorExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

def("ComprehensionExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

def("ComprehensionBlock")
    .bases("Node")
    .build("left", "right", "each")
    .field("left", def("Pattern"))
    .field("right", def("Expression"))
    .field("each", isBoolean);

def("ModuleSpecifier")
    .bases("Literal")
    .build("value")
    .field("value", isString);

def("Property")
    // Esprima extensions not mentioned in the Mozilla Parser API:
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("method", isBoolean, defaults["false"])
    .field("shorthand", isBoolean, defaults["false"])
    .field("computed", isBoolean, defaults["false"]);

def("PropertyPattern")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("computed", isBoolean, defaults["false"]);

def("MethodDefinition")
    .bases("Declaration")
    .build("kind", "key", "value")
    .field("kind", or("init", "get", "set", ""))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", def("Function"))
    .field("computed", isBoolean, defaults["false"]);

def("SpreadElement")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

def("ArrayExpression")
    .field("elements", [or(def("Expression"), def("SpreadElement"), null)]);

def("NewExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

def("CallExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

def("SpreadElementPattern")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

def("ArrayPattern")
    .field("elements", [or(
        def("Pattern"),
        null,
        // used by esprima
        def("SpreadElement")
    )]);

var ClassBodyElement = or(
    def("MethodDefinition"),
    def("VariableDeclarator"),
    def("ClassPropertyDefinition"),
    def("ClassProperty")
);

def("ClassProperty")
  .bases("Declaration")
  .build("key")
  .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
  .field("computed", isBoolean, defaults["false"]);

def("ClassPropertyDefinition") // static property
    .bases("Declaration")
    .build("definition")
    // Yes, Virginia, circular definitions are permitted.
    .field("definition", ClassBodyElement);

def("ClassBody")
    .bases("Declaration")
    .build("body")
    .field("body", [ClassBodyElement]);

def("ClassDeclaration")
    .bases("Declaration")
    .build("id", "body", "superClass")
    .field("id", def("Identifier"))
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

def("ClassExpression")
    .bases("Expression")
    .build("id", "body", "superClass")
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"])
    .field("implements", [def("ClassImplements")], defaults.emptyArray);

def("ClassImplements")
    .bases("Node")
    .build("id")
    .field("id", def("Identifier"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

// Specifier and NamedSpecifier are abstract non-standard types that I
// introduced for definitional convenience.
def("Specifier").bases("Node");
def("NamedSpecifier")
    .bases("Specifier")
    // Note: this abstract type is intentionally not buildable.
    .field("id", def("Identifier"))
    .field("name", or(def("Identifier"), null), defaults["null"]);

// Like NamedSpecifier, except type:"ExportSpecifier" and buildable.
// export {<id [as name]>} [from ...];
def("ExportSpecifier")
    .bases("NamedSpecifier")
    .build("id", "name");

// export <*> from ...;
def("ExportBatchSpecifier")
    .bases("Specifier")
    .build();

// Like NamedSpecifier, except type:"ImportSpecifier" and buildable.
// import {<id [as name]>} from ...;
def("ImportSpecifier")
    .bases("NamedSpecifier")
    .build("id", "name");

// import <* as id> from ...;
def("ImportNamespaceSpecifier")
    .bases("Specifier")
    .build("id")
    .field("id", def("Identifier"));

// import <id> from ...;
def("ImportDefaultSpecifier")
    .bases("Specifier")
    .build("id")
    .field("id", def("Identifier"));

def("ExportDeclaration")
    .bases("Declaration")
    .build("default", "declaration", "specifiers", "source")
    .field("default", isBoolean)
    .field("declaration", or(
        def("Declaration"),
        def("Expression"), // Implies default.
        null
    ))
    .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
    )], defaults.emptyArray)
    .field("source", or(def("ModuleSpecifier"), null), defaults["null"]);

def("ImportDeclaration")
    .bases("Declaration")
    .build("specifiers", "source")
    .field("specifiers", [or(
        def("ImportSpecifier"),
        def("ImportNamespaceSpecifier"),
        def("ImportDefaultSpecifier")
    )], defaults.emptyArray)
    .field("source", def("ModuleSpecifier"));

def("TaggedTemplateExpression")
    .bases("Expression")
    .field("tag", def("Expression"))
    .field("quasi", def("TemplateLiteral"));

def("TemplateLiteral")
    .bases("Expression")
    .build("quasis", "expressions")
    .field("quasis", [def("TemplateElement")])
    .field("expressions", [def("Expression")]);

def("TemplateElement")
    .bases("Node")
    .build("value", "tail")
    .field("value", {"cooked": isString, "raw": isString})
    .field("tail", isBoolean);

},{"../lib/shared":266,"../lib/types":267,"./core":255}],258:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isBoolean = builtin.boolean;
var defaults = require("../lib/shared").defaults;

def("Function")
    .field("async", isBoolean, defaults["false"]);

def("SpreadProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

def("ObjectExpression")
    .field("properties", [or(def("Property"), def("SpreadProperty"))]);

def("SpreadPropertyPattern")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

def("ObjectPattern")
    .field("properties", [or(
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        // used by esprima
        def("Property"),
        def("SpreadProperty")
    )]);

def("AwaitExpression")
    .bases("Expression")
    .build("argument", "all")
    .field("argument", or(def("Expression"), null))
    .field("all", isBoolean, defaults["false"]);

},{"../lib/shared":266,"../lib/types":267,"./core":255}],259:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isBoolean = builtin.boolean;
var defaults = require("../lib/shared").defaults;

def("XJSAttribute")
    .bases("Node")
    .build("name", "value")
    .field("name", or(def("XJSIdentifier"), def("XJSNamespacedName")))
    .field("value", or(
        def("Literal"), // attr="value"
        def("XJSExpressionContainer"), // attr={value}
        null // attr= or just attr
    ), defaults["null"]);

def("XJSIdentifier")
    .bases("Node")
    .build("name")
    .field("name", isString);

def("XJSNamespacedName")
    .bases("Node")
    .build("namespace", "name")
    .field("namespace", def("XJSIdentifier"))
    .field("name", def("XJSIdentifier"));

def("XJSMemberExpression")
    .bases("MemberExpression")
    .build("object", "property")
    .field("object", or(def("XJSIdentifier"), def("XJSMemberExpression")))
    .field("property", def("XJSIdentifier"))
    .field("computed", isBoolean, defaults.false);

var XJSElementName = or(
    def("XJSIdentifier"),
    def("XJSNamespacedName"),
    def("XJSMemberExpression")
);

def("XJSSpreadAttribute")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

var XJSAttributes = [or(
    def("XJSAttribute"),
    def("XJSSpreadAttribute")
)];

def("XJSExpressionContainer")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));

def("XJSElement")
    .bases("Expression")
    .build("openingElement", "closingElement", "children")
    .field("openingElement", def("XJSOpeningElement"))
    .field("closingElement", or(def("XJSClosingElement"), null), defaults["null"])
    .field("children", [or(
        def("XJSElement"),
        def("XJSExpressionContainer"),
        def("XJSText"),
        def("Literal") // TODO Esprima should return XJSText instead.
    )], defaults.emptyArray)
    .field("name", XJSElementName, function() {
        // Little-known fact: the `this` object inside a default function
        // is none other than the partially-built object itself, and any
        // fields initialized directly from builder function arguments
        // (like openingElement, closingElement, and children) are
        // guaranteed to be available.
        return this.openingElement.name;
    })
    .field("selfClosing", isBoolean, function() {
        return this.openingElement.selfClosing;
    })
    .field("attributes", XJSAttributes, function() {
        return this.openingElement.attributes;
    });

def("XJSOpeningElement")
    .bases("Node") // TODO Does this make sense? Can't really be an XJSElement.
    .build("name", "attributes", "selfClosing")
    .field("name", XJSElementName)
    .field("attributes", XJSAttributes, defaults.emptyArray)
    .field("selfClosing", isBoolean, defaults["false"]);

def("XJSClosingElement")
    .bases("Node") // TODO Same concern.
    .build("name")
    .field("name", XJSElementName);

def("XJSText")
    .bases("Literal")
    .build("value")
    .field("value", isString);

def("XJSEmptyExpression").bases("Expression").build();

// Type Annotations
def("Type")
  .bases("Node");

def("AnyTypeAnnotation")
  .bases("Type");

def("VoidTypeAnnotation")
  .bases("Type");

def("NumberTypeAnnotation")
  .bases("Type");

def("StringTypeAnnotation")
  .bases("Type");

def("StringLiteralTypeAnnotation")
  .bases("Type")
  .build("value", "raw")
  .field("value", isString)
  .field("raw", isString);

def("BooleanTypeAnnotation")
  .bases("Type");

def("TypeAnnotation")
  .bases("Node")
  .build("typeAnnotation")
  .field("typeAnnotation", def("Type"));

def("NullableTypeAnnotation")
  .bases("Type")
  .build("typeAnnotation")
  .field("typeAnnotation", def("Type"));

def("FunctionTypeAnnotation")
  .bases("Type")
  .build("params", "returnType", "rest", "typeParameters")
  .field("params", [def("FunctionTypeParam")])
  .field("returnType", def("Type"))
  .field("rest", or(def("FunctionTypeParam"), null))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null));

def("FunctionTypeParam")
  .bases("Node")
  .build("name", "typeAnnotation", "optional")
  .field("name", def("Identifier"))
  .field("typeAnnotation", def("Type"))
  .field("optional", isBoolean);
  
def("ArrayTypeAnnotation")
  .bases("Type")
  .build("elementType")
  .field("elementType", def("Type"));

def("ObjectTypeAnnotation")
  .bases("Type")
  .build("properties")
  .field("properties", [def("ObjectTypeProperty")])
  .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
  .field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray);

def("ObjectTypeProperty")
  .bases("Node")
  .build("key", "value", "optional")
  .field("key", or(def("Literal"), def("Identifier")))
  .field("value", def("Type"))
  .field("optional", isBoolean);

def("ObjectTypeIndexer")
  .bases("Node")
  .build("id", "key", "value")
  .field("id", def("Identifier"))
  .field("key", def("Type"))
  .field("value", def("Type"));

def("ObjectTypeCallProperty")
  .bases("Node")
  .build("value")
  .field("value", def("FunctionTypeAnnotation"))
  .field("static", isBoolean, false);

def("QualifiedTypeIdentifier")
  .bases("Node")
  .build("qualification", "id")
  .field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier")))
  .field("id", def("Identifier"));

def("GenericTypeAnnotation")
  .bases("Type")
  .build("id", "typeParameters")
  .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
  .field("typeParameters", or(def("TypeParameterInstantiation"), null));

def("MemberTypeAnnotation")
  .bases("Type")
  .build("object", "property")
  .field("object", def("Identifier"))
  .field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));

def("UnionTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("IntersectionTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("TypeofTypeAnnotation")
  .bases("Type")
  .build("argument")
  .field("argument", def("Type"));

def("Identifier")
  .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

def("TypeParameterDeclaration")
  .bases("Node")
  .build("params")
  .field("params", [def("Identifier")]);

def("TypeParameterInstantiation")
  .bases("Node")
  .build("params")
  .field("params", [def("Type")]);

def("Function")
  .field("returnType", or(def("TypeAnnotation"), null), defaults["null"])
  .field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]);

def("ClassProperty")
  .build("key", "typeAnnotation")
  .field("typeAnnotation", def("TypeAnnotation"))
  .field("static", isBoolean, false);

def("ClassImplements")
  .field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);

def("InterfaceDeclaration")
  .bases("Statement")
  .build("id", "body", "extends")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"])
  .field("body", def("ObjectTypeAnnotation"))
  .field("extends", [def("InterfaceExtends")]);

def("InterfaceExtends")
  .bases("Node")
  .build("id")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterInstantiation"), null));

def("TypeAlias")
  .bases("Statement")
  .build("id", "typeParameters", "right")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null))
  .field("right", def("Type"));
  
def("TypeCastExpression")
  .bases("Expression")
  .build("expression", "typeAnnotation")
  .field("expression", def("Expression"))
  .field("typeAnnotation", def("TypeAnnotation"));

def("TupleTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("DeclareVariable")
  .bases("Statement")
  .build("id")
  .field("id", def("Identifier"));

def("DeclareFunction")
  .bases("Statement")
  .build("id")
  .field("id", def("Identifier"));

def("DeclareClass")
  .bases("InterfaceDeclaration")
  .build("id");

def("DeclareModule")
  .bases("Statement")
  .build("id", "body")
  .field("id", or(def("Identifier"), def("Literal")))
  .field("body", def("BlockStatement"));

},{"../lib/shared":266,"../lib/types":267,"./core":255}],260:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var geq = require("../lib/shared").geq;

def("ForOfStatement")
    .bases("Statement")
    .build("left", "right", "body")
    .field("left", or(
        def("VariableDeclaration"),
        def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"));

def("LetStatement")
    .bases("Statement")
    .build("head", "body")
    // TODO Deviating from the spec by reusing VariableDeclarator here.
    .field("head", [def("VariableDeclarator")])
    .field("body", def("Statement"));

def("LetExpression")
    .bases("Expression")
    .build("head", "body")
    // TODO Deviating from the spec by reusing VariableDeclarator here.
    .field("head", [def("VariableDeclarator")])
    .field("body", def("Expression"));

def("GraphExpression")
    .bases("Expression")
    .build("index", "expression")
    .field("index", geq(0))
    .field("expression", def("Literal"));

def("GraphIndexExpression")
    .bases("Expression")
    .build("index")
    .field("index", geq(0));

},{"../lib/shared":266,"../lib/types":267,"./core":255}],261:[function(require,module,exports){
var assert = require("assert");
var types = require("../main");
var getFieldNames = types.getFieldNames;
var getFieldValue = types.getFieldValue;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var isDate = types.builtInTypes.Date;
var isRegExp = types.builtInTypes.RegExp;
var hasOwn = Object.prototype.hasOwnProperty;

function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}

astNodesAreEquivalent.assert = function(a, b) {
    var problemPath = [];
    if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
            assert.strictEqual(a, b);
        } else {
            assert.ok(
                false,
                "Nodes differ in the following path: " +
                    problemPath.map(subscriptForProperty).join("")
            );
        }
    }
};

function subscriptForProperty(property) {
    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
        return "." + property;
    }
    return "[" + JSON.stringify(property) + "]";
}

function areEquivalent(a, b, problemPath) {
    if (a === b) {
        return true;
    }

    if (isArray.check(a)) {
        return arraysAreEquivalent(a, b, problemPath);
    }

    if (isObject.check(a)) {
        return objectsAreEquivalent(a, b, problemPath);
    }

    if (isDate.check(a)) {
        return isDate.check(b) && (+a === +b);
    }

    if (isRegExp.check(a)) {
        return isRegExp.check(b) && (
            a.source === b.source &&
            a.global === b.global &&
            a.multiline === b.multiline &&
            a.ignoreCase === b.ignoreCase
        );
    }

    return a == b;
}

function arraysAreEquivalent(a, b, problemPath) {
    isArray.assert(a);
    var aLength = a.length;

    if (!isArray.check(b) || b.length !== aLength) {
        if (problemPath) {
            problemPath.push("length");
        }
        return false;
    }

    for (var i = 0; i < aLength; ++i) {
        if (problemPath) {
            problemPath.push(i);
        }

        if (i in a !== i in b) {
            return false;
        }

        if (!areEquivalent(a[i], b[i], problemPath)) {
            return false;
        }

        if (problemPath) {
            assert.strictEqual(problemPath.pop(), i);
        }
    }

    return true;
}

function objectsAreEquivalent(a, b, problemPath) {
    isObject.assert(a);
    if (!isObject.check(b)) {
        return false;
    }

    // Fast path for a common property of AST nodes.
    if (a.type !== b.type) {
        if (problemPath) {
            problemPath.push("type");
        }
        return false;
    }

    var aNames = getFieldNames(a);
    var aNameCount = aNames.length;

    var bNames = getFieldNames(b);
    var bNameCount = bNames.length;

    if (aNameCount === bNameCount) {
        for (var i = 0; i < aNameCount; ++i) {
            var name = aNames[i];
            var aChild = getFieldValue(a, name);
            var bChild = getFieldValue(b, name);

            if (problemPath) {
                problemPath.push(name);
            }

            if (!areEquivalent(aChild, bChild, problemPath)) {
                return false;
            }

            if (problemPath) {
                assert.strictEqual(problemPath.pop(), name);
            }
        }

        return true;
    }

    if (!problemPath) {
        return false;
    }

    // Since aNameCount !== bNameCount, we need to find some name that's
    // missing in aNames but present in bNames, or vice-versa.

    var seenNames = Object.create(null);

    for (i = 0; i < aNameCount; ++i) {
        seenNames[aNames[i]] = true;
    }

    for (i = 0; i < bNameCount; ++i) {
        name = bNames[i];

        if (!hasOwn.call(seenNames, name)) {
            problemPath.push(name);
            return false;
        }

        delete seenNames[name];
    }

    for (name in seenNames) {
        problemPath.push(name);
        break;
    }

    return false;
}

module.exports = astNodesAreEquivalent;

},{"../main":268,"assert":698}],262:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var n = types.namedTypes;
var b = types.builders;
var isNumber = types.builtInTypes.number;
var isArray = types.builtInTypes.array;
var Path = require("./path");
var Scope = require("./scope");

function NodePath(value, parentPath, name) {
    assert.ok(this instanceof NodePath);
    Path.call(this, value, parentPath, name);
}

require("util").inherits(NodePath, Path);
var NPp = NodePath.prototype;

Object.defineProperties(NPp, {
    node: {
        get: function() {
            Object.defineProperty(this, "node", {
                configurable: true, // Enable deletion.
                value: this._computeNode()
            });

            return this.node;
        }
    },

    parent: {
        get: function() {
            Object.defineProperty(this, "parent", {
                configurable: true, // Enable deletion.
                value: this._computeParent()
            });

            return this.parent;
        }
    },

    scope: {
        get: function() {
            Object.defineProperty(this, "scope", {
                configurable: true, // Enable deletion.
                value: this._computeScope()
            });

            return this.scope;
        }
    }
});

NPp.replace = function() {
    delete this.node;
    delete this.parent;
    delete this.scope;
    return Path.prototype.replace.apply(this, arguments);
};

NPp.prune = function() {
    var remainingNodePath = this.parent;

    this.replace();

    return cleanUpNodesAfterPrune(remainingNodePath);
};

// The value of the first ancestor Path whose value is a Node.
NPp._computeNode = function() {
    var value = this.value;
    if (n.Node.check(value)) {
        return value;
    }

    var pp = this.parentPath;
    return pp && pp.node || null;
};

// The first ancestor Path whose value is a Node distinct from this.node.
NPp._computeParent = function() {
    var value = this.value;
    var pp = this.parentPath;

    if (!n.Node.check(value)) {
        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        if (pp) {
            pp = pp.parentPath;
        }
    }

    while (pp && !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    return pp || null;
};

// The closest enclosing scope that governs this node.
NPp._computeScope = function() {
    var value = this.value;
    var pp = this.parentPath;
    var scope = pp && pp.scope;

    if (n.Node.check(value) &&
        Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
    }

    return scope || null;
};

NPp.getValueProperty = function(name) {
    return types.getFieldValue(this.value, name);
};

/**
 * Determine whether this.node needs to be wrapped in parentheses in order
 * for a parser to reproduce the same local AST structure.
 *
 * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
 * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
 * parse differently.
 *
 * If assumeExpressionContext === true, we don't worry about edge cases
 * like an anonymous FunctionExpression appearing lexically first in its
 * enclosing statement and thus needing parentheses to avoid being parsed
 * as a FunctionDeclaration with a missing name.
 */
NPp.needsParens = function(assumeExpressionContext) {
    var pp = this.parentPath;
    if (!pp) {
        return false;
    }

    var node = this.value;

    // Only expressions need parentheses.
    if (!n.Expression.check(node)) {
        return false;
    }

    // Identifiers never need parentheses.
    if (node.type === "Identifier") {
        return false;
    }

    while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
            return false;
        }
    }

    var parent = pp.value;

    switch (node.type) {
    case "UnaryExpression":
    case "SpreadElement":
    case "SpreadProperty":
        return parent.type === "MemberExpression"
            && this.name === "object"
            && parent.object === node;

    case "BinaryExpression":
    case "LogicalExpression":
        switch (parent.type) {
        case "CallExpression":
            return this.name === "callee"
                && parent.callee === node;

        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
            return true;

        case "MemberExpression":
            return this.name === "object"
                && parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
            var po = parent.operator;
            var pp = PRECEDENCE[po];
            var no = node.operator;
            var np = PRECEDENCE[no];

            if (pp > np) {
                return true;
            }

            if (pp === np && this.name === "right") {
                assert.strictEqual(parent.right, node);
                return true;
            }

        default:
            return false;
        }

    case "SequenceExpression":
        switch (parent.type) {
        case "ForStatement":
            // Although parentheses wouldn't hurt around sequence
            // expressions in the head of for loops, traditional style
            // dictates that e.g. i++, j++ should not be wrapped with
            // parentheses.
            return false;

        case "ExpressionStatement":
            return this.name !== "expression";

        default:
            // Otherwise err on the side of overparenthesization, adding
            // explicit exceptions above if this proves overzealous.
            return true;
        }

    case "YieldExpression":
        switch (parent.type) {
        case "BinaryExpression":
        case "LogicalExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "CallExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ConditionalExpression":
        case "YieldExpression":
            return true;

        default:
            return false;
        }

    case "Literal":
        return parent.type === "MemberExpression"
            && isNumber.check(node.value)
            && this.name === "object"
            && parent.object === node;

    case "AssignmentExpression":
    case "ConditionalExpression":
        switch (parent.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
            return true;

        case "CallExpression":
            return this.name === "callee"
                && parent.callee === node;

        case "ConditionalExpression":
            return this.name === "test"
                && parent.test === node;

        case "MemberExpression":
            return this.name === "object"
                && parent.object === node;

        default:
            return false;
        }

    default:
        if (parent.type === "NewExpression" &&
            this.name === "callee" &&
            parent.callee === node) {
            return containsCallExpression(node);
        }
    }

    if (assumeExpressionContext !== true &&
        !this.canBeFirstInStatement() &&
        this.firstInStatement())
        return true;

    return false;
};

function isBinary(node) {
    return n.BinaryExpression.check(node)
        || n.LogicalExpression.check(node);
}

function isUnaryLike(node) {
    return n.UnaryExpression.check(node)
        // I considered making SpreadElement and SpreadProperty subtypes
        // of UnaryExpression, but they're not really Expression nodes.
        || (n.SpreadElement && n.SpreadElement.check(node))
        || (n.SpreadProperty && n.SpreadProperty.check(node));
}

var PRECEDENCE = {};
[["||"],
 ["&&"],
 ["|"],
 ["^"],
 ["&"],
 ["==", "===", "!=", "!=="],
 ["<", ">", "<=", ">=", "in", "instanceof"],
 [">>", "<<", ">>>"],
 ["+", "-"],
 ["*", "/", "%"]
].forEach(function(tier, i) {
    tier.forEach(function(op) {
        PRECEDENCE[op] = i;
    });
});

function containsCallExpression(node) {
    if (n.CallExpression.check(node)) {
        return true;
    }

    if (isArray.check(node)) {
        return node.some(containsCallExpression);
    }

    if (n.Node.check(node)) {
        return types.someField(node, function(name, child) {
            return containsCallExpression(child);
        });
    }

    return false;
}

NPp.canBeFirstInStatement = function() {
    var node = this.node;
    return !n.FunctionExpression.check(node)
        && !n.ObjectExpression.check(node);
};

NPp.firstInStatement = function() {
    return firstInStatement(this);
};

function firstInStatement(path) {
    for (var node, parent; path.parent; path = path.parent) {
        node = path.node;
        parent = path.parent.node;

        if (n.BlockStatement.check(parent) &&
            path.parent.name === "body" &&
            path.name === 0) {
            assert.strictEqual(parent.body[0], node);
            return true;
        }

        if (n.ExpressionStatement.check(parent) &&
            path.name === "expression") {
            assert.strictEqual(parent.expression, node);
            return true;
        }

        if (n.SequenceExpression.check(parent) &&
            path.parent.name === "expressions" &&
            path.name === 0) {
            assert.strictEqual(parent.expressions[0], node);
            continue;
        }

        if (n.CallExpression.check(parent) &&
            path.name === "callee") {
            assert.strictEqual(parent.callee, node);
            continue;
        }

        if (n.MemberExpression.check(parent) &&
            path.name === "object") {
            assert.strictEqual(parent.object, node);
            continue;
        }

        if (n.ConditionalExpression.check(parent) &&
            path.name === "test") {
            assert.strictEqual(parent.test, node);
            continue;
        }

        if (isBinary(parent) &&
            path.name === "left") {
            assert.strictEqual(parent.left, node);
            continue;
        }

        if (n.UnaryExpression.check(parent) &&
            !parent.prefix &&
            path.name === "argument") {
            assert.strictEqual(parent.argument, node);
            continue;
        }

        return false;
    }

    return true;
}

/**
 * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
 */
function cleanUpNodesAfterPrune(remainingNodePath) {
    if (n.VariableDeclaration.check(remainingNodePath.node)) {
        var declarations = remainingNodePath.get('declarations').value;
        if (!declarations || declarations.length === 0) {
            return remainingNodePath.prune();
        }
    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
        if (!remainingNodePath.get('expression').value) {
            return remainingNodePath.prune();
        }
    } else if (n.IfStatement.check(remainingNodePath.node)) {
        cleanUpIfStatementAfterPrune(remainingNodePath);
    }

    return remainingNodePath;
}

function cleanUpIfStatementAfterPrune(ifStatement) {
    var testExpression = ifStatement.get('test').value;
    var alternate = ifStatement.get('alternate').value;
    var consequent = ifStatement.get('consequent').value;

    if (!consequent && !alternate) {
        var testExpressionStatement = b.expressionStatement(testExpression);

        ifStatement.replace(testExpressionStatement);
    } else if (!consequent && alternate) {
        var negatedTestExpression = b.unaryExpression('!', testExpression, true);

        if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
            negatedTestExpression = testExpression.argument;
        }

        ifStatement.get("test").replace(negatedTestExpression);
        ifStatement.get("consequent").replace(alternate);
        ifStatement.get("alternate").replace();
    }
}

module.exports = NodePath;

},{"./path":264,"./scope":265,"./types":267,"assert":698,"util":723}],263:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var NodePath = require("./node-path");
var Printable = types.namedTypes.Printable;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var isFunction = types.builtInTypes.function;
var hasOwn = Object.prototype.hasOwnProperty;
var undefined;

function PathVisitor() {
    assert.ok(this instanceof PathVisitor);

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
        hasOwn.call(this._methodNameTable, "Block") ||
        hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}

function computeMethodNameTable(visitor) {
    var typeNames = Object.create(null);

    for (var methodName in visitor) {
        if (/^visit[A-Z]/.test(methodName)) {
            typeNames[methodName.slice("visit".length)] = true;
        }
    }

    var supertypeTable = types.computeSupertypeLookupTable(typeNames);
    var methodNameTable = Object.create(null);

    var typeNames = Object.keys(supertypeTable);
    var typeNameCount = typeNames.length;
    for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        methodName = "visit" + supertypeTable[typeName];
        if (isFunction.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
        }
    }

    return methodNameTable;
}

PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
    if (methods instanceof PathVisitor) {
        return methods;
    }

    if (!isObject.check(methods)) {
        // An empty visitor?
        return new PathVisitor;
    }

    function Visitor() {
        assert.ok(this instanceof Visitor);
        PathVisitor.call(this);
    }

    var Vp = Visitor.prototype = Object.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    return new Visitor;
};

function extend(target, source) {
    for (var property in source) {
        if (hasOwn.call(source, property)) {
            target[property] = source[property];
        }
    }

    return target;
}

PathVisitor.visit = function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
};

var PVp = PathVisitor.prototype;

var recursiveVisitWarning = [
    "Recursively calling visitor.visit(path) resets visitor state.",
    "Try this.visit(path) or this.traverse(path) instead."
].join(" ");

PVp.visit = function() {
    assert.ok(!this._visiting, recursiveVisitWarning);

    // Private state that needs to be reset before every traversal.
    this._visiting = true;
    this._changeReported = false;
    this._abortRequested = false;

    var argc = arguments.length;
    var args = new Array(argc)
    for (var i = 0; i < argc; ++i) {
        args[i] = arguments[i];
    }

    if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({ root: args[0] }).get("root");
    }

    // Called with the same arguments as .visit.
    this.reset.apply(this, args);

    try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
    } finally {
        this._visiting = false;

        if (!didNotThrow && this._abortRequested) {
            // If this.visitWithoutReset threw an exception and
            // this._abortRequested was set to true, return the root of
            // the AST instead of letting the exception propagate, so that
            // client code does not have to provide a try-catch block to
            // intercept the AbortRequest exception.  Other kinds of
            // exceptions will propagate without being intercepted and
            // rethrown by a catch block, so their stacks will accurately
            // reflect the original throwing context.
            return args[0].value;
        }
    }

    return root;
};

PVp.AbortRequest = function AbortRequest() {};
PVp.abort = function() {
    var visitor = this;
    visitor._abortRequested = true;
    var request = new visitor.AbortRequest();

    // If you decide to catch this exception and stop it from propagating,
    // make sure to call its cancel method to avoid silencing other
    // exceptions that might be thrown later in the traversal.
    request.cancel = function() {
        visitor._abortRequested = false;
    };

    throw request;
};

PVp.reset = function(path/*, additional arguments */) {
    // Empty stub; may be reassigned or overridden by subclasses.
};

PVp.visitWithoutReset = function(path) {
    if (this instanceof this.Context) {
        // Since this.Context.prototype === this, there's a chance we
        // might accidentally call context.visitWithoutReset. If that
        // happens, re-invoke the method against context.visitor.
        return this.visitor.visitWithoutReset(path);
    }

    assert.ok(path instanceof NodePath);
    var value = path.value;

    var methodName = Printable.check(value) && this._methodNameTable[value.type];
    if (methodName) {
        var context = this.acquireContext(path);
        try {
            return context.invokeVisitorMethod(methodName);
        } finally {
            this.releaseContext(context);
        }

    } else {
        // If there was no visitor method to call, visit the children of
        // this node generically.
        return visitChildren(path, this);
    }
};

function visitChildren(path, visitor) {
    assert.ok(path instanceof NodePath);
    assert.ok(visitor instanceof PathVisitor);

    var value = path.value;

    if (isArray.check(value)) {
        path.each(visitor.visitWithoutReset, visitor);
    } else if (!isObject.check(value)) {
        // No children to visit.
    } else {
        var childNames = types.getFieldNames(value);

        // The .comments field of the Node type is hidden, so we only
        // visit it if the visitor defines visitBlock or visitLine, and
        // value.comments is defined.
        if (visitor._shouldVisitComments &&
            value.comments &&
            childNames.indexOf("comments") < 0) {
            childNames.push("comments");
        }

        var childCount = childNames.length;
        var childPaths = [];

        for (var i = 0; i < childCount; ++i) {
            var childName = childNames[i];
            if (!hasOwn.call(value, childName)) {
                value[childName] = types.getFieldValue(value, childName);
            }
            childPaths.push(path.get(childName));
        }

        for (var i = 0; i < childCount; ++i) {
            visitor.visitWithoutReset(childPaths[i]);
        }
    }

    return path.value;
}

PVp.acquireContext = function(path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().reset(path);
};

PVp.releaseContext = function(context) {
    assert.ok(context instanceof this.Context);
    this._reusableContextStack.push(context);
    context.currentPath = null;
};

PVp.reportChanged = function() {
    this._changeReported = true;
};

PVp.wasChangeReported = function() {
    return this._changeReported;
};

function makeContextConstructor(visitor) {
    function Context(path) {
        assert.ok(this instanceof Context);
        assert.ok(this instanceof PathVisitor);
        assert.ok(path instanceof NodePath);

        Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: false,
            enumerable: true,
            configurable: false
        });

        this.currentPath = path;
        this.needToCallTraverse = true;

        Object.seal(this);
    }

    assert.ok(visitor instanceof PathVisitor);

    // Note that the visitor object is the prototype of Context.prototype,
    // so all visitor methods are inherited by context objects.
    var Cp = Context.prototype = Object.create(visitor);

    Cp.constructor = Context;
    extend(Cp, sharedContextProtoMethods);

    return Context;
}

// Every PathVisitor has a different this.Context constructor and
// this.Context.prototype object, but those prototypes can all use the
// same reset, invokeVisitorMethod, and traverse function objects.
var sharedContextProtoMethods = Object.create(null);

sharedContextProtoMethods.reset =
function reset(path) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);

    this.currentPath = path;
    this.needToCallTraverse = true;

    return this;
};

sharedContextProtoMethods.invokeVisitorMethod =
function invokeVisitorMethod(methodName) {
    assert.ok(this instanceof this.Context);
    assert.ok(this.currentPath instanceof NodePath);

    var result = this.visitor[methodName].call(this, this.currentPath);

    if (result === false) {
        // Visitor methods return false to indicate that they have handled
        // their own traversal needs, and we should not complain if
        // this.needToCallTraverse is still true.
        this.needToCallTraverse = false;

    } else if (result !== undefined) {
        // Any other non-undefined value returned from the visitor method
        // is interpreted as a replacement value.
        this.currentPath = this.currentPath.replace(result)[0];

        if (this.needToCallTraverse) {
            // If this.traverse still hasn't been called, visit the
            // children of the replacement node.
            this.traverse(this.currentPath);
        }
    }

    assert.strictEqual(
        this.needToCallTraverse, false,
        "Must either call this.traverse or return false in " + methodName
    );

    var path = this.currentPath;
    return path && path.value;
};

sharedContextProtoMethods.traverse =
function traverse(path, newVisitor) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);
    assert.ok(this.currentPath instanceof NodePath);

    this.needToCallTraverse = false;

    return visitChildren(path, PathVisitor.fromMethodsObject(
        newVisitor || this.visitor
    ));
};

sharedContextProtoMethods.visit =
function visit(path, newVisitor) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);
    assert.ok(this.currentPath instanceof NodePath);

    this.needToCallTraverse = false;

    return PathVisitor.fromMethodsObject(
        newVisitor || this.visitor
    ).visitWithoutReset(path);
};

sharedContextProtoMethods.reportChanged = function reportChanged() {
    this.visitor.reportChanged();
};

sharedContextProtoMethods.abort = function abort() {
    this.needToCallTraverse = false;
    this.visitor.abort();
};

module.exports = PathVisitor;

},{"./node-path":262,"./types":267,"assert":698}],264:[function(require,module,exports){
var assert = require("assert");
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var types = require("./types");
var isArray = types.builtInTypes.array;
var isNumber = types.builtInTypes.number;
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;

function Path(value, parentPath, name) {
    assert.ok(this instanceof Path);

    if (parentPath) {
        assert.ok(parentPath instanceof Path);
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}

var Pp = Path.prototype;

function getChildCache(path) {
    // Lazily create the child cache. This also cheapens cache
    // invalidation, since you can just reset path.__childCache to null.
    return path.__childCache || (path.__childCache = Object.create(null));
}

function getChildPath(path, name) {
    var cache = getChildCache(path);
    var actualChildValue = path.getValueProperty(name);
    var childPath = cache[name];
    if (!hasOwn.call(cache, name) ||
        // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) {
        childPath = cache[name] = new path.constructor(
            actualChildValue, path, name
        );
    }
    return childPath;
}

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
Pp.getValueProperty = function getValueProperty(name) {
    return this.value[name];
};

Pp.get = function get(name) {
    var path = this;
    var names = arguments;
    var count = names.length;

    for (var i = 0; i < count; ++i) {
        path = getChildPath(path, names[i]);
    }

    return path;
};

Pp.each = function each(callback, context) {
    var childPaths = [];
    var len = this.value.length;
    var i = 0;

    // Collect all the original child paths before invoking the callback.
    for (var i = 0; i < len; ++i) {
        if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
        }
    }

    // Invoke the callback on just the original child paths, regardless of
    // any modifications made to the array by the callback. I chose these
    // semantics over cleverly invoking the callback on new elements because
    // this way is much easier to reason about.
    context = context || this;
    for (i = 0; i < len; ++i) {
        if (hasOwn.call(childPaths, i)) {
            callback.call(context, childPaths[i]);
        }
    }
};

Pp.map = function map(callback, context) {
    var result = [];

    this.each(function(childPath) {
        result.push(callback.call(this, childPath));
    }, context);

    return result;
};

Pp.filter = function filter(callback, context) {
    var result = [];

    this.each(function(childPath) {
        if (callback.call(this, childPath)) {
            result.push(childPath);
        }
    }, context);

    return result;
};

function emptyMoves() {}
function getMoves(path, offset, start, end) {
    isArray.assert(path.value);

    if (offset === 0) {
        return emptyMoves;
    }

    var length = path.value.length;
    if (length < 1) {
        return emptyMoves;
    }

    var argc = arguments.length;
    if (argc === 2) {
        start = 0;
        end = length;
    } else if (argc === 3) {
        start = Math.max(start, 0);
        end = length;
    } else {
        start = Math.max(start, 0);
        end = Math.min(end, length);
    }

    isNumber.assert(start);
    isNumber.assert(end);

    var moves = Object.create(null);
    var cache = getChildCache(path);

    for (var i = start; i < end; ++i) {
        if (hasOwn.call(path.value, i)) {
            var childPath = path.get(i);
            assert.strictEqual(childPath.name, i);
            var newIndex = i + offset;
            childPath.name = newIndex;
            moves[newIndex] = childPath;
            delete cache[i];
        }
    }

    delete cache.length;

    return function() {
        for (var newIndex in moves) {
            var childPath = moves[newIndex];
            assert.strictEqual(childPath.name, +newIndex);
            cache[newIndex] = childPath;
            path.value[newIndex] = childPath.value;
        }
    };
}

Pp.shift = function shift() {
    var move = getMoves(this, -1);
    var result = this.value.shift();
    move();
    return result;
};

Pp.unshift = function unshift(node) {
    var move = getMoves(this, arguments.length);
    var result = this.value.unshift.apply(this.value, arguments);
    move();
    return result;
};

Pp.push = function push(node) {
    isArray.assert(this.value);
    delete getChildCache(this).length
    return this.value.push.apply(this.value, arguments);
};

Pp.pop = function pop() {
    isArray.assert(this.value);
    var cache = getChildCache(this);
    delete cache[this.value.length - 1];
    delete cache.length;
    return this.value.pop();
};

Pp.insertAt = function insertAt(index, node) {
    var argc = arguments.length;
    var move = getMoves(this, argc - 1, index);
    if (move === emptyMoves) {
        return this;
    }

    index = Math.max(index, 0);

    for (var i = 1; i < argc; ++i) {
        this.value[index + i - 1] = arguments[i];
    }

    move();

    return this;
};

Pp.insertBefore = function insertBefore(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name];
    for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
};

Pp.insertAfter = function insertAfter(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name + 1];
    for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
};

function repairRelationshipWithParent(path) {
    assert.ok(path instanceof Path);

    var pp = path.parentPath;
    if (!pp) {
        // Orphan paths have no relationship to repair.
        return path;
    }

    var parentValue = pp.value;
    var parentCache = getChildCache(pp);

    // Make sure parentCache[path.name] is populated.
    if (parentValue[path.name] === path.value) {
        parentCache[path.name] = path;
    } else if (isArray.check(parentValue)) {
        // Something caused path.name to become out of date, so attempt to
        // recover by searching for path.value in parentValue.
        var i = parentValue.indexOf(path.value);
        if (i >= 0) {
            parentCache[path.name = i] = path;
        }
    } else {
        // If path.value disagrees with parentValue[path.name], and
        // path.name is not an array index, let path.value become the new
        // parentValue[path.name] and update parentCache accordingly.
        parentValue[path.name] = path.value;
        parentCache[path.name] = path;
    }

    assert.strictEqual(parentValue[path.name], path.value);
    assert.strictEqual(path.parentPath.get(path.name), path);

    return path;
}

Pp.replace = function replace(replacement) {
    var results = [];
    var parentValue = this.parentPath.value;
    var parentCache = getChildCache(this.parentPath);
    var count = arguments.length;

    repairRelationshipWithParent(this);

    if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);

        var spliceArgs = [this.name, 1];
        for (var i = 0; i < count; ++i) {
            spliceArgs.push(arguments[i]);
        }

        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

        assert.strictEqual(splicedOut[0], this.value);
        assert.strictEqual(
            parentValue.length,
            originalLength - 1 + count
        );

        move();

        if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;

        } else {
            assert.strictEqual(parentValue[this.name], replacement);

            if (this.value !== replacement) {
                this.value = replacement;
                this.__childCache = null;
            }

            for (i = 0; i < count; ++i) {
                results.push(this.parentPath.get(this.name + i));
            }

            assert.strictEqual(results[0], this);
        }

    } else if (count === 1) {
        if (this.value !== replacement) {
            this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);

    } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;

        // Leave this path cached as parentCache[this.name], even though
        // it no longer has a value defined.

    } else {
        assert.ok(false, "Could not replace path");
    }

    return results;
};

module.exports = Path;

},{"./types":267,"assert":698}],265:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var Type = types.Type;
var namedTypes = types.namedTypes;
var Node = namedTypes.Node;
var Expression = namedTypes.Expression;
var isArray = types.builtInTypes.array;
var hasOwn = Object.prototype.hasOwnProperty;
var b = types.builders;

function Scope(path, parentScope) {
    assert.ok(this instanceof Scope);
    assert.ok(path instanceof require("./node-path"));
    ScopeType.assert(path.value);

    var depth;

    if (parentScope) {
        assert.ok(parentScope instanceof Scope);
        depth = parentScope.depth + 1;
    } else {
        parentScope = null;
        depth = 0;
    }

    Object.defineProperties(this, {
        path: { value: path },
        node: { value: path.value },
        isGlobal: { value: !parentScope, enumerable: true },
        depth: { value: depth },
        parent: { value: parentScope },
        bindings: { value: {} }
    });
}

var scopeTypes = [
    // Program nodes introduce global scopes.
    namedTypes.Program,

    // Function is the supertype of FunctionExpression,
    // FunctionDeclaration, ArrowExpression, etc.
    namedTypes.Function,

    // In case you didn't know, the caught parameter shadows any variable
    // of the same name in an outer scope.
    namedTypes.CatchClause
];

var ScopeType = Type.or.apply(Type, scopeTypes);

Scope.isEstablishedBy = function(node) {
    return ScopeType.check(node);
};

var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
Sp.didScan = false;

Sp.declares = function(name) {
    this.scan();
    return hasOwn.call(this.bindings, name);
};

Sp.declareTemporary = function(prefix) {
    if (prefix) {
        assert.ok(/^[a-z$_]/i.test(prefix), prefix);
    } else {
        prefix = "t$";
    }

    // Include this.depth in the name to make sure the name does not
    // collide with any variables in nested/enclosing scopes.
    prefix += this.depth.toString(36) + "$";

    this.scan();

    var index = 0;
    while (this.declares(prefix + index)) {
        ++index;
    }

    var name = prefix + index;
    return this.bindings[name] = types.builders.identifier(name);
};

Sp.injectTemporary = function(identifier, init) {
    identifier || (identifier = this.declareTemporary());

    var bodyPath = this.path.get("body");
    if (namedTypes.BlockStatement.check(bodyPath.value)) {
        bodyPath = bodyPath.get("body");
    }

    bodyPath.unshift(
        b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
        )
    );

    return identifier;
};

Sp.scan = function(force) {
    if (force || !this.didScan) {
        for (var name in this.bindings) {
            // Empty out this.bindings, just in cases.
            delete this.bindings[name];
        }
        scanScope(this.path, this.bindings);
        this.didScan = true;
    }
};

Sp.getBindings = function () {
    this.scan();
    return this.bindings;
};

function scanScope(path, bindings) {
    var node = path.value;
    ScopeType.assert(node);

    if (namedTypes.CatchClause.check(node)) {
        // A catch clause establishes a new scope but the only variable
        // bound in that scope is the catch parameter. Any other
        // declarations create bindings in the outer scope.
        addPattern(path.get("param"), bindings);

    } else {
        recursiveScanScope(path, bindings);
    }
}

function recursiveScanScope(path, bindings) {
    var node = path.value;

    if (path.parent &&
        namedTypes.FunctionExpression.check(path.parent.node) &&
        path.parent.node.id) {
        addPattern(path.parent.get("id"), bindings);
    }

    if (!node) {
        // None of the remaining cases matter if node is falsy.

    } else if (isArray.check(node)) {
        path.each(function(childPath) {
            recursiveScanChild(childPath, bindings);
        });

    } else if (namedTypes.Function.check(node)) {
        path.get("params").each(function(paramPath) {
            addPattern(paramPath, bindings);
        });

        recursiveScanChild(path.get("body"), bindings);

    } else if (namedTypes.VariableDeclarator.check(node)) {
        addPattern(path.get("id"), bindings);
        recursiveScanChild(path.get("init"), bindings);

    } else if (node.type === "ImportSpecifier" ||
               node.type === "ImportNamespaceSpecifier" ||
               node.type === "ImportDefaultSpecifier") {
        addPattern(
            node.name ? path.get("name") : path.get("id"),
            bindings
        );

    } else if (Node.check(node) && !Expression.check(node)) {
        types.eachField(node, function(name, child) {
            var childPath = path.get(name);
            assert.strictEqual(childPath.value, child);
            recursiveScanChild(childPath, bindings);
        });
    }
}

function recursiveScanChild(path, bindings) {
    var node = path.value;

    if (!node || Expression.check(node)) {
        // Ignore falsy values and Expressions.

    } else if (namedTypes.FunctionDeclaration.check(node)) {
        addPattern(path.get("id"), bindings);

    } else if (namedTypes.ClassDeclaration &&
               namedTypes.ClassDeclaration.check(node)) {
        addPattern(path.get("id"), bindings);

    } else if (ScopeType.check(node)) {
        if (namedTypes.CatchClause.check(node)) {
            var catchParamName = node.param.name;
            var hadBinding = hasOwn.call(bindings, catchParamName);

            // Any declarations that occur inside the catch body that do
            // not have the same name as the catch parameter should count
            // as bindings in the outer scope.
            recursiveScanScope(path.get("body"), bindings);

            // If a new binding matching the catch parameter name was
            // created while scanning the catch body, ignore it because it
            // actually refers to the catch parameter and not the outer
            // scope that we're currently scanning.
            if (!hadBinding) {
                delete bindings[catchParamName];
            }
        }

    } else {
        recursiveScanScope(path, bindings);
    }
}

function addPattern(patternPath, bindings) {
    var pattern = patternPath.value;
    namedTypes.Pattern.assert(pattern);

    if (namedTypes.Identifier.check(pattern)) {
        if (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
        } else {
            bindings[pattern.name] = [patternPath];
        }

    } else if (namedTypes.ObjectPattern &&
               namedTypes.ObjectPattern.check(pattern)) {
        patternPath.get('properties').each(function(propertyPath) {
            var property = propertyPath.value;
            if (namedTypes.Pattern.check(property)) {
                addPattern(propertyPath, bindings);
            } else  if (namedTypes.Property.check(property)) {
                addPattern(propertyPath.get('value'), bindings);
            } else if (namedTypes.SpreadProperty &&
                       namedTypes.SpreadProperty.check(property)) {
                addPattern(propertyPath.get('argument'), bindings);
            }
        });

    } else if (namedTypes.ArrayPattern &&
               namedTypes.ArrayPattern.check(pattern)) {
        patternPath.get('elements').each(function(elementPath) {
            var element = elementPath.value;
            if (namedTypes.Pattern.check(element)) {
                addPattern(elementPath, bindings);
            } else if (namedTypes.SpreadElement &&
                       namedTypes.SpreadElement.check(element)) {
                addPattern(elementPath.get("argument"), bindings);
            }
        });

    } else if (namedTypes.PropertyPattern &&
               namedTypes.PropertyPattern.check(pattern)) {
        addPattern(patternPath.get('pattern'), bindings);

    } else if ((namedTypes.SpreadElementPattern &&
                namedTypes.SpreadElementPattern.check(pattern)) ||
               (namedTypes.SpreadPropertyPattern &&
                namedTypes.SpreadPropertyPattern.check(pattern))) {
        addPattern(patternPath.get('argument'), bindings);
    }
}

Sp.lookup = function(name) {
    for (var scope = this; scope; scope = scope.parent)
        if (scope.declares(name))
            break;
    return scope;
};

Sp.getGlobalScope = function() {
    var scope = this;
    while (!scope.isGlobal)
        scope = scope.parent;
    return scope;
};

module.exports = Scope;

},{"./node-path":262,"./types":267,"assert":698}],266:[function(require,module,exports){
var types = require("../lib/types");
var Type = types.Type;
var builtin = types.builtInTypes;
var isNumber = builtin.number;

// An example of constructing a new type with arbitrary constraints from
// an existing type.
exports.geq = function(than) {
    return new Type(function(value) {
        return isNumber.check(value) && value >= than;
    }, isNumber + " >= " + than);
};

// Default value-returning functions that may optionally be passed as a
// third argument to Def.prototype.field.
exports.defaults = {
    // Functions were used because (among other reasons) that's the most
    // elegant way to allow for the emptyArray one always to give a new
    // array instance.
    "null": function() { return null },
    "emptyArray": function() { return [] },
    "false": function() { return false },
    "true": function() { return true },
    "undefined": function() {}
};

var naiveIsPrimitive = Type.or(
    builtin.string,
    builtin.number,
    builtin.boolean,
    builtin.null,
    builtin.undefined
);

exports.isPrimitive = new Type(function(value) {
    if (value === null)
        return true;
    var type = typeof value;
    return !(type === "object" ||
             type === "function");
}, naiveIsPrimitive.toString());

},{"../lib/types":267}],267:[function(require,module,exports){
var assert = require("assert");
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;
var each = Ap.forEach;
var Op = Object.prototype;
var objToStr = Op.toString;
var funObjStr = objToStr.call(function(){});
var strObjStr = objToStr.call("");
var hasOwn = Op.hasOwnProperty;

// A type is an object with a .check method that takes a value and returns
// true or false according to whether the value matches the type.

function Type(check, name) {
    var self = this;
    assert.ok(self instanceof Type, self);

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    assert.strictEqual(objToStr.call(check), funObjStr,
                       check + " is not a function");

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    assert.ok(nameObjStr === funObjStr ||
              nameObjStr === strObjStr,
              name + " is neither a function nor a string");

    Object.defineProperties(self, {
        name: { value: name },
        check: {
            value: function(value, deep) {
                var result = check.call(self, value, deep);
                if (!result && deep && objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}

var Tp = Type.prototype;

// Throughout this file we use Object.defineProperty to prevent
// redefinition of exported properties.
exports.Type = Type;

// Like .check, except that failure triggers an AssertionError.
Tp.assert = function(value, deep) {
    if (!this.check(value, deep)) {
        var str = shallowStringify(value);
        assert.ok(false, str + " does not match type " + this);
        return false;
    }
    return true;
};

function shallowStringify(value) {
    if (isObject.check(value))
        return "{" + Object.keys(value).map(function(key) {
            return key + ": " + value[key];
        }).join(", ") + "}";

    if (isArray.check(value))
        return "[" + value.map(shallowStringify).join(", ") + "]";

    return JSON.stringify(value);
}

Tp.toString = function() {
    var name = this.name;

    if (isString.check(name))
        return name;

    if (isFunction.check(name))
        return name.call(this) + "";

    return name + " type";
};

var builtInTypes = {};
exports.builtInTypes = builtInTypes;

function defBuiltInType(example, name) {
    var objStr = objToStr.call(example);

    Object.defineProperty(builtInTypes, name, {
        enumerable: true,
        value: new Type(function(value) {
            return objToStr.call(value) === objStr;
        }, name)
    });

    return builtInTypes[name];
}

// These types check the underlying [[Class]] attribute of the given
// value, rather than using the problematic typeof operator. Note however
// that no subtyping is considered; so, for instance, isObject.check
// returns false for [], /./, new Date, and null.
var isString = defBuiltInType("", "string");
var isFunction = defBuiltInType(function(){}, "function");
var isArray = defBuiltInType([], "array");
var isObject = defBuiltInType({}, "object");
var isRegExp = defBuiltInType(/./, "RegExp");
var isDate = defBuiltInType(new Date, "Date");
var isNumber = defBuiltInType(3, "number");
var isBoolean = defBuiltInType(true, "boolean");
var isNull = defBuiltInType(null, "null");
var isUndefined = defBuiltInType(void 0, "undefined");

// There are a number of idiomatic ways of expressing types, so this
// function serves to coerce them all to actual Type objects. Note that
// providing the name argument is not necessary in most cases.
function toType(from, name) {
    // The toType function should of course be idempotent.
    if (from instanceof Type)
        return from;

    // The Def type is used as a helper for constructing compound
    // interface types for AST nodes.
    if (from instanceof Def)
        return from.type;

    // Support [ElemType] syntax.
    if (isArray.check(from))
        return Type.fromArray(from);

    // Support { someField: FieldType, ... } syntax.
    if (isObject.check(from))
        return Type.fromObject(from);

    // If isFunction.check(from), assume that from is a binary predicate
    // function we can use to define the type.
    if (isFunction.check(from))
        return new Type(from, name);

    // As a last resort, toType returns a type that matches any value that
    // is === from. This is primarily useful for literal values like
    // toType(null), but it has the additional advantage of allowing
    // toType to be a total function.
    return new Type(function(value) {
        return value === from;
    }, isUndefined.check(name) ? function() {
        return from + "";
    } : name);
}

// Returns a type that matches the given value iff any of type1, type2,
// etc. match the value.
Type.or = function(/* type1, type2, ... */) {
    var types = [];
    var len = arguments.length;
    for (var i = 0; i < len; ++i)
        types.push(toType(arguments[i]));

    return new Type(function(value, deep) {
        for (var i = 0; i < len; ++i)
            if (types[i].check(value, deep))
                return true;
        return false;
    }, function() {
        return types.join(" | ");
    });
};

Type.fromArray = function(arr) {
    assert.ok(isArray.check(arr));
    assert.strictEqual(
        arr.length, 1,
        "only one element type is permitted for typed arrays");
    return toType(arr[0]).arrayOf();
};

Tp.arrayOf = function() {
    var elemType = this;
    return new Type(function(value, deep) {
        return isArray.check(value) && value.every(function(elem) {
            return elemType.check(elem, deep);
        });
    }, function() {
        return "[" + elemType + "]";
    });
};

Type.fromObject = function(obj) {
    var fields = Object.keys(obj).map(function(name) {
        return new Field(name, obj[name]);
    });

    return new Type(function(value, deep) {
        return isObject.check(value) && fields.every(function(field) {
            return field.type.check(value[field.name], deep);
        });
    }, function() {
        return "{ " + fields.join(", ") + " }";
    });
};

function Field(name, type, defaultFn, hidden) {
    var self = this;

    assert.ok(self instanceof Field);
    isString.assert(name);

    type = toType(type);

    var properties = {
        name: { value: name },
        type: { value: type },
        hidden: { value: !!hidden }
    };

    if (isFunction.check(defaultFn)) {
        properties.defaultFn = { value: defaultFn };
    }

    Object.defineProperties(self, properties);
}

var Fp = Field.prototype;

Fp.toString = function() {
    return JSON.stringify(this.name) + ": " + this.type;
};

Fp.getValue = function(obj) {
    var value = obj[this.name];

    if (!isUndefined.check(value))
        return value;

    if (this.defaultFn)
        value = this.defaultFn.call(obj);

    return value;
};

// Define a type whose name is registered in a namespace (the defCache) so
// that future definitions will return the same type given the same name.
// In particular, this system allows for circular and forward definitions.
// The Def object d returned from Type.def may be used to configure the
// type d.type by calling methods such as d.bases, d.build, and d.field.
Type.def = function(typeName) {
    isString.assert(typeName);
    return hasOwn.call(defCache, typeName)
        ? defCache[typeName]
        : defCache[typeName] = new Def(typeName);
};

// In order to return the same Def instance every time Type.def is called
// with a particular name, those instances need to be stored in a cache.
var defCache = Object.create(null);

function Def(typeName) {
    var self = this;
    assert.ok(self instanceof Def);

    Object.defineProperties(self, {
        typeName: { value: typeName },
        baseNames: { value: [] },
        ownFields: { value: Object.create(null) },

        // These two are populated during finalization.
        allSupertypes: { value: Object.create(null) }, // Includes own typeName.
        supertypeList: { value: [] }, // Linear inheritance hierarchy.
        allFields: { value: Object.create(null) }, // Includes inherited fields.
        fieldNames: { value: [] }, // Non-hidden keys of allFields.

        type: {
            value: new Type(function(value, deep) {
                return self.check(value, deep);
            }, typeName)
        }
    });
}

Def.fromValue = function(value) {
    if (value && typeof value === "object") {
        var type = value.type;
        if (typeof type === "string" &&
            hasOwn.call(defCache, type)) {
            var d = defCache[type];
            if (d.finalized) {
                return d;
            }
        }
    }

    return null;
};

var Dp = Def.prototype;

Dp.isSupertypeOf = function(that) {
    if (that instanceof Def) {
        assert.strictEqual(this.finalized, true);
        assert.strictEqual(that.finalized, true);
        return hasOwn.call(that.allSupertypes, this.typeName);
    } else {
        assert.ok(false, that + " is not a Def");
    }
};

// Note that the list returned by this function is a copy of the internal
// supertypeList, *without* the typeName itself as the first element.
exports.getSupertypeNames = function(typeName) {
    assert.ok(hasOwn.call(defCache, typeName));
    var d = defCache[typeName];
    assert.strictEqual(d.finalized, true);
    return d.supertypeList.slice(1);
};

// Returns an object mapping from every known type in the defCache to the
// most specific supertype whose name is an own property of the candidates
// object.
exports.computeSupertypeLookupTable = function(candidates) {
    var table = {};
    var typeNames = Object.keys(defCache);
    var typeNameCount = typeNames.length;

    for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        var d = defCache[typeName];
        assert.strictEqual(d.finalized, true);
        for (var j = 0; j < d.supertypeList.length; ++j) {
            var superTypeName = d.supertypeList[j];
            if (hasOwn.call(candidates, superTypeName)) {
                table[typeName] = superTypeName;
                break;
            }
        }
    }

    return table;
};

Dp.checkAllFields = function(value, deep) {
    var allFields = this.allFields;
    assert.strictEqual(this.finalized, true);

    function checkFieldByName(name) {
        var field = allFields[name];
        var type = field.type;
        var child = field.getValue(value);
        return type.check(child, deep);
    }

    return isObject.check(value)
        && Object.keys(allFields).every(checkFieldByName);
};

Dp.check = function(value, deep) {
    assert.strictEqual(
        this.finalized, true,
        "prematurely checking unfinalized type " + this.typeName);

    // A Def type can only match an object value.
    if (!isObject.check(value))
        return false;

    var vDef = Def.fromValue(value);
    if (!vDef) {
        // If we couldn't infer the Def associated with the given value,
        // and we expected it to be a SourceLocation or a Position, it was
        // probably just missing a "type" field (because Esprima does not
        // assign a type property to such nodes). Be optimistic and let
        // this.checkAllFields make the final decision.
        if (this.typeName === "SourceLocation" ||
            this.typeName === "Position") {
            return this.checkAllFields(value, deep);
        }

        // Calling this.checkAllFields for any other type of node is both
        // bad for performance and way too forgiving.
        return false;
    }

    // If checking deeply and vDef === this, then we only need to call
    // checkAllFields once. Calling checkAllFields is too strict when deep
    // is false, because then we only care about this.isSupertypeOf(vDef).
    if (deep && vDef === this)
        return this.checkAllFields(value, deep);

    // In most cases we rely exclusively on isSupertypeOf to make O(1)
    // subtyping determinations. This suffices in most situations outside
    // of unit tests, since interface conformance is checked whenever new
    // instances are created using builder functions.
    if (!this.isSupertypeOf(vDef))
        return false;

    // The exception is when deep is true; then, we recursively check all
    // fields.
    if (!deep)
        return true;

    // Use the more specific Def (vDef) to perform the deep check, but
    // shallow-check fields defined by the less specific Def (this).
    return vDef.checkAllFields(value, deep)
        && this.checkAllFields(value, false);
};

Dp.bases = function() {
    var bases = this.baseNames;

    assert.strictEqual(this.finalized, false);

    each.call(arguments, function(baseName) {
        isString.assert(baseName);

        // This indexOf lookup may be O(n), but the typical number of base
        // names is very small, and indexOf is a native Array method.
        if (bases.indexOf(baseName) < 0)
            bases.push(baseName);
    });

    return this; // For chaining.
};

// False by default until .build(...) is called on an instance.
Object.defineProperty(Dp, "buildable", { value: false });

var builders = {};
exports.builders = builders;

// This object is used as prototype for any node created by a builder.
var nodePrototype = {};

// Call this function to define a new method to be shared by all AST
// nodes. The replaced method (if any) is returned for easy wrapping.
exports.defineMethod = function(name, func) {
    var old = nodePrototype[name];

    // Pass undefined as func to delete nodePrototype[name].
    if (isUndefined.check(func)) {
        delete nodePrototype[name];

    } else {
        isFunction.assert(func);

        Object.defineProperty(nodePrototype, name, {
            enumerable: true, // For discoverability.
            configurable: true, // For delete proto[name].
            value: func
        });
    }

    return old;
};

// Calling the .build method of a Def simultaneously marks the type as
// buildable (by defining builders[getBuilderName(typeName)]) and
// specifies the order of arguments that should be passed to the builder
// function to create an instance of the type.
Dp.build = function(/* param1, param2, ... */) {
    var self = this;

    // Calling Def.prototype.build multiple times has the effect of merely
    // redefining this property.
    Object.defineProperty(self, "buildParams", {
        value: slice.call(arguments),
        writable: false,
        enumerable: false,
        configurable: true
    });

    assert.strictEqual(self.finalized, false);
    isString.arrayOf().assert(self.buildParams);

    if (self.buildable) {
        // If this Def is already buildable, update self.buildParams and
        // continue using the old builder function.
        return self;
    }

    // Every buildable type will have its "type" field filled in
    // automatically. This includes types that are not subtypes of Node,
    // like SourceLocation, but that seems harmless (TODO?).
    self.field("type", self.typeName, function() { return self.typeName });

    // Override Dp.buildable for this Def instance.
    Object.defineProperty(self, "buildable", { value: true });

    Object.defineProperty(builders, getBuilderName(self.typeName), {
        enumerable: true,

        value: function() {
            var args = arguments;
            var argc = args.length;
            var built = Object.create(nodePrototype);

            assert.ok(
                self.finalized,
                "attempting to instantiate unfinalized type " + self.typeName);

            function add(param, i) {
                if (hasOwn.call(built, param))
                    return;

                var all = self.allFields;
                assert.ok(hasOwn.call(all, param), param);

                var field = all[param];
                var type = field.type;
                var value;

                if (isNumber.check(i) && i < argc) {
                    value = args[i];
                } else if (field.defaultFn) {
                    // Expose the partially-built object to the default
                    // function as its `this` object.
                    value = field.defaultFn.call(built);
                } else {
                    var message = "no value or default function given for field " +
                        JSON.stringify(param) + " of " + self.typeName + "(" +
                            self.buildParams.map(function(name) {
                                return all[name];
                            }).join(", ") + ")";
                    assert.ok(false, message);
                }

                if (!type.check(value)) {
                    assert.ok(
                        false,
                        shallowStringify(value) +
                            " does not match field " + field +
                            " of type " + self.typeName
                    );
                }

                // TODO Could attach getters and setters here to enforce
                // dynamic type safety.
                built[param] = value;
            }

            self.buildParams.forEach(function(param, i) {
                add(param, i);
            });

            Object.keys(self.allFields).forEach(function(param) {
                add(param); // Use the default value.
            });

            // Make sure that the "type" field was filled automatically.
            assert.strictEqual(built.type, self.typeName);

            return built;
        }
    });

    return self; // For chaining.
};

function getBuilderName(typeName) {
    return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
        var len = upperCasePrefix.length;
        switch (len) {
        case 0: return "";
        // If there's only one initial capital letter, just lower-case it.
        case 1: return upperCasePrefix.toLowerCase();
        default:
            // If there's more than one initial capital letter, lower-case
            // all but the last one, so that XMLDefaultDeclaration (for
            // example) becomes xmlDefaultDeclaration.
            return upperCasePrefix.slice(
                0, len - 1).toLowerCase() +
                upperCasePrefix.charAt(len - 1);
        }
    });
}

// The reason fields are specified using .field(...) instead of an object
// literal syntax is somewhat subtle: the object literal syntax would
// support only one key and one value, but with .field(...) we can pass
// any number of arguments to specify the field.
Dp.field = function(name, type, defaultFn, hidden) {
    assert.strictEqual(this.finalized, false);
    this.ownFields[name] = new Field(name, type, defaultFn, hidden);
    return this; // For chaining.
};

var namedTypes = {};
exports.namedTypes = namedTypes;

// Like Object.keys, but aware of what fields each AST type should have.
function getFieldNames(object) {
    var d = Def.fromValue(object);
    if (d) {
        return d.fieldNames.slice(0);
    }

    if ("type" in object) {
        assert.ok(
            false,
            "did not recognize object of type " +
                JSON.stringify(object.type)
        );
    }

    return Object.keys(object);
}
exports.getFieldNames = getFieldNames;

// Get the value of an object property, taking object.type and default
// functions into account.
function getFieldValue(object, fieldName) {
    var d = Def.fromValue(object);
    if (d) {
        var field = d.allFields[fieldName];
        if (field) {
            return field.getValue(object);
        }
    }

    return object[fieldName];
}
exports.getFieldValue = getFieldValue;

// Iterate over all defined fields of an object, including those missing
// or undefined, passing each field name and effective value (as returned
// by getFieldValue) to the callback. If the object has no corresponding
// Def, the callback will never be called.
exports.eachField = function(object, callback, context) {
    getFieldNames(object).forEach(function(name) {
        callback.call(this, name, getFieldValue(object, name));
    }, context);
};

// Similar to eachField, except that iteration stops as soon as the
// callback returns a truthy value. Like Array.prototype.some, the final
// result is either true or false to indicates whether the callback
// returned true for any element or not.
exports.someField = function(object, callback, context) {
    return getFieldNames(object).some(function(name) {
        return callback.call(this, name, getFieldValue(object, name));
    }, context);
};

// This property will be overridden as true by individual Def instances
// when they are finalized.
Object.defineProperty(Dp, "finalized", { value: false });

Dp.finalize = function() {
    // It's not an error to finalize a type more than once, but only the
    // first call to .finalize does anything.
    if (!this.finalized) {
        var allFields = this.allFields;
        var allSupertypes = this.allSupertypes;

        this.baseNames.forEach(function(name) {
            var def = defCache[name];
            def.finalize();
            extend(allFields, def.allFields);
            extend(allSupertypes, def.allSupertypes);
        });

        // TODO Warn if fields are overridden with incompatible types.
        extend(allFields, this.ownFields);
        allSupertypes[this.typeName] = this;

        this.fieldNames.length = 0;
        for (var fieldName in allFields) {
            if (hasOwn.call(allFields, fieldName) &&
                !allFields[fieldName].hidden) {
                this.fieldNames.push(fieldName);
            }
        }

        // Types are exported only once they have been finalized.
        Object.defineProperty(namedTypes, this.typeName, {
            enumerable: true,
            value: this.type
        });

        Object.defineProperty(this, "finalized", { value: true });

        // A linearization of the inheritance hierarchy.
        populateSupertypeList(this.typeName, this.supertypeList);
    }
};

function populateSupertypeList(typeName, list) {
    list.length = 0;
    list.push(typeName);

    var lastSeen = Object.create(null);

    for (var pos = 0; pos < list.length; ++pos) {
        typeName = list[pos];
        var d = defCache[typeName];
        assert.strictEqual(d.finalized, true);

        // If we saw typeName earlier in the breadth-first traversal,
        // delete the last-seen occurrence.
        if (hasOwn.call(lastSeen, typeName)) {
            delete list[lastSeen[typeName]];
        }

        // Record the new index of the last-seen occurrence of typeName.
        lastSeen[typeName] = pos;

        // Enqueue the base names of this type.
        list.push.apply(list, d.baseNames);
    }

    // Compaction loop to remove array holes.
    for (var to = 0, from = to, len = list.length; from < len; ++from) {
        if (hasOwn.call(list, from)) {
            list[to++] = list[from];
        }
    }

    list.length = to;
}

function extend(into, from) {
    Object.keys(from).forEach(function(name) {
        into[name] = from[name];
    });

    return into;
};

exports.finalize = function() {
    Object.keys(defCache).forEach(function(name) {
        defCache[name].finalize();
    });
};

},{"assert":698}],268:[function(require,module,exports){
var types = require("./lib/types");

// This core module of AST types captures ES5 as it is parsed today by
// git://github.com/ariya/esprima.git#master.
require("./def/core");

// Feel free to add to or remove from this list of extension modules to
// configure the precise type hierarchy that you need.
require("./def/es6");
require("./def/es7");
require("./def/mozilla");
require("./def/e4x");
require("./def/fb-harmony");

types.finalize();

exports.Type = types.Type;
exports.builtInTypes = types.builtInTypes;
exports.namedTypes = types.namedTypes;
exports.builders = types.builders;
exports.defineMethod = types.defineMethod;
exports.getFieldNames = types.getFieldNames;
exports.getFieldValue = types.getFieldValue;
exports.eachField = types.eachField;
exports.someField = types.someField;
exports.getSupertypeNames = types.getSupertypeNames;
exports.astNodesAreEquivalent = require("./lib/equiv");
exports.finalize = types.finalize;
exports.NodePath = require("./lib/node-path");
exports.PathVisitor = require("./lib/path-visitor");
exports.visit = exports.PathVisitor.visit;

},{"./def/core":255,"./def/e4x":256,"./def/es6":257,"./def/es7":258,"./def/fb-harmony":259,"./def/mozilla":260,"./lib/equiv":261,"./lib/node-path":262,"./lib/path-visitor":263,"./lib/types":267}],269:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (process.platform === 'win32') {
	ansiStyles.blue.open = '\u001b[94m';
}

function build(_styles) {
	var builder = function builder() {
		return applyStyle.apply(builder, arguments);
	};
	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	builder.__proto__ = proto;
	return builder;
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);
	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	/*jshint validthis: true */
	var nestedStyles = this._styles;

	var i = nestedStyles.length;
	while (i--) {
		var code = ansiStyles[nestedStyles[i]];
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))
},{"_process":707,"ansi-styles":270,"escape-string-regexp":271,"has-ansi":272,"strip-ansi":274,"supports-color":276}],270:[function(require,module,exports){
'use strict';

var styles = module.exports = {
	modifiers: {
		reset: [0, 0],
		bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	colors: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		gray: [90, 39]
	},
	bgColors: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49]
	}
};

// fix humans
styles.colors.grey = styles.colors.gray;

Object.keys(styles).forEach(function (groupName) {
	var group = styles[groupName];

	Object.keys(group).forEach(function (styleName) {
		var style = group[styleName];

		styles[styleName] = group[styleName] = {
			open: '\u001b[' + style[0] + 'm',
			close: '\u001b[' + style[1] + 'm'
		};
	});

	Object.defineProperty(styles, groupName, {
		value: group,
		enumerable: false
	});
});

},{}],271:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe,  '\\$&');
};

},{}],272:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":273}],273:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/g;
};

},{}],274:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":275}],275:[function(require,module,exports){
module.exports=require(273)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/chalk/node_modules/has-ansi/node_modules/ansi-regex/index.js":273}],276:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (argv.indexOf('--no-color') !== -1 ||
		argv.indexOf('--no-colors') !== -1 ||
		argv.indexOf('--color=false') !== -1) {
		return false;
	}

	if (argv.indexOf('--color') !== -1 ||
		argv.indexOf('--colors') !== -1 ||
		argv.indexOf('--color=true') !== -1 ||
		argv.indexOf('--color=always') !== -1) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if ('UPSTART_JOB' in process.env) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))
},{"_process":707}],277:[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : core.dict                                                         *
 ******************************************************************************/

!function(DICT){
  Dict = function(iterable){
    var dict = create(null);
    if(iterable != undefined){
      if(isIterable(iterable)){
        forOf(iterable, true, function(key, value){
          dict[key] = value;
        });
      } else assign(dict, iterable);
    }
    return dict;
  }
  Dict[PROTOTYPE] = null;
  
  function DictIterator(iterated, kind){
    set(this, ITER, {o: toObject(iterated), a: getKeys(iterated), i: 0, k: kind});
  }
  createIterator(DictIterator, DICT, function(){
    var iter = this[ITER]
      , O    = iter.o
      , keys = iter.a
      , kind = iter.k
      , key;
    do {
      if(iter.i >= keys.length){
        iter.o = undefined;
        return iterResult(1);
      }
    } while(!has(O, key = keys[iter.i++]));
    if(kind == KEY)  return iterResult(0, key);
    if(kind == VALUE)return iterResult(0, O[key]);
                     return iterResult(0, [key, O[key]]);
  });
  function createDictIter(kind){
    return function(it){
      return new DictIterator(it, kind);
    }
  }
  
  /*
   * 0 -> forEach
   * 1 -> map
   * 2 -> filter
   * 3 -> some
   * 4 -> every
   * 5 -> find
   * 6 -> findKey
   * 7 -> mapPairs
   */
  function createDictMethod(type){
    var isMap    = type == 1
      , isEvery  = type == 4;
    return function(object, callbackfn, that /* = undefined */){
      var f      = ctx(callbackfn, that, 3)
        , O      = toObject(object)
        , result = isMap || type == 7 || type == 2 ? new (generic(this, Dict)) : undefined
        , key, val, res;
      for(key in O)if(has(O, key)){
        val = O[key];
        res = f(val, key, object);
        if(type){
          if(isMap)result[key] = res;             // map
          else if(res)switch(type){
            case 2: result[key] = val; break      // filter
            case 3: return true;                  // some
            case 5: return val;                   // find
            case 6: return key;                   // findKey
            case 7: result[res[0]] = res[1];      // mapPairs
          } else if(isEvery)return false;         // every
        }
      }
      return type == 3 || isEvery ? isEvery : result;
    }
  }
  function createDictReduce(isTurn){
    return function(object, mapfn, init){
      assertFunction(mapfn);
      var O      = toObject(object)
        , keys   = getKeys(O)
        , length = keys.length
        , i      = 0
        , memo, key, result;
      if(isTurn)memo = init == undefined ? new (generic(this, Dict)) : Object(init);
      else if(arguments.length < 3){
        assert(length, REDUCE_ERROR);
        memo = O[keys[i++]];
      } else memo = Object(init);
      while(length > i)if(has(O, key = keys[i++])){
        result = mapfn(memo, O[key], key, object);
        if(isTurn){
          if(result === false)break;
        } else memo = result;
      }
      return memo;
    }
  }
  var findKey = createDictMethod(6);
  function includes(object, el){
    return (el == el ? keyOf(object, el) : findKey(object, sameNaN)) !== undefined;
  }
  
  var dictMethods = {
    keys:    createDictIter(KEY),
    values:  createDictIter(VALUE),
    entries: createDictIter(KEY+VALUE),
    forEach: createDictMethod(0),
    map:     createDictMethod(1),
    filter:  createDictMethod(2),
    some:    createDictMethod(3),
    every:   createDictMethod(4),
    find:    createDictMethod(5),
    findKey: findKey,
    mapPairs:createDictMethod(7),
    reduce:  createDictReduce(false),
    turn:    createDictReduce(true),
    keyOf:   keyOf,
    includes:includes,
    // Has / get / set own property
    has: has,
    get: get,
    set: createDefiner(0),
    isDict: function(it){
      return isObject(it) && getPrototypeOf(it) === Dict[PROTOTYPE];
    }
  };
  
  if(REFERENCE_GET)for(var key in dictMethods)!function(fn){
    function method(){
      for(var args = [this], i = 0; i < arguments.length;)args.push(arguments[i++]);
      return invoke(fn, args);
    }
    fn[REFERENCE_GET] = function(){
      return method;
    }
  }(dictMethods[key]);
  
  $define(GLOBAL + FORCED, {Dict: assignHidden(Dict, dictMethods)});
}('Dict');

/******************************************************************************
 * Module : core.$for                                                         *
 ******************************************************************************/

!function(ENTRIES, FN){  
  function $for(iterable, entries){
    if(!(this instanceof $for))return new $for(iterable, entries);
    this[ITER]    = getIterator(iterable);
    this[ENTRIES] = !!entries;
  }
  
  createIterator($for, 'Wrapper', function(){
    return this[ITER].next();
  });
  var $forProto = $for[PROTOTYPE];
  setIterator($forProto, function(){
    return this[ITER]; // unwrap
  });
  
  function createChainIterator(next){
    function Iter(I, fn, that){
      this[ITER]    = getIterator(I);
      this[ENTRIES] = I[ENTRIES];
      this[FN]      = ctx(fn, that, I[ENTRIES] ? 2 : 1);
    }
    createIterator(Iter, 'Chain', next, $forProto);
    setIterator(Iter[PROTOTYPE], returnThis); // override $forProto iterator
    return Iter;
  }
  
  var MapIter = createChainIterator(function(){
    var step = this[ITER].next();
    return step.done ? step : iterResult(0, stepCall(this[FN], step.value, this[ENTRIES]));
  });
  
  var FilterIter = createChainIterator(function(){
    for(;;){
      var step = this[ITER].next();
      if(step.done || stepCall(this[FN], step.value, this[ENTRIES]))return step;
    }
  });
  
  assignHidden($forProto, {
    of: function(fn, that){
      forOf(this, this[ENTRIES], fn, that);
    },
    array: function(fn, that){
      var result = [];
      forOf(fn != undefined ? this.map(fn, that) : this, false, push, result);
      return result;
    },
    filter: function(fn, that){
      return new FilterIter(this, fn, that);
    },
    map: function(fn, that){
      return new MapIter(this, fn, that);
    }
  });
  
  $for.isIterable  = isIterable;
  $for.getIterator = getIterator;
  
  $define(GLOBAL + FORCED, {$for: $for});
}('entries', safeSymbol('fn'));

/******************************************************************************
 * Module : core.delay                                                        *
 ******************************************************************************/

// https://esdiscuss.org/topic/promise-returning-delay-function
$define(GLOBAL + FORCED, {
  delay: function(time){
    return new Promise(function(resolve){
      setTimeout(resolve, time, true);
    });
  }
});

/******************************************************************************
 * Module : core.binding                                                      *
 ******************************************************************************/

!function(_, toLocaleString){
  // Placeholder
  core._ = path._ = path._ || {};

  $define(PROTO + FORCED, FUNCTION, {
    part: part,
    only: function(numberArguments, that /* = @ */){
      var fn     = assertFunction(this)
        , n      = toLength(numberArguments)
        , isThat = arguments.length > 1;
      return function(/* ...args */){
        var length = min(n, arguments.length)
          , args   = Array(length)
          , i      = 0;
        while(length > i)args[i] = arguments[i++];
        return invoke(fn, args, isThat ? that : this);
      }
    }
  });
  
  function tie(key){
    var that  = this
      , bound = {};
    return hidden(that, _, function(key){
      if(key === undefined || !(key in that))return toLocaleString.call(that);
      return has(bound, key) ? bound[key] : (bound[key] = ctx(that[key], that, -1));
    })[_](key);
  }
  
  hidden(path._, TO_STRING, function(){
    return _;
  });
  
  hidden(ObjectProto, _, tie);
  DESC || hidden(ArrayProto, _, tie);
  // IE8- dirty hack - redefined toLocaleString is not enumerable
}(DESC ? uid('tie') : TO_LOCALE, ObjectProto[TO_LOCALE]);

/******************************************************************************
 * Module : core.object                                                       *
 ******************************************************************************/

!function(){
  function define(target, mixin){
    var keys   = ownKeys(toObject(mixin))
      , length = keys.length
      , i = 0, key;
    while(length > i)defineProperty(target, key = keys[i++], getOwnDescriptor(mixin, key));
    return target;
  };
  $define(STATIC + FORCED, OBJECT, {
    isObject: isObject,
    classof: classof,
    define: define,
    make: function(proto, mixin){
      return define(create(proto), mixin);
    }
  });
}();

/******************************************************************************
 * Module : core.array                                                        *
 ******************************************************************************/

$define(PROTO + FORCED, ARRAY, {
  turn: function(fn, target /* = [] */){
    assertFunction(fn);
    var memo   = target == undefined ? [] : Object(target)
      , O      = ES5Object(this)
      , length = toLength(O.length)
      , index  = 0;
    while(length > index)if(fn(memo, O[index], index++, this) === false)break;
    return memo;
  }
});
if(framework)ArrayUnscopables.turn = true;

/******************************************************************************
 * Module : core.number                                                       *
 ******************************************************************************/

!function(numberMethods){  
  function NumberIterator(iterated){
    set(this, ITER, {l: toLength(iterated), i: 0});
  }
  createIterator(NumberIterator, NUMBER, function(){
    var iter = this[ITER]
      , i    = iter.i++;
    return i < iter.l ? iterResult(0, i) : iterResult(1);
  });
  defineIterator(Number, NUMBER, function(){
    return new NumberIterator(this);
  });
  
  numberMethods.random = function(lim /* = 0 */){
    var a = +this
      , b = lim == undefined ? 0 : +lim
      , m = min(a, b);
    return random() * (max(a, b) - m) + m;
  };

  forEach.call(array(
      // ES3:
      'round,floor,ceil,abs,sin,asin,cos,acos,tan,atan,exp,sqrt,max,min,pow,atan2,' +
      // ES6:
      'acosh,asinh,atanh,cbrt,clz32,cosh,expm1,hypot,imul,log1p,log10,log2,sign,sinh,tanh,trunc'
    ), function(key){
      var fn = Math[key];
      if(fn)numberMethods[key] = function(/* ...args */){
        // ie9- dont support strict mode & convert `this` to object -> convert it to number
        var args = [+this]
          , i    = 0;
        while(arguments.length > i)args.push(arguments[i++]);
        return invoke(fn, args);
      }
    }
  );
  
  $define(PROTO + FORCED, NUMBER, numberMethods);
}({});

/******************************************************************************
 * Module : core.string                                                       *
 ******************************************************************************/

!function(){
  var escapeHTMLDict = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  }, unescapeHTMLDict = {}, key;
  for(key in escapeHTMLDict)unescapeHTMLDict[escapeHTMLDict[key]] = key;
  $define(PROTO + FORCED, STRING, {
    escapeHTML:   createReplacer(/[&<>"']/g, escapeHTMLDict),
    unescapeHTML: createReplacer(/&(?:amp|lt|gt|quot|apos);/g, unescapeHTMLDict)
  });
}();

/******************************************************************************
 * Module : core.date                                                         *
 ******************************************************************************/

!function(formatRegExp, flexioRegExp, locales, current, SECONDS, MINUTES, HOURS, MONTH, YEAR){
  function createFormat(prefix){
    return function(template, locale /* = current */){
      var that = this
        , dict = locales[has(locales, locale) ? locale : current];
      function get(unit){
        return that[prefix + unit]();
      }
      return String(template).replace(formatRegExp, function(part){
        switch(part){
          case 's'  : return get(SECONDS);                  // Seconds : 0-59
          case 'ss' : return lz(get(SECONDS));              // Seconds : 00-59
          case 'm'  : return get(MINUTES);                  // Minutes : 0-59
          case 'mm' : return lz(get(MINUTES));              // Minutes : 00-59
          case 'h'  : return get(HOURS);                    // Hours   : 0-23
          case 'hh' : return lz(get(HOURS));                // Hours   : 00-23
          case 'D'  : return get(DATE);                     // Date    : 1-31
          case 'DD' : return lz(get(DATE));                 // Date    : 01-31
          case 'W'  : return dict[0][get('Day')];           // Day     : Понедельник
          case 'N'  : return get(MONTH) + 1;                // Month   : 1-12
          case 'NN' : return lz(get(MONTH) + 1);            // Month   : 01-12
          case 'M'  : return dict[2][get(MONTH)];           // Month   : Январь
          case 'MM' : return dict[1][get(MONTH)];           // Month   : Января
          case 'Y'  : return get(YEAR);                     // Year    : 2014
          case 'YY' : return lz(get(YEAR) % 100);           // Year    : 14
        } return part;
      });
    }
  }
  function addLocale(lang, locale){
    function split(index){
      var result = [];
      forEach.call(array(locale.months), function(it){
        result.push(it.replace(flexioRegExp, '$' + index));
      });
      return result;
    }
    locales[lang] = [array(locale.weekdays), split(1), split(2)];
    return core;
  }
  $define(PROTO + FORCED, DATE, {
    format:    createFormat('get'),
    formatUTC: createFormat('getUTC')
  });
  addLocale(current, {
    weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday',
    months: 'January,February,March,April,May,June,July,August,September,October,November,December'
  });
  addLocale('ru', {
    weekdays: 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',
    months: 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,' +
            'Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь'
  });
  core.locale = function(locale){
    return has(locales, locale) ? current = locale : current;
  };
  core.addLocale = addLocale;
}(/\b\w\w?\b/g, /:(.*)\|(.*)$/, {}, 'en', 'Seconds', 'Minutes', 'Hours', 'Month', 'FullYear');

/******************************************************************************
 * Module : core.global                                                       *
 ******************************************************************************/

$define(GLOBAL + FORCED, {global: global});

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);

/******************************************************************************
 * Module : core.log                                                          *
 ******************************************************************************/

!function(log, enabled){
  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md
  forEach.call(array('assert,clear,count,debug,dir,dirxml,error,exception,' +
      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +
      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +
      'timelineEnd,timeStamp,trace,warn'), function(key){
    log[key] = function(){
      if(enabled && key in console)return apply.call(console[key], console, arguments);
    };
  });
  $define(GLOBAL + FORCED, {log: assign(log.log, log, {
    enable: function(){
      enabled = true;
    },
    disable: function(){
      enabled = false;
    }
  })});
}({}, true);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), false);
},{}],278:[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.prototype                                              *
 ******************************************************************************/

!function(tmp){
  // 19.1.3.6 Object.prototype.toString()
  tmp[SYMBOL_TAG] = DOT;
  if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
    return '[object ' + classof(this) + ']';
  });
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.function                                                      *
 ******************************************************************************/

!function(NAME){
  // 19.2.4.2 name
  NAME in FunctionProto || (DESC && defineProperty(FunctionProto, NAME, {
    configurable: true,
    get: function(){
      var match = String(this).match(/^\s*function ([^ (]*)/)
        , name  = match ? match[1] : '';
      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));
      return name;
    },
    set: function(value){
      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));
    }
  }));
}('name');

/******************************************************************************
 * Module : es6.number.constructor                                            *
 ******************************************************************************/

Number('0o1') && Number('0b1') || function(_Number, NumberProto){
  function toNumber(it){
    if(isObject(it))it = toPrimitive(it);
    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
      var binary = false;
      switch(it.charCodeAt(1)){
        case 66 : case 98  : binary = true;
        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
      }
    } return +it;
  }
  function toPrimitive(it){
    var fn, val;
    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to number");
  }
  Number = function Number(it){
    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);
  }
  forEach.call(DESC ? getNames(_Number)
  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){
    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));
  });
  Number[PROTOTYPE] = NumberProto;
  NumberProto[CONSTRUCTOR] = Number;
  hidden(global, NUMBER, Number);
}(Number, Number[PROTOTYPE]);

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : es6.regexp                                                        *
 ******************************************************************************/

DESC && !function(RegExpProto, _RegExp){  
  // RegExp allows a regex with flags as the pattern
  if(!function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){
    RegExp = function RegExp(pattern, flags){
      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined
        ? pattern.source : pattern, flags);
    }
    forEach.call(getNames(_RegExp), function(key){
      key in RegExp || defineProperty(RegExp, key, {
        configurable: true,
        get: function(){ return _RegExp[key] },
        set: function(it){ _RegExp[key] = it }
      });
    });
    RegExpProto[CONSTRUCTOR] = RegExp;
    RegExp[PROTOTYPE] = RegExpProto;
    hidden(global, REGEXP, RegExp);
  }
  
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {
    configurable: true,
    get: createReplacer(/^.*\/(\w*)$/, '$1')
  });
  
  setSpecies(RegExp);
}(RegExp[PROTOTYPE], RegExp);

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);
},{}],279:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":281}],280:[function(require,module,exports){
(function (process){

/**
 * Module dependencies.
 */

var tty = require('tty');
var util = require('util');

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
  if (0 === debugColors.length) {
    return tty.isatty(fd);
  } else {
    return '0' !== debugColors
        && 'no' !== debugColors
        && 'false' !== debugColors
        && 'disabled' !== debugColors;
  }
}

/**
 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
 */

var inspect = (4 === util.inspect.length ?
  // node <= 0.8.x
  function (v, colors) {
    return util.inspect(v, void 0, void 0, colors);
  } :
  // node > 0.8.x
  function (v, colors) {
    return util.inspect(v, { colors: colors });
  }
);

exports.formatters.o = function(v) {
  return inspect(v, this.useColors)
    .replace(/\s*\n\s*/g, ' ');
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;
  var name = this.namespace;

  if (useColors) {
    var c = this.color;

    args[0] = '  \u001b[9' + c + 'm' + name + ' '
      + '\u001b[0m'
      + args[0] + '\u001b[3' + c + 'm'
      + ' +' + exports.humanize(this.diff) + '\u001b[0m';
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
  return args;
}

/**
 * Invokes `console.error()` with the specified arguments.
 */

function log() {
  return stream.write(util.format.apply(this, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = require('fs');
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require('net');
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());

}).call(this,require('_process'))
},{"./debug":279,"_process":707,"fs":697,"net":697,"tty":721,"util":723}],281:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],282:[function(require,module,exports){
'use strict';
var repeating = require('repeating');

// detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment
var INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
	var result = 0;
	var maxUsed = 0;
	var maxWeight = 0;

	for (var n in indents) {
		var indent = indents[n];
		var u = indent[0];
		var w = indent[1];

		if (u > maxUsed || u === maxUsed && w > maxWeight) {
			maxUsed = u;
			maxWeight = w;
			result = +n;
		}
	}

	return result;
}

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	// used to see if tabs or spaces are the most used
	var tabs = 0;
	var spaces = 0;

	// remember the size of previous line's indentation
	var prev = 0;

	// remember how many indents/unindents as occurred for a given size
	// and how much lines follow a given indentation
	//
	// indents = {
	//    3: [1, 0],
	//    4: [1, 5],
	//    5: [1, 0],
	//   12: [1, 0],
	// }
	var indents = {};

	// pointer to the array of last used indent
	var current;

	// whether the last action was an indent (opposed to an unindent)
	var isIndent;

	str.split(/\n/g).forEach(function (line) {
		if (!line) {
			// ignore empty lines
			return;
		}

		var indent;
		var matches = line.match(INDENT_RE);

		if (!matches) {
			indent = 0;
		} else {
			indent = matches[0].length;

			if (matches[1]) {
				spaces++;
			} else {
				tabs++;
			}
		}

		var diff = indent - prev;
		prev = indent;

		if (diff) {
			// an indent or unindent has been detected

			isIndent = diff > 0;

			current = indents[isIndent ? diff : -diff];

			if (current) {
				current[0]++;
			} else {
				current = indents[diff] = [1, 0];
			}
		} else if (current) {
			// if the last action was an indent, increment the weight
			current[1] += +isIndent;
		}
	});

	var amount = getMostUsed(indents);

	var type;
	var actual;
	if (!amount) {
		type = null;
		actual = '';
	} else if (spaces >= tabs) {
		type = 'space';
		actual = repeating(' ', amount);
	} else {
		type = 'tab';
		actual = repeating('\t', amount);
	}

	return {
		amount: amount,
		type: type,
		indent: actual
	};
};

},{"repeating":427}],283:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        objectKeys(from).forEach(function (key) {
            to[key] = from[key];
        });
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportDeclaration: 'ExportDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportBatchSpecifier: [],
        ExportDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['id', 'name'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['id'],
        ImportNamespaceSpecifier: ['id'],
        ImportSpecifier: ['id', 'name'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],284:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],285:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    // See `tools/generate-identifier-regex.js`.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],286:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":285}],287:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":284,"./code":285,"./keyword":286}],288:[function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"nonstandard": {
		"escape": false,
		"unescape": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"applicationCache": false,
		"atob": false,
		"Audio": false,
		"AudioProcessingEvent": false,
		"BeforeUnloadEvent": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": false,
		"closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"crypto": false,
		"CSS": false,
		"CustomEvent": false,
		"DataView": false,
		"Debug": false,
		"defaultStatus": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DOMParser": false,
		"DragEvent": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"FileReader": false,
		"find": false,
		"focus": false,
		"FocusEvent": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"history": false,
		"HTMLAnchorElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPreElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLUListElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"Intl": false,
		"KeyboardEvent": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"matchMedia": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MouseEvent": false,
		"moveBy": false,
		"moveTo": false,
		"MutationObserver": false,
		"name": false,
		"navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		"open": false,
		"openDatabase": false,
		"opener": false,
		"opera": false,
		"Option": false,
		"outerHeight": false,
		"outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"parent": false,
		"PopStateEvent": false,
		"postMessage": false,
		"print": false,
		"ProgressEvent": false,
		"prompt": false,
		"Range": false,
		"removeEventListener": false,
		"requestAnimationFrame": false,
		"resizeBy": false,
		"resizeTo": false,
		"screen": false,
		"screenX": false,
		"screenY": false,
		"scroll": false,
		"scrollbars": false,
		"scrollBy": false,
		"scrollTo": false,
		"scrollX": false,
		"scrollY": false,
		"self": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"status": false,
		"stop": false,
		"StorageEvent": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TimeEvent": false,
		"top": false,
		"TouchEvent": false,
		"UIEvent": false,
		"URL": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLHttpRequest": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false
	},
	"worker": {
		"importScripts": true,
		"postMessage": true,
		"self": true
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"DataView": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"module": false,
		"process": false,
		"require": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"ObjectId": false,
		"PlanCache": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	}
}

},{}],289:[function(require,module,exports){
module.exports = require('./globals.json');

},{"./globals.json":288}],290:[function(require,module,exports){
// https://github.com/paulmillr/es6-shim
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger
var isNaN = require("is-nan");
var isFinite = require("is-finite");
module.exports = Number.isInteger || function(val) {
	return typeof val === "number" &&
		! isNaN(val) &&
		isFinite(val) &&
		parseInt(val, 10) === val;
};

},{"is-finite":291,"is-nan":292}],291:[function(require,module,exports){
'use strict';
module.exports = Number.isFinite || function (val) {
	// Number.isNaN() => val !== val
	if (typeof val !== 'number' || val !== val || val === Infinity || val === -Infinity) {
		return false;
	}

	return true;
};

},{}],292:[function(require,module,exports){
"use strict";

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


},{}],293:[function(require,module,exports){
// Copyright 2014, 2015 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
module.exports = /((['"])(?:(?!\2)[^\\\r\n\u2028\u2029]|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:[^\]\\\r\n\u2028\u2029]|\\.)*\]|[^\/\]\\\r\n\u2028\u2029]|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(-?(?:0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?))|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-*\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~])|([;,.[\](){}])|(\s+)|(^$|[\s\S])/g

module.exports.matchToToken = function(match) {
  token = {type: "invalid", value: match[0]}
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
  else if (match[ 5]) token.type = "comment"
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
  else if (match[ 8]) token.type = "regex"
  else if (match[ 9]) token.type = "number"
  else if (match[10]) token.type = "name"
  else if (match[11]) token.type = "operator"
  else if (match[12]) token.type = "punctuation"
  else if (match[13]) token.type = "whitespace"
  return token
}

},{}],294:[function(require,module,exports){
// intentionally commented out as it makes it slower...
//'use strict';

var arr = [];
var charCodeCache = [];

module.exports = function (a, b) {
	if (a === b) {
		return 0;
	}

	var aLen = a.length;
	var bLen = b.length;

	if (aLen === 0) {
		return bLen;
	}

	if (bLen === 0) {
		return aLen;
	}

	var bCharCode;
	var ret;
	var tmp;
	var tmp2;
	var i = 0;
	var j = 0;

	while (i < aLen) {
		charCodeCache[i] = a.charCodeAt(i);
		arr[i] = ++i;
	}

	while (j < bLen) {
		bCharCode = b.charCodeAt(j);
		tmp = j++;
		ret = j;

		for (i = 0; i < aLen; i++) {
			tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + 1;
			tmp = arr[i];
			ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
		}
	}

	return ret;
};

},{}],295:[function(require,module,exports){
// Copyright 2014, 2015 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

var leftPad = require("left-pad")

function get(options, key, defaultValue) {
  return (key in options ? options[key] : defaultValue)
}

function lineNumbers(code, options) {
  var getOption = get.bind(null, options || {})
  var transform = getOption("transform", Function.prototype)
  var padding   = getOption("padding", " ")
  var before    = getOption("before", " ")
  var after     = getOption("after", " | ")
  var start     = getOption("start", 1)
  var isArray   = Array.isArray(code)
  var lines     = (isArray ? code : code.split("\n"))
  var end       = start + lines.length - 1
  var width     = String(end).length
  var numbered  = lines.map(function(line, index) {
    var number  = start + index
    var params  = {before: before, number: number, width: width, after: after,
                   line: line}
    transform(params)
    return params.before + leftPad(params.number, width, padding) +
           params.after + params.line
  })
  return (isArray ? numbered : numbered.join("\n"))
}

module.exports = lineNumbers

},{"left-pad":296}],296:[function(require,module,exports){
module.exports = leftpad;

function leftpad (str, len, ch) {
  str = String(str);

  var i = -1;

  ch || (ch = ' ');
  len = len - str.length;


  while (++i < len) {
    str = ch + str;
  }

  return str;
}

},{}],297:[function(require,module,exports){
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = compact;

},{}],298:[function(require,module,exports){
var baseFlatten = require('../internal/baseFlatten'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Flattens a nested array. If `isDeep` is `true` the array is recursively
 * flattened, otherwise it is only flattened a single level.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, 3, [4]]]);
 * // => [1, 2, 3, [4]];
 *
 * // using `isDeep`
 * _.flatten([1, [2, 3, [4]]], true);
 * // => [1, 2, 3, 4];
 */
function flatten(array, isDeep, guard) {
  var length = array ? array.length : 0;
  if (guard && isIterateeCall(array, isDeep, guard)) {
    isDeep = false;
  }
  return length ? baseFlatten(array, isDeep) : [];
}

module.exports = flatten;

},{"../internal/baseFlatten":328,"../internal/isIterateeCall":374}],299:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],300:[function(require,module,exports){
var baseIndexOf = require('../internal/baseIndexOf');

/** Used for native method references. */
var arrayProto = Array.prototype;

/** Native method references. */
var splice = arrayProto.splice;

/**
 * Removes all provided values from `array` using `SameValueZero` for equality
 * comparisons.
 *
 * **Notes:**
 *  - Unlike `_.without`, this method mutates `array`.
 *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
 *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 *    for more details.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 *
 * _.pull(array, 2, 3);
 * console.log(array);
 * // => [1, 1]
 */
function pull() {
  var array = arguments[0];
  if (!(array && array.length)) {
    return array;
  }
  var index = 0,
      indexOf = baseIndexOf,
      length = arguments.length;

  while (++index < length) {
    var fromIndex = 0,
        value = arguments[index];

    while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}

module.exports = pull;

},{"../internal/baseIndexOf":333}],301:[function(require,module,exports){
var baseCallback = require('../internal/baseCallback'),
    baseUniq = require('../internal/baseUniq'),
    isIterateeCall = require('../internal/isIterateeCall'),
    sortedUniq = require('../internal/sortedUniq');

/**
 * Creates a duplicate-value-free version of an array using `SameValueZero`
 * for equality comparisons. Providing `true` for `isSorted` performs a faster
 * search algorithm for sorted arrays. If an iteratee function is provided it
 * is invoked for each value in the array to generate the criterion by which
 * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
 * with three arguments; (value, index, array).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
 * e.g. `===`, except that `NaN` matches `NaN`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * for more details.
 *
 * @static
 * @memberOf _
 * @alias unique
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {boolean} [isSorted] Specify the array is sorted.
 * @param {Function|Object|string} [iteratee] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new duplicate-value-free array.
 * @example
 *
 * _.uniq([1, 2, 1]);
 * // => [1, 2]
 *
 * // using `isSorted`
 * _.uniq([1, 1, 2], true);
 * // => [1, 2]
 *
 * // using an iteratee function
 * _.uniq([1, 2.5, 1.5, 2], function(n) {
 *   return this.floor(n);
 * }, Math);
 * // => [1, 2.5]
 *
 * // using the `_.property` callback shorthand
 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniq(array, isSorted, iteratee, thisArg) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (isSorted != null && typeof isSorted != 'boolean') {
    thisArg = iteratee;
    iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
    isSorted = false;
  }
  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
  return (isSorted)
    ? sortedUniq(array, iteratee)
    : baseUniq(array, iteratee);
}

module.exports = uniq;

},{"../internal/baseCallback":321,"../internal/baseUniq":347,"../internal/isIterateeCall":374,"../internal/sortedUniq":384}],302:[function(require,module,exports){
module.exports = require('./includes');

},{"./includes":306}],303:[function(require,module,exports){
module.exports = require('./forEach');

},{"./forEach":304}],304:[function(require,module,exports){
var arrayEach = require('../internal/arrayEach'),
    baseEach = require('../internal/baseEach'),
    bindCallback = require('../internal/bindCallback'),
    isArray = require('../lang/isArray');

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection). Iterator functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a `length` property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
function forEach(collection, iteratee, thisArg) {
  return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
    ? arrayEach(collection, iteratee)
    : baseEach(collection, bindCallback(iteratee, thisArg, 3));
}

module.exports = forEach;

},{"../internal/arrayEach":315,"../internal/baseEach":326,"../internal/bindCallback":349,"../lang/isArray":389}],305:[function(require,module,exports){
var createAggregator = require('../internal/createAggregator');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` through `iteratee`. The corresponding value
 * of each key is an array of the elements responsible for generating the key.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([4.2, 6.1, 6.4], function(n) {
 *   return Math.floor(n);
 * });
 * // => { '4': [4.2], '6': [6.1, 6.4] }
 *
 * _.groupBy([4.2, 6.1, 6.4], function(n) {
 *   return this.floor(n);
 * }, Math);
 * // => { '4': [4.2], '6': [6.1, 6.4] }
 *
 * // using the `_.property` callback shorthand
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    result[key] = [value];
  }
});

module.exports = groupBy;

},{"../internal/createAggregator":356}],306:[function(require,module,exports){
var baseIndexOf = require('../internal/baseIndexOf'),
    isArray = require('../lang/isArray'),
    isLength = require('../internal/isLength'),
    isString = require('../lang/isString'),
    values = require('../object/values');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection` using `SameValueZero` for equality
 * comparisons. If `fromIndex` is negative, it is used as the offset from
 * the end of `collection`.
 *
 * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
 * e.g. `===`, except that `NaN` matches `NaN`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * for more details.
 *
 * @static
 * @memberOf _
 * @alias contains, include
 * @category Collection
 * @param {Array|Object|string} collection The collection to search.
 * @param {*} target The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {boolean} Returns `true` if a matching element is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
 * // => true
 *
 * _.includes('pebbles', 'eb');
 * // => true
 */
function includes(collection, target, fromIndex) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    collection = values(collection);
    length = collection.length;
  }
  if (!length) {
    return false;
  }
  if (typeof fromIndex == 'number') {
    fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
  } else {
    fromIndex = 0;
  }
  return (typeof collection == 'string' || !isArray(collection) && isString(collection))
    ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
    : (baseIndexOf(collection, target, fromIndex) > -1);
}

module.exports = includes;

},{"../internal/baseIndexOf":333,"../internal/isLength":375,"../lang/isArray":389,"../lang/isString":397,"../object/values":405}],307:[function(require,module,exports){
var arrayMap = require('../internal/arrayMap'),
    baseCallback = require('../internal/baseCallback'),
    baseMap = require('../internal/baseMap'),
    isArray = require('../lang/isArray');

/**
 * Creates an array of values by running each element in `collection` through
 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
 * arguments; (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * Many lodash methods are guarded to work as interatees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
 * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
 * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
 * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
 *
 * @static
 * @memberOf _
 * @alias collect
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration.
 *  create a `_.property` or `_.matches` style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function timesThree(n) {
 *   return n * 3;
 * }
 *
 * _.map([1, 2], timesThree);
 * // => [3, 6]
 *
 * _.map({ 'a': 1, 'b': 2 }, timesThree);
 * // => [3, 6] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // using the `_.property` callback shorthand
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee, thisArg) {
  var func = isArray(collection) ? arrayMap : baseMap;
  iteratee = baseCallback(iteratee, thisArg, 3);
  return func(collection, iteratee);
}

module.exports = map;

},{"../internal/arrayMap":316,"../internal/baseCallback":321,"../internal/baseMap":338,"../lang/isArray":389}],308:[function(require,module,exports){
var arrayReduceRight = require('../internal/arrayReduceRight'),
    baseCallback = require('../internal/baseCallback'),
    baseEachRight = require('../internal/baseEachRight'),
    baseReduce = require('../internal/baseReduce'),
    isArray = require('../lang/isArray');

/**
 * This method is like `_.reduce` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @alias foldr
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * var array = [[0, 1], [2, 3], [4, 5]];
 *
 * _.reduceRight(array, function(flattened, other) {
 *   return flattened.concat(other);
 * }, []);
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection, iteratee, accumulator, thisArg) {
  var func = isArray(collection) ? arrayReduceRight : baseReduce;
  return func(collection, baseCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
}

module.exports = reduceRight;

},{"../internal/arrayReduceRight":317,"../internal/baseCallback":321,"../internal/baseEachRight":327,"../internal/baseReduce":342,"../lang/isArray":389}],309:[function(require,module,exports){
var arraySome = require('../internal/arraySome'),
    baseCallback = require('../internal/baseCallback'),
    baseSome = require('../internal/baseSome'),
    isArray = require('../lang/isArray');

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * The function returns as soon as it finds a passing value and does not iterate
 * over the entire collection. The predicate is bound to `thisArg` and invoked
 * with three arguments; (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @alias any
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [predicate=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `predicate`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // using the `_.matches` callback shorthand
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // using the `_.matchesProperty` callback shorthand
 * _.some(users, 'active', false);
 * // => true
 *
 * // using the `_.property` callback shorthand
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, thisArg) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
    predicate = baseCallback(predicate, thisArg, 3);
  }
  return func(collection, predicate);
}

module.exports = some;

},{"../internal/arraySome":318,"../internal/baseCallback":321,"../internal/baseSome":344,"../lang/isArray":389}],310:[function(require,module,exports){
var baseCallback = require('../internal/baseCallback'),
    baseEach = require('../internal/baseEach'),
    baseSortBy = require('../internal/baseSortBy'),
    compareAscending = require('../internal/compareAscending'),
    isIterateeCall = require('../internal/isIterateeCall'),
    isLength = require('../internal/isLength');

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through `iteratee`. This method performs
 * a stable sort, that is, it preserves the original sort order of equal elements.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity] The function
 *  invoked per iteration. If a property name or an object is provided it is
 *  used to create a `_.property` or `_.matches` style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * _.sortBy([1, 2, 3], function(n) {
 *   return Math.sin(n);
 * });
 * // => [3, 1, 2]
 *
 * _.sortBy([1, 2, 3], function(n) {
 *   return this.sin(n);
 * }, Math);
 * // => [3, 1, 2]
 *
 * var users = [
 *   { 'user': 'fred' },
 *   { 'user': 'pebbles' },
 *   { 'user': 'barney' }
 * ];
 *
 * // using the `_.property` callback shorthand
 * _.pluck(_.sortBy(users, 'user'), 'user');
 * // => ['barney', 'fred', 'pebbles']
 */
function sortBy(collection, iteratee, thisArg) {
  var index = -1,
      length = collection ? collection.length : 0,
      result = isLength(length) ? Array(length) : [];

  if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
    iteratee = null;
  }
  iteratee = baseCallback(iteratee, thisArg, 3);
  baseEach(collection, function(value, key, collection) {
    result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
  });
  return baseSortBy(result, compareAscending);
}

module.exports = sortBy;

},{"../internal/baseCallback":321,"../internal/baseEach":326,"../internal/baseSortBy":345,"../internal/compareAscending":353,"../internal/isIterateeCall":374,"../internal/isLength":375}],311:[function(require,module,exports){
var isNative = require('../lang/isNative');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeNow = isNative(nativeNow = Date.now) && nativeNow;

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch
 * (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @category Date
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => logs the number of milliseconds it took for the deferred function to be invoked
 */
var now = nativeNow || function() {
  return new Date().getTime();
};

module.exports = now;

},{"../lang/isNative":393}],312:[function(require,module,exports){
var createWrapper = require('../internal/createWrapper'),
    isIterateeCall = require('../internal/isIterateeCall');

/** Used to compose bitmasks for wrapper metadata. */
var ARY_FLAG = 256;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that accepts up to `n` arguments ignoring any
 * additional arguments.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @param {number} [n=func.length] The arity cap.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Function} Returns the new function.
 * @example
 *
 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
 * // => [6, 8, 10]
 */
function ary(func, n, guard) {
  if (guard && isIterateeCall(func, n, guard)) {
    n = null;
  }
  n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
  return createWrapper(func, ARY_FLAG, null, null, null, null, n);
}

module.exports = ary;

},{"../internal/createWrapper":363,"../internal/isIterateeCall":374}],313:[function(require,module,exports){
(function (global){
var cachePush = require('./cachePush'),
    isNative = require('../lang/isNative');

/** Native method references. */
var Set = isNative(Set = global.Set) && Set;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;

/**
 *
 * Creates a cache object to store unique values.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var length = values ? values.length : 0;

  this.data = { 'hash': nativeCreate(null), 'set': new Set };
  while (length--) {
    this.push(values[length]);
  }
}

// Add functions to the `Set` cache.
SetCache.prototype.push = cachePush;

module.exports = SetCache;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":393,"./cachePush":352}],314:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],315:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],316:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],317:[function(require,module,exports){
/**
 * A specialized version of `_.reduceRight` for arrays without support for
 * callback shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initFromArray] Specify using the last element of `array`
 *  as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
  var length = array.length;
  if (initFromArray && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array);
  }
  return accumulator;
}

module.exports = arrayReduceRight;

},{}],318:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],319:[function(require,module,exports){
/**
 * Used by `_.defaults` to customize its `_.assign` use.
 *
 * @private
 * @param {*} objectValue The destination object property value.
 * @param {*} sourceValue The source object property value.
 * @returns {*} Returns the value to assign to the destination object.
 */
function assignDefaults(objectValue, sourceValue) {
  return typeof objectValue == 'undefined' ? sourceValue : objectValue;
}

module.exports = assignDefaults;

},{}],320:[function(require,module,exports){
var baseCopy = require('./baseCopy'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize assigning values.
 * @returns {Object} Returns the destination object.
 */
function baseAssign(object, source, customizer) {
  var props = keys(source);
  if (!customizer) {
    return baseCopy(source, object, props);
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? result !== value : value === value) ||
        (typeof value == 'undefined' && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

module.exports = baseAssign;

},{"../object/keys":403,"./baseCopy":324}],321:[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    baseProperty = require('./baseProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    isBindable = require('./isBindable');

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return (typeof thisArg != 'undefined' && isBindable(func))
      ? bindCallback(func, thisArg, argCount)
      : func;
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return typeof thisArg == 'undefined'
    ? baseProperty(func + '')
    : baseMatchesProperty(func + '', thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":409,"./baseMatches":339,"./baseMatchesProperty":340,"./baseProperty":341,"./bindCallback":349,"./isBindable":372}],322:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    arrayEach = require('./arrayEach'),
    baseCopy = require('./baseCopy'),
    baseForOwn = require('./baseForOwn'),
    initCloneArray = require('./initCloneArray'),
    initCloneByTag = require('./initCloneByTag'),
    initCloneObject = require('./initCloneObject'),
    isArray = require('../lang/isArray'),
    isObject = require('../lang/isObject'),
    keys = require('../object/keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[stringTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[mapTag] = cloneableTags[setTag] =
cloneableTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * The base implementation of `_.clone` without support for argument juggling
 * and `this` binding `customizer` functions.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The object `value` belongs to.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates clones with source counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object) : customizer(value);
  }
  if (typeof result != 'undefined') {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return arrayCopy(value, result);
    }
  } else {
    var tag = objToString.call(value),
        isFunc = tag == funcTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return baseCopy(value, result, keys(value));
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return corresponding clone.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == value) {
      return stackB[length];
    }
  }
  // Add the source value to the stack of traversed objects and associate it with its clone.
  stackA.push(value);
  stackB.push(result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  });
  return result;
}

module.exports = baseClone;

},{"../lang/isArray":389,"../lang/isObject":395,"../object/keys":403,"./arrayCopy":314,"./arrayEach":315,"./baseCopy":324,"./baseForOwn":330,"./initCloneArray":369,"./initCloneByTag":370,"./initCloneObject":371}],323:[function(require,module,exports){
/**
 * The base implementation of `compareAscending` which compares values and
 * sorts them in ascending order without guaranteeing a stable sort.
 *
 * @private
 * @param {*} value The value to compare to `other`.
 * @param {*} other The value to compare to `value`.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function baseCompareAscending(value, other) {
  if (value !== other) {
    var valIsReflexive = value === value,
        othIsReflexive = other === other;

    if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
      return 1;
    }
    if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
      return -1;
    }
  }
  return 0;
}

module.exports = baseCompareAscending;

},{}],324:[function(require,module,exports){
/**
 * Copies the properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Array} props The property names to copy.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, object, props) {
  if (!props) {
    props = object;
    object = {};
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],325:[function(require,module,exports){
(function (global){
var isObject = require('../lang/isObject');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function Object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      Object.prototype = prototype;
      var result = new Object;
      Object.prototype = null;
    }
    return result || global.Object();
  };
}());

module.exports = baseCreate;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isObject":395}],326:[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
function baseEach(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwn(collection, iteratee);
  }
  var index = -1,
      iterable = toObject(collection);

  while (++index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEach;

},{"./baseForOwn":330,"./isLength":375,"./toObject":385}],327:[function(require,module,exports){
var baseForOwnRight = require('./baseForOwnRight'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.forEachRight` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
function baseEachRight(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwnRight(collection, iteratee);
  }
  var iterable = toObject(collection);
  while (length--) {
    if (iteratee(iterable[length], length, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEachRight;

},{"./baseForOwnRight":331,"./isLength":375,"./toObject":385}],328:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
 * @param {number} [fromIndex=0] The index to start from.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, fromIndex) {
  var index = (fromIndex || 0) - 1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        value = baseFlatten(value, isDeep, isStrict);
      }
      var valIndex = -1,
          valLength = value.length;

      result.length += valLength;
      while (++valIndex < valLength) {
        result[++resIndex] = value[valIndex];
      }
    } else if (!isStrict) {
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"../lang/isArguments":388,"../lang/isArray":389,"./isLength":375,"./isObjectLike":376}],329:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iterator functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
function baseFor(object, iteratee, keysFunc) {
  var index = -1,
      iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (++index < length) {
    var key = props[index];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseFor;

},{"./toObject":385}],330:[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":403,"./baseFor":329}],331:[function(require,module,exports){
var baseForRight = require('./baseForRight'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwnRight` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwnRight(object, iteratee) {
  return baseForRight(object, iteratee, keys);
}

module.exports = baseForOwnRight;

},{"../object/keys":403,"./baseForRight":332}],332:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * This function is like `baseFor` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
function baseForRight(object, iteratee, keysFunc) {
  var iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (length--) {
    var key = props[length];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseForRight;

},{"./toObject":385}],333:[function(require,module,exports){
var indexOfNaN = require('./indexOfNaN');

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = (fromIndex || 0) - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;

},{"./indexOfNaN":368}],334:[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep');

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
  // Exit early for identical values.
  if (value === other) {
    // Treat `+0` vs. `-0` as not equal.
    return value !== 0 || (1 / value == 1 / other);
  }
  var valType = typeof value,
      othType = typeof other;

  // Exit early for unlike primitive values.
  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
      value == null || other == null) {
    // Return `false` unless both values are `NaN`.
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
}

module.exports = baseIsEqual;

},{"./baseIsEqualDeep":335}],335:[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  if (valWrapped || othWrapped) {
    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":389,"../lang/isTypedArray":398,"./equalArrays":364,"./equalByTag":365,"./equalObjects":366}],336:[function(require,module,exports){
/**
 * The base implementation of `_.isFunction` without support for environments
 * with incorrect `typeof` results.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 */
function baseIsFunction(value) {
  // Avoid a Chakra JIT bug in compatibility modes of IE 11.
  // See https://github.com/jashkenas/underscore/issues/1621 for more details.
  return typeof value == 'function' || false;
}

module.exports = baseIsFunction;

},{}],337:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The source property names to match.
 * @param {Array} values The source values to match.
 * @param {Array} strictCompareFlags Strict comparison flags for source values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  var index = -1,
      noCustomizer = !customizer;

  while (++index < length) {
    if ((noCustomizer && strictCompareFlags[index])
          ? values[index] !== object[props[index]]
          : !hasOwnProperty.call(object, props[index])
        ) {
      return false;
    }
  }
  index = -1;
  while (++index < length) {
    var key = props[index];
    if (noCustomizer && strictCompareFlags[index]) {
      var result = hasOwnProperty.call(object, key);
    } else {
      var objValue = object[key],
          srcValue = values[index];

      result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (typeof result == 'undefined') {
        result = baseIsEqual(srcValue, objValue, customizer, true);
      }
    }
    if (!result) {
      return false;
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":334}],338:[function(require,module,exports){
var baseEach = require('./baseEach');

/**
 * The base implementation of `_.map` without support for callback shorthands
 * or `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var result = [];
  baseEach(collection, function(value, key, collection) {
    result.push(iteratee(value, key, collection));
  });
  return result;
}

module.exports = baseMap;

},{"./baseEach":326}],339:[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    isStrictComparable = require('./isStrictComparable'),
    keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var props = keys(source),
      length = props.length;

  if (length == 1) {
    var key = props[0],
        value = source[key];

    if (isStrictComparable(value)) {
      return function(object) {
        return object != null && object[key] === value && hasOwnProperty.call(object, key);
      };
    }
  }
  var values = Array(length),
      strictCompareFlags = Array(length);

  while (length--) {
    value = source[props[length]];
    values[length] = value;
    strictCompareFlags[length] = isStrictComparable(value);
  }
  return function(object) {
    return baseIsMatch(object, props, values, strictCompareFlags);
  };
}

module.exports = baseMatches;

},{"../object/keys":403,"./baseIsMatch":337,"./isStrictComparable":377}],340:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    isStrictComparable = require('./isStrictComparable');

/**
 * The base implementation of `_.matchesProperty` which does not coerce `key`
 * to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} value The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(key, value) {
  if (isStrictComparable(value)) {
    return function(object) {
      return object != null && object[key] === value;
    };
  }
  return function(object) {
    return object != null && baseIsEqual(value, object[key], null, true);
  };
}

module.exports = baseMatchesProperty;

},{"./baseIsEqual":334,"./isStrictComparable":377}],341:[function(require,module,exports){
/**
 * The base implementation of `_.property` which does not coerce `key` to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],342:[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight` without support
 * for callback shorthands or `this` binding, which iterates over `collection`
 * using the provided `eachFunc`.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initFromCollection Specify using the first or last element
 *  of `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initFromCollection
      ? (initFromCollection = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],343:[function(require,module,exports){
var identity = require('../utility/identity'),
    metaMap = require('./metaMap');

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"../utility/identity":409,"./metaMap":379}],344:[function(require,module,exports){
var baseEach = require('./baseEach');

/**
 * The base implementation of `_.some` without support for callback shorthands
 * or `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;

},{"./baseEach":326}],345:[function(require,module,exports){
/**
 * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
 * to define the sort order of `array` and replaces criteria objects with their
 * corresponding values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

},{}],346:[function(require,module,exports){
/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],347:[function(require,module,exports){
var baseIndexOf = require('./baseIndexOf'),
    cacheIndexOf = require('./cacheIndexOf'),
    createCache = require('./createCache');

/**
 * The base implementation of `_.uniq` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function baseUniq(array, iteratee) {
  var index = -1,
      indexOf = baseIndexOf,
      length = array.length,
      isCommon = true,
      isLarge = isCommon && length >= 200,
      seen = isLarge ? createCache() : null,
      result = [];

  if (seen) {
    indexOf = cacheIndexOf;
    isCommon = false;
  } else {
    isLarge = false;
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (isCommon && value === value) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (indexOf(seen, computed) < 0) {
      if (iteratee || isLarge) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./baseIndexOf":333,"./cacheIndexOf":351,"./createCache":359}],348:[function(require,module,exports){
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * returned by `keysFunc`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  var index = -1,
      length = props.length,
      result = Array(length);

  while (++index < length) {
    result[index] = object[props[index]];
  }
  return result;
}

module.exports = baseValues;

},{}],349:[function(require,module,exports){
var identity = require('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (typeof thisArg == 'undefined') {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":409}],350:[function(require,module,exports){
(function (global){
var constant = require('../utility/constant'),
    isNative = require('../lang/isNative');

/** Native method references. */
var ArrayBuffer = isNative(ArrayBuffer = global.ArrayBuffer) && ArrayBuffer,
    bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
    floor = Math.floor,
    Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/** Used to clone array buffers. */
var Float64Array = (function() {
  // Safari 5 errors when using an array buffer to initialize a typed array
  // where the array buffer's `byteLength` is not a multiple of the typed
  // array's `BYTES_PER_ELEMENT`.
  try {
    var func = isNative(func = global.Float64Array) && func,
        result = new func(new ArrayBuffer(10), 0, 1) && func;
  } catch(e) {}
  return result;
}());

/** Used as the size, in bytes, of each `Float64Array` element. */
var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

/**
 * Creates a clone of the given array buffer.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function bufferClone(buffer) {
  return bufferSlice.call(buffer, 0);
}
if (!bufferSlice) {
  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
    var byteLength = buffer.byteLength,
        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
        result = new ArrayBuffer(byteLength);

    if (floatLength) {
      var view = new Float64Array(result, 0, floatLength);
      view.set(new Float64Array(buffer, 0, floatLength));
    }
    if (byteLength != offset) {
      view = new Uint8Array(result, offset);
      view.set(new Uint8Array(buffer, offset));
    }
    return result;
  };
}

module.exports = bufferClone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":393,"../utility/constant":408}],351:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is in `cache` mimicking the return signature of
 * `_.indexOf` by returning `0` if the value is found, else `-1`.
 *
 * @private
 * @param {Object} cache The cache to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns `0` if `value` is found, else `-1`.
 */
function cacheIndexOf(cache, value) {
  var data = cache.data,
      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

  return result ? 0 : -1;
}

module.exports = cacheIndexOf;

},{"../lang/isObject":395}],352:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Adds `value` to the cache.
 *
 * @private
 * @name push
 * @memberOf SetCache
 * @param {*} value The value to cache.
 */
function cachePush(value) {
  var data = this.data;
  if (typeof value == 'string' || isObject(value)) {
    data.set.add(value);
  } else {
    data.hash[value] = true;
  }
}

module.exports = cachePush;

},{"../lang/isObject":395}],353:[function(require,module,exports){
var baseCompareAscending = require('./baseCompareAscending');

/**
 * Used by `_.sortBy` to compare transformed elements of a collection and stable
 * sort them in ascending order.
 *
 * @private
 * @param {Object} object The object to compare to `other`.
 * @param {Object} other The object to compare to `object`.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareAscending(object, other) {
  return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
}

module.exports = compareAscending;

},{"./baseCompareAscending":323}],354:[function(require,module,exports){
/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders) {
  var holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      leftIndex = -1,
      leftLength = partials.length,
      result = Array(argsLength + leftLength);

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    result[holders[argsIndex]] = args[argsIndex];
  }
  while (argsLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;

},{}],355:[function(require,module,exports){
/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders) {
  var holdersIndex = -1,
      holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      rightIndex = -1,
      rightLength = partials.length,
      result = Array(argsLength + rightLength);

  while (++argsIndex < argsLength) {
    result[argsIndex] = args[argsIndex];
  }
  var pad = argsIndex;
  while (++rightIndex < rightLength) {
    result[pad + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    result[pad + holders[holdersIndex]] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgsRight;

},{}],356:[function(require,module,exports){
var baseCallback = require('./baseCallback'),
    baseEach = require('./baseEach'),
    isArray = require('../lang/isArray');

/**
 * Creates a function that aggregates a collection, creating an accumulator
 * object composed from the results of running each element in the collection
 * through an iteratee.
 *
 * @private
 * @param {Function} setter The function to set keys and values of the accumulator object.
 * @param {Function} [initializer] The function to initialize the accumulator object.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee, thisArg) {
    var result = initializer ? initializer() : {};
    iteratee = baseCallback(iteratee, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        setter(result, value, iteratee(value, index, collection), collection);
      }
    } else {
      baseEach(collection, function(value, key, collection) {
        setter(result, value, iteratee(value, key, collection), collection);
      });
    }
    return result;
  };
}

module.exports = createAggregator;

},{"../lang/isArray":389,"./baseCallback":321,"./baseEach":326}],357:[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return function() {
    var length = arguments.length,
        object = arguments[0];

    if (length < 2 || object == null) {
      return object;
    }
    if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
      length = 2;
    }
    // Juggle arguments.
    if (length > 3 && typeof arguments[length - 2] == 'function') {
      var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
    } else if (length > 2 && typeof arguments[length - 1] == 'function') {
      customizer = arguments[--length];
    }
    var index = 0;
    while (++index < length) {
      var source = arguments[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  };
}

module.exports = createAssigner;

},{"./bindCallback":349,"./isIterateeCall":374}],358:[function(require,module,exports){
var createCtorWrapper = require('./createCtorWrapper');

/**
 * Creates a function that wraps `func` and invokes it with the `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new bound function.
 */
function createBindWrapper(func, thisArg) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
  }
  return wrapper;
}

module.exports = createBindWrapper;

},{"./createCtorWrapper":360}],359:[function(require,module,exports){
(function (global){
var SetCache = require('./SetCache'),
    constant = require('../utility/constant'),
    isNative = require('../lang/isNative');

/** Native method references. */
var Set = isNative(Set = global.Set) && Set;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;

/**
 * Creates a `Set` cache object to optimize linear searches of large arrays.
 *
 * @private
 * @param {Array} [values] The values to cache.
 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
 */
var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
  return new SetCache(values);
};

module.exports = createCache;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":393,"../utility/constant":408,"./SetCache":313}],360:[function(require,module,exports){
var baseCreate = require('./baseCreate'),
    isObject = require('../lang/isObject');

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function() {
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, arguments);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtorWrapper;

},{"../lang/isObject":395,"./baseCreate":325}],361:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    composeArgs = require('./composeArgs'),
    composeArgsRight = require('./composeArgsRight'),
    createCtorWrapper = require('./createCtorWrapper'),
    reorder = require('./reorder'),
    replaceHolders = require('./replaceHolders');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64,
    ARY_FLAG = 256;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that wraps `func` and invokes it with optional `this`
 * binding of, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to reference.
 * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurry = bitmask & CURRY_FLAG,
      isCurryBound = bitmask & CURRY_BOUND_FLAG,
      isCurryRight = bitmask & CURRY_RIGHT_FLAG;

  var Ctor = !isBindKey && createCtorWrapper(func),
      key = func;

  function wrapper() {
    // Avoid `arguments` object use disqualifying optimizations by
    // converting it to an array before providing it to other functions.
    var length = arguments.length,
        index = length,
        args = Array(length);

    while (index--) {
      args[index] = arguments[index];
    }
    if (partials) {
      args = composeArgs(args, partials, holders);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight);
    }
    if (isCurry || isCurryRight) {
      var placeholder = wrapper.placeholder,
          argsHolders = replaceHolders(args, placeholder);

      length -= argsHolders.length;
      if (length < arity) {
        var newArgPos = argPos ? arrayCopy(argPos) : null,
            newArity = nativeMax(arity - length, 0),
            newsHolders = isCurry ? argsHolders : null,
            newHoldersRight = isCurry ? null : argsHolders,
            newPartials = isCurry ? args : null,
            newPartialsRight = isCurry ? null : args;

        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

        if (!isCurryBound) {
          bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
        }
        var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
        result.placeholder = placeholder;
        return result;
      }
    }
    var thisBinding = isBind ? thisArg : this;
    if (isBindKey) {
      func = thisBinding[key];
    }
    if (argPos) {
      args = reorder(args, argPos);
    }
    if (isAry && ary < args.length) {
      args.length = ary;
    }
    return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybridWrapper;

},{"./arrayCopy":314,"./composeArgs":354,"./composeArgsRight":355,"./createCtorWrapper":360,"./reorder":380,"./replaceHolders":381}],362:[function(require,module,exports){
var createCtorWrapper = require('./createCtorWrapper');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` and invokes it with the optional `this`
 * binding of `thisArg` and the `partials` prepended to those provided to
 * the wrapper.
 *
 * @private
 * @param {Function} func The function to partially apply arguments to.
 * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to the new function.
 * @returns {Function} Returns the new bound function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    // Avoid `arguments` object use disqualifying optimizations by
    // converting it to an array before providing it `func`.
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(argsLength + leftLength);

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartialWrapper;

},{"./createCtorWrapper":360}],363:[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    createBindWrapper = require('./createBindWrapper'),
    createHybridWrapper = require('./createHybridWrapper'),
    createPartialWrapper = require('./createPartialWrapper'),
    getData = require('./getData'),
    mergeData = require('./mergeData'),
    setData = require('./setData');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to reference.
 * @param {number} bitmask The bitmask of flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = null;
  }
  length -= (holders ? holders.length : 0);
  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = null;
  }
  var data = !isBindKey && getData(func),
      newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

  if (data && data !== true) {
    mergeData(newData, data);
    bitmask = newData[1];
    arity = newData[9];
  }
  newData[9] = arity == null
    ? (isBindKey ? 0 : func.length)
    : (nativeMax(arity - length, 0) || 0);

  if (bitmask == BIND_FLAG) {
    var result = createBindWrapper(newData[0], newData[2]);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
    result = createPartialWrapper.apply(undefined, newData);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setter(result, newData);
}

module.exports = createWrapper;

},{"./baseSetData":343,"./createBindWrapper":358,"./createHybridWrapper":361,"./createPartialWrapper":362,"./getData":367,"./mergeData":378,"./setData":382}],364:[function(require,module,exports){
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length,
      result = true;

  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
    return false;
  }
  // Deep compare the contents, ignoring non-numeric properties.
  while (result && ++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    result = undefined;
    if (customizer) {
      result = isWhere
        ? customizer(othValue, arrValue, index)
        : customizer(arrValue, othValue, index);
    }
    if (typeof result == 'undefined') {
      // Recursively compare arrays (susceptible to call stack limits).
      if (isWhere) {
        var othIndex = othLength;
        while (othIndex--) {
          othValue = other[othIndex];
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          if (result) {
            break;
          }
        }
      } else {
        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
  }
  return !!result;
}

module.exports = equalArrays;

},{}],365:[function(require,module,exports){
/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        // But, treat `-0` vs. `+0` as not equal.
        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],366:[function(require,module,exports){
var keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isWhere) {
    return false;
  }
  var hasCtor,
      index = -1;

  while (++index < objLength) {
    var key = objProps[index],
        result = hasOwnProperty.call(other, key);

    if (result) {
      var objValue = object[key],
          othValue = other[key];

      result = undefined;
      if (customizer) {
        result = isWhere
          ? customizer(othValue, objValue, key)
          : customizer(objValue, othValue, key);
      }
      if (typeof result == 'undefined') {
        // Recursively compare objects (susceptible to call stack limits).
        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
    if (!result) {
      return false;
    }
    hasCtor || (hasCtor = key == 'constructor');
  }
  if (!hasCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":403}],367:[function(require,module,exports){
var metaMap = require('./metaMap'),
    noop = require('../utility/noop');

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;

},{"../utility/noop":410,"./metaMap":379}],368:[function(require,module,exports){
/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 * If `fromRight` is provided elements of `array` are iterated from right to left.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} [fromIndex] The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = indexOfNaN;

},{}],369:[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add array properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],370:[function(require,module,exports){
var bufferClone = require('./bufferClone');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return bufferClone(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      var buffer = object.buffer;
      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      var result = new Ctor(object.source, reFlags.exec(object));
      result.lastIndex = object.lastIndex;
  }
  return result;
}

module.exports = initCloneByTag;

},{"./bufferClone":350}],371:[function(require,module,exports){
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
    Ctor = Object;
  }
  return new Ctor;
}

module.exports = initCloneObject;

},{}],372:[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    isNative = require('../lang/isNative'),
    support = require('../support');

/** Used to detect named functions. */
var reFuncName = /^\s*function[ \n\r\t]+\w/;

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Checks if `func` is eligible for `this` binding.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
 */
function isBindable(func) {
  var result = !(support.funcNames ? func.name : support.funcDecomp);

  if (!result) {
    var source = fnToString.call(func);
    if (!support.funcNames) {
      result = !reFuncName.test(source);
    }
    if (!result) {
      // Check if `func` references the `this` keyword and store the result.
      result = reThis.test(source) || isNative(func);
      baseSetData(func, result);
    }
  }
  return result;
}

module.exports = isBindable;

},{"../lang/isNative":393,"../support":407,"./baseSetData":343}],373:[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],374:[function(require,module,exports){
var isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    isObject = require('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number') {
    var length = object.length,
        prereq = isLength(length) && isIndex(index, length);
  } else {
    prereq = type == 'string' && index in object;
  }
  if (prereq) {
    var other = object[index];
    return value === value ? value === other : other !== other;
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":395,"./isIndex":373,"./isLength":375}],375:[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on ES `ToLength`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
 * for more details.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],376:[function(require,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return (value && typeof value == 'object') || false;
}

module.exports = isObjectLike;

},{}],377:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
}

module.exports = isStrictComparable;

},{"../lang/isObject":395}],378:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    composeArgs = require('./composeArgs'),
    composeArgsRight = require('./composeArgsRight'),
    replaceHolders = require('./replaceHolders');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_RIGHT_FLAG = 16,
    REARG_FLAG = 128,
    ARY_FLAG = 256;

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers required to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
 * augment function arguments, making the order in which they are executed important,
 * preventing the merging of metadata. However, we make an exception for a safe
 * common case where curried functions have `_.ary` and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask;

  var arityFlags = ARY_FLAG | REARG_FLAG,
      bindFlags = BIND_FLAG | BIND_KEY_FLAG,
      comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

  var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
      isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
      argPos = (isRearg ? data : source)[7],
      ary = (isAry ? data : source)[8];

  var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
    !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

  var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
    (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = arrayCopy(value);
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;

},{"./arrayCopy":314,"./composeArgs":354,"./composeArgsRight":355,"./replaceHolders":381}],379:[function(require,module,exports){
(function (global){
var isNative = require('../lang/isNative');

/** Native method references. */
var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lang/isNative":393}],380:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    isIndex = require('./isIndex');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = arrayCopy(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;

},{"./arrayCopy":314,"./isIndex":373}],381:[function(require,module,exports){
/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    if (array[index] === placeholder) {
      array[index] = PLACEHOLDER;
      result[++resIndex] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;

},{}],382:[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    now = require('../date/now');

/** Used to detect when a function becomes hot. */
var HOT_COUNT = 150,
    HOT_SPAN = 16;

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity function
 * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = (function() {
  var count = 0,
      lastCalled = 0;

  return function(key, value) {
    var stamp = now(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return key;
      }
    } else {
      count = 0;
    }
    return baseSetData(key, value);
  };
}());

module.exports = setData;

},{"../date/now":311,"./baseSetData":343}],383:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":388,"../lang/isArray":389,"../object/keysIn":404,"../support":407,"./isIndex":373,"./isLength":375}],384:[function(require,module,exports){
/**
 * An implementation of `_.uniq` optimized for sorted arrays without support
 * for callback shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function sortedUniq(array, iteratee) {
  var seen,
      index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (!index || seen !== computed) {
      seen = computed;
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = sortedUniq;

},{}],385:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":395}],386:[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
 * otherwise they are assigned by reference. If `customizer` is provided it is
 * invoked to produce the cloned values. If `customizer` returns `undefined`
 * cloning is handled by the method instead. The `customizer` is bound to
 * `thisArg` and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var shallow = _.clone(users);
 * shallow[0] === users[0];
 * // => true
 *
 * var deep = _.clone(users, true);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.clone(document.body, function(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(false);
 *   }
 * });
 *
 * el === document.body
 * // => false
 * el.nodeName
 * // => BODY
 * el.childNodes.length;
 * // => 0
 */
function clone(value, isDeep, customizer, thisArg) {
  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
    isDeep = false;
  }
  else if (typeof isDeep == 'function') {
    thisArg = customizer;
    customizer = isDeep;
    isDeep = false;
  }
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, isDeep, customizer);
}

module.exports = clone;

},{"../internal/baseClone":322,"../internal/bindCallback":349,"../internal/isIterateeCall":374}],387:[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback');

/**
 * Creates a deep clone of `value`. If `customizer` is provided it is invoked
 * to produce the cloned values. If `customizer` returns `undefined` cloning
 * is handled by the method instead. The `customizer` is bound to `thisArg`
 * and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the deep cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var deep = _.cloneDeep(users);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.cloneDeep(document.body, function(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * });
 *
 * el === document.body
 * // => false
 * el.nodeName
 * // => BODY
 * el.childNodes.length;
 * // => 20
 */
function cloneDeep(value, customizer, thisArg) {
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, true, customizer);
}

module.exports = cloneDeep;

},{"../internal/baseClone":322,"../internal/bindCallback":349}],388:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  var length = isObjectLike(value) ? value.length : undefined;
  return (isLength(length) && objToString.call(value) == argsTag) || false;
}

module.exports = isArguments;

},{"../internal/isLength":375,"../internal/isObjectLike":376}],389:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('./isNative'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
};

module.exports = isArray;

},{"../internal/isLength":375,"../internal/isObjectLike":376,"./isNative":393}],390:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
}

module.exports = isBoolean;

},{"../internal/isObjectLike":376}],391:[function(require,module,exports){
var isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isFunction = require('./isFunction'),
    isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike'),
    isString = require('./isString'),
    keys = require('../object/keys');

/**
 * Checks if a value is empty. A value is considered empty unless it is an
 * `arguments` object, array, string, or jQuery-like collection with a length
 * greater than `0` or an object with own enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {Array|Object|string} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  var length = value.length;
  if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
      (isObjectLike(value) && isFunction(value.splice)))) {
    return !length;
  }
  return !keys(value).length;
}

module.exports = isEmpty;

},{"../internal/isLength":375,"../internal/isObjectLike":376,"../object/keys":403,"./isArguments":388,"./isArray":389,"./isFunction":392,"./isString":397}],392:[function(require,module,exports){
(function (global){
var baseIsFunction = require('../internal/baseIsFunction'),
    isNative = require('./isNative');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Native method references. */
var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return objToString.call(value) == funcTag;
};

module.exports = isFunction;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../internal/baseIsFunction":336,"./isNative":393}],393:[function(require,module,exports){
var escapeRegExp = require('../string/escapeRegExp'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reNative.test(fnToString.call(value));
  }
  return (isObjectLike(value) && reHostCtor.test(value)) || false;
}

module.exports = isNative;

},{"../internal/isObjectLike":376,"../string/escapeRegExp":406}],394:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(8.4);
 * // => true
 *
 * _.isNumber(NaN);
 * // => true
 *
 * _.isNumber('8.4');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
}

module.exports = isNumber;

},{"../internal/isObjectLike":376}],395:[function(require,module,exports){
/**
 * Checks if `value` is the language type of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (value && type == 'object') || false;
}

module.exports = isObject;

},{}],396:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
function isRegExp(value) {
  return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
}

module.exports = isRegExp;

},{"../internal/isObjectLike":376}],397:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
}

module.exports = isString;

},{"../internal/isObjectLike":376}],398:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
}

module.exports = isTypedArray;

},{"../internal/isLength":375,"../internal/isObjectLike":376}],399:[function(require,module,exports){
var baseAssign = require('../internal/baseAssign'),
    createAssigner = require('../internal/createAssigner');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments;
 * (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return typeof value == 'undefined' ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(baseAssign);

module.exports = assign;

},{"../internal/baseAssign":320,"../internal/createAssigner":357}],400:[function(require,module,exports){
var arrayCopy = require('../internal/arrayCopy'),
    assign = require('./assign'),
    assignDefaults = require('../internal/assignDefaults');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object for all destination properties that resolve to `undefined`. Once a
 * property is set, additional defaults of the same property are ignored.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
function defaults(object) {
  if (object == null) {
    return object;
  }
  var args = arrayCopy(arguments);
  args.push(assignDefaults);
  return assign.apply(undefined, args);
}

module.exports = defaults;

},{"../internal/arrayCopy":314,"../internal/assignDefaults":319,"./assign":399}],401:[function(require,module,exports){
module.exports = require('./assign');

},{"./assign":399}],402:[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `key` exists as a direct property of `object` instead of an
 * inherited property.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {string} key The key to check.
 * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 3 };
 *
 * _.has(object, 'b');
 * // => true
 */
function has(object, key) {
  return object ? hasOwnProperty.call(object, key) : false;
}

module.exports = has;

},{}],403:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('../lang/isNative'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  if (object) {
    var Ctor = object.constructor,
        length = object.length;
  }
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
     (typeof object != 'function' && (length && isLength(length)))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/isLength":375,"../internal/shimKeys":383,"../lang/isNative":393,"../lang/isObject":395}],404:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":373,"../internal/isLength":375,"../lang/isArguments":388,"../lang/isArray":389,"../lang/isObject":395,"../support":407}],405:[function(require,module,exports){
var baseValues = require('../internal/baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return baseValues(object, keys(object));
}

module.exports = values;

},{"../internal/baseValues":348,"./keys":403}],406:[function(require,module,exports){
var baseToString = require('../internal/baseToString');

/**
 * Used to match `RegExp` special characters.
 * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
 * for more details.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/**
 * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
 * "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = escapeRegExp;

},{"../internal/baseToString":346}],407:[function(require,module,exports){
(function (global){
var isNative = require('./lang/isNative');

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to detect DOM support. */
var document = (document = global.window) && document.document;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {

  /**
   * Detect if functions can be decompiled by `Function#toString`
   * (all but Firefox OS certified apps, older Opera mobile browsers, and
   * the PlayStation 3; forced `false` for Windows 8 apps).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

  /**
   * Detect if `Function#name` is supported (all but IE).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcNames = typeof Function.name == 'string';

  /**
   * Detect if the DOM is supported.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.dom = document.createDocumentFragment().nodeType === 11;
  } catch(e) {
    support.dom = false;
  }

  /**
   * Detect if `arguments` object indexes are non-enumerable.
   *
   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
   * checks for indexes that exceed their function's formal parameters with
   * associated values of `0`.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(0, 0));

module.exports = support;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lang/isNative":393}],408:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],409:[function(require,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],410:[function(require,module,exports){
/**
 * A no-operation function which returns `undefined` regardless of the
 * arguments it receives.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.noop(object) === undefined;
 * // => true
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],411:[function(require,module,exports){
"use strict";

var originalObject = Object;
var originalDefProp = Object.defineProperty;
var originalCreate = Object.create;

function defProp(obj, name, value) {
  if (originalDefProp) try {
    originalDefProp.call(originalObject, obj, name, { value: value });
  } catch (definePropertyIsBrokenInIE8) {
    obj[name] = value;
  } else {
    obj[name] = value;
  }
}

// For functions that will be invoked using .call or .apply, we need to
// define those methods on the function objects themselves, rather than
// inheriting them from Function.prototype, so that a malicious or clumsy
// third party cannot interfere with the functionality of this module by
// redefining Function.prototype.call or .apply.
function makeSafeToCall(fun) {
  if (fun) {
    defProp(fun, "call", fun.call);
    defProp(fun, "apply", fun.apply);
  }
  return fun;
}

makeSafeToCall(originalDefProp);
makeSafeToCall(originalCreate);

var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
var numToStr = makeSafeToCall(Number.prototype.toString);
var strSlice = makeSafeToCall(String.prototype.slice);

var cloner = function(){};
function create(prototype) {
  if (originalCreate) {
    return originalCreate.call(originalObject, prototype);
  }
  cloner.prototype = prototype || null;
  return new cloner;
}

var rand = Math.random;
var uniqueKeys = create(null);

function makeUniqueKey() {
  // Collisions are highly unlikely, but this module is in the business of
  // making guarantees rather than safe bets.
  do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
  while (hasOwn.call(uniqueKeys, uniqueKey));
  return uniqueKeys[uniqueKey] = uniqueKey;
}

function internString(str) {
  var obj = {};
  obj[str] = true;
  return Object.keys(obj)[0];
}

// External users might find this function useful, but it is not necessary
// for the typical use of this module.
defProp(exports, "makeUniqueKey", makeUniqueKey);

// Object.getOwnPropertyNames is the only way to enumerate non-enumerable
// properties, so if we wrap it to ignore our secret keys, there should be
// no way (except guessing) to access those properties.
var originalGetOPNs = Object.getOwnPropertyNames;
Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
  for (var names = originalGetOPNs(object),
           src = 0,
           dst = 0,
           len = names.length;
       src < len;
       ++src) {
    if (!hasOwn.call(uniqueKeys, names[src])) {
      if (src > dst) {
        names[dst] = names[src];
      }
      ++dst;
    }
  }
  names.length = dst;
  return names;
};

function defaultCreatorFn(object) {
  return create(null);
}

function makeAccessor(secretCreatorFn) {
  var brand = makeUniqueKey();
  var passkey = create(null);

  secretCreatorFn = secretCreatorFn || defaultCreatorFn;

  function register(object) {
    var secret; // Created lazily.

    function vault(key, forget) {
      // Only code that has access to the passkey can retrieve (or forget)
      // the secret object.
      if (key === passkey) {
        return forget
          ? secret = null
          : secret || (secret = secretCreatorFn(object));
      }
    }

    defProp(object, brand, vault);
  }

  function accessor(object) {
    if (!hasOwn.call(object, brand))
      register(object);
    return object[brand](passkey);
  }

  accessor.forget = function(object) {
    if (hasOwn.call(object, brand))
      object[brand](passkey, true);
  };

  return accessor;
}

defProp(exports, "makeAccessor", makeAccessor);

},{}],412:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var isArray = types.builtInTypes.array;
var b = types.builders;
var n = types.namedTypes;
var leap = require("./leap");
var meta = require("./meta");
var util = require("./util");
var hasOwn = Object.prototype.hasOwnProperty;

function Emitter(contextId) {
  assert.ok(this instanceof Emitter);
  n.Identifier.assert(contextId);

  Object.defineProperties(this, {
    // In order to make sure the context object does not collide with
    // anything in the local scope, we might have to rename it, so we
    // refer to it symbolically instead of just assuming that it will be
    // called "context".
    contextId: { value: contextId },

    // An append-only list of Statements that grows each time this.emit is
    // called.
    listing: { value: [] },

    // A sparse array whose keys correspond to locations in this.listing
    // that have been marked as branch/jump targets.
    marked: { value: [true] },

    // The last location will be marked when this.getDispatchLoop is
    // called.
    finalLoc: { value: loc() },

    // A list of all leap.TryEntry statements emitted.
    tryEntries: { value: [] }
  });

  // The .leapManager property needs to be defined by a separate
  // defineProperties call so that .finalLoc will be visible to the
  // leap.LeapManager constructor.
  Object.defineProperties(this, {
    // Each time we evaluate the body of a loop, we tell this.leapManager
    // to enter a nested loop context that determines the meaning of break
    // and continue statements therein.
    leapManager: { value: new leap.LeapManager(this) }
  });
}

var Ep = Emitter.prototype;
exports.Emitter = Emitter;

// Offsets into this.listing that could be used as targets for branches or
// jumps are represented as numeric Literal nodes. This representation has
// the amazingly convenient benefit of allowing the exact value of the
// location to be determined at any time, even after generating code that
// refers to the location.
function loc() {
  return b.literal(-1);
}

// Sets the exact value of the given location to the offset of the next
// Statement emitted.
Ep.mark = function(loc) {
  n.Literal.assert(loc);
  var index = this.listing.length;
  if (loc.value === -1) {
    loc.value = index;
  } else {
    // Locations can be marked redundantly, but their values cannot change
    // once set the first time.
    assert.strictEqual(loc.value, index);
  }
  this.marked[index] = true;
  return loc;
};

Ep.emit = function(node) {
  if (n.Expression.check(node))
    node = b.expressionStatement(node);
  n.Statement.assert(node);
  this.listing.push(node);
};

// Shorthand for emitting assignment statements. This will come in handy
// for assignments to temporary variables.
Ep.emitAssign = function(lhs, rhs) {
  this.emit(this.assign(lhs, rhs));
  return lhs;
};

// Shorthand for an assignment statement.
Ep.assign = function(lhs, rhs) {
  return b.expressionStatement(
    b.assignmentExpression("=", lhs, rhs));
};

// Convenience function for generating expressions like context.next,
// context.sent, and context.rval.
Ep.contextProperty = function(name, computed) {
  return b.memberExpression(
    this.contextId,
    computed ? b.literal(name) : b.identifier(name),
    !!computed
  );
};

var volatileContextPropertyNames = {
  prev: true,
  next: true,
  sent: true,
  rval: true
};

// A "volatile" context property is a MemberExpression like context.sent
// that should probably be stored in a temporary variable when there's a
// possibility the property will get overwritten.
Ep.isVolatileContextProperty = function(expr) {
  if (n.MemberExpression.check(expr)) {
    if (expr.computed) {
      // If it's a computed property such as context[couldBeAnything],
      // assume the worst in terms of volatility.
      return true;
    }

    if (n.Identifier.check(expr.object) &&
        n.Identifier.check(expr.property) &&
        expr.object.name === this.contextId.name &&
        hasOwn.call(volatileContextPropertyNames,
                    expr.property.name)) {
      return true;
    }
  }

  return false;
};

// Shorthand for setting context.rval and jumping to `context.stop()`.
Ep.stop = function(rval) {
  if (rval) {
    this.setReturnValue(rval);
  }

  this.jump(this.finalLoc);
};

Ep.setReturnValue = function(valuePath) {
  n.Expression.assert(valuePath.value);

  this.emitAssign(
    this.contextProperty("rval"),
    this.explodeExpression(valuePath)
  );
};

Ep.clearPendingException = function(tryLoc, assignee) {
  n.Literal.assert(tryLoc);

  var catchCall = b.callExpression(
    this.contextProperty("catch", true),
    [tryLoc]
  );

  if (assignee) {
    this.emitAssign(assignee, catchCall);
  } else {
    this.emit(catchCall);
  }
};

// Emits code for an unconditional jump to the given location, even if the
// exact value of the location is not yet known.
Ep.jump = function(toLoc) {
  this.emitAssign(this.contextProperty("next"), toLoc);
  this.emit(b.breakStatement());
};

// Conditional jump.
Ep.jumpIf = function(test, toLoc) {
  n.Expression.assert(test);
  n.Literal.assert(toLoc);

  this.emit(b.ifStatement(
    test,
    b.blockStatement([
      this.assign(this.contextProperty("next"), toLoc),
      b.breakStatement()
    ])
  ));
};

// Conditional jump, with the condition negated.
Ep.jumpIfNot = function(test, toLoc) {
  n.Expression.assert(test);
  n.Literal.assert(toLoc);

  var negatedTest;
  if (n.UnaryExpression.check(test) &&
      test.operator === "!") {
    // Avoid double negation.
    negatedTest = test.argument;
  } else {
    negatedTest = b.unaryExpression("!", test);
  }

  this.emit(b.ifStatement(
    negatedTest,
    b.blockStatement([
      this.assign(this.contextProperty("next"), toLoc),
      b.breakStatement()
    ])
  ));
};

// Returns a unique MemberExpression that can be used to store and
// retrieve temporary values. Since the object of the member expression is
// the context object, which is presumed to coexist peacefully with all
// other local variables, and since we just increment `nextTempId`
// monotonically, uniqueness is assured.
var nextTempId = 0;
Ep.makeTempVar = function() {
  return this.contextProperty("t" + nextTempId++);
};

Ep.getContextFunction = function(id) {
  var func = b.functionExpression(
    id || null/*Anonymous*/,
    [this.contextId],
    b.blockStatement([this.getDispatchLoop()]),
    false, // Not a generator anymore!
    false // Nor an expression.
  );
  func._aliasFunction = true;
  return func;
};

// Turns this.listing into a loop of the form
//
//   while (1) switch (context.next) {
//   case 0:
//   ...
//   case n:
//     return context.stop();
//   }
//
// Each marked location in this.listing will correspond to one generated
// case statement.
Ep.getDispatchLoop = function() {
  var self = this;
  var cases = [];
  var current;

  // If we encounter a break, continue, or return statement in a switch
  // case, we can skip the rest of the statements until the next case.
  var alreadyEnded = false;

  self.listing.forEach(function(stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(b.switchCase(
        b.literal(i),
        current = []));
      alreadyEnded = false;
    }

    if (!alreadyEnded) {
      current.push(stmt);
      if (isSwitchCaseEnder(stmt))
        alreadyEnded = true;
    }
  });

  // Now that we know how many statements there will be in this.listing,
  // we can finally resolve this.finalLoc.value.
  this.finalLoc.value = this.listing.length;

  cases.push(
    b.switchCase(this.finalLoc, [
      // Intentionally fall through to the "end" case...
    ]),

    // So that the runtime can jump to the final location without having
    // to know its offset, we provide the "end" case as a synonym.
    b.switchCase(b.literal("end"), [
      // This will check/clear both context.thrown and context.rval.
      b.returnStatement(
        b.callExpression(this.contextProperty("stop"), [])
      )
    ])
  );

  return b.whileStatement(
    b.literal(1),
    b.switchStatement(
      b.assignmentExpression(
        "=",
        this.contextProperty("prev"),
        this.contextProperty("next")
      ),
      cases
    )
  );
};

// See comment above re: alreadyEnded.
function isSwitchCaseEnder(stmt) {
  return n.BreakStatement.check(stmt)
      || n.ContinueStatement.check(stmt)
      || n.ReturnStatement.check(stmt)
      || n.ThrowStatement.check(stmt);
}

Ep.getTryLocsList = function() {
  if (this.tryEntries.length === 0) {
    // To avoid adding a needless [] to the majority of runtime.wrap
    // argument lists, force the caller to handle this case specially.
    return null;
  }

  var lastLocValue = 0;

  return b.arrayExpression(
    this.tryEntries.map(function(tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;
      assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
      lastLocValue = thisLocValue;

      var ce = tryEntry.catchEntry;
      var fe = tryEntry.finallyEntry;

      var locs = [
        tryEntry.firstLoc,
        // The null here makes a hole in the array.
        ce ? ce.firstLoc : null
      ];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return b.arrayExpression(locs);
    })
  );
};

// All side effects must be realized in order.

// If any subexpression harbors a leap, all subexpressions must be
// neutered of side effects.

// No destructive modification of AST nodes.

Ep.explode = function(path, ignoreResult) {
  assert.ok(path instanceof types.NodePath);

  var node = path.value;
  var self = this;

  n.Node.assert(node);

  if (n.Statement.check(node))
    return self.explodeStatement(path);

  if (n.Expression.check(node))
    return self.explodeExpression(path, ignoreResult);

  if (n.Declaration.check(node))
    throw getDeclError(node);

  switch (node.type) {
  case "Program":
    return path.get("body").map(
      self.explodeStatement,
      self
    );

  case "VariableDeclarator":
    throw getDeclError(node);

  // These node types should be handled by their parent nodes
  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).
  case "Property":
  case "SwitchCase":
  case "CatchClause":
    throw new Error(
      node.type + " nodes should be handled by their parents");

  default:
    throw new Error(
      "unknown Node of type " +
        JSON.stringify(node.type));
  }
};

function getDeclError(node) {
  return new Error(
    "all declarations should have been transformed into " +
    "assignments before the Exploder began its work: " +
    JSON.stringify(node));
}

Ep.explodeStatement = function(path, labelId) {
  assert.ok(path instanceof types.NodePath);

  var stmt = path.value;
  var self = this;

  n.Statement.assert(stmt);

  if (labelId) {
    n.Identifier.assert(labelId);
  } else {
    labelId = null;
  }

  // Explode BlockStatement nodes even if they do not contain a yield,
  // because we don't want or need the curly braces.
  if (n.BlockStatement.check(stmt)) {
    return path.get("body").each(
      self.explodeStatement,
      self
    );
  }

  if (!meta.containsLeap(stmt)) {
    // Technically we should be able to avoid emitting the statement
    // altogether if !meta.hasSideEffects(stmt), but that leads to
    // confusing generated code (for instance, `while (true) {}` just
    // disappears) and is probably a more appropriate job for a dedicated
    // dead code elimination pass.
    self.emit(stmt);
    return;
  }

  switch (stmt.type) {
  case "ExpressionStatement":
    self.explodeExpression(path.get("expression"), true);
    break;

  case "LabeledStatement":
    var after = loc();

    // Did you know you can break from any labeled block statement or
    // control structure? Well, you can! Note: when a labeled loop is
    // encountered, the leap.LabeledEntry created here will immediately
    // enclose a leap.LoopEntry on the leap manager's stack, and both
    // entries will have the same label. Though this works just fine, it
    // may seem a bit redundant. In theory, we could check here to
    // determine if stmt knows how to handle its own label; for example,
    // stmt happens to be a WhileStatement and so we know it's going to
    // establish its own LoopEntry when we explode it (below). Then this
    // LabeledEntry would be unnecessary. Alternatively, we might be
    // tempted not to pass stmt.label down into self.explodeStatement,
    // because we've handled the label here, but that's a mistake because
    // labeled loops may contain labeled continue statements, which is not
    // something we can handle in this generic case. All in all, I think a
    // little redundancy greatly simplifies the logic of this case, since
    // it's clear that we handle all possible LabeledStatements correctly
    // here, regardless of whether they interact with the leap manager
    // themselves. Also remember that labels and break/continue-to-label
    // statements are rare, and all of this logic happens at transform
    // time, so it has no additional runtime cost.
    self.leapManager.withEntry(
      new leap.LabeledEntry(after, stmt.label),
      function() {
        self.explodeStatement(path.get("body"), stmt.label);
      }
    );

    self.mark(after);

    break;

  case "WhileStatement":
    var before = loc();
    var after = loc();

    self.mark(before);
    self.jumpIfNot(self.explodeExpression(path.get("test")), after);
    self.leapManager.withEntry(
      new leap.LoopEntry(after, before, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );
    self.jump(before);
    self.mark(after);

    break;

  case "DoWhileStatement":
    var first = loc();
    var test = loc();
    var after = loc();

    self.mark(first);
    self.leapManager.withEntry(
      new leap.LoopEntry(after, test, labelId),
      function() { self.explode(path.get("body")); }
    );
    self.mark(test);
    self.jumpIf(self.explodeExpression(path.get("test")), first);
    self.mark(after);

    break;

  case "ForStatement":
    var head = loc();
    var update = loc();
    var after = loc();

    if (stmt.init) {
      // We pass true here to indicate that if stmt.init is an expression
      // then we do not care about its result.
      self.explode(path.get("init"), true);
    }

    self.mark(head);

    if (stmt.test) {
      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
    } else {
      // No test means continue unconditionally.
    }

    self.leapManager.withEntry(
      new leap.LoopEntry(after, update, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );

    self.mark(update);

    if (stmt.update) {
      // We pass true here to indicate that if stmt.update is an
      // expression then we do not care about its result.
      self.explode(path.get("update"), true);
    }

    self.jump(head);

    self.mark(after);

    break;

  case "ForInStatement":
    n.Identifier.assert(stmt.left);

    var head = loc();
    var after = loc();

    var keyIterNextFn = self.makeTempVar();
    self.emitAssign(
      keyIterNextFn,
      b.callExpression(
        util.runtimeProperty("keys"),
        [self.explodeExpression(path.get("right"))]
      )
    );

    self.mark(head);

    var keyInfoTmpVar = self.makeTempVar();
    self.jumpIf(
      b.memberExpression(
        b.assignmentExpression(
          "=",
          keyInfoTmpVar,
          b.callExpression(keyIterNextFn, [])
        ),
        b.identifier("done"),
        false
      ),
      after
    );

    self.emitAssign(
      stmt.left,
      b.memberExpression(
        keyInfoTmpVar,
        b.identifier("value"),
        false
      )
    );

    self.leapManager.withEntry(
      new leap.LoopEntry(after, head, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );

    self.jump(head);

    self.mark(after);

    break;

  case "BreakStatement":
    self.emitAbruptCompletion({
      type: "break",
      target: self.leapManager.getBreakLoc(stmt.label)
    });

    break;

  case "ContinueStatement":
    self.emitAbruptCompletion({
      type: "continue",
      target: self.leapManager.getContinueLoc(stmt.label)
    });

    break;

  case "SwitchStatement":
    // Always save the discriminant into a temporary variable in case the
    // test expressions overwrite values like context.sent.
    var disc = self.emitAssign(
      self.makeTempVar(),
      self.explodeExpression(path.get("discriminant"))
    );

    var after = loc();
    var defaultLoc = loc();
    var condition = defaultLoc;
    var caseLocs = [];

    // If there are no cases, .cases might be undefined.
    var cases = stmt.cases || [];

    for (var i = cases.length - 1; i >= 0; --i) {
      var c = cases[i];
      n.SwitchCase.assert(c);

      if (c.test) {
        condition = b.conditionalExpression(
          b.binaryExpression("===", disc, c.test),
          caseLocs[i] = loc(),
          condition
        );
      } else {
        caseLocs[i] = defaultLoc;
      }
    }

    self.jump(self.explodeExpression(
      new types.NodePath(condition, path, "discriminant")
    ));

    self.leapManager.withEntry(
      new leap.SwitchEntry(after),
      function() {
        path.get("cases").each(function(casePath) {
          var c = casePath.value;
          var i = casePath.name;

          self.mark(caseLocs[i]);

          casePath.get("consequent").each(
            self.explodeStatement,
            self
          );
        });
      }
    );

    self.mark(after);
    if (defaultLoc.value === -1) {
      self.mark(defaultLoc);
      assert.strictEqual(after.value, defaultLoc.value);
    }

    break;

  case "IfStatement":
    var elseLoc = stmt.alternate && loc();
    var after = loc();

    self.jumpIfNot(
      self.explodeExpression(path.get("test")),
      elseLoc || after
    );

    self.explodeStatement(path.get("consequent"));

    if (elseLoc) {
      self.jump(after);
      self.mark(elseLoc);
      self.explodeStatement(path.get("alternate"));
    }

    self.mark(after);

    break;

  case "ReturnStatement":
    self.emitAbruptCompletion({
      type: "return",
      value: self.explodeExpression(path.get("argument"))
    });

    break;

  case "WithStatement":
    throw new Error(
      node.type + " not supported in generator functions.");

  case "TryStatement":
    var after = loc();

    var handler = stmt.handler;
    if (!handler && stmt.handlers) {
      handler = stmt.handlers[0] || null;
    }

    var catchLoc = handler && loc();
    var catchEntry = catchLoc && new leap.CatchEntry(
      catchLoc,
      handler.param
    );

    var finallyLoc = stmt.finalizer && loc();
    var finallyEntry = finallyLoc &&
      new leap.FinallyEntry(finallyLoc, after);

    var tryEntry = new leap.TryEntry(
      self.getUnmarkedCurrentLoc(),
      catchEntry,
      finallyEntry
    );

    self.tryEntries.push(tryEntry);
    self.updateContextPrevLoc(tryEntry.firstLoc);

    self.leapManager.withEntry(tryEntry, function() {
      self.explodeStatement(path.get("block"));

      if (catchLoc) {
        if (finallyLoc) {
          // If we have both a catch block and a finally block, then
          // because we emit the catch block first, we need to jump over
          // it to the finally block.
          self.jump(finallyLoc);

        } else {
          // If there is no finally block, then we need to jump over the
          // catch block to the fall-through location.
          self.jump(after);
        }

        self.updateContextPrevLoc(self.mark(catchLoc));

        var bodyPath = path.get("handler", "body");
        var safeParam = self.makeTempVar();
        self.clearPendingException(tryEntry.firstLoc, safeParam);

        var catchScope = bodyPath.scope;
        var catchParamName = handler.param.name;
        n.CatchClause.assert(catchScope.node);
        assert.strictEqual(catchScope.lookup(catchParamName), catchScope);

        types.visit(bodyPath, {
          visitIdentifier: function(path) {
            if (util.isReference(path, catchParamName) &&
                path.scope.lookup(catchParamName) === catchScope) {
              return safeParam;
            }

            this.traverse(path);
          },

          visitFunction: function(path) {
            if (path.scope.declares(catchParamName)) {
              // Don't descend into nested scopes that shadow the catch
              // parameter with their own declarations. This isn't
              // logically necessary because of the path.scope.lookup we
              // do in visitIdentifier, but it saves time.
              return false;
            }

            this.traverse(path);
          }
        });

        self.leapManager.withEntry(catchEntry, function() {
          self.explodeStatement(bodyPath);
        });
      }

      if (finallyLoc) {
        self.updateContextPrevLoc(self.mark(finallyLoc));

        self.leapManager.withEntry(finallyEntry, function() {
          self.explodeStatement(path.get("finalizer"));
        });

        self.emit(b.returnStatement(b.callExpression(
          self.contextProperty("finish"),
          [finallyEntry.firstLoc]
        )));
      }
    });

    self.mark(after);

    break;

  case "ThrowStatement":
    self.emit(b.throwStatement(
      self.explodeExpression(path.get("argument"))
    ));

    break;

  default:
    throw new Error(
      "unknown Statement of type " +
        JSON.stringify(stmt.type));
  }
};

Ep.emitAbruptCompletion = function(record) {
  if (!isValidCompletion(record)) {
    assert.ok(
      false,
      "invalid completion record: " +
        JSON.stringify(record)
    );
  }

  assert.notStrictEqual(
    record.type, "normal",
    "normal completions are not abrupt"
  );

  var abruptArgs = [b.literal(record.type)];

  if (record.type === "break" ||
      record.type === "continue") {
    n.Literal.assert(record.target);
    abruptArgs[1] = record.target;
  } else if (record.type === "return" ||
             record.type === "throw") {
    if (record.value) {
      n.Expression.assert(record.value);
      abruptArgs[1] = record.value;
    }
  }

  this.emit(
    b.returnStatement(
      b.callExpression(
        this.contextProperty("abrupt"),
        abruptArgs
      )
    )
  );
};

function isValidCompletion(record) {
  var type = record.type;

  if (type === "normal") {
    return !hasOwn.call(record, "target");
  }

  if (type === "break" ||
      type === "continue") {
    return !hasOwn.call(record, "value")
        && n.Literal.check(record.target);
  }

  if (type === "return" ||
      type === "throw") {
    return hasOwn.call(record, "value")
        && !hasOwn.call(record, "target");
  }

  return false;
}


// Not all offsets into emitter.listing are potential jump targets. For
// example, execution typically falls into the beginning of a try block
// without jumping directly there. This method returns the current offset
// without marking it, so that a switch case will not necessarily be
// generated for this offset (I say "not necessarily" because the same
// location might end up being marked in the process of emitting other
// statements). There's no logical harm in marking such locations as jump
// targets, but minimizing the number of switch cases keeps the generated
// code shorter.
Ep.getUnmarkedCurrentLoc = function() {
  return b.literal(this.listing.length);
};

// The context.prev property takes the value of context.next whenever we
// evaluate the switch statement discriminant, which is generally good
// enough for tracking the last location we jumped to, but sometimes
// context.prev needs to be more precise, such as when we fall
// successfully out of a try block and into a finally block without
// jumping. This method exists to update context.prev to the freshest
// available location. If we were implementing a full interpreter, we
// would know the location of the current instruction with complete
// precision at all times, but we don't have that luxury here, as it would
// be costly and verbose to set context.prev before every statement.
Ep.updateContextPrevLoc = function(loc) {
  if (loc) {
    n.Literal.assert(loc);

    if (loc.value === -1) {
      // If an uninitialized location literal was passed in, set its value
      // to the current this.listing.length.
      loc.value = this.listing.length;
    } else {
      // Otherwise assert that the location matches the current offset.
      assert.strictEqual(loc.value, this.listing.length);
    }

  } else {
    loc = this.getUnmarkedCurrentLoc();
  }

  // Make sure context.prev is up to date in case we fell into this try
  // statement without jumping to it. TODO Consider avoiding this
  // assignment when we know control must have jumped here.
  this.emitAssign(this.contextProperty("prev"), loc);
};

Ep.explodeExpression = function(path, ignoreResult) {
  assert.ok(path instanceof types.NodePath);

  var expr = path.value;
  if (expr) {
    n.Expression.assert(expr);
  } else {
    return expr;
  }

  var self = this;
  var result; // Used optionally by several cases below.

  function finish(expr) {
    n.Expression.assert(expr);
    if (ignoreResult) {
      self.emit(expr);
    } else {
      return expr;
    }
  }

  // If the expression does not contain a leap, then we either emit the
  // expression as a standalone statement or return it whole.
  if (!meta.containsLeap(expr)) {
    return finish(expr);
  }

  // If any child contains a leap (such as a yield or labeled continue or
  // break statement), then any sibling subexpressions will almost
  // certainly have to be exploded in order to maintain the order of their
  // side effects relative to the leaping child(ren).
  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);

  // In order to save the rest of explodeExpression from a combinatorial
  // trainwreck of special cases, explodeViaTempVar is responsible for
  // deciding when a subexpression needs to be "exploded," which is my
  // very technical term for emitting the subexpression as an assignment
  // to a temporary variable and the substituting the temporary variable
  // for the original subexpression. Think of exploded view diagrams, not
  // Michael Bay movies. The point of exploding subexpressions is to
  // control the precise order in which the generated code realizes the
  // side effects of those subexpressions.
  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
    assert.ok(childPath instanceof types.NodePath);

    assert.ok(
      !ignoreChildResult || !tempVar,
      "Ignoring the result of a child expression but forcing it to " +
        "be assigned to a temporary variable?"
    );

    var result = self.explodeExpression(childPath, ignoreChildResult);

    if (ignoreChildResult) {
      // Side effects already emitted above.

    } else if (tempVar || (hasLeapingChildren &&
                           (self.isVolatileContextProperty(result) ||
                            meta.hasSideEffects(result)))) {
      // If tempVar was provided, then the result will always be assigned
      // to it, even if the result does not otherwise need to be assigned
      // to a temporary variable.  When no tempVar is provided, we have
      // the flexibility to decide whether a temporary variable is really
      // necessary.  In general, temporary assignment is required only
      // when some other child contains a leap and the child in question
      // is a context property like $ctx.sent that might get overwritten
      // or an expression with side effects that need to occur in proper
      // sequence relative to the leap.
      result = self.emitAssign(
        tempVar || self.makeTempVar(),
        result
      );
    }
    return result;
  }

  // If ignoreResult is true, then we must take full responsibility for
  // emitting the expression with all its side effects, and we should not
  // return a result.

  switch (expr.type) {
  case "MemberExpression":
    return finish(b.memberExpression(
      self.explodeExpression(path.get("object")),
      expr.computed
        ? explodeViaTempVar(null, path.get("property"))
        : expr.property,
      expr.computed
    ));

  case "CallExpression":
    var oldCalleePath = path.get("callee");
    var newCallee = self.explodeExpression(oldCalleePath);

    // If the callee was not previously a MemberExpression, then the
    // CallExpression was "unqualified," meaning its `this` object should
    // be the global object. If the exploded expression has become a
    // MemberExpression, then we need to force it to be unqualified by
    // using the (0, object.property)(...) trick; otherwise, it will
    // receive the object of the MemberExpression as its `this` object.
    if (!n.MemberExpression.check(oldCalleePath.node) &&
        n.MemberExpression.check(newCallee)) {
      newCallee = b.sequenceExpression([
        b.literal(0),
        newCallee
      ]);
    }

    return finish(b.callExpression(
      newCallee,
      path.get("arguments").map(function(argPath) {
        return explodeViaTempVar(null, argPath);
      })
    ));

  case "NewExpression":
    return finish(b.newExpression(
      explodeViaTempVar(null, path.get("callee")),
      path.get("arguments").map(function(argPath) {
        return explodeViaTempVar(null, argPath);
      })
    ));

  case "ObjectExpression":
    return finish(b.objectExpression(
      path.get("properties").map(function(propPath) {
        return b.property(
          propPath.value.kind,
          propPath.value.key,
          explodeViaTempVar(null, propPath.get("value"))
        );
      })
    ));

  case "ArrayExpression":
    return finish(b.arrayExpression(
      path.get("elements").map(function(elemPath) {
        return explodeViaTempVar(null, elemPath);
      })
    ));

  case "SequenceExpression":
    var lastIndex = expr.expressions.length - 1;

    path.get("expressions").each(function(exprPath) {
      if (exprPath.name === lastIndex) {
        result = self.explodeExpression(exprPath, ignoreResult);
      } else {
        self.explodeExpression(exprPath, true);
      }
    });

    return result;

  case "LogicalExpression":
    var after = loc();

    if (!ignoreResult) {
      result = self.makeTempVar();
    }

    var left = explodeViaTempVar(result, path.get("left"));

    if (expr.operator === "&&") {
      self.jumpIfNot(left, after);
    } else {
      assert.strictEqual(expr.operator, "||");
      self.jumpIf(left, after);
    }

    explodeViaTempVar(result, path.get("right"), ignoreResult);

    self.mark(after);

    return result;

  case "ConditionalExpression":
    var elseLoc = loc();
    var after = loc();
    var test = self.explodeExpression(path.get("test"));

    self.jumpIfNot(test, elseLoc);

    if (!ignoreResult) {
      result = self.makeTempVar();
    }

    explodeViaTempVar(result, path.get("consequent"), ignoreResult);
    self.jump(after);

    self.mark(elseLoc);
    explodeViaTempVar(result, path.get("alternate"), ignoreResult);

    self.mark(after);

    return result;

  case "UnaryExpression":
    return finish(b.unaryExpression(
      expr.operator,
      // Can't (and don't need to) break up the syntax of the argument.
      // Think about delete a[b].
      self.explodeExpression(path.get("argument")),
      !!expr.prefix
    ));

  case "BinaryExpression":
    return finish(b.binaryExpression(
      expr.operator,
      explodeViaTempVar(null, path.get("left")),
      explodeViaTempVar(null, path.get("right"))
    ));

  case "AssignmentExpression":
    return finish(b.assignmentExpression(
      expr.operator,
      self.explodeExpression(path.get("left")),
      self.explodeExpression(path.get("right"))
    ));

  case "UpdateExpression":
    return finish(b.updateExpression(
      expr.operator,
      self.explodeExpression(path.get("argument")),
      expr.prefix
    ));

  case "YieldExpression":
    var after = loc();
    var arg = expr.argument && self.explodeExpression(path.get("argument"));

    if (arg && expr.delegate) {
      var result = self.makeTempVar();

      self.emit(b.returnStatement(b.callExpression(
        self.contextProperty("delegateYield"), [
          arg,
          b.literal(result.property.name),
          after
        ]
      )));

      self.mark(after);

      return result;
    }

    self.emitAssign(self.contextProperty("next"), after);
    self.emit(b.returnStatement(arg || null));
    self.mark(after);

    return self.contextProperty("sent");

  default:
    throw new Error(
      "unknown Expression of type " +
        JSON.stringify(expr.type));
  }
};

},{"./leap":414,"./meta":415,"./util":416,"assert":698,"ast-types":268}],413:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var hasOwn = Object.prototype.hasOwnProperty;

// The hoist function takes a FunctionExpression or FunctionDeclaration
// and replaces any Declaration nodes in its body with assignments, then
// returns a VariableDeclaration containing just the names of the removed
// declarations.
exports.hoist = function(funPath) {
  assert.ok(funPath instanceof types.NodePath);
  n.Function.assert(funPath.value);

  var vars = {};

  function varDeclToExpr(vdec, includeIdentifiers) {
    n.VariableDeclaration.assert(vdec);
    var exprs = [];

    vdec.declarations.forEach(function(dec) {
      vars[dec.id.name] = dec.id;

      if (dec.init) {
        exprs.push(b.assignmentExpression(
          "=", dec.id, dec.init
        ));
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });

    if (exprs.length === 0)
      return null;

    if (exprs.length === 1)
      return exprs[0];

    return b.sequenceExpression(exprs);
  }

  types.visit(funPath.get("body"), {
    visitVariableDeclaration: function(path) {
      var expr = varDeclToExpr(path.value, false);
      if (expr === null) {
        path.replace();
      } else {
        // We don't need to traverse this expression any further because
        // there can't be any new declarations inside an expression.
        return b.expressionStatement(expr);
      }

      // Since the original node has been either removed or replaced,
      // avoid traversing it any further.
      return false;
    },

    visitForStatement: function(path) {
      var init = path.value.init;
      if (n.VariableDeclaration.check(init)) {
        path.get("init").replace(varDeclToExpr(init, false));
      }
      this.traverse(path);
    },

    visitForInStatement: function(path) {
      var left = path.value.left;
      if (n.VariableDeclaration.check(left)) {
        path.get("left").replace(varDeclToExpr(left, true));
      }
      this.traverse(path);
    },

    visitFunctionDeclaration: function(path) {
      var node = path.value;
      vars[node.id.name] = node.id;

      var parentNode = path.parent.node;
      var assignment = b.expressionStatement(
        b.assignmentExpression(
          "=",
          node.id,
          b.functionExpression(
            node.id,
            node.params,
            node.body,
            node.generator,
            node.expression
          )
        )
      );

      if (n.BlockStatement.check(path.parent.node)) {
        // Insert the assignment form before the first statement in the
        // enclosing block.
        path.parent.get("body").unshift(assignment);

        // Remove the function declaration now that we've inserted the
        // equivalent assignment form at the beginning of the block.
        path.replace();

      } else {
        // If the parent node is not a block statement, then we can just
        // replace the declaration with the equivalent assignment form
        // without worrying about hoisting it.
        path.replace(assignment);
      }

      // Don't hoist variables out of inner functions.
      return false;
    },

    visitFunctionExpression: function(path) {
      // Don't descend into nested function expressions.
      return false;
    }
  });

  var paramNames = {};
  funPath.get("params").each(function(paramPath) {
    var param = paramPath.value;
    if (n.Identifier.check(param)) {
      paramNames[param.name] = param;
    } else {
      // Variables declared by destructuring parameter patterns will be
      // harmlessly re-declared.
    }
  });

  var declarations = [];

  Object.keys(vars).forEach(function(name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(b.variableDeclarator(vars[name], null));
    }
  });

  if (declarations.length === 0) {
    return null; // Be sure to handle this case!
  }

  return b.variableDeclaration("var", declarations);
};

},{"assert":698,"ast-types":268}],414:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var inherits = require("util").inherits;
var hasOwn = Object.prototype.hasOwnProperty;

function Entry() {
  assert.ok(this instanceof Entry);
}

function FunctionEntry(returnLoc) {
  Entry.call(this);
  n.Literal.assert(returnLoc);
  this.returnLoc = returnLoc;
}

inherits(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;

function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);

  n.Literal.assert(breakLoc);
  n.Literal.assert(continueLoc);

  if (label) {
    n.Identifier.assert(label);
  } else {
    label = null;
  }

  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}

inherits(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;

function SwitchEntry(breakLoc) {
  Entry.call(this);
  n.Literal.assert(breakLoc);
  this.breakLoc = breakLoc;
}

inherits(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;

function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);

  n.Literal.assert(firstLoc);

  if (catchEntry) {
    assert.ok(catchEntry instanceof CatchEntry);
  } else {
    catchEntry = null;
  }

  if (finallyEntry) {
    assert.ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  }

  // Have to have one or the other (or both).
  assert.ok(catchEntry || finallyEntry);

  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}

inherits(TryEntry, Entry);
exports.TryEntry = TryEntry;

function CatchEntry(firstLoc, paramId) {
  Entry.call(this);

  n.Literal.assert(firstLoc);
  n.Identifier.assert(paramId);

  this.firstLoc = firstLoc;
  this.paramId = paramId;
}

inherits(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;

function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  n.Literal.assert(firstLoc);
  n.Literal.assert(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}

inherits(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;

function LabeledEntry(breakLoc, label) {
  Entry.call(this);

  n.Literal.assert(breakLoc);
  n.Identifier.assert(label);

  this.breakLoc = breakLoc;
  this.label = label;
}

inherits(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;

function LeapManager(emitter) {
  assert.ok(this instanceof LeapManager);

  var Emitter = require("./emit").Emitter;
  assert.ok(emitter instanceof Emitter);

  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}

var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;

LMp.withEntry = function(entry, callback) {
  assert.ok(entry instanceof Entry);
  this.entryStack.push(entry);
  try {
    callback.call(this.emitter);
  } finally {
    var popped = this.entryStack.pop();
    assert.strictEqual(popped, entry);
  }
};

LMp._findLeapLocation = function(property, label) {
  for (var i = this.entryStack.length - 1; i >= 0; --i) {
    var entry = this.entryStack[i];
    var loc = entry[property];
    if (loc) {
      if (label) {
        if (entry.label &&
            entry.label.name === label.name) {
          return loc;
        }
      } else if (entry instanceof LabeledEntry) {
        // Ignore LabeledEntry entries unless we are actually breaking to
        // a label.
      } else {
        return loc;
      }
    }
  }

  return null;
};

LMp.getBreakLoc = function(label) {
  return this._findLeapLocation("breakLoc", label);
};

LMp.getContinueLoc = function(label) {
  return this._findLeapLocation("continueLoc", label);
};

},{"./emit":412,"assert":698,"ast-types":268,"util":723}],415:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var m = require("private").makeAccessor();
var types = require("ast-types");
var isArray = types.builtInTypes.array;
var n = types.namedTypes;
var hasOwn = Object.prototype.hasOwnProperty;

function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    n.Node.assert(node);

    // Assume no side effects until we find out otherwise.
    var result = false;

    function check(child) {
      if (result) {
        // Do nothing.
      } else if (isArray.check(child)) {
        child.some(check);
      } else if (n.Node.check(child)) {
        assert.strictEqual(result, false);
        result = predicate(child);
      }
      return result;
    }

    types.eachField(node, function(name, child) {
      check(child);
    });

    return result;
  }

  function predicate(node) {
    n.Node.assert(node);

    var meta = m(node);
    if (hasOwn.call(meta, propertyName))
      return meta[propertyName];

    // Certain types are "opaque," which means they have no side
    // effects or leaps and we don't care about their subexpressions.
    if (hasOwn.call(opaqueTypes, node.type))
      return meta[propertyName] = false;

    if (hasOwn.call(knownTypes, node.type))
      return meta[propertyName] = true;

    return meta[propertyName] = onlyChildren(node);
  }

  predicate.onlyChildren = onlyChildren;

  return predicate;
}

var opaqueTypes = {
  FunctionExpression: true
};

// These types potentially have side effects regardless of what side
// effects their subexpressions have.
var sideEffectTypes = {
  CallExpression: true, // Anything could happen!
  ForInStatement: true, // Modifies the key variable.
  UnaryExpression: true, // Think delete.
  BinaryExpression: true, // Might invoke .toString() or .valueOf().
  AssignmentExpression: true, // Side-effecting by definition.
  UpdateExpression: true, // Updates are essentially assignments.
  NewExpression: true // Similar to CallExpression.
};

// These types are the direct cause of all leaps in control flow.
var leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
};

// All leap types are also side effect types.
for (var type in leapTypes) {
  if (hasOwn.call(leapTypes, type)) {
    sideEffectTypes[type] = leapTypes[type];
  }
}

exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
exports.containsLeap = makePredicate("containsLeap", leapTypes);

},{"assert":698,"ast-types":268,"private":411}],416:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var hasOwn = Object.prototype.hasOwnProperty;

exports.defaults = function(obj) {
  var len = arguments.length;
  var extension;

  for (var i = 1; i < len; ++i) {
    if ((extension = arguments[i])) {
      for (var key in extension) {
        if (hasOwn.call(extension, key) && !hasOwn.call(obj, key)) {
          obj[key] = extension[key];
        }
      }
    }
  }

  return obj;
};

exports.runtimeProperty = function(name) {
  return b.memberExpression(
    b.identifier("regeneratorRuntime"),
    b.identifier(name),
    false
  );
};

// Inspired by the isReference function from ast-util:
// https://github.com/eventualbuddha/ast-util/blob/9bf91c5ce8/lib/index.js#L466-L506
exports.isReference = function(path, name) {
  var node = path.value;

  if (!n.Identifier.check(node)) {
    return false;
  }

  if (name && node.name !== name) {
    return false;
  }

  var parent = path.parent.value;

  switch (parent.type) {
  case "VariableDeclarator":
    return path.name === "init";

  case "MemberExpression":
    return path.name === "object" || (
      parent.computed && path.name === "property"
    );

  case "FunctionExpression":
  case "FunctionDeclaration":
  case "ArrowFunctionExpression":
    if (path.name === "id") {
      return false;
    }

    if (parent.params === path.parentPath &&
        parent.params[path.name] === node) {
      return false;
    }

    return true;

  case "ClassDeclaration":
  case "ClassExpression":
    return path.name !== "id";

  case "CatchClause":
    return path.name !== "param";

  case "Property":
  case "MethodDefinition":
    return path.name !== "key";

  case "ImportSpecifier":
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "LabeledStatement":
    return false;

  default:
    return true;
  }
};

},{"assert":698,"ast-types":268}],417:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var fs = require("fs");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var NodePath = types.NodePath;
var hoist = require("./hoist").hoist;
var Emitter = require("./emit").Emitter;
var runtimeProperty = require("./util").runtimeProperty;

exports.transform = function transform(node, options) {
  options = options || {};

  var path = node instanceof NodePath ? node : new NodePath(node);
  visitor.visit(path, options);
  node = path.value;

  options.madeChanges = visitor.wasChangeReported();

  return node;
};

var visitor = types.PathVisitor.fromMethodsObject({
  reset: function(node, options) {
    this.options = options;
  },

  visitFunction: function(path) {
    // Calling this.traverse(path) first makes for a post-order traversal.
    this.traverse(path);

    var node = path.value;
    var shouldTransformAsync = node.async && !this.options.disableAsync;

    if (!node.generator && !shouldTransformAsync) {
      return;
    }

    this.reportChanged();

    node.generator = false;

    if (node.expression) {
      // Transform expression lambdas into normal functions.
      node.expression = false;
      node.body = b.blockStatement([
        b.returnStatement(node.body)
      ]);
    }

    if (shouldTransformAsync) {
      awaitVisitor.visit(path.get("body"));
    }

    var outerFnId = node.id || (
      node.id = path.scope.parent.declareTemporary("callee$")
    );

    var outerBody = [];
    var bodyBlock = path.value.body;
    bodyBlock.body = bodyBlock.body.filter(function (node) {
      if (node && node._blockHoist != null) {
        outerBody.push(node);
        return false;
      } else {
        return true;
      }
    });

    var innerFnId = b.identifier(node.id.name + "$");
    var contextId = path.scope.declareTemporary("context$");
    var vars = hoist(path);

    var emitter = new Emitter(contextId);
    emitter.explode(path.get("body"));

    if (vars && vars.declarations.length > 0) {
      outerBody.push(vars);
    }

    var wrapArgs = [
      emitter.getContextFunction(innerFnId),
      // Async functions don't care about the outer function because they
      // don't need it to be marked and don't inherit from its .prototype.
      shouldTransformAsync ? b.literal(null) : outerFnId,
      b.thisExpression()
    ];

    var tryLocsList = emitter.getTryLocsList();
    if (tryLocsList) {
      wrapArgs.push(tryLocsList);
    }

    var wrapCall = b.callExpression(
      shouldTransformAsync ? runtimeProperty("async") : runtimeProperty("wrap"),
      wrapArgs
    );

    outerBody.push(b.returnStatement(wrapCall));
    node.body = b.blockStatement(outerBody);
    node.body._declarations = bodyBlock._declarations;

    if (shouldTransformAsync) {
      node.async = false;
      return;
    }

    if (n.FunctionDeclaration.check(node)) {
      var pp = path.parent;

      while (pp && !(n.BlockStatement.check(pp.value) ||
                     n.Program.check(pp.value))) {
        pp = pp.parent;
      }

      if (!pp) {
        return;
      }

      // Here we turn the FunctionDeclaration into a named
      // FunctionExpression that will be assigned to a variable of the
      // same name at the top of the enclosing block. This is important
      // for a very subtle reason: named function expressions can refer to
      // themselves by name without fear that the binding may change due
      // to code executing outside the function, whereas function
      // declarations are vulnerable to the following rebinding:
      //
      //   function f() { return f }
      //   var g = f;
      //   f = "asdf";
      //   g(); // "asdf"
      //
      // One way to prevent the problem illustrated above is to transform
      // the function declaration thus:
      //
      //   var f = function f() { return f };
      //   var g = f;
      //   f = "asdf";
      //   g(); // f
      //   g()()()()(); // f
      //
      // In the code below, we transform generator function declarations
      // in the following way:
      //
      //   gen().next(); // { value: gen, done: true }
      //   function *gen() {
      //     return gen;
      //   }
      //
      // becomes something like
      //
      //   var gen = runtime.mark(function *gen() {
      //     return gen;
      //   });
      //   gen().next(); // { value: gen, done: true }
      //
      // which ensures that the generator body can always reliably refer
      // to gen by name.

      // Remove the FunctionDeclaration so that we can add it back as a
      // FunctionExpression passed to runtime.mark.
      path.replace();

      // Change the type of the function to be an expression instead of a
      // declaration. Note that all the other fields are the same.
      node.type = "FunctionExpression";

      var varDecl = b.variableDeclaration("var", [
        b.variableDeclarator(
          node.id,
          b.callExpression(runtimeProperty("mark"), [node])
        )
      ]);

      if (node.comments) {
        // Copy any comments preceding the function declaration to the
        // variable declaration, to avoid weird formatting consequences.
        varDecl.leadingComments = node.leadingComments;
        varDecl.trailingComments = node.trailingComments;
        node.leadingComments = null;
        node.trailingComments = null;
      }

      varDecl._blockHoist = 3;

      var bodyPath = pp.get("body");
      var bodyLen = bodyPath.value.length;

      bodyPath.push(varDecl);

    } else {
      n.FunctionExpression.assert(node);
      return b.callExpression(runtimeProperty("mark"), [node]);
    }
  }
});

function shouldNotHoistAbove(stmtPath) {
  var value = stmtPath.value;
  n.Statement.assert(value);

  // If the first statement is a "use strict" declaration, make sure to
  // insert hoisted declarations afterwards.
  if (n.ExpressionStatement.check(value) &&
      n.Literal.check(value.expression) &&
      value.expression.value === "use strict") {
    return true;
  }

  if (n.VariableDeclaration.check(value)) {
    for (var i = 0; i < value.declarations.length; ++i) {
      var decl = value.declarations[i];
      if (n.CallExpression.check(decl.init) &&
          types.astNodesAreEquivalent(decl.init.callee,
                                      runtimeProperty("mark"))) {
        return true;
      }
    }
  }

  return false;
}

var awaitVisitor = types.PathVisitor.fromMethodsObject({
  visitFunction: function(path) {
    return false; // Don't descend into nested function scopes.
  },

  visitAwaitExpression: function(path) {
    // Convert await and await* expressions to yield expressions.
    var argument = path.value.argument;

    // If the parser supports await* syntax using a boolean .all property
    // (#171), desugar that syntax to yield Promise.all(argument).
    if (path.value.all) {
      argument = b.callExpression(
        b.memberExpression(
          b.identifier("Promise"),
          b.identifier("all"),
          false
        ),
        [argument]
      );
    }

    return b.yieldExpression(argument, false);
  }
});

},{"./emit":412,"./hoist":413,"./util":416,"assert":698,"ast-types":268,"fs":697}],418:[function(require,module,exports){
(function (__dirname){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var path = require("path");
var fs = require("fs");
var through = require("through");
var transform = require("./lib/visit").transform;
var utils = require("./lib/util");
var types = require("ast-types");
var genOrAsyncFunExp = /\bfunction\s*\*|\basync\b/;
var blockBindingExp = /\b(let|const)\s+/;

function exports(file, options) {
  var data = [];
  return through(write, end);

  function write(buf) {
    data.push(buf);
  }

  function end() {
    this.queue(compile(data.join(""), options).code);
    this.queue(null);
  }
}

// To get a writable stream for use as a browserify transform, call
// require("regenerator")().
module.exports = exports;

// To include the runtime globally in the current node process, call
// require("regenerator").runtime().
function runtime() {
  require("./runtime");
}
exports.runtime = runtime;
runtime.path = path.join(__dirname, "runtime.js");

// To modify an AST directly, call require("regenerator").transform(ast).
exports.transform = transform;

}).call(this,"/node_modules/earlgrey/node_modules/babel/node_modules/regenerator-babel")
},{"./lib/util":416,"./lib/visit":417,"./runtime":420,"assert":698,"ast-types":268,"fs":697,"path":706,"through":419}],419:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data == null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))
},{"_process":707,"stream":719}],420:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg < finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          return this.complete(entry.completion, entry.afterLoc);
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],421:[function(require,module,exports){
// Generated by `/scripts/character-class-escape-sets.js`. Do not edit.
var regenerate = require('regenerate');

exports.REGULAR = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0xFFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0xFFFF),
	'w': regenerate(0x5F)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0xFFFF)
};

exports.UNICODE = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x10FFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0x10FFFF),
	'w': regenerate(0x5F)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0x10FFFF)
};

exports.UNICODE_IGNORE_CASE = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x10FFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0x10FFFF),
	'w': regenerate(0x5F, 0x17F, 0x212A)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x4B, 0x53, 0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0x10FFFF)
};

},{"regenerate":423}],422:[function(require,module,exports){
module.exports={
	"75": 8490,
	"83": 383,
	"107": 8490,
	"115": 383,
	"181": 924,
	"197": 8491,
	"383": 83,
	"452": 453,
	"453": 452,
	"455": 456,
	"456": 455,
	"458": 459,
	"459": 458,
	"497": 498,
	"498": 497,
	"837": 8126,
	"914": 976,
	"917": 1013,
	"920": 1012,
	"921": 8126,
	"922": 1008,
	"924": 181,
	"928": 982,
	"929": 1009,
	"931": 962,
	"934": 981,
	"937": 8486,
	"962": 931,
	"976": 914,
	"977": 1012,
	"981": 934,
	"982": 928,
	"1008": 922,
	"1009": 929,
	"1012": [
		920,
		977
	],
	"1013": 917,
	"7776": 7835,
	"7835": 7776,
	"8126": [
		837,
		921
	],
	"8486": 937,
	"8490": 75,
	"8491": 197,
	"66560": 66600,
	"66561": 66601,
	"66562": 66602,
	"66563": 66603,
	"66564": 66604,
	"66565": 66605,
	"66566": 66606,
	"66567": 66607,
	"66568": 66608,
	"66569": 66609,
	"66570": 66610,
	"66571": 66611,
	"66572": 66612,
	"66573": 66613,
	"66574": 66614,
	"66575": 66615,
	"66576": 66616,
	"66577": 66617,
	"66578": 66618,
	"66579": 66619,
	"66580": 66620,
	"66581": 66621,
	"66582": 66622,
	"66583": 66623,
	"66584": 66624,
	"66585": 66625,
	"66586": 66626,
	"66587": 66627,
	"66588": 66628,
	"66589": 66629,
	"66590": 66630,
	"66591": 66631,
	"66592": 66632,
	"66593": 66633,
	"66594": 66634,
	"66595": 66635,
	"66596": 66636,
	"66597": 66637,
	"66598": 66638,
	"66599": 66639,
	"66600": 66560,
	"66601": 66561,
	"66602": 66562,
	"66603": 66563,
	"66604": 66564,
	"66605": 66565,
	"66606": 66566,
	"66607": 66567,
	"66608": 66568,
	"66609": 66569,
	"66610": 66570,
	"66611": 66571,
	"66612": 66572,
	"66613": 66573,
	"66614": 66574,
	"66615": 66575,
	"66616": 66576,
	"66617": 66577,
	"66618": 66578,
	"66619": 66579,
	"66620": 66580,
	"66621": 66581,
	"66622": 66582,
	"66623": 66583,
	"66624": 66584,
	"66625": 66585,
	"66626": 66586,
	"66627": 66587,
	"66628": 66588,
	"66629": 66589,
	"66630": 66590,
	"66631": 66591,
	"66632": 66592,
	"66633": 66593,
	"66634": 66594,
	"66635": 66595,
	"66636": 66596,
	"66637": 66597,
	"66638": 66598,
	"66639": 66599,
	"71840": 71872,
	"71841": 71873,
	"71842": 71874,
	"71843": 71875,
	"71844": 71876,
	"71845": 71877,
	"71846": 71878,
	"71847": 71879,
	"71848": 71880,
	"71849": 71881,
	"71850": 71882,
	"71851": 71883,
	"71852": 71884,
	"71853": 71885,
	"71854": 71886,
	"71855": 71887,
	"71856": 71888,
	"71857": 71889,
	"71858": 71890,
	"71859": 71891,
	"71860": 71892,
	"71861": 71893,
	"71862": 71894,
	"71863": 71895,
	"71864": 71896,
	"71865": 71897,
	"71866": 71898,
	"71867": 71899,
	"71868": 71900,
	"71869": 71901,
	"71870": 71902,
	"71871": 71903,
	"71872": 71840,
	"71873": 71841,
	"71874": 71842,
	"71875": 71843,
	"71876": 71844,
	"71877": 71845,
	"71878": 71846,
	"71879": 71847,
	"71880": 71848,
	"71881": 71849,
	"71882": 71850,
	"71883": 71851,
	"71884": 71852,
	"71885": 71853,
	"71886": 71854,
	"71887": 71855,
	"71888": 71856,
	"71889": 71857,
	"71890": 71858,
	"71891": 71859,
	"71892": 71860,
	"71893": 71861,
	"71894": 71862,
	"71895": 71863,
	"71896": 71864,
	"71897": 71865,
	"71898": 71866,
	"71899": 71867,
	"71900": 71868,
	"71901": 71869,
	"71902": 71870,
	"71903": 71871
}

},{}],423:[function(require,module,exports){
(function (global){
/*! https://mths.be/regenerate v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`.
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var ERRORS = {
		'rangeOrder': 'A range\u2019s `stop` value must be greater than or equal ' +
			'to the `start` value.',
		'codePointRange': 'Invalid code point value. Code points range from ' +
			'U+000000 to U+10FFFF.'
	};

	// https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs
	var HIGH_SURROGATE_MIN = 0xD800;
	var HIGH_SURROGATE_MAX = 0xDBFF;
	var LOW_SURROGATE_MIN = 0xDC00;
	var LOW_SURROGATE_MAX = 0xDFFF;

	// In Regenerate output, `\0` will never be preceded by `\` because we sort
	// by code point value, so let’s keep this regular expression simple.
	var regexNull = /\\x00([^0123456789]|$)/g;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var extend = function(destination, source) {
		var key;
		for (key in source) {
			if (hasOwnProperty.call(source, key)) {
				destination[key] = source[key];
			}
		}
		return destination;
	};

	var forEach = function(array, callback) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			callback(array[index], index);
		}
	};

	var toString = object.toString;
	var isArray = function(value) {
		return toString.call(value) == '[object Array]';
	};
	var isNumber = function(value) {
		return typeof value == 'number' ||
			toString.call(value) == '[object Number]';
	};

	// This assumes that `number` is a positive integer that `toString()`s nicely
	// (which is the case for all code point values).
	var zeroes = '0000';
	var pad = function(number, totalCharacters) {
		var string = String(number);
		return string.length < totalCharacters
			? (zeroes + string).slice(-totalCharacters)
			: string;
	};

	var hex = function(number) {
		return Number(number).toString(16).toUpperCase();
	};

	var slice = [].slice;

	/*--------------------------------------------------------------------------*/

	var dataFromCodePoints = function(codePoints) {
		var index = -1;
		var length = codePoints.length;
		var max = length - 1;
		var result = [];
		var isStart = true;
		var tmp;
		var previous = 0;
		while (++index < length) {
			tmp = codePoints[index];
			if (isStart) {
				result.push(tmp);
				previous = tmp;
				isStart = false;
			} else {
				if (tmp == previous + 1) {
					if (index != max) {
						previous = tmp;
						continue;
					} else {
						isStart = true;
						result.push(tmp + 1);
					}
				} else {
					// End the previous range and start a new one.
					result.push(previous + 1, tmp);
					previous = tmp;
				}
			}
		}
		if (!isStart) {
			result.push(tmp + 1);
		}
		return result;
	};

	var dataRemove = function(data, codePoint) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			if (codePoint >= start && codePoint < end) {
				// Modify this pair.
				if (codePoint == start) {
					if (end == start + 1) {
						// Just remove `start` and `end`.
						data.splice(index, 2);
						return data;
					} else {
						// Just replace `start` with a new value.
						data[index] = codePoint + 1;
						return data;
					}
				} else if (codePoint == end - 1) {
					// Just replace `end` with a new value.
					data[index + 1] = codePoint;
					return data;
				} else {
					// Replace `[start, end]` with `[startA, endA, startB, endB]`.
					data.splice(index, 2, start, codePoint, codePoint + 1, end);
					return data;
				}
			}
			index += 2;
		}
		return data;
	};

	var dataRemoveRange = function(data, rangeStart, rangeEnd) {
		if (rangeEnd < rangeStart) {
			throw Error(ERRORS.rangeOrder);
		}
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		while (index < data.length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

			// Exit as soon as no more matching pairs can be found.
			if (start > rangeEnd) {
				return data;
			}

			// Check if this range pair is equal to, or forms a subset of, the range
			// to be removed.
			// E.g. we have `[0, 11, 40, 51]` and want to remove 0-10 → `[40, 51]`.
			// E.g. we have `[40, 51]` and want to remove 0-100 → `[]`.
			if (rangeStart <= start && rangeEnd >= end) {
				// Remove this pair.
				data.splice(index, 2);
				continue;
			}

			// Check if both `rangeStart` and `rangeEnd` are within the bounds of
			// this pair.
			// E.g. we have `[0, 11]` and want to remove 4-6 → `[0, 4, 7, 11]`.
			if (rangeStart >= start && rangeEnd < end) {
				if (rangeStart == start) {
					// Replace `[start, end]` with `[startB, endB]`.
					data[index] = rangeEnd + 1;
					data[index + 1] = end + 1;
					return data;
				}
				// Replace `[start, end]` with `[startA, endA, startB, endB]`.
				data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
				return data;
			}

			// Check if only `rangeStart` is within the bounds of this pair.
			// E.g. we have `[0, 11]` and want to remove 4-20 → `[0, 4]`.
			if (rangeStart >= start && rangeStart <= end) {
				// Replace `end` with `rangeStart`.
				data[index + 1] = rangeStart;
				// Note: we cannot `return` just yet, in case any following pairs still
				// contain matching code points.
				// E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
				// → `[0, 4, 21, 31]`.
			}

			// Check if only `rangeEnd` is within the bounds of this pair.
			// E.g. we have `[14, 31]` and want to remove 4-20 → `[21, 31]`.
			else if (rangeEnd >= start && rangeEnd <= end) {
				// Just replace `start`.
				data[index] = rangeEnd + 1;
				return data;
			}

			index += 2;
		}
		return data;
	};

	 var dataAdd = function(data, codePoint) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var lastIndex = null;
		var length = data.length;
		if (codePoint < 0x0 || codePoint > 0x10FFFF) {
			throw RangeError(ERRORS.codePointRange);
		}
		while (index < length) {
			start = data[index];
			end = data[index + 1];

			// Check if the code point is already in the set.
			if (codePoint >= start && codePoint < end) {
				return data;
			}

			if (codePoint == start - 1) {
				// Just replace `start` with a new value.
				data[index] = codePoint;
				return data;
			}

			// At this point, if `start` is `greater` than `codePoint`, insert a new
			// `[start, end]` pair before the current pair, or after the current pair
			// if there is a known `lastIndex`.
			if (start > codePoint) {
				data.splice(
					lastIndex != null ? lastIndex + 2 : 0,
					0,
					codePoint,
					codePoint + 1
				);
				return data;
			}

			if (codePoint == end) {
				// Check if adding this code point causes two separate ranges to become
				// a single range, e.g. `dataAdd([0, 4, 5, 10], 4)` → `[0, 10]`.
				if (codePoint + 1 == data[index + 2]) {
					data.splice(index, 4, start, data[index + 3]);
					return data;
				}
				// Else, just replace `end` with a new value.
				data[index + 1] = codePoint + 1;
				return data;
			}
			lastIndex = index;
			index += 2;
		}
		// The loop has finished; add the new pair to the end of the data set.
		data.push(codePoint, codePoint + 1);
		return data;
	};

	var dataAddData = function(dataA, dataB) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var data = dataA.slice();
		var length = dataB.length;
		while (index < length) {
			start = dataB[index];
			end = dataB[index + 1] - 1;
			if (start == end) {
				data = dataAdd(data, start);
			} else {
				data = dataAddRange(data, start, end);
			}
			index += 2;
		}
		return data;
	};

	var dataRemoveData = function(dataA, dataB) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var data = dataA.slice();
		var length = dataB.length;
		while (index < length) {
			start = dataB[index];
			end = dataB[index + 1] - 1;
			if (start == end) {
				data = dataRemove(data, start);
			} else {
				data = dataRemoveRange(data, start, end);
			}
			index += 2;
		}
		return data;
	};

	var dataAddRange = function(data, rangeStart, rangeEnd) {
		if (rangeEnd < rangeStart) {
			throw Error(ERRORS.rangeOrder);
		}
		if (
			rangeStart < 0x0 || rangeStart > 0x10FFFF ||
			rangeEnd < 0x0 || rangeEnd > 0x10FFFF
		) {
			throw RangeError(ERRORS.codePointRange);
		}
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var added = false;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];

			if (added) {
				// The range has already been added to the set; at this point, we just
				// need to get rid of the following ranges in case they overlap.

				// Check if this range can be combined with the previous range.
				if (start == rangeEnd + 1) {
					data.splice(index - 1, 2);
					return data;
				}

				// Exit as soon as no more possibly overlapping pairs can be found.
				if (start > rangeEnd) {
					return data;
				}

				// E.g. `[0, 11, 12, 16]` and we’ve added 5-15, so we now have
				// `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
				// `0,16` range that was previously added.
				if (start >= rangeStart && start <= rangeEnd) {
					// `start` lies within the range that was previously added.

					if (end > rangeStart && end - 1 <= rangeEnd) {
						// `end` lies within the range that was previously added as well,
						// so remove this pair.
						data.splice(index, 2);
						index -= 2;
						// Note: we cannot `return` just yet, as there may still be other
						// overlapping pairs.
					} else {
						// `start` lies within the range that was previously added, but
						// `end` doesn’t. E.g. `[0, 11, 12, 31]` and we’ve added 5-15, so
						// now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
						// Remove the previously added `end` and the current `start`.
						data.splice(index - 1, 2);
						index -= 2;
					}

					// Note: we cannot return yet.
				}

			}

			else if (start == rangeEnd + 1) {
				data[index] = rangeStart;
				return data;
			}

			// Check if a new pair must be inserted *before* the current one.
			else if (start > rangeEnd) {
				data.splice(index, 0, rangeStart, rangeEnd + 1);
				return data;
			}

			else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
				// The new range lies entirely within an existing range pair. No action
				// needed.
				return data;
			}

			else if (
				// E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.
				(rangeStart >= start && rangeStart < end) ||
				// E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.
				end == rangeStart
			) {
				// Replace `end` with the new value.
				data[index + 1] = rangeEnd + 1;
				// Make sure the next range pair doesn’t overlap, e.g. `[0, 11, 12, 14]`
				// and you add 5-15 → `[0, 16]`, i.e. remove the `12,14` part.
				added = true;
				// Note: we cannot `return` just yet.
			}

			else if (rangeStart <= start && rangeEnd + 1 >= end) {
				// The new range is a superset of the old range.
				data[index] = rangeStart;
				data[index + 1] = rangeEnd + 1;
				added = true;
			}

			index += 2;
		}
		// The loop has finished without doing anything; add the new pair to the end
		// of the data set.
		if (!added) {
			data.push(rangeStart, rangeEnd + 1);
		}
		return data;
	};

	var dataContains = function(data, codePoint) {
		var index = 0;
		var length = data.length;
		// Exit early if `codePoint` is not within `data`’s overall range.
		var start = data[index];
		var end = data[length - 1];
		if (length >= 2) {
			if (codePoint < start || codePoint > end) {
				return false;
			}
		}
		// Iterate over the data per `(start, end)` pair.
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			if (codePoint >= start && codePoint < end) {
				return true;
			}
			index += 2;
		}
		return false;
	};

	var dataIntersection = function(data, codePoints) {
		var index = 0;
		var length = codePoints.length;
		var codePoint;
		var result = [];
		while (index < length) {
			codePoint = codePoints[index];
			if (dataContains(data, codePoint)) {
				result.push(codePoint);
			}
			++index;
		}
		return dataFromCodePoints(result);
	};

	var dataIsEmpty = function(data) {
		return !data.length;
	};

	var dataIsSingleton = function(data) {
		// Check if the set only represents a single code point.
		return data.length == 2 && data[0] + 1 == data[1];
	};

	var dataToArray = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var result = [];
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			while (start < end) {
				result.push(start);
				++start;
			}
			index += 2;
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var floor = Math.floor;
	var highSurrogate = function(codePoint) {
		return parseInt(
			floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN,
			10
		);
	};

	var lowSurrogate = function(codePoint) {
		return parseInt(
			(codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN,
			10
		);
	};

	var stringFromCharCode = String.fromCharCode;
	var codePointToString = function(codePoint) {
		var string;
		// https://mathiasbynens.be/notes/javascript-escapes#single
		// Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
		// different meaning in regular expressions (word boundary), so it cannot
		// be used here.
		if (codePoint == 0x09) {
			string = '\\t';
		}
		// Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
		// else if (codePoint == 0x0B) {
		// 	string = '\\v';
		// }
		else if (codePoint == 0x0A) {
			string = '\\n';
		}
		else if (codePoint == 0x0C) {
			string = '\\f';
		}
		else if (codePoint == 0x0D) {
			string = '\\r';
		}
		else if (codePoint == 0x5C) {
			string = '\\\\';
		}
		else if (
			codePoint == 0x24 ||
			(codePoint >= 0x28 && codePoint <= 0x2B) ||
			codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F ||
			(codePoint >= 0x5B && codePoint <= 0x5E) ||
			(codePoint >= 0x7B && codePoint <= 0x7D)
		) {
			// The code point maps to an unsafe printable ASCII character;
			// backslash-escape it. Here’s the list of those symbols:
			//
			//     $()*+-.?[\]^{|}
			//
			// See #7 for more info.
			string = '\\' + stringFromCharCode(codePoint);
		}
		else if (codePoint >= 0x20 && codePoint <= 0x7E) {
			// The code point maps to one of these printable ASCII symbols
			// (including the space character):
			//
			//      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
			//     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
			//
			// These can safely be used directly.
			string = stringFromCharCode(codePoint);
		}
		else if (codePoint <= 0xFF) {
			// https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
			string = '\\x' + pad(hex(codePoint), 2);
		}
		else { // `codePoint <= 0xFFFF` holds true.
			// https://mathiasbynens.be/notes/javascript-escapes#unicode
			string = '\\u' + pad(hex(codePoint), 4);
		}

		// There’s no need to account for astral symbols / surrogate pairs here,
		// since `codePointToString` is private and only used for BMP code points.
		// But if that’s what you need, just add an `else` block with this code:
		//
		//     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
		//     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);

		return string;
	};

	var symbolToCodePoint = function(symbol) {
		var length = symbol.length;
		var first = symbol.charCodeAt(0);
		var second;
		if (
			first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX &&
			length > 1 // There is a next code unit.
		) {
			// `first` is a high surrogate, and there is a next character. Assume
			// it’s a low surrogate (else it’s invalid usage of Regenerate anyway).
			second = symbol.charCodeAt(1);
			// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
			return (first - HIGH_SURROGATE_MIN) * 0x400 +
				second - LOW_SURROGATE_MIN + 0x10000;
		}
		return first;
	};

	var createBMPCharacterClasses = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var result = '';
		var index = 0;
		var start;
		var end;
		var length = data.length;
		if (dataIsSingleton(data)) {
			return codePointToString(data[0]);
		}
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
			if (start == end) {
				result += codePointToString(start);
			} else if (start + 1 == end) {
				result += codePointToString(start) + codePointToString(end);
			} else {
				result += codePointToString(start) + '-' + codePointToString(end);
			}
			index += 2;
		}
		return '[' + result + ']';
	};

	var splitAtBMP = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var loneHighSurrogates = [];
		var loneLowSurrogates = [];
		var bmp = [];
		var astral = [];
		var index = 0;
		var start;
		var end;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

			if (start < HIGH_SURROGATE_MIN) {

				// The range starts and ends before the high surrogate range.
				// E.g. (0, 0x10).
				if (end < HIGH_SURROGATE_MIN) {
					bmp.push(start, end + 1);
				}

				// The range starts before the high surrogate range and ends within it.
				// E.g. (0, 0xD855).
				if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
				}

				// The range starts before the high surrogate range and ends in the low
				// surrogate range. E.g. (0, 0xDCFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
				}

				// The range starts before the high surrogate range and ends after the
				// low surrogate range. E.g. (0, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {

				// The range starts and ends in the high surrogate range.
				// E.g. (0xD855, 0xD866).
				if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
					loneHighSurrogates.push(start, end + 1);
				}

				// The range starts in the high surrogate range and ends in the low
				// surrogate range. E.g. (0xD855, 0xDCFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
				}

				// The range starts in the high surrogate range and ends after the low
				// surrogate range. E.g. (0xD855, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {

				// The range starts and ends in the low surrogate range.
				// E.g. (0xDCFF, 0xDDFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					loneLowSurrogates.push(start, end + 1);
				}

				// The range starts in the low surrogate range and ends after the low
				// surrogate range. E.g. (0xDCFF, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {

				// The range starts and ends after the low surrogate range.
				// E.g. (0xFFAA, 0x10FFFF).
				if (end <= 0xFFFF) {
					bmp.push(start, end + 1);
				} else {
					bmp.push(start, 0xFFFF + 1);
					astral.push(0xFFFF + 1, end + 1);
				}

			} else {

				// The range starts and ends in the astral range.
				astral.push(start, end + 1);

			}

			index += 2;
		}
		return {
			'loneHighSurrogates': loneHighSurrogates,
			'loneLowSurrogates': loneLowSurrogates,
			'bmp': bmp,
			'astral': astral
		};
	};

	var optimizeSurrogateMappings = function(surrogateMappings) {
		var result = [];
		var tmpLow = [];
		var addLow = false;
		var mapping;
		var nextMapping;
		var highSurrogates;
		var lowSurrogates;
		var nextHighSurrogates;
		var nextLowSurrogates;
		var index = -1;
		var length = surrogateMappings.length;
		while (++index < length) {
			mapping = surrogateMappings[index];
			nextMapping = surrogateMappings[index + 1];
			if (!nextMapping) {
				result.push(mapping);
				continue;
			}
			highSurrogates = mapping[0];
			lowSurrogates = mapping[1];
			nextHighSurrogates = nextMapping[0];
			nextLowSurrogates = nextMapping[1];

			// Check for identical high surrogate ranges.
			tmpLow = lowSurrogates;
			while (
				nextHighSurrogates &&
				highSurrogates[0] == nextHighSurrogates[0] &&
				highSurrogates[1] == nextHighSurrogates[1]
			) {
				// Merge with the next item.
				if (dataIsSingleton(nextLowSurrogates)) {
					tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
				} else {
					tmpLow = dataAddRange(
						tmpLow,
						nextLowSurrogates[0],
						nextLowSurrogates[1] - 1
					);
				}
				++index;
				mapping = surrogateMappings[index];
				highSurrogates = mapping[0];
				lowSurrogates = mapping[1];
				nextMapping = surrogateMappings[index + 1];
				nextHighSurrogates = nextMapping && nextMapping[0];
				nextLowSurrogates = nextMapping && nextMapping[1];
				addLow = true;
			}
			result.push([
				highSurrogates,
				addLow ? tmpLow : lowSurrogates
			]);
			addLow = false;
		}
		return optimizeByLowSurrogates(result);
	};

	var optimizeByLowSurrogates = function(surrogateMappings) {
		if (surrogateMappings.length == 1) {
			return surrogateMappings;
		}
		var index = -1;
		var innerIndex = -1;
		while (++index < surrogateMappings.length) {
			var mapping = surrogateMappings[index];
			var lowSurrogates = mapping[1];
			var lowSurrogateStart = lowSurrogates[0];
			var lowSurrogateEnd = lowSurrogates[1];
			innerIndex = index; // Note: the loop starts at the next index.
			while (++innerIndex < surrogateMappings.length) {
				var otherMapping = surrogateMappings[innerIndex];
				var otherLowSurrogates = otherMapping[1];
				var otherLowSurrogateStart = otherLowSurrogates[0];
				var otherLowSurrogateEnd = otherLowSurrogates[1];
				if (
					lowSurrogateStart == otherLowSurrogateStart &&
					lowSurrogateEnd == otherLowSurrogateEnd
				) {
					// Add the code points in the other item to this one.
					if (dataIsSingleton(otherMapping[0])) {
						mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
					} else {
						mapping[0] = dataAddRange(
							mapping[0],
							otherMapping[0][0],
							otherMapping[0][1] - 1
						);
					}
					// Remove the other, now redundant, item.
					surrogateMappings.splice(innerIndex, 1);
					--innerIndex;
				}
			}
		}
		return surrogateMappings;
	};

	var surrogateSet = function(data) {
		// Exit early if `data` is an empty set.
		if (!data.length) {
			return [];
		}

		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var startHigh;
		var startLow;
		var prevStartHigh = 0;
		var prevEndHigh = 0;
		var tmpLow = [];
		var endHigh;
		var endLow;
		var surrogateMappings = [];
		var length = data.length;
		var dataHigh = [];
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1;

			startHigh = highSurrogate(start);
			startLow = lowSurrogate(start);
			endHigh = highSurrogate(end);
			endLow = lowSurrogate(end);

			var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
			var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
			var complete = false;

			// Append the previous high-surrogate-to-low-surrogate mappings.
			// Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.
			if (
				startHigh == endHigh ||
				startsWithLowestLowSurrogate && endsWithHighestLowSurrogate
			) {
				surrogateMappings.push([
					[startHigh, endHigh + 1],
					[startLow, endLow + 1]
				]);
				complete = true;
			} else {
				surrogateMappings.push([
					[startHigh, startHigh + 1],
					[startLow, LOW_SURROGATE_MAX + 1]
				]);
			}

			// Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
			// `(endHigh - 1, LOW_SURROGATE_MAX)`.
			if (!complete && startHigh + 1 < endHigh) {
				if (endsWithHighestLowSurrogate) {
					// Combine step 2 and step 3.
					surrogateMappings.push([
						[startHigh + 1, endHigh + 1],
						[LOW_SURROGATE_MIN, endLow + 1]
					]);
					complete = true;
				} else {
					surrogateMappings.push([
						[startHigh + 1, endHigh],
						[LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]
					]);
				}
			}

			// Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.
			if (!complete) {
				surrogateMappings.push([
					[endHigh, endHigh + 1],
					[LOW_SURROGATE_MIN, endLow + 1]
				]);
			}

			prevStartHigh = startHigh;
			prevEndHigh = endHigh;

			index += 2;
		}

		// The format of `surrogateMappings` is as follows:
		//
		//     [ surrogateMapping1, surrogateMapping2 ]
		//
		// i.e.:
		//
		//     [
		//       [ highSurrogates1, lowSurrogates1 ],
		//       [ highSurrogates2, lowSurrogates2 ]
		//     ]
		return optimizeSurrogateMappings(surrogateMappings);
	};

	var createSurrogateCharacterClasses = function(surrogateMappings) {
		var result = [];
		forEach(surrogateMappings, function(surrogateMapping) {
			var highSurrogates = surrogateMapping[0];
			var lowSurrogates = surrogateMapping[1];
			result.push(
				createBMPCharacterClasses(highSurrogates) +
				createBMPCharacterClasses(lowSurrogates)
			);
		});
		return result.join('|');
	};

	var createCharacterClassesFromData = function(data, bmpOnly) {
		var result = [];

		var parts = splitAtBMP(data);
		var loneHighSurrogates = parts.loneHighSurrogates;
		var loneLowSurrogates = parts.loneLowSurrogates;
		var bmp = parts.bmp;
		var astral = parts.astral;
		var hasAstral = !dataIsEmpty(parts.astral);
		var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
		var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);

		var surrogateMappings = surrogateSet(astral);

		if (bmpOnly) {
			bmp = dataAddData(bmp, loneHighSurrogates);
			hasLoneHighSurrogates = false;
			bmp = dataAddData(bmp, loneLowSurrogates);
			hasLoneLowSurrogates = false;
		}

		if (!dataIsEmpty(bmp)) {
			// The data set contains BMP code points that are not high surrogates
			// needed for astral code points in the set.
			result.push(createBMPCharacterClasses(bmp));
		}
		if (surrogateMappings.length) {
			// The data set contains astral code points; append character classes
			// based on their surrogate pairs.
			result.push(createSurrogateCharacterClasses(surrogateMappings));
		}
		// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
		if (hasLoneHighSurrogates) {
			result.push(
				createBMPCharacterClasses(loneHighSurrogates) +
				// Make sure the high surrogates aren’t part of a surrogate pair.
				'(?![\\uDC00-\\uDFFF])'
			);
		}
		if (hasLoneLowSurrogates) {
			result.push(
				// Make sure the low surrogates aren’t part of a surrogate pair.
				'(?:[^\\uD800-\\uDBFF]|^)' +
				createBMPCharacterClasses(loneLowSurrogates)
			);
		}
		return result.join('|');
	};

	/*--------------------------------------------------------------------------*/

	// `regenerate` can be used as a constructor (and new methods can be added to
	// its prototype) but also as a regular function, the latter of which is the
	// documented and most common usage. For that reason, it’s not capitalized.
	var regenerate = function(value) {
		if (arguments.length > 1) {
			value = slice.call(arguments);
		}
		if (this instanceof regenerate) {
			this.data = [];
			return value ? this.add(value) : this;
		}
		return (new regenerate).add(value);
	};

	regenerate.version = '1.2.0';

	var proto = regenerate.prototype;
	extend(proto, {
		'add': function(value) {
			var $this = this;
			if (value == null) {
				return $this;
			}
			if (value instanceof regenerate) {
				// Allow passing other Regenerate instances.
				$this.data = dataAddData($this.data, value.data);
				return $this;
			}
			if (arguments.length > 1) {
				value = slice.call(arguments);
			}
			if (isArray(value)) {
				forEach(value, function(item) {
					$this.add(item);
				});
				return $this;
			}
			$this.data = dataAdd(
				$this.data,
				isNumber(value) ? value : symbolToCodePoint(value)
			);
			return $this;
		},
		'remove': function(value) {
			var $this = this;
			if (value == null) {
				return $this;
			}
			if (value instanceof regenerate) {
				// Allow passing other Regenerate instances.
				$this.data = dataRemoveData($this.data, value.data);
				return $this;
			}
			if (arguments.length > 1) {
				value = slice.call(arguments);
			}
			if (isArray(value)) {
				forEach(value, function(item) {
					$this.remove(item);
				});
				return $this;
			}
			$this.data = dataRemove(
				$this.data,
				isNumber(value) ? value : symbolToCodePoint(value)
			);
			return $this;
		},
		'addRange': function(start, end) {
			var $this = this;
			$this.data = dataAddRange($this.data,
				isNumber(start) ? start : symbolToCodePoint(start),
				isNumber(end) ? end : symbolToCodePoint(end)
			);
			return $this;
		},
		'removeRange': function(start, end) {
			var $this = this;
			var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
			var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
			$this.data = dataRemoveRange(
				$this.data,
				startCodePoint,
				endCodePoint
			);
			return $this;
		},
		'intersection': function(argument) {
			var $this = this;
			// Allow passing other Regenerate instances.
			// TODO: Optimize this by writing and using `dataIntersectionData()`.
			var array = argument instanceof regenerate ?
				dataToArray(argument.data) :
				argument;
			$this.data = dataIntersection($this.data, array);
			return $this;
		},
		'contains': function(codePoint) {
			return dataContains(
				this.data,
				isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint)
			);
		},
		'clone': function() {
			var set = new regenerate;
			set.data = this.data.slice(0);
			return set;
		},
		'toString': function(options) {
			var result = createCharacterClassesFromData(
				this.data,
				options ? options.bmpOnly : false
			);
			// Use `\0` instead of `\x00` where possible.
			return result.replace(regexNull, '\\0$1');
		},
		'toRegExp': function(flags) {
			return RegExp(this.toString(), flags || '');
		},
		'valueOf': function() { // Note: `valueOf` is aliased as `toArray`.
			return dataToArray(this.data);
		}
	});

	proto.toArray = proto.valueOf;

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return regenerate;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = regenerate;
		} else { // in Narwhal or RingoJS v0.7.0-
			freeExports.regenerate = regenerate;
		}
	} else { // in Rhino or a web browser
		root.regenerate = regenerate;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],424:[function(require,module,exports){
(function (global){
/*!
 * RegJSGen
 * Copyright 2014 Benjamin Tan <https://d10.github.io/>
 * Available under MIT license <http://d10.mit-license.org/>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object` */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object */
  var oldRoot = root;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */

  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    var result = '';
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (
        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 0x10FFFF || // not a valid Unicode code point
        floor(codePoint) != codePoint // not an integer
      ) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        // BMP code point
        codeUnits.push(codePoint);
      } else {
        // Astral code point; split in surrogate halves
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  }

  function assertType(type, expected) {
    if (expected.indexOf('|') == -1) {
      if (type == expected) {
        return;
      }

      throw Error('Invalid node type: ' + type);
    }

    expected = assertType.hasOwnProperty(expected)
      ? assertType[expected]
      : (assertType[expected] = RegExp('^(?:' + expected + ')$'));

    if (expected.test(type)) {
      return;
    }

    throw Error('Invalid node type: ' + type);
  }

  /*--------------------------------------------------------------------------*/

  function generate(node) {
    var type = node.type;

    if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {
      return generate[type](node);
    }

    throw Error('Invalid node type: ' + type);
  }

  /*--------------------------------------------------------------------------*/

  function generateAlternative(node) {
    assertType(node.type, 'alternative');

    var terms = node.body,
        length = terms ? terms.length : 0;

    if (length == 1) {
      return generateTerm(terms[0]);
    } else {
      var i = -1,
          result = '';

      while (++i < length) {
        result += generateTerm(terms[i]);
      }

      return result;
    }
  }

  function generateAnchor(node) {
    assertType(node.type, 'anchor');

    switch (node.kind) {
      case 'start':
        return '^';
      case 'end':
        return '$';
      case 'boundary':
        return '\\b';
      case 'not-boundary':
        return '\\B';
      default:
        throw Error('Invalid assertion');
    }
  }

  function generateAtom(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');

    return generate(node);
  }

  function generateCharacterClass(node) {
    assertType(node.type, 'characterClass');

    var classRanges = node.body,
        length = classRanges ? classRanges.length : 0;

    var i = -1,
        result = '[';

    if (node.negative) {
      result += '^';
    }

    while (++i < length) {
      result += generateClassAtom(classRanges[i]);
    }

    result += ']';

    return result;
  }

  function generateCharacterClassEscape(node) {
    assertType(node.type, 'characterClassEscape');

    return '\\' + node.value;
  }

  function generateCharacterClassRange(node) {
    assertType(node.type, 'characterClassRange');

    var min = node.min,
        max = node.max;

    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
      throw Error('Invalid character class range');
    }

    return generateClassAtom(min) + '-' + generateClassAtom(max);
  }

  function generateClassAtom(node) {
    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');

    return generate(node);
  }

  function generateDisjunction(node) {
    assertType(node.type, 'disjunction');

    var body = node.body,
        length = body ? body.length : 0;

    if (length == 0) {
      throw Error('No body');
    } else if (length == 1) {
      return generate(body[0]);
    } else {
      var i = -1,
          result = '';

      while (++i < length) {
        if (i != 0) {
          result += '|';
        }
        result += generate(body[i]);
      }

      return result;
    }
  }

  function generateDot(node) {
    assertType(node.type, 'dot');

    return '.';
  }

  function generateGroup(node) {
    assertType(node.type, 'group');

    var result = '(';

    switch (node.behavior) {
      case 'normal':
        break;
      case 'ignore':
        result += '?:';
        break;
      case 'lookahead':
        result += '?=';
        break;
      case 'negativeLookahead':
        result += '?!';
        break;
      default:
        throw Error('Invalid behaviour: ' + node.behaviour);
    }

    var body = node.body,
        length = body ? body.length : 0;

    if (length == 1) {
      result += generate(body[0]);
    } else {
      var i = -1;

      while (++i < length) {
        result += generate(body[i]);
      }
    }

    result += ')';

    return result;
  }

  function generateQuantifier(node) {
    assertType(node.type, 'quantifier');

    var quantifier = '',
        min = node.min,
        max = node.max;

    switch (max) {
      case undefined:
      case null:
        switch (min) {
          case 0:
            quantifier = '*'
            break;
          case 1:
            quantifier = '+';
            break;
          default:
            quantifier = '{' + min + ',}';
            break;
        }
        break;
      default:
        if (min == max) {
          quantifier = '{' + min + '}';
        }
        else if (min == 0 && max == 1) {
          quantifier = '?';
        } else {
          quantifier = '{' + min + ',' + max + '}';
        }
        break;
    }

    if (!node.greedy) {
      quantifier += '?';
    }

    return generateAtom(node.body[0]) + quantifier;
  }

  function generateReference(node) {
    assertType(node.type, 'reference');

    return '\\' + node.matchIndex;
  }

  function generateTerm(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');

    return generate(node);
  }

  function generateValue(node) {
    assertType(node.type, 'value');

    var kind = node.kind,
        codePoint = node.codePoint;

    switch (kind) {
      case 'controlLetter':
        return '\\c' + fromCodePoint(codePoint + 64);
      case 'hexadecimalEscape':
        return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);
      case 'identifier':
        return '\\' + fromCodePoint(codePoint);
      case 'null':
        return '\\' + codePoint;
      case 'octal':
        return '\\' + codePoint.toString(8);
      case 'singleEscape':
        switch (codePoint) {
          case 0x0008:
            return '\\b';
          case 0x009:
            return '\\t';
          case 0x00A:
            return '\\n';
          case 0x00B:
            return '\\v';
          case 0x00C:
            return '\\f';
          case 0x00D:
            return '\\r';
          default:
            throw Error('Invalid codepoint: ' + codePoint);
        }
      case 'symbol':
        return fromCodePoint(codePoint);
      case 'unicodeEscape':
        return '\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);
      case 'unicodeCodePointEscape':
        return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
      default:
        throw Error('Unsupported node kind: ' + kind);
    }
  }

  /*--------------------------------------------------------------------------*/

  generate.alternative = generateAlternative;
  generate.anchor = generateAnchor;
  generate.characterClass = generateCharacterClass;
  generate.characterClassEscape = generateCharacterClassEscape;
  generate.characterClassRange = generateCharacterClassRange;
  generate.disjunction = generateDisjunction;
  generate.dot = generateDot;
  generate.group = generateGroup;
  generate.quantifier = generateQuantifier;
  generate.reference = generateReference;
  generate.value = generateValue;

  /*--------------------------------------------------------------------------*/

  // export regjsgen
  // some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module so, through path mapping, it can be aliased
    define(function() {
      return {
        'generate': generate
      };
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Narwhal, Node.js, Rhino -require, or RingoJS
    freeExports.generate = generate;
  }
  // in a browser or Rhino
  else {
    root.regjsgen = {
      'generate': generate
    };
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],425:[function(require,module,exports){
// regjsparser
//
// ==================================================================
//
// See ECMA-262 Standard: 15.10.1
//
// NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
//   term "Anchor" is used.
//
// Pattern ::
//      Disjunction
//
// Disjunction ::
//      Alternative
//      Alternative | Disjunction
//
// Alternative ::
//      [empty]
//      Alternative Term
//
// Term ::
//      Anchor
//      Atom
//      Atom Quantifier
//
// Anchor ::
//      ^
//      $
//      \ b
//      \ B
//      ( ? = Disjunction )
//      ( ? ! Disjunction )
//
// Quantifier ::
//      QuantifierPrefix
//      QuantifierPrefix ?
//
// QuantifierPrefix ::
//      *
//      +
//      ?
//      { DecimalDigits }
//      { DecimalDigits , }
//      { DecimalDigits , DecimalDigits }
//
// Atom ::
//      PatternCharacter
//      .
//      \ AtomEscape
//      CharacterClass
//      ( Disjunction )
//      ( ? : Disjunction )
//
// PatternCharacter ::
//      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
//
// AtomEscape ::
//      DecimalEscape
//      CharacterEscape
//      CharacterClassEscape
//
// CharacterEscape[U] ::
//      ControlEscape
//      c ControlLetter
//      HexEscapeSequence
//      RegExpUnicodeEscapeSequence[?U] (ES6)
//      IdentityEscape[?U]
//
// ControlEscape ::
//      one of f n r t v
// ControlLetter ::
//      one of
//          a b c d e f g h i j k l m n o p q r s t u v w x y z
//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
//
// IdentityEscape ::
//      SourceCharacter but not IdentifierPart
//      <ZWJ>
//      <ZWNJ>
//
// DecimalEscape ::
//      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
//
// CharacterClassEscape ::
//      one of d D s S w W
//
// CharacterClass ::
//      [ [lookahead ∉ {^}] ClassRanges ]
//      [ ^ ClassRanges ]
//
// ClassRanges ::
//      [empty]
//      NonemptyClassRanges
//
// NonemptyClassRanges ::
//      ClassAtom
//      ClassAtom NonemptyClassRangesNoDash
//      ClassAtom - ClassAtom ClassRanges
//
// NonemptyClassRangesNoDash ::
//      ClassAtom
//      ClassAtomNoDash NonemptyClassRangesNoDash
//      ClassAtomNoDash - ClassAtom ClassRanges
//
// ClassAtom ::
//      -
//      ClassAtomNoDash
//
// ClassAtomNoDash ::
//      SourceCharacter but not one of \ or ] or -
//      \ ClassEscape
//
// ClassEscape ::
//      DecimalEscape
//      b
//      CharacterEscape
//      CharacterClassEscape

(function() {

  function parse(str, flags) {
    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
    var pos = 0;
    var closedCaptureCounter = 0;

    function addRaw(node) {
      node.raw = str.substring(node.range[0], node.range[1]);
      return node;
    }

    function updateRawStart(node, start) {
      node.range[0] = start;
      return addRaw(node);
    }

    function createAnchor(kind, rawLength) {
      return addRaw({
        type: 'anchor',
        kind: kind,
        range: [
          pos - rawLength,
          pos
        ]
      });
    }

    function createValue(kind, codePoint, from, to) {
      return addRaw({
        type: 'value',
        kind: kind,
        codePoint: codePoint,
        range: [from, to]
      });
    }

    function createEscaped(kind, codePoint, value, fromOffset) {
      fromOffset = fromOffset || 0;
      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
    }

    function createCharacter(matches) {
      var _char = matches[0];
      var first = _char.charCodeAt(0);
      if (hasUnicodeFlag) {
        var second;
        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
          second = lookahead().charCodeAt(0);
          if (second >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            pos++;
            return createValue(
                'symbol',
                (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,
                pos - 2, pos);
          }
        }
      }
      return createValue('symbol', first, pos - 1, pos);
    }

    function createDisjunction(alternatives, from, to) {
      return addRaw({
        type: 'disjunction',
        body: alternatives,
        range: [
          from,
          to
        ]
      });
    }

    function createDot() {
      return addRaw({
        type: 'dot',
        range: [
          pos - 1,
          pos
        ]
      });
    }

    function createCharacterClassEscape(value) {
      return addRaw({
        type: 'characterClassEscape',
        value: value,
        range: [
          pos - 2,
          pos
        ]
      });
    }

    function createReference(matchIndex) {
      return addRaw({
        type: 'reference',
        matchIndex: parseInt(matchIndex, 10),
        range: [
          pos - 1 - matchIndex.length,
          pos
        ]
      });
    }

    function createGroup(behavior, disjunction, from, to) {
      return addRaw({
        type: 'group',
        behavior: behavior,
        body: disjunction,
        range: [
          from,
          to
        ]
      });
    }

    function createQuantifier(min, max, from, to) {
      if (to == null) {
        from = pos - 1;
        to = pos;
      }

      return addRaw({
        type: 'quantifier',
        min: min,
        max: max,
        greedy: true,
        body: null, // set later on,
        range: [
          from,
          to
        ]
      });
    }

    function createAlternative(terms, from, to) {
      return addRaw({
        type: 'alternative',
        body: terms,
        range: [
          from,
          to
        ]
      });
    }

    function createCharacterClass(classRanges, negative, from, to) {
      return addRaw({
        type: 'characterClass',
        body: classRanges,
        negative: negative,
        range: [
          from,
          to
        ]
      });
    }

    function createClassRange(min, max, from, to) {
      // See 15.10.2.15:
      if (min.codePoint > max.codePoint) {
        throw SyntaxError('invalid range in character class');
      }

      return addRaw({
        type: 'characterClassRange',
        min: min,
        max: max,
        range: [
          from,
          to
        ]
      });
    }

    function flattenBody(body) {
      if (body.type === 'alternative') {
        return body.body;
      } else {
        return [body];
      }
    }

    function isEmpty(obj) {
      return obj.type === 'empty';
    }

    function incr(amount) {
      amount = (amount || 1);
      var res = str.substring(pos, pos + amount);
      pos += (amount || 1);
      return res;
    }

    function skip(value) {
      if (!match(value)) {
        throw SyntaxError('character: ' + value);
      }
    }

    function match(value) {
      if (str.indexOf(value, pos) === pos) {
        return incr(value.length);
      }
    }

    function lookahead() {
      return str[pos];
    }

    function current(value) {
      return str.indexOf(value, pos) === pos;
    }

    function next(value) {
      return str[pos + 1] === value;
    }

    function matchReg(regExp) {
      var subStr = str.substring(pos);
      var res = subStr.match(regExp);
      if (res) {
        res.range = [];
        res.range[0] = pos;
        incr(res[0].length);
        res.range[1] = pos;
      }
      return res;
    }

    function parseDisjunction() {
      // Disjunction ::
      //      Alternative
      //      Alternative | Disjunction
      var res = [], from = pos;
      res.push(parseAlternative());

      while (match('|')) {
        res.push(parseAlternative());
      }

      if (res.length === 1) {
        return res[0];
      }

      return createDisjunction(res, from, pos);
    }

    function parseAlternative() {
      var res = [], from = pos;
      var term;

      // Alternative ::
      //      [empty]
      //      Alternative Term
      while (term = parseTerm()) {
        res.push(term);
      }

      if (res.length === 1) {
        return res[0];
      }

      return createAlternative(res, from, pos);
    }

    function parseTerm() {
      // Term ::
      //      Anchor
      //      Atom
      //      Atom Quantifier

      if (pos >= str.length || current('|') || current(')')) {
        return null; /* Means: The term is empty */
      }

      var anchor = parseAnchor();

      if (anchor) {
        return anchor;
      }

      var atom = parseAtom();
      if (!atom) {
        throw SyntaxError('Expected atom')
      }
      var quantifier = parseQuantifier() || false;
      if (quantifier) {
        quantifier.body = flattenBody(atom);
        // The quantifier contains the atom. Therefore, the beginning of the
        // quantifier range is given by the beginning of the atom.
        updateRawStart(quantifier, atom.range[0]);
        return quantifier;
      }
      return atom;
    }

    function parseGroup(matchA, typeA, matchB, typeB) {
      var type = null, from = pos;

      if (match(matchA)) {
        type = typeA;
      } else if (match(matchB)) {
        type = typeB;
      } else {
        return false;
      }

      var body = parseDisjunction();
      if (!body) {
        throw SyntaxError('Expected disjunction');
      }
      skip(')');
      var group = createGroup(type, flattenBody(body), from, pos);

      if (type == 'normal') {
        // Keep track of the number of closed groups. This is required for
        // parseDecimalEscape().
        closedCaptureCounter++;
      }
      return group;
    }

    function parseAnchor() {
      // Anchor ::
      //      ^
      //      $
      //      \ b
      //      \ B
      //      ( ? = Disjunction )
      //      ( ? ! Disjunction )
      var res, from = pos;

      if (match('^')) {
        return createAnchor('start', 1 /* rawLength */);
      } else if (match('$')) {
        return createAnchor('end', 1 /* rawLength */);
      } else if (match('\\b')) {
        return createAnchor('boundary', 2 /* rawLength */);
      } else if (match('\\B')) {
        return createAnchor('not-boundary', 2 /* rawLength */);
      } else {
        return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
      }
    }

    function parseQuantifier() {
      // Quantifier ::
      //      QuantifierPrefix
      //      QuantifierPrefix ?
      //
      // QuantifierPrefix ::
      //      *
      //      +
      //      ?
      //      { DecimalDigits }
      //      { DecimalDigits , }
      //      { DecimalDigits , DecimalDigits }

      var res;
      var quantifier;
      var min, max;

      if (match('*')) {
        quantifier = createQuantifier(0);
      }
      else if (match('+')) {
        quantifier = createQuantifier(1);
      }
      else if (match('?')) {
        quantifier = createQuantifier(0, 1);
      }
      else if (res = matchReg(/^\{([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
      }
      else if (res = matchReg(/^\{([0-9]+),\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
      }
      else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        max = parseInt(res[2], 10);
        if (min > max) {
          throw SyntaxError('numbers out of order in {} quantifier');
        }
        quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
      }

      if (quantifier) {
        if (match('?')) {
          quantifier.greedy = false;
          quantifier.range[1] += 1;
        }
      }

      return quantifier;
    }

    function parseAtom() {
      // Atom ::
      //      PatternCharacter
      //      .
      //      \ AtomEscape
      //      CharacterClass
      //      ( Disjunction )
      //      ( ? : Disjunction )

      var res;

      // jviereck: allow ']', '}' here as well to be compatible with browser's
      //   implementations: ']'.match(/]/);
      // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
      if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
        //      PatternCharacter
        return createCharacter(res);
      }
      else if (match('.')) {
        //      .
        return createDot();
      }
      else if (match('\\')) {
        //      \ AtomEscape
        res = parseAtomEscape();
        if (!res) {
          throw SyntaxError('atomEscape');
        }
        return res;
      }
      else if (res = parseCharacterClass()) {
        return res;
      }
      else {
        //      ( Disjunction )
        //      ( ? : Disjunction )
        return parseGroup('(?:', 'ignore', '(', 'normal');
      }
    }

    function parseUnicodeSurrogatePairEscape(firstEscape) {
      if (hasUnicodeFlag) {
        var first, second;
        if (firstEscape.kind == 'unicodeEscape' &&
          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&
          current('\\') && next('u') ) {
          var prevPos = pos;
          pos++;
          var secondEscape = parseClassEscape();
          if (secondEscape.kind == 'unicodeEscape' &&
            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            firstEscape.range[1] = secondEscape.range[1];
            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            firstEscape.type = 'value';
            firstEscape.kind = 'unicodeCodePointEscape';
            addRaw(firstEscape);
          }
          else {
            pos = prevPos;
          }
        }
      }
      return firstEscape;
    }

    function parseClassEscape() {
      return parseAtomEscape(true);
    }

    function parseAtomEscape(insideCharacterClass) {
      // AtomEscape ::
      //      DecimalEscape
      //      CharacterEscape
      //      CharacterClassEscape

      var res;

      res = parseDecimalEscape();
      if (res) {
        return res;
      }

      // For ClassEscape
      if (insideCharacterClass) {
        if (match('b')) {
          // 15.10.2.19
          // The production ClassEscape :: b evaluates by returning the
          // CharSet containing the one character <BS> (Unicode value 0008).
          return createEscaped('singleEscape', 0x0008, '\\b');
        } else if (match('B')) {
          throw SyntaxError('\\B not possible inside of CharacterClass');
        }
      }

      res = parseCharacterEscape();

      return res;
    }


    function parseDecimalEscape() {
      // DecimalEscape ::
      //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
      //      CharacterClassEscape :: one of d D s S w W

      var res, match;

      if (res = matchReg(/^(?!0)\d+/)) {
        match = res[0];
        var refIdx = parseInt(res[0], 10);
        if (refIdx <= closedCaptureCounter) {
          // If the number is smaller than the normal-groups found so
          // far, then it is a reference...
          return createReference(res[0]);
        } else {
          // ... otherwise it needs to be interpreted as a octal (if the
          // number is in an octal format). If it is NOT octal format,
          // then the slash is ignored and the number is matched later
          // as normal characters.

          // Reset the position again, as maybe only parts of the previous
          // matched numbers are actual octal numbers. E.g. in '019' only
          // the '01' should be matched.
          incr(-res[0].length);
          if (res = matchReg(/^[0-7]{1,3}/)) {
            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
          } else {
            // If we end up here, we have a case like /\91/. Then the
            // first slash is to be ignored and the 9 & 1 to be treated
            // like ordinary characters. Create a character for the
            // first number only here - other number-characters
            // (if available) will be matched later.
            res = createCharacter(matchReg(/^[89]/));
            return updateRawStart(res, res.range[0] - 1);
          }
        }
      }
      // Only allow octal numbers in the following. All matched numbers start
      // with a zero (if the do not, the previous if-branch is executed).
      // If the number is not octal format and starts with zero (e.g. `091`)
      // then only the zeros `0` is treated here and the `91` are ordinary
      // characters.
      // Example:
      //   /\091/.exec('\091')[0].length === 3
      else if (res = matchReg(/^[0-7]{1,3}/)) {
        match = res[0];
        if (/^0{1,3}$/.test(match)) {
          // If they are all zeros, then only take the first one.
          return createEscaped('null', 0x0000, '0', match.length + 1);
        } else {
          return createEscaped('octal', parseInt(match, 8), match, 1);
        }
      } else if (res = matchReg(/^[dDsSwW]/)) {
        return createCharacterClassEscape(res[0]);
      }
      return false;
    }

    function parseCharacterEscape() {
      // CharacterEscape ::
      //      ControlEscape
      //      c ControlLetter
      //      HexEscapeSequence
      //      UnicodeEscapeSequence
      //      IdentityEscape

      var res;
      if (res = matchReg(/^[fnrtv]/)) {
        // ControlEscape
        var codePoint = 0;
        switch (res[0]) {
          case 't': codePoint = 0x009; break;
          case 'n': codePoint = 0x00A; break;
          case 'v': codePoint = 0x00B; break;
          case 'f': codePoint = 0x00C; break;
          case 'r': codePoint = 0x00D; break;
        }
        return createEscaped('singleEscape', codePoint, '\\' + res[0]);
      } else if (res = matchReg(/^c([a-zA-Z])/)) {
        // c ControlLetter
        return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
      } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
        // HexEscapeSequence
        return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
      } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
        // UnicodeEscapeSequence
        return parseUnicodeSurrogatePairEscape(
          createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2)
        );
      } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]{1,})\}/))) {
        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
      } else {
        // IdentityEscape
        return parseIdentityEscape();
      }
    }

    // Taken from the Esprima parser.
    function isIdentifierPart(ch) {
      // Generated by `tools/generate-identifier-regex.js`.
      var NonAsciiIdentifierPart = new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]');

      return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
        (ch >= 65 && ch <= 90) ||         // A..Z
        (ch >= 97 && ch <= 122) ||        // a..z
        (ch >= 48 && ch <= 57) ||         // 0..9
        (ch === 92) ||                    // \ (backslash)
        ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    function parseIdentityEscape() {
      // IdentityEscape ::
      //      SourceCharacter but not IdentifierPart
      //      <ZWJ>
      //      <ZWNJ>

      var ZWJ = '\u200C';
      var ZWNJ = '\u200D';

      var res;
      var tmp;

      if (!isIdentifierPart(lookahead())) {
        tmp = incr();
        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
      }

      if (match(ZWJ)) {
        // <ZWJ>
        return createEscaped('identifier', 0x200C, ZWJ);
      } else if (match(ZWNJ)) {
        // <ZWNJ>
        return createEscaped('identifier', 0x200D, ZWNJ);
      }

      return null;
    }

    function parseCharacterClass() {
      // CharacterClass ::
      //      [ [lookahead ∉ {^}] ClassRanges ]
      //      [ ^ ClassRanges ]

      var res, from = pos;
      if (res = matchReg(/^\[\^/)) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, true, from, pos);
      } else if (match('[')) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, false, from, pos);
      }

      return null;
    }

    function parseClassRanges() {
      // ClassRanges ::
      //      [empty]
      //      NonemptyClassRanges

      var res;
      if (current(']')) {
        // Empty array means nothing insinde of the ClassRange.
        return [];
      } else {
        res = parseNonemptyClassRanges();
        if (!res) {
          throw SyntaxError('nonEmptyClassRanges');
        }
        return res;
      }
    }

    function parseHelperClassRanges(atom) {
      var from, to, res;
      if (current('-') && !next(']')) {
        // ClassAtom - ClassAtom ClassRanges
        skip('-');

        res = parseClassAtom();
        if (!res) {
          throw SyntaxError('classAtom');
        }
        to = pos;
        var classRanges = parseClassRanges();
        if (!classRanges) {
          throw SyntaxError('classRanges');
        }
        from = atom.range[0];
        if (classRanges.type === 'empty') {
          return [createClassRange(atom, res, from, to)];
        }
        return [createClassRange(atom, res, from, to)].concat(classRanges);
      }

      res = parseNonemptyClassRangesNoDash();
      if (!res) {
        throw SyntaxError('nonEmptyClassRangesNoDash');
      }

      return [atom].concat(res);
    }

    function parseNonemptyClassRanges() {
      // NonemptyClassRanges ::
      //      ClassAtom
      //      ClassAtom NonemptyClassRangesNoDash
      //      ClassAtom - ClassAtom ClassRanges

      var atom = parseClassAtom();
      if (!atom) {
        throw SyntaxError('classAtom');
      }

      if (current(']')) {
        // ClassAtom
        return [atom];
      }

      // ClassAtom NonemptyClassRangesNoDash
      // ClassAtom - ClassAtom ClassRanges
      return parseHelperClassRanges(atom);
    }

    function parseNonemptyClassRangesNoDash() {
      // NonemptyClassRangesNoDash ::
      //      ClassAtom
      //      ClassAtomNoDash NonemptyClassRangesNoDash
      //      ClassAtomNoDash - ClassAtom ClassRanges

      var res = parseClassAtom();
      if (!res) {
        throw SyntaxError('classAtom');
      }
      if (current(']')) {
        //      ClassAtom
        return res;
      }

      // ClassAtomNoDash NonemptyClassRangesNoDash
      // ClassAtomNoDash - ClassAtom ClassRanges
      return parseHelperClassRanges(res);
    }

    function parseClassAtom() {
      // ClassAtom ::
      //      -
      //      ClassAtomNoDash
      if (match('-')) {
        return createCharacter('-');
      } else {
        return parseClassAtomNoDash();
      }
    }

    function parseClassAtomNoDash() {
      // ClassAtomNoDash ::
      //      SourceCharacter but not one of \ or ] or -
      //      \ ClassEscape

      var res;
      if (res = matchReg(/^[^\\\]-]/)) {
        return createCharacter(res[0]);
      } else if (match('\\')) {
        res = parseClassEscape();
        if (!res) {
          throw SyntaxError('classEscape');
        }

        return parseUnicodeSurrogatePairEscape(res);
      }
    }

    // Convert the input to a string and treat the empty string special.
    str = String(str);
    if (str === '') {
      str = '(?:)';
    }

    var result = parseDisjunction();

    if (result.range[1] !== str.length) {
      throw SyntaxError('Could not parse entire input - got stuck: ' + str);
    }

    return result;
  };

  var regjsparser = {
    parse: parse
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = regjsparser;
  } else {
    window.regjsparser = regjsparser;
  }

}());

},{}],426:[function(require,module,exports){
var generate = require('regjsgen').generate;
var parse = require('regjsparser').parse;
var regenerate = require('regenerate');
var iuMappings = require('./data/iu-mappings.json');
var ESCAPE_SETS = require('./data/character-class-escape-sets.js');

function getCharacterClassEscapeSet(character) {
	if (unicode) {
		if (ignoreCase) {
			return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];
		}
		return ESCAPE_SETS.UNICODE[character];
	}
	return ESCAPE_SETS.REGULAR[character];
}

var object = {};
var hasOwnProperty = object.hasOwnProperty;
function has(object, property) {
	return hasOwnProperty.call(object, property);
}

// Prepare a Regenerate set containing all code points, used for negative
// character classes (if any).
var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
// Without the `u` flag, the range stops at 0xFFFF.
// https://mths.be/es6#sec-pattern-semantics
var BMP_SET = regenerate().addRange(0x0, 0xFFFF);

// Prepare a Regenerate set containing all code points that are supposed to be
// matched by `/./u`. https://mths.be/es6#sec-atom
var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
	.remove(
		// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
		0x000A, // Line Feed <LF>
		0x000D, // Carriage Return <CR>
		0x2028, // Line Separator <LS>
		0x2029  // Paragraph Separator <PS>
	);
// Prepare a Regenerate set containing all code points that are supposed to be
// matched by `/./` (only BMP code points).
var DOT_SET = DOT_SET_UNICODE.clone()
	.intersection(BMP_SET);

// Add a range of code points + any case-folded code points in that range to a
// set.
regenerate.prototype.iuAddRange = function(min, max) {
	var $this = this;
	do {
		var folded = caseFold(min);
		if (folded) {
			$this.add(folded);
		}
	} while (++min <= max);
	return $this;
};

function assign(target, source) {
	for (var key in source) {
		// Note: `hasOwnProperty` is not needed here.
		target[key] = source[key];
	}
}

function update(item, pattern) {
	// TODO: Test if memoizing `pattern` here is worth the effort.
	if (!pattern) {
		return;
	}
	var tree = parse(pattern, '');
	switch (tree.type) {
		case 'characterClass':
		case 'group':
		case 'value':
			// No wrapping needed.
			break;
		default:
			// Wrap the pattern in a non-capturing group.
			tree = wrap(tree, pattern);
	}
	assign(item, tree);
}

function wrap(tree, pattern) {
	// Wrap the pattern in a non-capturing group.
	return {
		'type': 'group',
		'behavior': 'ignore',
		'body': [tree],
		'raw': '(?:' + pattern + ')'
	};
}

function caseFold(codePoint) {
	return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;
}

var ignoreCase = false;
var unicode = false;
function processCharacterClass(characterClassItem) {
	var set = regenerate();
	var body = characterClassItem.body.forEach(function(item) {
		switch (item.type) {
			case 'value':
				set.add(item.codePoint);
				if (ignoreCase && unicode) {
					var folded = caseFold(item.codePoint);
					if (folded) {
						set.add(folded);
					}
				}
				break;
			case 'characterClassRange':
				var min = item.min.codePoint;
				var max = item.max.codePoint;
				set.addRange(min, max);
				if (ignoreCase && unicode) {
					set.iuAddRange(min, max);
				}
				break;
			case 'characterClassEscape':
				set.add(getCharacterClassEscapeSet(item.value));
				break;
			// The `default` clause is only here as a safeguard; it should never be
			// reached. Code coverage tools should ignore it.
			/* istanbul ignore next */
			default:
				throw Error('Unknown term type: ' + item.type);
		}
	});
	if (characterClassItem.negative) {
		set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
	}
	update(characterClassItem, set.toString());
	return characterClassItem;
}

function processTerm(item) {
	switch (item.type) {
		case 'dot':
			update(
				item,
				(unicode ? DOT_SET_UNICODE : DOT_SET).toString()
			);
			break;
		case 'characterClass':
			item = processCharacterClass(item);
			break;
		case 'characterClassEscape':
			update(
				item,
				getCharacterClassEscapeSet(item.value).toString()
			);
			break;
		case 'alternative':
		case 'disjunction':
		case 'group':
		case 'quantifier':
			item.body = item.body.map(processTerm);
			break;
		case 'value':
			var codePoint = item.codePoint;
			var set = regenerate(codePoint);
			if (ignoreCase && unicode) {
				var folded = caseFold(codePoint);
				if (folded) {
					set.add(folded);
				}
			}
			update(item, set.toString());
			break;
		case 'anchor':
		case 'empty':
		case 'group':
		case 'reference':
			// Nothing to do here.
			break;
		// The `default` clause is only here as a safeguard; it should never be
		// reached. Code coverage tools should ignore it.
		/* istanbul ignore next */
		default:
			throw Error('Unknown term type: ' + item.type);
	}
	return item;
};

module.exports = function(pattern, flags) {
	var tree = parse(pattern, flags);
	ignoreCase = flags ? flags.indexOf('i') > -1 : false;
	unicode = flags ? flags.indexOf('u') > -1 : false;
	assign(tree, processTerm(tree));
	return generate(tree);
};

},{"./data/character-class-escape-sets.js":421,"./data/iu-mappings.json":422,"regenerate":423,"regjsgen":424,"regjsparser":425}],427:[function(require,module,exports){
'use strict';
var isFinite = require('is-finite');

module.exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string as the first argument');
	}

	if (n < 0 || !isFinite(n)) {
		throw new TypeError('Expected a finite positive number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while (n = n >> 1);

	return ret;
};

},{"is-finite":428}],428:[function(require,module,exports){
module.exports=require(291)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/is-integer/node_modules/is-finite/index.js":291}],429:[function(require,module,exports){
'use strict';
module.exports = /^#!.*/;

},{}],430:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	var isExtendedLengthPath = /^\\\\\?\\/.test(str);
	var hasNonAscii = /[^\x00-\x80]+/.test(str);

	if (isExtendedLengthPath || hasNonAscii) {
		return str;
	}

	return str.replace(/\\/g, '/');
};

},{}],431:[function(require,module,exports){
(function (Buffer){
'use strict';
module.exports = function (val) {
	var base64 = new Buffer(JSON.stringify(val)).toString('base64');
	return '//# sourceMappingURL=data:application/json;base64,' + base64;
};

}).call(this,require("buffer").Buffer)
},{"buffer":699}],432:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":438,"./source-map/source-map-generator":439,"./source-map/source-node":440}],433:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":441,"amdefine":442}],434:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":435,"amdefine":442}],435:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":442}],436:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":442}],437:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":441,"amdefine":442}],438:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":433,"./base64-vlq":434,"./binary-search":436,"./util":441,"amdefine":442}],439:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":433,"./base64-vlq":434,"./mapping-list":437,"./util":441,"amdefine":442}],440:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":439,"./util":441,"amdefine":442}],441:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":442}],442:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/earlgrey/node_modules/babel/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"_process":707,"path":706}],443:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return str.replace(/[\s\uFEFF\xA0]+$/g, '');
};

},{}],444:[function(require,module,exports){
module.exports={
  "name": "babel",
  "description": "Turn ES6 code into readable vanilla ES5 with source maps",
  "version": "4.5.5",
  "author": {
    "name": "Sebastian McKenzie",
    "email": "sebmck@gmail.com"
  },
  "homepage": "https://babeljs.io/",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel"
  },
  "preferGlobal": true,
  "main": "lib/babel/api/node.js",
  "browser": {
    "./lib/babel/api/register/node.js": "./lib/babel/api/register/browser.js"
  },
  "bin": {
    "6to5": "./bin/deprecated/6to5",
    "6to5-node": "./bin/deprecated/6to5-node",
    "6to5-runtime": "./bin/deprecated/6to5-runtime",
    "babel": "./bin/babel/index.js",
    "babel-node": "./bin/babel-node",
    "babel-external-helpers": "./bin/babel-external-helpers"
  },
  "keywords": [
    "harmony",
    "classes",
    "modules",
    "let",
    "const",
    "var",
    "es6",
    "transpile",
    "transpiler",
    "6to5",
    "babel"
  ],
  "scripts": {
    "bench": "make bench",
    "test": "make test"
  },
  "dependencies": {
    "acorn-babel": "0.11.1-35",
    "ast-types": "~0.6.1",
    "chalk": "^1.0.0",
    "chokidar": "^0.12.6",
    "commander": "^2.6.0",
    "core-js": "^0.6.1",
    "debug": "^2.1.1",
    "detect-indent": "^3.0.0",
    "estraverse": "^1.9.1",
    "esutils": "^1.1.6",
    "fs-readdir-recursive": "^0.1.0",
    "globals": "^6.2.0",
    "is-integer": "^1.0.4",
    "js-tokens": "0.4.1",
    "leven": "^1.0.1",
    "line-numbers": "0.2.0",
    "lodash": "^3.2.0",
    "output-file-sync": "^1.1.0",
    "path-is-absolute": "^1.0.0",
    "private": "^0.1.6",
    "regenerator-babel": "0.8.13-1",
    "regexpu": "^1.1.1",
    "repeating": "^1.1.2",
    "shebang-regex": "^1.0.0",
    "slash": "^1.0.0",
    "source-map": "^0.1.43",
    "source-map-support": "^0.2.9",
    "source-map-to-comment": "^1.0.0",
    "trim-right": "^1.0.0"
  },
  "devDependencies": {
    "babel": "4.5.1",
    "browserify": "^8.1.3",
    "chai": "^2.0.0",
    "esvalid": "^1.1.0",
    "istanbul": "^0.3.5",
    "matcha": "^0.6.0",
    "mocha": "^2.1.0",
    "rimraf": "^2.2.8",
    "uglify-js": "^2.4.16"
  },
  "gitHead": "00c964ed19177d4f064e7e00e757478c8795e6c1",
  "bugs": {
    "url": "https://github.com/babel/babel/issues"
  },
  "_id": "babel@4.5.5",
  "_shasum": "05d79db3c89d5af945f1d37f2f6bf36420593b9e",
  "_from": "babel@*",
  "_npmVersion": "2.1.18",
  "_nodeVersion": "1.0.2",
  "_npmUser": {
    "name": "sebmck",
    "email": "sebmck@gmail.com"
  },
  "maintainers": [
    {
      "name": "sebmck",
      "email": "sebmck@gmail.com"
    }
  ],
  "dist": {
    "shasum": "05d79db3c89d5af945f1d37f2f6bf36420593b9e",
    "tarball": "http://registry.npmjs.org/babel/-/babel-4.5.5.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/babel/-/babel-4.5.5.tgz"
}

},{}],445:[function(require,module,exports){
module.exports={"abstract-expression-call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceGet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-delete":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceDelete","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-get":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceGet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-set":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceSet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"apply-constructor":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"create","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"object","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"||","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-comprehension-container":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ArrayExpression","start":null,"end":null,"loc":null,"range":null,"elements":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-from":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-push":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"push","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STATEMENT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"async-to-generator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"fn","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"gen","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"fn","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Promise","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"reject","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"next","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callThrow","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"throw","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"FunctionDeclaration","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arg","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"TryStatement","start":null,"end":null,"loc":null,"range":null,"block":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"gen","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arg","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"handler":{"type":"CatchClause","start":null,"end":null,"loc":null,"range":null,"param":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"error","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"guard":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"reject","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"error","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"guardedHandlers":[],"finalizer":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Promise","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"then","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callThrow","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"bind":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Function","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CONTEXT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-call-check":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"instanceof","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Cannot call a class as a function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-super-constructor-call-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-super-constructor-call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"corejs-is-iterator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CORE_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"$for","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isIterable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"corejs-iterator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CORE_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"$for","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getIterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"default-parameter":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VARIABLE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENT_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"DEFAULT_VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENT_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"let","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"defaults":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyNames","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"define-property":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"enumerable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-assign":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-default-assign":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"module","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-module-declaration-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-module-declaration":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"__esModule","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"extends":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"assign","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"||","right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":1,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForInStatement","start":null,"end":null,"loc":null,"range":null,"left":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"for-of-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":null,"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":">=","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"for-of":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ITERATOR_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STEP_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STEP_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ITERATOR_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"get":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getPrototypeOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"value","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"in","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"has-own":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"inherits":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Super expression must either be null or a function, not ","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"+","right":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"create","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"enumerable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":false,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__proto__","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"interop-require-wildcard":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"default","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"interop-require":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"default","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"let-scoping-return":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"RETURN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"object","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"RETURN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"v","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"named-function":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"FunctionDeclaration","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"GET_OUTER_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"object-destructuring-empty":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Cannot destructure undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"object-without-properties":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForInStatement","start":null,"end":null,"loc":null,"range":null,"left":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"indexOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":">=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ContinueStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ContinueStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property-method-assignment-wrapper-generator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"regeneratorRuntime","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"mark","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_this","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"regeneratorRuntime","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"wrap","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID$","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"WhileStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":1,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"body":{"type":"SwitchStatement","start":null,"end":null,"loc":null,"range":null,"discriminant":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prev","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"cases":[{"type":"SwitchCase","start":null,"end":null,"loc":null,"range":null,"consequent":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"delegateYield","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_this","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"t0","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":1,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"SwitchCase","start":null,"end":null,"loc":null,"range":null,"consequent":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"abrupt","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"return","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"t0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":1,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"SwitchCase","start":null,"end":null,"loc":null,"range":null,"consequent":[],"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":2,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"SwitchCase","start":null,"end":null,"loc":null,"range":null,"consequent":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context$2$0","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"stop","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"end","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property-method-assignment-wrapper":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"prototype-identifier":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CLASS_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"prototype-properties":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"require-assign-key":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VARIABLE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"require","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"require":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"require","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"rest":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY_LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"START","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"self-contained-helpers-head":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"helpers","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"default","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"self-global":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"global","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"self","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"global","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"set":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getPrototypeOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"value","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"in","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"slice":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"slice","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"sliced-to-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"in","right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ArrayExpression","start":null,"end":null,"loc":null,"range":null,"elements":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"push","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Invalid attempt to destructure non-iterable instance","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"system":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"System","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"register","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_DEPENDENCIES","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"EXPORT_IDENTIFIER","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setters","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SETTERS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"execute","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"EXECUTE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tagged-template-literal-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tagged-template-literal":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"freeze","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"freeze","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tail-call-body":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"AGAIN_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"LabeledStatement","start":null,"end":null,"loc":null,"range":null,"body":{"type":"WhileStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"AGAIN_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"BLOCK","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"label":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"temporal-assert-defined":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"val","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"name","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undef","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"val","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undef","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ReferenceError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"name","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"+","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":" is not defined - temporal dead zone","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"temporal-undefined":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test-exports":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test-module":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"module","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"to-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"to-consumable-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"typeof":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"symbol","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"alternate":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"umd-runner-body":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"amd","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"AMD_ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"COMMON_TEST","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"COMMON_ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}}
},{}],446:[function(require,module,exports){
module.exports=require(5)
},{"./lib":447,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/5.js":5,"core-js/shim":536,"regenerator/runtime":538}],447:[function(require,module,exports){
module.exports=require(6)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/lib.js":6,"kaiser/reg":537}],448:[function(require,module,exports){
module.exports=require(7)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.array-includes.js":7}],449:[function(require,module,exports){
module.exports=require(8)
},{"./$":469,"./$.ctx":457,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.array-methods.js":8}],450:[function(require,module,exports){
module.exports=require(9)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.assert.js":9}],451:[function(require,module,exports){
module.exports=require(10)
},{"./$":469,"./$.enum-keys":460,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.assign.js":10}],452:[function(require,module,exports){
module.exports=require(11)
},{"./$":469,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.cof.js":11}],453:[function(require,module,exports){
module.exports=require(12)
},{"./$":469,"./$.assert":450,"./$.ctx":457,"./$.for-of":461,"./$.iter":468,"./$.iter-define":466,"./$.mix":471,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-strong.js":12}],454:[function(require,module,exports){
module.exports=require(13)
},{"./$.def":458,"./$.for-of":461,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-to-json.js":13}],455:[function(require,module,exports){
module.exports=require(14)
},{"./$":469,"./$.array-methods":449,"./$.assert":450,"./$.for-of":461,"./$.mix":471,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-weak.js":14}],456:[function(require,module,exports){
module.exports=require(15)
},{"./$":469,"./$.assert":450,"./$.cof":452,"./$.def":458,"./$.for-of":461,"./$.iter":468,"./$.iter-detect":467,"./$.mix":471,"./$.redef":474,"./$.species":479,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection.js":15}],457:[function(require,module,exports){
module.exports=require(16)
},{"./$.assert":450,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.ctx.js":16}],458:[function(require,module,exports){
module.exports=require(17)
},{"./$":469,"./$.redef":474,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.def.js":17}],459:[function(require,module,exports){
module.exports=require(18)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.dom-create.js":18}],460:[function(require,module,exports){
module.exports=require(19)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.enum-keys.js":19}],461:[function(require,module,exports){
module.exports=require(20)
},{"./$.ctx":457,"./$.iter":468,"./$.iter-call":465,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.for-of.js":20}],462:[function(require,module,exports){
module.exports=require(21)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.fw.js":21}],463:[function(require,module,exports){
module.exports=require(22)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.get-names.js":22}],464:[function(require,module,exports){
module.exports=require(23)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.invoke.js":23}],465:[function(require,module,exports){
module.exports=require(24)
},{"./$.assert":450,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-call.js":24}],466:[function(require,module,exports){
module.exports=require(25)
},{"./$":469,"./$.cof":452,"./$.def":458,"./$.iter":468,"./$.redef":474,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-define.js":25}],467:[function(require,module,exports){
module.exports=require(26)
},{"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-detect.js":26}],468:[function(require,module,exports){
module.exports=require(27)
},{"./$":469,"./$.assert":450,"./$.cof":452,"./$.shared":478,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter.js":27}],469:[function(require,module,exports){
module.exports=require(28)
},{"./$.fw":462,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.js":28}],470:[function(require,module,exports){
module.exports=require(29)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.keyof.js":29}],471:[function(require,module,exports){
module.exports=require(30)
},{"./$.redef":474,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.mix.js":30}],472:[function(require,module,exports){
module.exports=require(31)
},{"./$":469,"./$.assert":450,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.own-keys.js":31}],473:[function(require,module,exports){
module.exports=require(32)
},{"./$":469,"./$.assert":450,"./$.invoke":464,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.partial.js":32}],474:[function(require,module,exports){
module.exports=require(33)
},{"./$":469,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.redef.js":33}],475:[function(require,module,exports){
module.exports=require(34)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.replacer.js":34}],476:[function(require,module,exports){
module.exports=require(35)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.same.js":35}],477:[function(require,module,exports){
module.exports=require(36)
},{"./$":469,"./$.assert":450,"./$.ctx":457,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.set-proto.js":36}],478:[function(require,module,exports){
module.exports=require(37)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.shared.js":37}],479:[function(require,module,exports){
module.exports=require(38)
},{"./$":469,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.species.js":38}],480:[function(require,module,exports){
module.exports=require(39)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-at.js":39}],481:[function(require,module,exports){
module.exports=require(40)
},{"./$":469,"./$.string-repeat":482,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-pad.js":40}],482:[function(require,module,exports){
module.exports=require(41)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-repeat.js":41}],483:[function(require,module,exports){
module.exports=require(42)
},{"./$":469,"./$.cof":452,"./$.ctx":457,"./$.dom-create":459,"./$.invoke":464,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.task.js":42}],484:[function(require,module,exports){
module.exports=require(43)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.throws.js":43}],485:[function(require,module,exports){
module.exports=require(44)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.uid.js":44}],486:[function(require,module,exports){
module.exports=require(45)
},{"./$":469,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.unscope.js":45}],487:[function(require,module,exports){
module.exports=require(46)
},{"./$":469,"./$.shared":478,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.wks.js":46}],488:[function(require,module,exports){
module.exports=require(47)
},{"./$":469,"./$.array-includes":448,"./$.array-methods":449,"./$.assert":450,"./$.cof":452,"./$.def":458,"./$.dom-create":459,"./$.invoke":464,"./$.replacer":475,"./$.throws":484,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es5.js":47}],489:[function(require,module,exports){
module.exports=require(48)
},{"./$":469,"./$.def":458,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.copy-within.js":48}],490:[function(require,module,exports){
module.exports=require(49)
},{"./$":469,"./$.def":458,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.fill.js":49}],491:[function(require,module,exports){
module.exports=require(50)
},{"./$.array-methods":449,"./$.def":458,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.find-index.js":50}],492:[function(require,module,exports){
module.exports=require(51)
},{"./$.array-methods":449,"./$.def":458,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.find.js":51}],493:[function(require,module,exports){
module.exports=require(52)
},{"./$":469,"./$.ctx":457,"./$.def":458,"./$.iter":468,"./$.iter-call":465,"./$.iter-detect":467,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.from.js":52}],494:[function(require,module,exports){
module.exports=require(53)
},{"./$":469,"./$.iter":468,"./$.iter-define":466,"./$.uid":485,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.iterator.js":53}],495:[function(require,module,exports){
module.exports=require(54)
},{"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.of.js":54}],496:[function(require,module,exports){
module.exports=require(55)
},{"./$.species":479,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.species.js":55}],497:[function(require,module,exports){
module.exports=require(56)
},{"./$":469,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.function.has-instance.js":56}],498:[function(require,module,exports){
module.exports=require(57)
},{"./$":469,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.function.name.js":57}],499:[function(require,module,exports){
module.exports=require(58)
},{"./$.collection":456,"./$.collection-strong":453,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.map.js":58}],500:[function(require,module,exports){
module.exports=require(59)
},{"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.math.js":59}],501:[function(require,module,exports){
module.exports=require(60)
},{"./$":469,"./$.redef":474,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.number.constructor.js":60}],502:[function(require,module,exports){
module.exports=require(61)
},{"./$":469,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.number.statics.js":61}],503:[function(require,module,exports){
module.exports=require(62)
},{"./$.assign":451,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.assign.js":62}],504:[function(require,module,exports){
module.exports=require(63)
},{"./$.def":458,"./$.same":476,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.is.js":63}],505:[function(require,module,exports){
module.exports=require(64)
},{"./$.def":458,"./$.set-proto":477,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.set-prototype-of.js":64}],506:[function(require,module,exports){
module.exports=require(65)
},{"./$":469,"./$.def":458,"./$.get-names":463,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.statics-accept-primitives.js":65}],507:[function(require,module,exports){
module.exports=require(66)
},{"./$":469,"./$.cof":452,"./$.redef":474,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.to-string.js":66}],508:[function(require,module,exports){
module.exports=require(67)
},{"./$":469,"./$.assert":450,"./$.cof":452,"./$.ctx":457,"./$.def":458,"./$.for-of":461,"./$.iter-detect":467,"./$.mix":471,"./$.same":476,"./$.set-proto":477,"./$.species":479,"./$.task":483,"./$.uid":485,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.promise.js":67}],509:[function(require,module,exports){
module.exports=require(68)
},{"./$":469,"./$.assert":450,"./$.def":458,"./$.iter":468,"./$.own-keys":472,"./$.set-proto":477,"./$.uid":485,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.reflect.js":68}],510:[function(require,module,exports){
module.exports=require(69)
},{"./$":469,"./$.cof":452,"./$.redef":474,"./$.replacer":475,"./$.species":479,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.regexp.js":69}],511:[function(require,module,exports){
module.exports=require(70)
},{"./$.collection":456,"./$.collection-strong":453,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.set.js":70}],512:[function(require,module,exports){
module.exports=require(71)
},{"./$.def":458,"./$.string-at":480,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.code-point-at.js":71}],513:[function(require,module,exports){
module.exports=require(72)
},{"./$":469,"./$.cof":452,"./$.def":458,"./$.throws":484,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.ends-with.js":72}],514:[function(require,module,exports){
module.exports=require(73)
},{"./$":469,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.from-code-point.js":73}],515:[function(require,module,exports){
module.exports=require(74)
},{"./$":469,"./$.cof":452,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.includes.js":74}],516:[function(require,module,exports){
module.exports=require(75)
},{"./$":469,"./$.iter":468,"./$.iter-define":466,"./$.string-at":480,"./$.uid":485,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.iterator.js":75}],517:[function(require,module,exports){
module.exports=require(76)
},{"./$":469,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.raw.js":76}],518:[function(require,module,exports){
module.exports=require(77)
},{"./$.def":458,"./$.string-repeat":482,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.repeat.js":77}],519:[function(require,module,exports){
module.exports=require(78)
},{"./$":469,"./$.cof":452,"./$.def":458,"./$.throws":484,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.starts-with.js":78}],520:[function(require,module,exports){
module.exports=require(79)
},{"./$":469,"./$.assert":450,"./$.cof":452,"./$.def":458,"./$.enum-keys":460,"./$.get-names":463,"./$.keyof":470,"./$.redef":474,"./$.shared":478,"./$.uid":485,"./$.wks":487,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.symbol.js":79}],521:[function(require,module,exports){
module.exports=require(80)
},{"./$":469,"./$.collection":456,"./$.collection-weak":455,"./$.redef":474,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.weak-map.js":80}],522:[function(require,module,exports){
module.exports=require(81)
},{"./$.collection":456,"./$.collection-weak":455,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.weak-set.js":81}],523:[function(require,module,exports){
module.exports=require(82)
},{"./$.array-includes":448,"./$.def":458,"./$.unscope":486,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.array.includes.js":82}],524:[function(require,module,exports){
module.exports=require(83)
},{"./$.collection-to-json":454,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.map.to-json.js":83}],525:[function(require,module,exports){
module.exports=require(84)
},{"./$":469,"./$.def":458,"./$.own-keys":472,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":84}],526:[function(require,module,exports){
module.exports=require(85)
},{"./$":469,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.object.to-array.js":85}],527:[function(require,module,exports){
module.exports=require(86)
},{"./$.def":458,"./$.replacer":475,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.regexp.escape.js":86}],528:[function(require,module,exports){
module.exports=require(87)
},{"./$.collection-to-json":454,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.set.to-json.js":87}],529:[function(require,module,exports){
module.exports=require(88)
},{"./$.def":458,"./$.string-at":480,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.at.js":88}],530:[function(require,module,exports){
module.exports=require(89)
},{"./$.def":458,"./$.string-pad":481,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.lpad.js":89}],531:[function(require,module,exports){
module.exports=require(90)
},{"./$.def":458,"./$.string-pad":481,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.rpad.js":90}],532:[function(require,module,exports){
module.exports=require(91)
},{"./$":469,"./$.ctx":457,"./$.def":458,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/js.array.statics.js":91}],533:[function(require,module,exports){
module.exports=require(92)
},{"./$":469,"./$.iter":468,"./$.wks":487,"./es6.array.iterator":494,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.dom.iterable.js":92}],534:[function(require,module,exports){
module.exports=require(93)
},{"./$.def":458,"./$.task":483,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.immediate.js":93}],535:[function(require,module,exports){
module.exports=require(94)
},{"./$":469,"./$.def":458,"./$.invoke":464,"./$.partial":473,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.timers.js":94}],536:[function(require,module,exports){
module.exports=require(95)
},{"./modules/$":469,"./modules/es5":488,"./modules/es6.array.copy-within":489,"./modules/es6.array.fill":490,"./modules/es6.array.find":492,"./modules/es6.array.find-index":491,"./modules/es6.array.from":493,"./modules/es6.array.iterator":494,"./modules/es6.array.of":495,"./modules/es6.array.species":496,"./modules/es6.function.has-instance":497,"./modules/es6.function.name":498,"./modules/es6.map":499,"./modules/es6.math":500,"./modules/es6.number.constructor":501,"./modules/es6.number.statics":502,"./modules/es6.object.assign":503,"./modules/es6.object.is":504,"./modules/es6.object.set-prototype-of":505,"./modules/es6.object.statics-accept-primitives":506,"./modules/es6.object.to-string":507,"./modules/es6.promise":508,"./modules/es6.reflect":509,"./modules/es6.regexp":510,"./modules/es6.set":511,"./modules/es6.string.code-point-at":512,"./modules/es6.string.ends-with":513,"./modules/es6.string.from-code-point":514,"./modules/es6.string.includes":515,"./modules/es6.string.iterator":516,"./modules/es6.string.raw":517,"./modules/es6.string.repeat":518,"./modules/es6.string.starts-with":519,"./modules/es6.symbol":520,"./modules/es6.weak-map":521,"./modules/es6.weak-set":522,"./modules/es7.array.includes":523,"./modules/es7.map.to-json":524,"./modules/es7.object.get-own-property-descriptors":525,"./modules/es7.object.to-array":526,"./modules/es7.regexp.escape":527,"./modules/es7.set.to-json":528,"./modules/es7.string.at":529,"./modules/es7.string.lpad":530,"./modules/es7.string.rpad":531,"./modules/js.array.statics":532,"./modules/web.dom.iterable":533,"./modules/web.immediate":534,"./modules/web.timers":535,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/shim.js":95}],537:[function(require,module,exports){
module.exports=require(96)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/kaiser/reg.js":96}],538:[function(require,module,exports){
module.exports=require(97)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/regenerator/runtime.js":97,"_process":707}],539:[function(require,module,exports){
/**
 * Created by azu on 2014/07/02.
 * LICENSE : MIT
 */
"use strict";
module.exports = {
    transfer: require("./lib/multi-stage-sourcemap")
};
},{"./lib/multi-stage-sourcemap":540}],540:[function(require,module,exports){
"use strict";
var sourceMap = require("source-map");
var Generator = sourceMap.SourceMapGenerator;
var Consumer = sourceMap.SourceMapConsumer;
/**
 * return re-mapped rawSourceMap string
 * @param {object} mappingObject
 * @param {string} mappingObject.fromSourceMap
 * @param {string} mappingObject.toSourceMap
 * @returns {string}
 */
function transfer(mappingObject) {
    var fromSourceMap = mappingObject.fromSourceMap;
    var toSourceMap = mappingObject.toSourceMap;
    var fromSMC = new Consumer(fromSourceMap);
    var toSMC = new Consumer(toSourceMap);
    var resultMap = new Generator();
    fromSMC.eachMapping(function (mapping) {
        var generatedPosition = {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
        };
        var fromOriginalPosition = {
            line: mapping.originalLine,
            column: mapping.originalColumn
        };
        // from's generated position -> to's original position
        var originalPosition = toSMC.originalPositionFor(fromOriginalPosition);
        if (originalPosition.source !== null) {
            resultMap.addMapping({
                source: originalPosition.source,
                name : originalPosition.name,
                generated: generatedPosition,
                original: originalPosition
            });
        }
    });
    return resultMap.toString();
}

module.exports = transfer;
},{"source-map":541}],541:[function(require,module,exports){
arguments[4][432][0].apply(exports,arguments)
},{"./source-map/source-map-consumer":547,"./source-map/source-map-generator":548,"./source-map/source-node":549,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map.js":432}],542:[function(require,module,exports){
arguments[4][433][0].apply(exports,arguments)
},{"./util":550,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/array-set.js":433,"amdefine":551}],543:[function(require,module,exports){
arguments[4][434][0].apply(exports,arguments)
},{"./base64":544,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/base64-vlq.js":434,"amdefine":551}],544:[function(require,module,exports){
arguments[4][435][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/base64.js":435,"amdefine":551}],545:[function(require,module,exports){
arguments[4][436][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/binary-search.js":436,"amdefine":551}],546:[function(require,module,exports){
arguments[4][437][0].apply(exports,arguments)
},{"./util":550,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/mapping-list.js":437,"amdefine":551}],547:[function(require,module,exports){
arguments[4][438][0].apply(exports,arguments)
},{"./array-set":542,"./base64-vlq":543,"./binary-search":545,"./util":550,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/source-map-consumer.js":438,"amdefine":551}],548:[function(require,module,exports){
arguments[4][439][0].apply(exports,arguments)
},{"./array-set":542,"./base64-vlq":543,"./mapping-list":546,"./util":550,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/source-map-generator.js":439,"amdefine":551}],549:[function(require,module,exports){
arguments[4][440][0].apply(exports,arguments)
},{"./source-map-generator":548,"./util":550,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/source-node.js":440,"amdefine":551}],550:[function(require,module,exports){
arguments[4][441][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/util.js":441,"amdefine":551}],551:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/earlgrey/node_modules/multi-stage-sourcemap/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"_process":707,"path":706}],552:[function(require,module,exports){

var util = require("./util");


function highlight(text, spans, offset) {
    if (!offset) offset = 0;
    return ENode(
        [], {},
        util.morsel(spans).map(function (x) {
            var start = Math.max(x[0] - offset, 0);
            var end = Math.min(x[1] - offset, text.length);
            var attributes = x[2];
            return ENode(["span", "." + attributes.slice(0, 1)], {},
                         [text.slice(start, end)]);
        })
    );
}

function highlightLines(text, linelocs, l1, l2, spans) {
    var results = [];
    for (var i = l1; i <= l2; i++) {
        var start = linelocs[i];
        var end = linelocs[i + 1];
        var r = ENode(
            [], {},
            [ENode([".lineno"], {}, [i + 1]),
             ENode([".sourcecode"], {},
                  [highlight(text, [[start, end, []]].concat(clamp(spans, start, end)))])]
        );
        results.push(r);
    }
    return ENode([], {}, results);
}

function clamp(spans, bot, top) {
    var results = [];
    spans.forEach(function (x) {
        var start = x[0];
        var end = x[1];
        var attr = x[2];
        if (end >= bot && start <= top)
            results.push([Math.max(start, bot), Math.min(end, top), attr]);
    });
    return results;
}

function highlightLocations(locations, context) {
    if (!context) context = 0;
    var srcs = {};
    locations.forEach(function (x) {
        var loc = x[0];
        var cls = x[1];
        var key = String(loc.source && loc.source.url);
        if (!srcs[key])
            srcs[key] = []
        srcs[key].push([loc, cls]);
    });
    return ENode([], {}, items(srcs).map(function (x) {
        return highlightLocationsSameSource(x[1], context);
    }));
}

function highlightLocationsSameSource(locations, context) {
    if (!context) context = 0;
    var loc = mergeLocations(locations.map(function (x) {
        return x[0];
    }));
    var src = loc.source;
    var l1l2 = loc.linerange();
    var l1 = l1l2[0];
    var l2 = l1l2[1];
    var first = Math.max(1, l1 - context);
    var last = Math.min(src.nlines, l2 + context);
    return ENode(
        ["div", ".location"], {},
        [
            ENode(["div", ".source"], {}, [
                ENode([".sourcefile"], {}, [src.url || "???"]),
                locations.map(function (x) {
                    var loc = x[0];
                    var cls = x[1];
                    return ENode(["." + cls, ".sourcepos"], {}, [loc.ref()]);
                })
            ]),
            src.highlightLines(first, last, locations.map(function (x) {
                var loc = x[0];
                var cls = x[1];
                return [loc.start, loc.end, [cls]];
            }))
        ]
    );
}

function mergeLocations(locs) {
    var ll = locs.length;
    if (ll === 0)
        return Location(null, 0, 0);
    else if (ll === 1)
        return locs[0];
    else {
        var l = locs[0];
        locs.slice(1).forEach(function (l2) {
            l = l.merge(l2);
        });
        return l;
    }
}

exports.highlight = highlight;
exports.highlightLines = highlightLines;
exports.highlightLocations = highlightLocations;
exports.mergeLocations = mergeLocations;


},{"./util":557}],553:[function(require,module,exports){

exports.tokenize = require("./tokenize.js");
exports.parse = require("./parse.js");

loc = require("./location.js");
exports.transferLocation = loc.transferLocation
exports.Location = loc.Location
exports.Source = loc.Source

},{"./location.js":554,"./parse.js":555,"./tokenize.js":556}],554:[function(require,module,exports){

var util = require("./util");
var hl = require("./highlight");
var kreg = require("kaiser/reg");
var fs = require("fs");

////////////
// Source //
////////////

function Source(text, url, offset) {
    if (!(this instanceof Source))
        return new Source(text, url);
    this.text = text;
    this.url = url;
    this.offset = offset || 0;
    this.counts = [];
    var curr = 0;
    var self = this;
    text.split("\n").forEach(function (line) {
        self.counts.push(curr);
        curr += line.length + 1;
    });
    this.counts.push(curr);
    this.nlines = this.counts.length - 1;
}

Source.prototype.linecol = function (pos) {
    var line = util.binsearch(this.counts, pos);
    var col = pos - this.counts[line - 1];
    return [line, col];
};

Source.prototype.at = function (start, end) {
    if (end === undefined) { end = start; }
    return Location(this, start, end);
}

Source.prototype.highlightLines = function (l1, l2, spans) {
    return hl.highlightLines(this.text, this.counts, l1 - 1, l2 - 1, spans);
}

kreg.register(Source.prototype, {
    package: require("../package"),
    serialize: function (src) {
        if (src.url) return {
            text: null,
            url: src.url,
            offset: src.offset
        }
        else return {
            text: src.text,
            url: src.url,
            offset: src.offset
        }
    },
    deserialize: function (obj) {
        if (obj.text === null)
            return new Source(fs.readFileSync(obj.url, "utf8"), obj.url, obj.offset);
        else
            return new Source(obj.text, obj.url, obj.offset);
    }
});


//////////////
// Location //
//////////////

function Location(source, start, end) {
    if (!(this instanceof Location))
        return new Location(source, start, end);
    this.source = source || Source("", null);
    this.start = start;
    this.end = end;
}

Location.prototype.text = function () {
    return this.source.text.slice(this.start, this.end);
};

Location.prototype.at_start = function () {
    return Location(this.source, this.start, this.start);
};

Location.prototype.at_end = function () {
    return Location(this.source, this.end, this.end);
};

Location.prototype.trim = function () {
    var t = this.source.text;
    var start = this.start;
    while (end > start && (t[start] == " " || t[start] == "\n"))
        start++;
    var end = this.end - 1;
    while (end > start && (t[end] == " " || t[end] == "\n"))
        end--;
    return Location(this.source, start, end + 1);
};

Location.prototype.linecol = function () {
    var start = this.source.linecol(this.start);
    var end = this.start === this.end ? null : this.source.linecol(this.end - 1);
    return [start, end];
};

Location.prototype.linerange = function () {
    var lc = this.linecol();
    if (lc[1] === null)
        return [lc[0][0], lc[0][0]];
    else
        return [lc[0][0], lc[1][0]];
};

Location.prototype.ref = function () {
    var lc = this.linecol();
    var l1 = lc[0][0];
    var c1 = lc[0][1];
    if (lc[1] === null)
        return l1 + ":" + c1;
    var l2 = lc[1][0];
    var c2 = lc[1][1];
    if (l1 === l2 && c1 === c2)
        return l1 + ":" + c1;
    if (l1 === l2)
        return l1 + ":" + c1 + "-" + c2;
    return l1 + ":" + c1 + "-" + l2 + ":" + c2;
};

Location.prototype.makeSource = function () {
    return Source(this.text(), this.source.url, this.start);
};

Location.prototype.merge = function (other) {
    if (other.source !== this.source)
        throw Error("Cannot merge locations from different sources.");
    return Location(
        this.source,
        Math.min(this.start, other.start),
        Math.max(this.end, other.end)
    );
};

Location.prototype.highlight = function(cls, context) {
    if (!context) context = 0;
    if (!cls) cls = "hl1";
    return hl.highlightLocations([[this.trim(), cls]], context);
}

kreg.register(Location.prototype, {
    package: require("../package"),
});



function transferLocation(x, y) {
    if (!(x.location instanceof Location))
        x.location = !(y && y.location instanceof Location) ? y : y.location;
    return x;
}


exports.Source = Source;
exports.Location = Location;
exports.transferLocation = transferLocation;



},{"../package":559,"./highlight":552,"./util":557,"fs":697,"kaiser/reg":558}],555:[function(require,module,exports){

function Parser(tokenizer, order, finalize) {
    if (!(this instanceof Parser))
        return new Parser(tokenizer, order, finalize);
    this.tokenizer = tokenizer;
    this.order = order;
    this.finalize = finalize || function (node) { return node; };
}

Parser.prototype.parse = function (source) {
    var next = this.tokenizer.iterator(source);
    var stack = [];
    var middle = null;
    var left = next();
    var right = next();
    var current = [null, left];
    while (true) {
        var o = this.order(left, right);
        switch (o) {
        case "done":
            return middle;
        case "<":
            stack.push(current);
            current = [middle, right];
            middle = null;
            left = right;
            right = next();
            break;
        case ">":
            current.push(middle);
            middle = this.finalize(current);
            current = stack.pop()
            left = current[current.length - 1];
            break;
        case "=":
            current.push(middle, right);
            middle = null;
            left = right;
            right = next();
            break;
        default:
            throw Error("Unknown order directive: " + o);
        }
    }
}



function TokenGroups(groups) {
    if (!(this instanceof TokenGroups))
        return new TokenGroups(groups);
    this.lookup = {boundary: "boundary"};
    this.fns = [];
    for (var name in groups) {
        var entries = groups[name];
        for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (typeof(e) === "string")
                this.lookup[e] = name;
            else
                this.fns.push([e, name]);
        }
    }
    this.groups = groups;
}

TokenGroups.prototype.resolve = function (token) {
    var x = this.lookup[token.type + " " + token.token];
    if (x) { return x; }
    else {
        for (var i = 0; i < this.fns.length; i++) {
            if (this.fns[i][0](token))
                return this.fns[i][1];
        }
        return this.lookup[token.type] || token.type;
    }
}



function PriorityOrder(groups, priorities) {
    if (!(this instanceof PriorityOrder))
        return new PriorityOrder(groups, priorities);
    this.groups = groups;
    this.priorities = priorities;
    this.priorities["boundary"] = {left: -1, right: -1};
}

PriorityOrder.prototype.getOrder = function () {
    return this.order.bind(this);
}

PriorityOrder.prototype.getPrio = function (token) {
    return this.priorities[this.groups.resolve(token)];
}

PriorityOrder.prototype.order = function (a, b) {
    if (a.type === "boundary" && b.type === "boundary") return "done";
    var pa = this.getPrio(a).right;
    var pb = this.getPrio(b).left;
    if (pa < pb)  return "<";
    if (pa > pb)  return ">";
    if (pa == pb) return "=";
}


exports.Parser = Parser
exports.TokenGroups = TokenGroups
exports.PriorityOrder = PriorityOrder


},{}],556:[function(require,module,exports){

var loc = require("./location");
var Source = loc.Source;
var Location = loc.Location;

function Tokenizer(config) {
    if (!(this instanceof Tokenizer))
        return new Tokenizer(config);
    this.config = config
    var parts = [];
    this.types = [];
    var regexps = config.regexps instanceof Array
        ? config.regexps
        : Object.getOwnPropertyNames(config.regexps).map(
            function (x) { return [x, config.regexps[x]]; });
    for (var i = 0; i < regexps.length; i++) {
        var pair = regexps[i];
        this.types.push(pair[0]);
        if (pair[2])
            parts.push(pair[1]);
        else
            parts.push("(" + pair[1] + ")");
    }
    this.re = parts.join("|");
}

Tokenizer.prototype.iterator = function(source) {
    var results = this.run(source);
    return results.shift.bind(results);
}

Tokenizer.prototype.run = function(source) {
    if (source instanceof Source) {
        var text = source.text;
        var index = source.offset || 0;
    }
    else {
        var text = source;
        var index = 0;
    }
    var re = new RegExp(this.re, "g");
    function dopost(post, toks) {
        var state = post.initState ? post.initState() : {};
        var results = [];
        for (var i = 0; i < toks.length; i++) {
            var r = post.call(state, toks[i], i, toks);
            if (r instanceof Array)
                results.push.apply(results, r);
            else
                results.push(r);
        }
        return results;
    }

    var post = this.config.post;
    if (post === undefined) post = [];
    else if (!(post instanceof Array)) post = [post];

    var m;
    var results = [{token: "", type: "boundary",
                    location: Location(source, index, index)}];
    while (m = re.exec(text)) {
        var type = this.types[m.slice(1).indexOf(m[0])];
        if (type === "comment") continue;
        results.push({
            token: m[0],
            type: type,
            location: Location(source, m.index + index, m.index + m[0].length + index)
        });
    }
    results.push({token: "", type: "boundary",
                  location: Location(source, text.length + index, text.length + index)});
    for (var i = 0; i < post.length; i++)
        results = dopost(post[i], results);
    return results;
}

function indentTracker(calcSize, tolerateErrors) {
    if (!calcSize)
        calcSize = function (tok) {
            if (tok.type === "newline") return tok.token.length;
            else return -1
        }
    function next(curr) {
        var sz;
        if (curr.type === "boundary") sz = 0;
        else sz = calcSize(curr);
        if (sz === -1) return curr;
        else if (sz > this.current) {
            this.stack.push(this.current);
            this.current = sz;
            return [{type: "indent", token: ""}, curr];
        }
        else {
            var rval = [];
            while (sz < this.current) {
                rval.push({type: "dedent", token: ""});
                this.current = this.stack.pop();
            }
            if (this.current !== sz) {
                if (!tolerateErrors)
                    throw SyntaxError("Indentation error. " + this.current + " " + sz);
                else {
                    this.stack.push(this.current);
                    this.current = sz;
                    rval.pop();
                    rval.push(curr);
                    return rval;
                }
            }
            this.current = sz;
            rval.push(curr);
            return rval;
        }
    }
    next.initState = function () { return {current: 0, stack: []}; };
    return next;
}

function inferLocation(tok, i, toks) {
    if (tok.location === undefined) {
        var src = (toks[i - 1] || toks[i + 1]).location.source;
        var start = toks[i - 1] ? toks[i - 1].location.end : 0;
        var end = toks[i + 1] && toks[i + 1].location ? toks[i + 1].location.start : start;
        tok.location = Location(src, start, end);
    }
    return tok;
}


exports.Tokenizer = Tokenizer
exports.indentTracker = indentTracker
exports.inferLocation = inferLocation


},{"./location":554}],557:[function(require,module,exports){

function binsearch(xs, x) {
    // Find an insertion point for x in the sorted array xs.
    // Returns an index i such that
    //   xs[i - 1] < x <= xs[i]
    // In particular,
    //   If x < xs[0]              ==> return 0
    //   If x > xs[xs.length - 1]  ==> return xs.length
    // Take note that
    //   If x == xs[i]             ==> return i + 1
    // The return value should not be interpreted as the index where x
    // is found, but some index where x can be safely spliced to
    // preserve the array's sortedness.
    var lo = 0;
    var hi = xs.length - 1;
    while (lo <= hi) {
        var mid = lo + ((hi - lo) >> 1);
        var v = xs[mid];
        if (v < x)
            lo = mid + 1;
        else if (v > x)
            hi = mid - 1;
        else
            return mid + 1
    }
    return lo;
}


function morsel(spans) {
    // Note: this is adapted from a different implementation I wrote a
    // year ago. I am not entirely sure how it works anymore, but I don't
    // really care, as long as it does. (At least I documented what it is
    // supposed to do)

    // spans == Array of span
    // span == {Integer start, Integer end, Array of attribute}
    // attribute == any

    // Morsels the sequence of spans so that none of the spans in the
    // sequence overlap. Ranges covered by more than one span are
    // given the union of the attributes of all the spans covering it.

    // Example:
    // morsel with {{0, 10, {1}}, {2, 5, {2}}, {4, 7, {3}}, {40, 50, {4}}}
    // => {{0, 2, {1}}, {2, 4, {1, 2}}, {4, 5, {1, 2, 3}}, {5, 7, {1, 3}},
    //     {7, 10, {1}}, {10, 40, {}}, {40, 50, {4}}}

    function jump(active, bot, top) {
        var choices = [top].concat(active.map(function (x) { return x[1]; }));
        var e = Math.min.apply(null, choices);
        var attributes = [];
        active.forEach(function (x) {
            attributes = attributes.concat(x[2]);
        });
        return [e, [bot, e, attributes]];
    }

    function jumptill(active, bot, top) {
        if (bot === top) {
            return [[], active];
        }
        else {
            var j = jump(active, bot, top);
            var newbot = j[0];
            var span = j[1];
            var newactive = [];
            active.forEach(function (x) {
                if (x[1] > newbot) {
                    newactive.push(x);
                }
            });
            var jt = jumptill(newactive, newbot, top);
            var spans = jt[0];
            var remainder = jt[1];
            return [[span].concat(spans), remainder];
        }
    }

    function process_elements(start, active, rem) {
        if (active.length === 0 && rem.length === 0) {
            return []
        }
        else if (rem.length === 0) {
            var choices = active.map(function (x) { return x[1]; });
            var top = Math.max.apply(null, choices);
            var bot = Math.min(start, top);
            var spans = jumptill(active, start, top)[0];
            return spans;
        }
        else {
            var next = rem[0];
            var rest = rem.slice(1);
            var target = next[0];
            var jt = jumptill(active, start, target);
            return jt[0].concat(process_elements(target, [next].concat(jt[1]), rest));
        }
    }

    var thespans = spans.sort(function (a, b) {
        if (a[0] === b[0])
            return a[1] - b[1];
        else
            return a[0] - b[0];
    });

    return process_elements(thespans[0][0], [], thespans);
}

exports.binsearch = binsearch;
exports.morsel = morsel;


},{}],558:[function(require,module,exports){
module.exports=require(96)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/kaiser/reg.js":96}],559:[function(require,module,exports){
module.exports={
  "name": "opg",
  "version": "0.0.5",
  "format": "cjs",
  "description": "Library to parse operator precedence grammars.",
  "main": "./lib/index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "homepage": "https://github.com/breuleux/opg",
  "repository": {
    "type": "git",
    "url": "https://github.com/breuleux/opg"
  },
  "keywords": [
    "parsing",
    "parser"
  ],
  "author": "Olivier Breuleux",
  "license": "MIT",
  "dependencies": {
    "kaiser": "0.0.3"
  }
}

},{}],560:[function(require,module,exports){
arguments[4][432][0].apply(exports,arguments)
},{"./source-map/source-map-consumer":565,"./source-map/source-map-generator":566,"./source-map/source-node":567,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map.js":432}],561:[function(require,module,exports){
arguments[4][433][0].apply(exports,arguments)
},{"./util":568,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/array-set.js":433,"amdefine":569}],562:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":563,"amdefine":569}],563:[function(require,module,exports){
arguments[4][435][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/base64.js":435,"amdefine":569}],564:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":569}],565:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":561,"./base64-vlq":562,"./binary-search":564,"./util":568,"amdefine":569}],566:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":561,"./base64-vlq":562,"./util":568,"amdefine":569}],567:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":566,"./util":568,"amdefine":569}],568:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":569}],569:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/earlgrey/node_modules/source-map-support/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"_process":707,"path":706}],570:[function(require,module,exports){
(function (process,Buffer){
var SourceMapConsumer = require('source-map').SourceMapConsumer;
var path = require('path');
var fs = require('fs');

// Only install once if called multiple times
var alreadyInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

function isInBrowser() {
  return typeof window !== 'undefined';
}

function retrieveFile(path) {
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  try {
    // Use SJAX if we are in the browser
    if (isInBrowser()) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, false);
      xhr.send(null);
      var contents = xhr.readyState === 4 ? xhr.responseText : null;
    }

    // Otherwise, use the filesystem
    else {
      var contents = fs.readFileSync(path, 'utf8');
    }
  } catch (e) {
    var contents = null;
  }

  return fileContentsCache[path] = contents;
}

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', source, false);
    xhr.send(null);
    fileData = xhr.readyState === 4 ? xhr.responseText : null;

    // Support providing a sourceMappingURL via the SourceMap header
    var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                          xhr.getResponseHeader("X-SourceMap");
    if (sourceMapHeader) {
      return sourceMapHeader;
    }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var match = /\/\/[#@]\s*sourceMappingURL=(.*)\s*$/m.exec(fileData);
  if (!match) return null;
  return match[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
function retrieveSourceMap(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  var dataUrlPrefix = "data:application/json;base64,";
  if (sourceMappingURL.slice(0, dataUrlPrefix.length).toLowerCase() == dataUrlPrefix) {
    // Support source map URL as a data url
    sourceMapData = new Buffer(sourceMappingURL.slice(dataUrlPrefix.length), "base64").toString();
    sourceMappingURL = null;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL, 'utf8');
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
}

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap) {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame) {
  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var position = mapSourcePosition({
      source: source,
      line: frame.getLineNumber(),
      column: frame.getColumnNumber() - 1
    });
    frame = cloneCallSite(frame);
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }
  return error + stack.map(function(frame) {
    return '\n    at ' + wrapCallSite(frame);
  }).join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs.existsSync(source)) {
      contents = fs.readFileSync(source, 'utf8');
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return '\n' + source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

// Mimic node's stack trace printing when an exception escapes the process
function handleUncaughtExceptions(error) {
  if (!error || !error.stack) {
    console.log('Uncaught exception:', error);
  } else {
    var source = getErrorSource(error);
    if (source !== null) console.log(source);
    console.log(error.stack);
  }
  process.exit(1);
}

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  if (!alreadyInstalled) {
    alreadyInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;

    // Configure options
    options = options || {};
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;

    // Allow sources to be found by methods other than reading the files
    // directly from disk.
    if (options.retrieveFile)
      retrieveFile = options.retrieveFile;

    // Allow source maps to be found by methods other than reading the files
    // directly from disk.
    if (options.retrieveSourceMap)
      retrieveSourceMap = options.retrieveSourceMap;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && !isInBrowser()) {
      process.on('uncaughtException', handleUncaughtExceptions);
    }
  }
};

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":707,"buffer":699,"fs":697,"path":706,"source-map":560}],571:[function(require,module,exports){
arguments[4][432][0].apply(exports,arguments)
},{"./source-map/source-map-consumer":579,"./source-map/source-map-generator":580,"./source-map/source-node":581,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map.js":432}],572:[function(require,module,exports){
arguments[4][433][0].apply(exports,arguments)
},{"./util":582,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/array-set.js":433,"amdefine":583}],573:[function(require,module,exports){
arguments[4][434][0].apply(exports,arguments)
},{"./base64":574,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/base64-vlq.js":434,"amdefine":583}],574:[function(require,module,exports){
arguments[4][435][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/base64.js":435,"amdefine":583}],575:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

});

},{"./array-set":572,"./base64-vlq":573,"./binary-search":576,"./source-map-consumer":579,"./util":582,"amdefine":583}],576:[function(require,module,exports){
arguments[4][436][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/binary-search.js":436,"amdefine":583}],577:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;
  var BasicSourceMapConsumer = require('./basic-source-map-consumer').BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      };
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0)
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[i];

          var source = mapping.source;
          var sourceRoot = section.consumer.sourceRoot;

          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.column +
              (section.generatedOffset.generatedLine === mapping.generatedLine)
              ? section.generatedOffset.generatedColumn - 1
              : 0,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        };
      };

    this.__generatedMappings.sort(util.compareByGeneratedPositions);
    this.__originalMappings.sort(util.compareByOriginalPositions);
  };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

},{"./basic-source-map-consumer":575,"./binary-search":576,"./source-map-consumer":579,"./util":582,"amdefine":583}],578:[function(require,module,exports){
arguments[4][437][0].apply(exports,arguments)
},{"./util":582,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/mapping-list.js":437,"amdefine":583}],579:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    // We do late requires because the subclasses require() this file.
    if (sourceMap.sections != null) {
      var indexedSourceMapConsumer = require('./indexed-source-map-consumer');
      return new indexedSourceMapConsumer.IndexedSourceMapConsumer(sourceMap);
    } else {
      var basicSourceMapConsumer = require('./basic-source-map-consumer');
      return new basicSourceMapConsumer.BasicSourceMapConsumer(sourceMap);
    }
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    var basicSourceMapConsumer = require('./basic-source-map-consumer');
    return basicSourceMapConsumer.BasicSourceMapConsumer
            .fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;


  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./basic-source-map-consumer":575,"./indexed-source-map-consumer":577,"./util":582,"amdefine":583}],580:[function(require,module,exports){
arguments[4][439][0].apply(exports,arguments)
},{"./array-set":572,"./base64-vlq":573,"./mapping-list":578,"./util":582,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/source-map-generator.js":439,"amdefine":583}],581:[function(require,module,exports){
arguments[4][440][0].apply(exports,arguments)
},{"./source-map-generator":580,"./util":582,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/source-node.js":440,"amdefine":583}],582:[function(require,module,exports){
arguments[4][441][0].apply(exports,arguments)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/babel/node_modules/source-map/lib/source-map/util.js":441,"amdefine":583}],583:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/earlgrey/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"_process":707,"path":706}],584:[function(require,module,exports){
module.exports={
  "name": "earlgrey",
  "version": "0.0.13",
  "description": "Programming language compiling to JavaScript, featuring macros, dynamic typing annotations and pattern matching.",
  "main": "./6.js",
  "dependencies": {
    "babel": "^4.5.5",
    "del": "^1.2.0",
    "earlgrey-runtime": ">=0.0.10",
    "js-beautify": "1.5.x",
    "mkdirp": "^0.5.1",
    "multi-stage-sourcemap": "^0.2.1",
    "opg": ">=0.0.3",
    "source-map": "^0.2.0",
    "source-map-support": "^0.2.9"
  },
  "devDependencies": {
    "mocha": "^2.2.1",
    "earl-mocha": ">=0.0.2"
  },
  "bin": {
    "earl": "bin/earl",
    "earl5": "bin/earl5"
  },
  "scripts": {
    "prepublish": "bin/bootstrap 2 && bin/bootstrap -5 2",
    "test": "earl clean test && mocha"
  },
  "homepage": "http://breuleux.github.io/earl-grey/repl",
  "repository": {
    "type": "git",
    "url": "https://github.com/breuleux/earl-grey"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "keywords": [
    "earlgrey",
    "language",
    "macros",
    "pattern-matching"
  ],
  "author": "Olivier Breuleux",
  "license": "MIT"
}

},{}],585:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$30 = undefined;var CodeMirror$0 = undefined;CodeMirror$0 = require("codemirror");CodeMirror$0.defineMode("earlgrey", function (config$0, parserConfig$0) {
  var accum$0 = undefined;var accum$1 = undefined;var accum$2 = undefined;var accum$3 = undefined;var re$0 = undefined;re$0 = { id: RegExp("(?:^[a-zA-Z$_](?:(?:[a-zA-Z$_0-9]|(?:-[a-zA-Z$_0-9]))*))", ""), numr: RegExp("(?:^((?:\\d+))[rR]((?:[A-Za-z0-9_]+))(?:(?:\\.((?:[A-Za-z0-9_]+)))?))", ""), num: RegExp("(?:^((?:[0-9_]+))(?:(?:\\.((?:\\d+)))?)(?:(?:[eE]((?:[+-]?)(?:[0-9_]+)))?))", ""), lowprio: RegExp("(?:(?:(?:(?:(?:(?:(?:(?:=|=>)|->)|%)|:)|with)|where)|each)(?:(?: +)|$))", ""), lowprio1: RegExp("(?:(?:(?:(?:(?:=|=>)|->)|%)|:)(?:(?: +)|$))", ""), lowprio2: RegExp("(?:(?:(?:with|where)|each)(?:(?: +)|$))", ""), op: RegExp("(?:^(?:[+\\-*/~\\^<>=%&|?!@#.:]+))", ""), op2_open: RegExp("(?:^[\\(\\[\\{])", ""), comma: RegExp("(?:^,)", ""), op2_close: RegExp("(?:^[\\}\\]\\)])", ""), op3: RegExp("(?:^(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:with|where)|when)|and)|not)|or)|in)|mod)|each)|as)|of)|is)(?:(?:[+\\-*/~\\^<>=%&|?!@#.:]+)|\\b))", ""), op4: RegExp("(?:^`((?:[A-Za-z0-9_$]+))`)", "") };return __amp____colon__((accum$0 = {}, accum$0.startState = function startState() {
    return { mode: "code", previous: null, sol: true, nest: [["", 0, 0, false]] };
  }, accum$0), __amp____colon__((accum$1 = {}, accum$1.token = function token(stream$0, state$0) {
    var $targ$1 = undefined;var o$0 = undefined;var a$0 = undefined;var t0$0 = undefined;var m$0$0 = undefined;var $targ$0 = undefined;var index$0 = undefined;var $targ$2 = undefined;var m$3$0 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var $targ$15 = undefined;var $targ$16 = undefined;var $targ$17 = undefined;var $targ$18 = undefined;var $targ$19 = undefined;var $$105$0 = undefined;var $targ$20 = undefined;var ph$1$0 = undefined;var $targ$21 = undefined;var n$0 = undefined;var n$1 = undefined;var opchar$0 = undefined;var $targ$22 = undefined;var $targ$23 = undefined;var $targ$24 = undefined;var ph$0$0 = undefined;var d$0 = undefined;var $$112$0 = undefined;var m$2$0 = undefined;var sf$0 = undefined;var rx$0 = undefined;var $targ$25 = undefined;var $targ$26 = undefined;var m$4$0 = undefined;var m$1$0 = undefined;var spaces$0 = undefined;var result$0 = undefined;if (stream$0.sol()) {
      if (stream$0.match(RegExp("===$", ""))) {
        return "sep";
      } else {
        $targ$0 = true;state$0.sol = $targ$0;index$0 = state$0.nest.length - 1;m$0$0 = send(send(state$0, "nest", true), index$0);if (Array.isArray(m$0$0) && (t0$0 = m$0$0.length, t0$0 === 4)) {
          o$0 = m$0$0[0];a$0 = m$0$0[1];m$0$0[2];m$0$0[3];$targ$1 = [o$0, a$0, stream$0.indentation(), false];state$0.nest[index$0] = $targ$1;void 0;
        } else {
          undefined;
        }
      }
    } else {
      $targ$2 = false;state$0.sol = $targ$2;void 0;
    }spaces$0 = stream$0.eatSpace();m$1$0 = state$0.mode;if (m$1$0 === "code") {
      m$2$0 = stream$0.peek();d$0 = m$2$0;if (__in__(m$2$0, ["\"", "'", "`"])) {
        stream$0.next();$targ$3 = "string";state$0.mode = $targ$3;m$3$0 = d$0;if (m$3$0 === "\"") {
          $targ$4 = "string";
        } else {
          if (m$3$0 === "'") {
            $targ$4 = "interpolated";
          } else {
            if (m$3$0 === "`") {
              $targ$4 = "quote";
            } else {
              $targ$4 = ___match_error(m$3$0, "\"`\"");
            }
          }
        }state$0.strtype = $targ$4;$targ$5 = d$0;state$0.finisher = $targ$5;result$0 = state$0.strtype;
      } else {
        if (stream$0.match(RegExp(";;", ""))) {
          stream$0.skipToEnd();$targ$6 = "comment";state$0.previous = $targ$6;result$0 = "comment";
        } else {
          if (stream$0.match(RegExp("\\.[A-Za-z0-9_$\\\\-]+", ""))) {
            $targ$7 = "id";state$0.previous = $targ$7;result$0 = "string";
          } else {
            if (stream$0.match(RegExp("@[A-Za-z0-9$\\\\-]+", ""))) {
              $targ$8 = "id";state$0.previous = $targ$8;result$0 = "attribute";
            } else {
              if (stream$0.match(RegExp("#[A-Za-z0-9$\\\\-]+", ""))) {
                $targ$9 = "id";state$0.previous = $targ$9;result$0 = "tag";
              } else {
                if (stream$0.match(RegExp("pass|else|return|break|continue|match", ""))) {
                  $targ$10 = "id";state$0.previous = $targ$10;result$0 = "keyword";
                } else {
                  if (stream$0.match(RegExp("true|false|null|undefined|this", ""))) {
                    $targ$11 = "id";state$0.previous = $targ$11;result$0 = "special";
                  } else {
                    if (stream$0.match(re$0.lowprio1)) {
                      $targ$12 = "lowprio";state$0.previous = $targ$12;result$0 = "operator";
                    } else {
                      if (stream$0.match(re$0.lowprio2)) {
                        $targ$13 = "lowprio";state$0.previous = $targ$13;result$0 = "wordop";
                      } else {
                        if (stream$0.match(re$0.op) || stream$0.match(re$0.op4)) {
                          $targ$14 = "op";state$0.previous = $targ$14;result$0 = "operator";
                        } else {
                          if (stream$0.match(re$0.op3)) {
                            $targ$15 = "op";state$0.previous = $targ$15;result$0 = "wordop";
                          } else {
                            ph$0$0 = m$2$0;if (stream$0.match(re$0.id)) {
                              ph$1$0 = ph$0$0;if (getChecker(RegExp("lowprio|comma", ""))(state$0.previous) || state$0.sol) {
                                if (stream$0.match(RegExp(" +(with|where|when|and|not|or|in|mod|each|as|of|is)( |$)", ""), false)) {
                                  $targ$16 = "id";state$0.previous = $targ$16;result$0 = "variable";
                                } else {
                                  if (stream$0.match(RegExp(" *:| +[A-Za-z0-9$\\[\\{\\\"]", ""), false)) {
                                    $targ$17 = "id";state$0.previous = $targ$17;result$0 = "keyword";
                                  } else {
                                    if (stream$0.match(RegExp(" +[+\\-*/~^<>=%&|?!@#.:']+[A-Za-z0-9$\\[\\{]", ""), false)) {
                                      $targ$18 = "id";state$0.previous = $targ$18;result$0 = "keyword";
                                    } else {
                                      $targ$19 = "id";state$0.previous = $targ$19;result$0 = "variable";
                                    }
                                  }
                                }
                              } else {
                                $targ$20 = "id";state$0.previous = $targ$20;result$0 = "variable";
                              }
                            } else {
                              if (stream$0.match(re$0.numr) || stream$0.match(re$0.num)) {
                                $targ$21 = "id";state$0.previous = $targ$21;result$0 = "number";
                              } else {
                                if (stream$0.match(re$0.op2_open, false)) {
                                  opchar$0 = stream$0.match(re$0.op2_open)[0];$targ$22 = "lowprio";state$0.previous = $targ$22;state$0.nest.push(stream$0.eol() ? (n$0 = send(send(state$0, "nest", true), state$0.nest.length - 1)[2], [opchar$0, n$0, n$0 + config$0.indentUnit, true]) : (n$1 = stream$0.column(), [opchar$0, n$1, n$1 + 1, true]));result$0 = "open";
                                } else {
                                  if (stream$0.match(re$0.comma)) {
                                    $targ$23 = "comma";state$0.previous = $targ$23;result$0 = "punctuation";
                                  } else {
                                    if (stream$0.match(re$0.op2_close)) {
                                      $targ$24 = "punct";state$0.previous = $targ$24;if (state$0.nest.length > 1) {
                                        state$0.nest.pop();
                                      }result$0 = "close";
                                    } else {
                                      stream$0.next();result$0 = null;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if (m$1$0 === "string") {
        sf$0 = state$0.finisher;rx$0 = new RegExp("(\\\\" + sf$0 + "|[^" + sf$0 + "])+");stream$0.match(rx$0);m$4$0 = stream$0.eat(state$0.finisher);if (m$4$0 === void 0) {
          result$0 = state$0.strtype;
        } else {
          $targ$25 = "code";state$0.mode = $targ$25;$targ$26 = "id";state$0.previous = $targ$26;result$0 = state$0.strtype;
        }
      } else {
        result$0 = ___match_error(m$1$0, ".string");
      }
    }return result$0;
  }, accum$1), __amp____colon__((accum$2 = {}, accum$2.indent = function indent(state$1, line$0) {
    var index$1 = undefined;var t0$1 = undefined;var t1$0 = undefined;var m$5$0 = undefined;var $targ$27 = undefined;var outr$0 = undefined;var inner$0 = undefined;var first$0 = undefined;var add$0 = undefined;index$1 = state$1.nest.length - 1;$targ$27 = send(send(state$1, "nest", true), index$1);t0$1 = $targ$27;if (Array.isArray(t0$1) && (t1$0 = t0$1.length, t1$0 === 4)) {
      t0$1[0];outr$0 = t0$1[1];inner$0 = t0$1[2];first$0 = t0$1[3];
    } else {
      ___match_error($targ$27, "{_, outr, inner, first}");
    }[outr$0, inner$0, first$0];if (!first$0 && (equal(state$1.previous, "lowprio") || equal(state$1.previous, "op"))) {
      add$0 = config$0.indentUnit;
    } else {
      add$0 = 0;
    }m$5$0 = line$0;if (getChecker(RegExp("(?:^[\\]\\}])", ""))(m$5$0)) {
      return outr$0 + add$0;
    } else {
      return inner$0 + add$0;
    }
  }, accum$2), __amp____colon__((accum$3 = {}, accum$3.blankLine = function blankLine(state$2) {
    var $targ$29 = undefined;var o$1 = undefined;var a$1 = undefined;var t0$2 = undefined;var m$6$0 = undefined;var $targ$28 = undefined;var index$2 = undefined;$targ$28 = true;state$2.sol = $targ$28;index$2 = state$2.nest.length - 1;m$6$0 = send(send(state$2, "nest", true), index$2);if (Array.isArray(m$6$0) && (t0$2 = m$6$0.length, t0$2 === 4)) {
      o$1 = m$6$0[0];a$1 = m$6$0[1];m$6$0[2];m$6$0[3];$targ$29 = [o$1, a$1, 0, false];state$2.nest[index$2] = $targ$29;void 0;
    } else {
      undefined;
    }return null;
  }, accum$3), { lineComment: ";;", electricInput: RegExp("(?:^(?: *)[\\]\\}\\)]$)", "") }))));
});$targ$30 = CodeMirror$0;exports.CodeMirror = $targ$30;void 0;
//# sourceMappingURL=earlmode.js.map


},{"codemirror":590,"earlgrey-runtime/5":591}],586:[function(require,module,exports){
"use strict";

require("earlgrey-runtime/5");var $targ$6 = undefined;var accum$4 = undefined;var $targ$7 = undefined;var accum$5 = undefined;var $targ$8 = undefined;var earlmode$0 = undefined;var Editor$0 = undefined;earlmode$0 = require("./earlmode");Editor$0 = function Editor(opts$0) {
  var t0$0 = undefined;var t1$0 = undefined;var $targ$2 = undefined;var accum$0 = undefined;var $targ$3 = undefined;var accum$1 = undefined;var $targ$4 = undefined;var accum$2 = undefined;var $targ$5 = undefined;var accum$3 = undefined;var km$0 = undefined;var $targ$0 = undefined;var $targ$1 = undefined;var __at___$0 = undefined;if (!getChecker(Editor$0)(this)) {
    __at___$0 = Object.create(Editor$0.prototype);
  } else {
    __at___$0 = this;
  }$targ$0 = opts$0;t0$0 = $targ$0;if (___hasprop(t0$0, "elements") && (t1$0 = t0$0.elements, ___hasprop(t1$0, "editorarea") && (__at___$0.textarea = t1$0.editorarea, ___hasprop(t0$0, "eval") && (__at___$0.eval = t0$0.eval, ___hasprop(t0$0, "setenv") && (__at___$0.setenv = t0$0.setenv, __at___$0.prepare = ___hasprop(t0$0, "prepare") ? t0$0.prepare : function () {
    return undefined;
  }, ___hasprop(t0$0, "success") && (__at___$0.success = t0$0.success, ___hasprop(t0$0, "failure") && (__at___$0.failure = t0$0.failure, ___hasprop(t0$0, "lang") && (__at___$0.lang = t0$0.lang, __at___$0.theme = ___hasprop(t0$0, "theme") ? t0$0.theme : "default", __at___$0.live = ___hasprop(t0$0, "live") ? t0$0.live : false, __at___$0.keymap = ___hasprop(t0$0, "keymap") ? t0$0.keymap : {}, ___hasprop(t0$0, "codemirror"))))))))) {
    __at___$0.CodeMirror = t0$0.codemirror;
  } else {
    ___match_error($targ$0, "{\n         elements => {\n            editorarea => @textarea\n         }\n         eval => @eval\n         setenv => @setenv\n         prepare => @prepare = [-> pass]\n         success => @success\n         failure => @failure\n         lang => @lang\n         theme => @theme = .default\n         live => @live = false\n         keymap => @keymap = {=}\n         codemirror => @CodeMirror\n      }");
  }$targ$1 = __at___$0.CodeMirror.fromTextArea(__at___$0.textarea, { indentUnit: 3, viewportMargin: 1 / 0, theme: __at___$0.theme, lineNumbers: opts$0.lineNumbers });__at___$0.cm = $targ$1;km$0 = __amp____colon__(($targ$2 = function (cm$0) {
    return __at___$0.submit();
  }, accum$0 = {}, accum$0["Ctrl-Enter"] = $targ$2, accum$0), __amp____colon__({ Tab: "indentAuto" }, __amp____colon__(($targ$3 = "goLineStart", accum$1 = {}, accum$1["Ctrl-A"] = $targ$3, accum$1), __amp____colon__(($targ$4 = "goLineEnd", accum$2 = {}, accum$2["Ctrl-E"] = $targ$4, accum$2), ($targ$5 = "killLine", accum$3 = {}, accum$3["Ctrl-K"] = $targ$5, accum$3)))));__at___$0.cm.addKeyMap(__amp__(km$0, __at___$0.keymap));__at___$0.cm.setOption("mode", __at___$0.lang);__at___$0.cm.setSize("auto", "100%");__at___$0.cm.on("changes", function () {
    if (__at___$0.live) {
      return __at___$0.submit();
    }
  });return __at___$0;
};Editor$0.prototype.submit = function submit() {
  var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
    var e$0, v$0, $$8914$0, $$8915$0, $$8916$0, t0$1, m$0$0, text$0;
    return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          e$0 = undefined;
          v$0 = undefined;
          $$8914$0 = undefined;
          $$8915$0 = undefined;
          $$8916$0 = undefined;
          t0$1 = undefined;
          m$0$0 = undefined;
          text$0 = undefined;
          text$0 = __at___$1.cm.getValue();context$2$0.next = 11;
          return __at___$1.prepare();

        case 11:
          context$2$0.next = 13;
          return __at___$1.eval(text$0);

        case 13:
          m$0$0 = context$2$0.sent;

          if (!(($$8914$0 = Array.isArray(m$0$0)) && (t0$1 = m$0$0.length, ($$8916$0 = t0$1 === 2) && m$0$0[0] === "success"))) {
            context$2$0.next = 19;
            break;
          }

          v$0 = m$0$0[1];return context$2$0.abrupt("return", __at___$1.success(v$0));

        case 19:
          if (!($$8916$0 && m$0$0[0] === "failure")) {
            context$2$0.next = 24;
            break;
          }

          e$0 = m$0$0[1];return context$2$0.abrupt("return", __at___$1.failure(e$0));

        case 24:
          throw ErrorFactory(["editor", "bad_eval"]).create("eval must return #success{value} or #failure{error}");

        case 25:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  }));
};__amp____colon__(Editor$0, __amp____colon__(($targ$6 = "Editor", accum$4 = {}, accum$4["::name"] = $targ$6, accum$4), ($targ$7 = true, accum$5 = {}, accum$5["::egclass"] = $targ$7, accum$5)));$targ$8 = Editor$0;exports.Editor = $targ$8;void 0;
//# sourceMappingURL=editor.js.map

},{"./earlmode":585,"earlgrey-runtime/5":591}],587:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var m$0 = undefined;var acc$0 = undefined;var temp$0 = undefined;var $targ$0 = undefined;var $targ$1 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var repl$0 = undefined;var Repl$0 = undefined;var Outputter$0 = undefined;var editor$0 = undefined;var Editor$0 = undefined;var util$0 = undefined;var DOM$0 = undefined;var _repr$0 = undefined;var dir$0 = undefined;var dom$0 = undefined;var html$0 = undefined;var to__minus__cache$0 = undefined;repl$0 = require("./repl");Repl$0 = getProperty(repl$0, "Repl", "repl");Outputter$0 = getProperty(repl$0, "Outputter", "repl");editor$0 = require("./editor");Editor$0 = getProperty(editor$0, "Editor", "editor");util$0 = require("./util");DOM$0 = getProperty(util$0, "DOM", "util");_repr$0 = getProperty(util$0, "repr", "util");dir$0 = require("earlgrey-runtime/std/dir");dom$0 = require("earlgrey-runtime/std/dom");html$0 = require("earlgrey-runtime/std/html");to__minus__cache$0 = [["npm:earlgrey-runtime/5", {}], ["npm:earlgrey-runtime/6", {}], ["npm:earlgrey-runtime/lib", {}], ["npm:earlgrey-runtime@0.0.5/5", {}], ["npm:earlgrey-runtime@0.0.5/6", {}], ["npm:earlgrey-runtime@0.0.5/lib", {}], ["npm:earlgrey-runtime/std/dir", dir$0], ["npm:earlgrey-runtime/std/dom", dom$0], ["npm:earlgrey-runtime/std/html", html$0]];if (global.System) {
  __amp____colon__(global.System._loader.modules, object((acc$0 = [], temp$0 = null, m$0 = null, (function () {
    $0: for (var _iterator = to__minus__cache$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      m$0 = _step.value;
      var x$0 = undefined;var v$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$0;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
        x$0 = t0$0[0];v$0 = t0$0[1];temp$0 = [x$0, { name: x$0, module: v$0 }];acc$0.push(temp$0);
      } else {
        ___match_error(m$0);
      }
    }
  })(), acc$0)));
} else {
  $targ$0 = {};global.System = $targ$0;void 0;
}$targ$1 = Repl$0;exports.Repl = $targ$1;$targ$2 = Editor$0;exports.Editor = $targ$2;$targ$3 = DOM$0;exports.DOM = $targ$3;$targ$4 = _repr$0;exports.repr = $targ$4;$targ$5 = Outputter$0;exports.Outputter = $targ$5;void 0;
//# sourceMappingURL=index.js.map


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./editor":586,"./repl":588,"./util":589,"earlgrey-runtime/5":591,"earlgrey-runtime/std/dir":684,"earlgrey-runtime/std/dom":685,"earlgrey-runtime/std/html":686}],588:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$0 = undefined;var $targ$1 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var accum$0 = undefined;var $targ$5 = undefined;var accum$1 = undefined;var $targ$27 = undefined;var accum$14 = undefined;var $targ$28 = undefined;var accum$15 = undefined;var $targ$29 = undefined;var $targ$30 = undefined;var $targ$31 = undefined;var util$0 = undefined;var DOM$0 = undefined;var _repr$0 = undefined;var GenSym$0 = undefined;var wait$0 = undefined;var jQuery$0 = undefined;var repr$0 = undefined;var gensym__minus__r$0 = undefined;var gensym$0 = undefined;var Outputter$0 = undefined;var Repl$0 = undefined;util$0 = require("./util");DOM$0 = getProperty(util$0, "DOM", "util");_repr$0 = getProperty(util$0, "repr", "util");GenSym$0 = getProperty(util$0, "GenSym", "util");wait$0 = getProperty(util$0, "wait", "util");jQuery$0 = require("jquery");if (typeof document === "undefined") {
  $targ$0 = undefined;global.document = $targ$0;void 0;
}if (typeof alert === "undefined") {
  $targ$1 = undefined;global.alert = $targ$1;void 0;
}if (typeof setTimeout === "undefined") {
  $targ$2 = undefined;global.setTimeout = $targ$2;void 0;
}if (typeof Element === "undefined") {
  $targ$3 = undefined;global.Element = $targ$3;void 0;
}repr$0 = _repr$0;gensym__minus__r$0 = GenSym$0("$repple_");gensym$0 = GenSym$0("io_");Outputter$0 = function Outputter() {
  var t0$0 = undefined;var m$0$0 = undefined;var __at___$0 = undefined;if (!getChecker(Outputter$0)(this)) {
    __at___$0 = Object.create(Outputter$0.prototype);
  } else {
    __at___$0 = this;
  }m$0$0 = arguments;t0$0 = m$0$0.length;if (t0$0 >= 1 && t0$0 <= 2) {
    __at___$0.elem = m$0$0[0];__at___$0.sink = 1 >= t0$0 ? false : m$0$0[1];undefined;
  } else {
    ___match_error(m$0$0, "{@elem, @sink = false}");
  }return __at___$0;
};Outputter$0.prototype.log = function log() {
  var m$2 = undefined;var acc$0 = undefined;var temp$0 = undefined;var f$0 = undefined;var result$0 = undefined;var data$0 = undefined;var t0$1 = undefined;var m$1$0 = undefined;var __at___$1 = undefined;var self$0 = undefined;__at___$1 = this;self$0 = this;m$1$0 = arguments;t0$1 = m$1$0.length;if (t0$1 >= 0) {
    data$0 = Array.prototype.slice.call(m$1$0, 0);result$0 = DOM$0(ENode(["div"], {}, (acc$0 = [], temp$0 = null, m$2 = null, (function () {
      $0: for (var _iterator = data$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        m$2 = _step.value;
        var bridge$$17334$0 = undefined;var x$0 = undefined;var ph$0$0 = undefined;var t0$2 = undefined;t0$2 = m$2;x$0 = t0$2;ph$0$0 = t0$2;bridge$$17334$0 = ph$0$0;if (getChecker(Element)(bridge$$17334$0) || getChecker(ENode)(bridge$$17334$0)) {
          temp$0 = x$0;
        } else {
          temp$0 = ENode([".repple-data"], {}, repr$0(x$0));
        }acc$0.push(temp$0);
      }
    })(), acc$0)));__at___$1.elem.appendChild(result$0);if (__at___$1.sink) {
      f$0 = function f() {
        return jQuery$0(__at___$1.elem).scrollTop(__at___$1.elem.scrollHeight);
      };setTimeout(f$0, 0);
    }return result$0;
  } else {
    return ___match_error(m$1$0, "{*data}");
  }
};__amp____colon__(Outputter$0, __amp____colon__(($targ$4 = "Outputter", accum$0 = {}, accum$0["::name"] = $targ$4, accum$0), ($targ$5 = true, accum$1 = {}, accum$1["::egclass"] = $targ$5, accum$1)));Repl$0 = function Repl(opts$0) {
  var t0$3 = undefined;var t1$0 = undefined;var $targ$15 = undefined;var $targ$6 = undefined;var $targ$7 = undefined;var $targ$8 = undefined;var $targ$9 = undefined;var $targ$10 = undefined;var $targ$11 = undefined;var $targ$12 = undefined;var $targ$13 = undefined;var $targ$14 = undefined;var __at___$2 = undefined;if (!getChecker(Repl$0)(this)) {
    __at___$2 = Object.create(Repl$0.prototype);
  } else {
    __at___$2 = this;
  }$targ$6 = opts$0;__at___$2.opts = $targ$6;$targ$7 = opts$0;t0$3 = $targ$7;if (___hasprop(t0$3, "elements") && (t1$0 = t0$3.elements, ___hasprop(t1$0, "repl") && (__at___$2.box = t1$0.repl, ___hasprop(t1$0, "scrollback") && (__at___$2.target = t1$0.scrollback, ___hasprop(t1$0, "replarea") && (__at___$2.textarea = t1$0.replarea, ___hasprop(t0$3, "eval") && (__at___$2.eval = t0$3.eval, ___hasprop(t0$3, "setenv") && (__at___$2.setenv = t0$3.setenv, __at___$2.lang = ___hasprop(t0$3, "lang") ? t0$3.lang : "javascript", __at___$2.theme = ___hasprop(t0$3, "theme") ? t0$3.theme : "default", __at___$2.continuate = ___hasprop(t0$3, "continuate") ? t0$3.continuate : null, ___hasprop(t0$3, "codemirror")))))))) {
    __at___$2.CodeMirror = t0$3.codemirror;
  } else {
    ___match_error($targ$7, "{\n         elements => {\n            repl => @box\n            scrollback => @target\n            replarea => @textarea\n         }\n         eval => @eval\n         setenv => @setenv\n         lang => @lang = \"javascript\"\n         theme => @theme = \"default\"\n         continuate => @continuate = null\n         codemirror => @CodeMirror\n      }");
  }$targ$8 = __at___$2.CodeMirror.Pass;__at___$2.pass = $targ$8;if (!__at___$2.CodeMirror.runMode) {
    throw ErrorFactory(["repple", "runMode"]).create("Missing run mode for CodeMirror. Try to require('codemirror/addon/runmode/runmode')");
  }$targ$9 = { io: [], current: -1 };__at___$2.repple = $targ$9;$targ$10 = gensym__minus__r$0();__at___$2.reppleSymbol = $targ$10;__at___$2.setenv((function () {
    var $$18064 = {};$$18064[__at___$2.reppleSymbol] = __at___$2.repple;return $$18064;
  })());$targ$11 = opts$0.elements.inputline;__at___$2.inputline = $targ$11;$targ$12 = opts$0.elements.keymap || {};__at___$2.keymap = $targ$12;if (opts$0.sink) {
    $targ$15 = opts$0.sink;__at___$2.sink = $targ$15;void 0;
  }__at___$2.keymap = __at___$2.keymap || {};__at___$2.setup_cm(__at___$2.textarea);$targ$13 = 0;__at___$2.cursor = $targ$13;$targ$14 = [""];__at___$2.history = $targ$14;return __at___$2;
};Repl$0.prototype.setup_cm = function setup_cm(textarea$0) {
  var accum$2 = undefined;var $targ$17 = undefined;var accum$3 = undefined;var $targ$18 = undefined;var accum$4 = undefined;var $targ$19 = undefined;var accum$5 = undefined;var $targ$20 = undefined;var accum$6 = undefined;var accum$7 = undefined;var accum$8 = undefined;var $targ$21 = undefined;var accum$9 = undefined;var $targ$22 = undefined;var accum$10 = undefined;var $targ$23 = undefined;var accum$11 = undefined;var $targ$24 = undefined;var accum$12 = undefined;var km$0 = undefined;var $targ$16 = undefined;var __at___$3 = undefined;var self$1 = undefined;__at___$3 = this;self$1 = this;$targ$16 = __at___$3.CodeMirror.fromTextArea(textarea$0, { indentUnit: 3, viewportMargin: 1 / 0, theme: __at___$3.theme });__at___$3.cm = $targ$16;km$0 = __amp____colon__((accum$2 = {}, accum$2.Enter = function Enter(cm$0) {
    var s$0 = undefined;var bridge$$17511$0 = undefined;var bridge$$17513$0 = undefined;var ph$1$0 = undefined;var m$3$0 = undefined;m$3$0 = __at___$3.continuate;if (typeof m$3$0 === "function") {
      if (__at___$3.continuate(cm$0)) {
        __at___$3.sink();return __at___$3.pass;
      } else {
        return __at___$3.submit();
      }
    } else {
      if (m$3$0 === false) {
        __at___$3.sink();return __at___$3.pass;
      } else {
        ph$1$0 = m$3$0;if (cm$0.lineCount() === 1) {
          bridge$$17511$0 = ph$1$0;if (bridge$$17511$0 === null || bridge$$17511$0 === void 0) {
            return __at___$3.submit();
          } else {
            bridge$$17513$0 = ph$1$0;if (typeof bridge$$17513$0 === "string" && (s$0 = bridge$$17513$0, true) || getChecker(RegExp)(bridge$$17513$0) && (s$0 = bridge$$17513$0, true)) {
              if (cm$0.getLine(0).match(s$0)) {
                __at___$3.sink();return __at___$3.pass;
              } else {
                return __at___$3.submit();
              }
            } else {
              __at___$3.sink();return __at___$3.pass;
            }
          }
        } else {
          __at___$3.sink();return __at___$3.pass;
        }
      }
    }
  }, accum$2), __amp____colon__(($targ$17 = "newlineAndIndent", accum$3 = {}, accum$3["Shift-Enter"] = $targ$17, accum$3), __amp____colon__(($targ$18 = function (cm$1) {
    return __at___$3.submit();
  }, accum$4 = {}, accum$4["Ctrl-Enter"] = $targ$18, accum$4), __amp____colon__(($targ$19 = function (cm$2) {
    if (__at___$3.cursor > 0) {
      __at___$3.cm.setValue(send(send(__at___$3, "history", true), --__at___$3.cursor));__at___$3.cm.setCursor(__at___$3.cm.lineCount(), 0);return __at___$3.sink();
    }
  }, accum$5 = {}, accum$5["Ctrl-Up"] = $targ$19, accum$5), __amp____colon__(($targ$20 = function (cm$3) {
    if (__at___$3.cursor < __at___$3.history.length - 1) {
      __at___$3.cm.setValue(send(send(__at___$3, "history", true), ++__at___$3.cursor));__at___$3.cm.setCursor(0, __at___$3.cm.getLine(0).length);return __at___$3.sink();
    }
  }, accum$6 = {}, accum$6["Ctrl-Down"] = $targ$20, accum$6), __amp____colon__((accum$7 = {}, accum$7.Up = function Up(temp$1$0) {
    var t0$4 = undefined;var $$17590$0 = undefined;var cm$4 = undefined;var ph$2$0 = undefined;t0$4 = temp$1$0;cm$4 = t0$4;ph$2$0 = t0$4;if (__at___$3.cursor > 0 && __at___$3.cm.getCursor().line === 0) {
      __at___$3.cm.setValue(send(send(__at___$3, "history", true), --__at___$3.cursor));__at___$3.cm.setCursor(__at___$3.cm.lineCount(), 0);return __at___$3.sink();
    } else {
      return __at___$3.pass;
    }
  }, accum$7), __amp____colon__((accum$8 = {}, accum$8.Down = function Down(temp$2$0) {
    var t0$5 = undefined;var $$17614$0 = undefined;var cm$5 = undefined;var ph$3$0 = undefined;t0$5 = temp$2$0;cm$5 = t0$5;ph$3$0 = t0$5;if (__at___$3.cursor < __at___$3.history.length - 1 && __at___$3.cm.getCursor().line === __at___$3.cm.lineCount() - 1) {
      __at___$3.cm.setValue(send(send(__at___$3, "history", true), ++__at___$3.cursor));__at___$3.cm.setCursor(0, __at___$3.cm.getLine(0).length);return __at___$3.sink();
    } else {
      return __at___$3.pass;
    }
  }, accum$8), __amp____colon__({ Tab: "indentAuto" }, __amp____colon__(($targ$21 = function (temp$3$0) {
    return jQuery$0(__at___$3.target).empty();
  }, accum$9 = {}, accum$9["Ctrl-L"] = $targ$21, accum$9), __amp____colon__(($targ$22 = "goLineStart", accum$10 = {}, accum$10["Ctrl-A"] = $targ$22, accum$10), __amp____colon__(($targ$23 = "goLineEnd", accum$11 = {}, accum$11["Ctrl-E"] = $targ$23, accum$11), ($targ$24 = "killLine", accum$12 = {}, accum$12["Ctrl-K"] = $targ$24, accum$12))))))))))));__at___$3.cm.addKeyMap(__amp__(km$0, __at___$3.keymap));__at___$3.cm.setOption("mode", __at___$3.lang);return __at___$3.cm.setSize("auto", "auto");
};Repl$0.prototype.sink = function sink() {
  var f$1 = undefined;var __at___$4 = undefined;var self$2 = undefined;__at___$4 = this;self$2 = this;f$1 = function f() {
    return jQuery$0(__at___$4.box).scrollTop(__at___$4.box.scrollHeight);
  };setTimeout(f$1, 0);return setTimeout(f$1, 10);
};Repl$0.prototype.add_to_history = function add_to_history(text$0) {
  var $targ$26 = undefined;var hl$0 = undefined;var $targ$25 = undefined;var __at___$5 = undefined;var self$3 = undefined;__at___$5 = this;self$3 = this;hl$0 = __at___$5.history.length;if (text$0 !== "" && !(hl$0 > 1 && equal(send(send(__at___$5, "history", true), hl$0 - 2), text$0))) {
    $targ$26 = text$0;__at___$5.history[hl$0 - 1] = $targ$26;__at___$5.history.push("");
  }$targ$25 = __at___$5.history.length - 1;__at___$5.cursor = $targ$25;return void 0;
};Repl$0.prototype.submit = function submit() {
  var __at___$6 = undefined;var self$4 = undefined;__at___$6 = this;self$4 = this;return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
    var f$2, text$1, done$0, e$0;
    return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          f$2 = undefined;
          text$1 = undefined;
          done$0 = undefined;
          text$1 = __at___$6.cm.getValue();if (__at___$6.inputline) {
            jQuery$0(__at___$6.inputline).hide();
          }done$0 = false;context$2$0.prev = 6;
          context$2$0.next = 9;
          return Promise.race([(f$2 = function f() {
            return spawn.call(this, regeneratorRuntime.mark(function callee$3$0() {
              var res$0;
              return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    res$0 = undefined;
                    context$4$0.next = 3;
                    return __at___$6.process_all(text$1, true, true);

                  case 3:
                    res$0 = context$4$0.sent;
                    done$0 = true;return context$4$0.abrupt("return", res$0);

                  case 6:
                  case "end":
                    return context$4$0.stop();
                }
              }, callee$3$0, this);
            }));
          }, f$2()), wait$0(10000)]);

        case 9:
          context$2$0.next = 17;
          break;

        case 11:
          context$2$0.prev = 11;
          context$2$0.t10 = context$2$0["catch"](6);
          e$0 = undefined;
          e$0 = context$2$0.t10;done$0 = true;console.log(e$0.stack);

        case 17:
          if (!done$0) {
            send(send(send(__at___$6, "repple", true), "io", true), __at___$6.repple.current).log("Request is taking too much time... executing in the background...");
          }if (__at___$6.inputline) {
            jQuery$0(__at___$6.inputline).show();
          }__at___$6.cm.setValue("");return context$2$0.abrupt("return", __at___$6.cm.focus());

        case 21:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this, [[6, 11]]);
  }));
};Repl$0.prototype.highlight = function highlight() {
  var hl$1 = undefined;var text$2 = undefined;var inline$0 = undefined;var t0$6 = undefined;var m$4$0 = undefined;var __at___$7 = undefined;var self$5 = undefined;__at___$7 = this;self$5 = this;m$4$0 = arguments;t0$6 = m$4$0.length;if (t0$6 >= 1 && t0$6 <= 2) {
    text$2 = m$4$0[0];if (1 >= t0$6) {
      inline$0 = false;
    } else {
      inline$0 = m$4$0[1];
    }hl$1 = [];__at___$7.CodeMirror.runMode(text$2 || " ", __at___$7.lang, function (text$3, style$0) {
      return hl$1.push(style$0 ? ENode(["span", ".cm-" + style$0], {}, text$3) : ENode(["span"], {}, text$3));
    });if (inline$0) {
      return ENode(["span"], { "class": "CodeMirror cm-s-" + __at___$7.theme }, hl$1);
    } else {
      return ENode(["div"], { "class": "CodeMirror cm-s-" + __at___$7.theme }, hl$1);
    }
  } else {
    return ___match_error(m$4$0, "{text, inline = false}");
  }
};Repl$0.prototype.process_all = function process_all() {
  var text$4 = undefined;var display_in$0 = undefined;var sink$0 = undefined;var t0$7 = undefined;var m$5$0 = undefined;var __at___$8 = undefined;var self$6 = undefined;__at___$8 = this;self$6 = this;m$5$0 = arguments;t0$7 = m$5$0.length;if (t0$7 >= 1 && t0$7 <= 3) {
    text$4 = m$5$0[0];if (1 >= t0$7) {
      display_in$0 = true;
    } else {
      display_in$0 = m$5$0[1];
    }if (2 >= t0$7) {
      sink$0 = false;
    } else {
      sink$0 = m$5$0[2];
    }return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
      var m$6, acc$1, temp$4, _iterator, _step, part$0;

      return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            m$6 = undefined;
            acc$1 = undefined;
            temp$4 = undefined;
            acc$1 = [];temp$4 = null;m$6 = null;_iterator = text$4.split("\n===\n")[Symbol.iterator]();

          case 7:
            if ((_step = _iterator.next()).done) {
              context$2$0.next = 17;
              break;
            }

            m$6 = _step.value;
            part$0 = undefined;
            part$0 = m$6;context$2$0.next = 13;
            return __at___$8.process(part$0, display_in$0, sink$0);

          case 13:
            temp$4 = context$2$0.sent;
            acc$1.push(temp$4);

          case 15:
            context$2$0.next = 7;
            break;

          case 17:
            return context$2$0.abrupt("return", acc$1);

          case 18:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    }));
  } else {
    return ___match_error(m$5$0, "{text, display_in = true, sink = false}");
  }
};Repl$0.prototype.process = function process() {
  var text$5 = undefined;var display_in$1 = undefined;var sink$1 = undefined;var t0$8 = undefined;var m$7$0 = undefined;var __at___$9 = undefined;var self$7 = undefined;__at___$9 = this;self$7 = this;m$7$0 = arguments;t0$8 = m$7$0.length;if (t0$8 >= 1 && t0$8 <= 3) {
    text$5 = m$7$0[0];if (1 >= t0$8) {
      display_in$1 = true;
    } else {
      display_in$1 = m$7$0[1];
    }if (2 >= t0$8) {
      sink$1 = false;
    } else {
      sink$1 = m$7$0[2];
    }return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
      var f$3, accum$13, node$0, opts$1, obox$0, result$1;
      return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            f$3 = undefined;
            accum$13 = undefined;
            node$0 = undefined;
            opts$1 = undefined;
            obox$0 = undefined;
            result$1 = undefined;
            if (display_in$1) {
              __at___$9.add_to_history(text$5);__at___$9.target.appendChild(DOM$0(ENode(["div", ".repple-in"], {}, [ENode(["div", ".repple-inbanner"], {}, []), ENode(["div", ".repple-entry"], {}, __at___$9.highlight(text$5))])));if (sink$1) {
                __at___$9.sink();
              }
            }obox$0 = DOM$0(ENode(["div"], { id: gensym$0() }, []));__at___$9.repple.current = __at___$9.repple.current + 1;__at___$9.repple.io.push(Outputter$0(obox$0));__at___$9.target.appendChild(obox$0);context$2$0.next = 13;
            return __at___$9.eval(text$5);

          case 13:
            result$1 = context$2$0.sent;
            obox$0.appendChild((node$0 = (f$3 = function f(ph$4$0) {
              var rval$0 = undefined;var rval$1 = undefined;var error$0 = undefined;var value$0 = undefined;var n$0 = undefined;var $$17925$0 = undefined;var $$17926$0 = undefined;var $$17927$0 = undefined;var $$17928$0 = undefined;var t0$9 = undefined;var t1$1 = undefined;var t2$0 = undefined;if (text$5.trim() === "") {
                return "";
              } else {
                t0$9 = ph$4$0;t1$1 = t0$9.length;if (($$17927$0 = t1$1 === 2) && (($$17928$0 = t0$9[0] === "success") && t0$9[1] === void 0)) {
                  return "";
                } else {
                  if ($$17928$0 && (t2$0 = t0$9[1], getChecker(ENode)(t2$0))) {
                    n$0 = t2$0;return n$0;
                  } else {
                    if ($$17928$0) {
                      value$0 = t0$9[1];rval$0 = false;try {
                        rval$0 = ENode(["div", ".repple-out"], {}, [ENode(["div", ".repple-outbanner"], {}, []), ENode(["div", ".repple-result"], {}, ENode([".repple-data"], {}, repr$0(value$0)))]);rval$0;
                      } catch (excv$1) {
                        var e$1 = undefined;e$1 = excv$1;rval$0 = f$3(["failure", e$1]);rval$0;
                      }return rval$0;
                    } else {
                      if ($$17927$0 && t0$9[0] === "failure") {
                        error$0 = t0$9[1];console.error(error$0);return ENode(["div", ".repple-err"], {}, [ENode(["div", ".repple-errbanner"], {}, []), ENode(["div", ".repple-result"], {}, ENode([".repple-data"], {}, (rval$1 = false, (function () {
                          try {
                            rval$1 = repr$0(error$0);rval$1;
                          } catch (excv$2) {
                            var e$2 = undefined;e$2 = excv$2;console.error(e$2);rval$1 = "Failed to print error.";rval$1;
                          }
                        })(), rval$1)))]);
                      } else {
                        return ___match_error(ph$4$0, "#failure{error}");
                      }
                    }
                  }
                }
              }
            }, f$3(result$1)), opts$1 = (accum$13 = {}, accum$13.wrapchange = function wrapchange(f$4) {
              return spawn.call(this, regeneratorRuntime.mark(function callee$3$0() {
                var at_top$0;
                return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      at_top$0 = undefined;
                      at_top$0 = equal(__at___$9.box.scrollTop + jQuery$0(__at___$9.box).height(), __at___$9.box.scrollHeight);f$4();
                      if (!at_top$0) {
                        context$4$0.next = 5;
                        break;
                      }

                      return context$4$0.abrupt("return", jQuery$0(__at___$9.box).scrollTop(__at___$9.box.scrollHeight));

                    case 5:
                    case "end":
                      return context$4$0.stop();
                  }
                }, callee$3$0, this);
              }));
            }, accum$13), DOM$0(node$0, opts$1)));
            if (!sink$1) {
              context$2$0.next = 18;
              break;
            }

            __at___$9.sink();return context$2$0.abrupt("return", __at___$9.cm.focus());

          case 18:
          case "end":
            return context$2$0.stop();
        }
      }, callee$1$0, this);
    }));
  } else {
    return ___match_error(m$7$0, "{text, display_in = true, sink = false}");
  }
};__amp____colon__(Repl$0, __amp____colon__(($targ$27 = "Repl", accum$14 = {}, accum$14["::name"] = $targ$27, accum$14), ($targ$28 = true, accum$15 = {}, accum$15["::egclass"] = $targ$28, accum$15)));$targ$29 = Outputter$0;exports.Outputter = $targ$29;$targ$30 = Repl$0;exports.Repl = $targ$30;$targ$31 = repr$0;exports.repr = $targ$31;void 0;
//# sourceMappingURL=repl.js.map

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./util":589,"earlgrey-runtime/5":591,"jquery":688}],589:[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var $targ$2 = undefined;var $targ$3 = undefined;var $targ$4 = undefined;var $targ$5 = undefined;var m$0 = undefined;var acc$0 = undefined;var temp$0 = undefined;var tags$0 = undefined;var $targ$16 = undefined;var $targ$17 = undefined;var $targ$18 = undefined;var $targ$19 = undefined;var $targ$20 = undefined;var $targ$21 = undefined;var opg$0 = undefined;var Location$0 = undefined;var Source$0 = undefined;var $0$0 = undefined;var highlightLocations$0 = undefined;var fs$0 = undefined;var jquery$0 = undefined;var html$0 = undefined;var dom$0 = undefined;var toDOM$0 = undefined;var wait$0 = undefined;var tag_namespaces$0 = undefined;var wrapChildren$0 = undefined;var preWrappers$0 = undefined;var collapsible$0 = undefined;var postWrappers$0 = undefined;var wrapNode$0 = undefined;var DOM$0 = undefined;var wrapRepr$0 = undefined;var myrepr$0 = undefined;var dom_node_clear$0 = undefined;var format_error$0 = undefined;var $targ$0 = undefined;var GenSym$0 = undefined;opg$0 = require("opg");Location$0 = getProperty(opg$0, "Location", "opg");Source$0 = getProperty(opg$0, "Source", "opg");$0$0 = require("opg/lib/highlight");highlightLocations$0 = getProperty($0$0, "highlightLocations", "opg/lib/highlight");fs$0 = require("fs");jquery$0 = require("jquery");html$0 = require("earlgrey-runtime/std/html");dom$0 = require("earlgrey-runtime/std/dom");toDOM$0 = getProperty(dom$0, "toDOM", "dom");if (typeof document === "undefined") {
  $targ$1 = undefined;global.document = $targ$1;void 0;
}if (typeof window === "undefined") {
  $targ$2 = undefined;global.window = $targ$2;void 0;
}if (typeof alert === "undefined") {
  $targ$3 = undefined;global.alert = $targ$3;void 0;
}if (typeof setTimeout === "undefined") {
  $targ$4 = undefined;global.setTimeout = $targ$4;void 0;
}if (typeof Element === "undefined") {
  $targ$5 = undefined;global.Element = $targ$5;void 0;
}wait$0 = promisify(function (d$0, f$0) {
  return setTimeout.call(null, f$0, d$0);
});tag_namespaces$0 = {};tags$0 = ["svg", "circle", "line", "path", "rect", "text", "g"];acc$0 = [];temp$0 = null;m$0 = null;$1: for (var _iterator = tags$0[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
  m$0 = _step.value;
  var $targ$6 = undefined;var tag$0 = undefined;tag$0 = m$0;$targ$6 = "http://www.w3.org/2000/svg";tag_namespaces$0[tag$0] = $targ$6;temp$0 = void 0;acc$0.push(temp$0);
}wrapChildren$0 = function wrapChildren(tag$1, attrs$0, children$0) {
  var m$1 = undefined;var acc$1 = undefined;var temp$1 = undefined;acc$1 = [];temp$1 = null;m$1 = null;$2: for (var _iterator2 = children$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
    (function () {
      m$1 = _step2.value;
      var m$2 = undefined;var acc$2 = undefined;var temp$2 = undefined;var $targ$7 = undefined;var wrapper$0 = undefined;var c$0 = undefined;c$0 = m$1;wrapper$0 = document.createElement("span");wrapper$0.appendChild(c$0);if (c$0.className) {
        $targ$7 = (acc$2 = [], temp$2 = null, m$2 = null, (function () {
          $5: for (var _iterator3 = c$0.className.split(" ")[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
            m$2 = _step3.value;
            var x$0 = undefined;x$0 = m$2;temp$2 = String("container-" + x$0);acc$2.push(temp$2);
          }
        })(), acc$2).join(" ");wrapper$0.className = $targ$7;void 0;
      }temp$1 = wrapper$0;acc$1.push(temp$1);
    })();
  }children$0 = acc$1;return [tag$1, attrs$0, children$0];
};preWrappers$0 = { assoc: wrapChildren$0, array: wrapChildren$0 };collapsible$0 = function collapsible(collapsed$0) {
  return function (result$0, opts$0) {
    var $targ$8 = undefined;$targ$8 = function (e$0) {
      e$0.stopPropagation();return (opts$0.wrapchange || function (f$1) {
        return f$1();
      })(function () {
        return jquery$0(result$0).toggleClass("collapsed");
      });
    };result$0.onclick = $targ$8;if (collapsed$0) {
      result$0.className = result$0.className + " collapsed";
    }return result$0;
  };
};postWrappers$0 = { array: collapsible$0(false), object: collapsible$0(false), instance: collapsible$0(false), "class": collapsible$0(false), traceback: collapsible$0(true), error_args: collapsible$0(true) };wrapNode$0 = function wrapNode(c$1) {
  var m$3 = undefined;var acc$3 = undefined;var temp$3 = undefined;var $targ$9 = undefined;var wrapper$1 = undefined;wrapper$1 = document.createElement("span");wrapper$1.appendChild(c$1);if (c$1.className) {
    $targ$9 = (acc$3 = [], temp$3 = null, m$3 = null, (function () {
      $8: for (var _iterator2 = c$1.className.split(" ")[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$3 = _step2.value;
        var x$1 = undefined;x$1 = m$3;temp$3 = String("container-" + x$1);acc$3.push(temp$3);
      }
    })(), acc$3).join(" ");wrapper$1.className = $targ$9;void 0;
  }return wrapper$1;
};DOM$0 = function DOM() {
  var e$2 = undefined;var args$0 = undefined;var e$1 = undefined;var $$32512$0 = undefined;var t0$1 = undefined;var x$2 = undefined;var ph$1$0 = undefined;var opts$1 = undefined;var t0$0 = undefined;var t1$0 = undefined;var m$4$0 = undefined;m$4$0 = arguments;t0$0 = m$4$0.length;if (t0$0 >= 1 && t0$0 <= 2) {
    t1$0 = m$4$0[0];x$2 = t1$0;ph$1$0 = t1$0;if (1 >= t0$0) {
      opts$1 = {};
    } else {
      opts$1 = m$4$0[1];
    }t0$1 = ph$1$0;if (getChecker(Element)(t0$1)) {
      e$1 = t0$1;return e$1;
    } else {
      if (Array.isArray(t0$1)) {
        args$0 = t0$1;return DOM$0(ENode([], {}, args$0), opts$1);
      } else {
        if (getChecker(ENode)(t0$1)) {
          e$2 = t0$1;return html$0(e$2, function (temp$4$0, _classes$0, _attrs$0, _children$0, raw$0) {
            var t0$2 = undefined;var t0$3 = undefined;var t1$1 = undefined;var accum$0 = undefined;var elem$0 = undefined;var t0$4 = undefined;var expanded$0 = undefined;var fn$0 = undefined;var $targ$11 = undefined;var node$0 = undefined;var $get$0$0 = undefined;var m$5 = undefined;var ns$0 = undefined;var m$6 = undefined;var $targ$14 = undefined;var accum$1 = undefined;var $targ$15 = undefined;var accum$2 = undefined;var _theid$0 = undefined;var result$1 = undefined;var orig$0 = undefined;var $targ$10 = undefined;var tag$2 = undefined;var classes$0 = undefined;var attrs$1 = undefined;var children$1 = undefined;var _tag$0 = undefined;var ph$2$0 = undefined;t0$2 = temp$4$0;_tag$0 = t0$2;ph$2$0 = t0$2;orig$0 = this;$targ$10 = [_tag$0, _classes$0, _attrs$0, _children$0];t0$3 = $targ$10;if (Array.isArray(t0$3) && (t1$1 = t0$3.length, t1$1 === 4)) {
              tag$2 = t0$3[0];classes$0 = t0$3[1];attrs$1 = t0$3[2];children$1 = t0$3[3];
            } else {
              ___match_error($targ$10, "var {tag, classes, attrs, children}");
            }[tag$2, classes$0, attrs$1, children$1];if (ph$2$0 === "delayed") {
              expanded$0 = false;fn$0 = attrs$1.compute;elem$0 = ENode(["span", ".collapsed"], (accum$0 = {}, accum$0.onclick = function onclick(e$3) {
                var $targ$12 = undefined;e$3.stopPropagation();if (!expanded$0) {
                  delete node$0.onclick;expanded$0 = true;$targ$12 = "";node$0.className = $targ$12;return (opts$1.wrapchange || function (f$2) {
                    return f$2();
                  })(function () {
                    return node$0.appendChild(DOM$0(fn$0(), opts$1));
                  });
                }
              }, accum$0), []);$targ$11 = DOM$0(elem$0, opts$1);t0$4 = $targ$11;node$0 = t0$4;$get$0$0 = t0$4;[node$0, $get$0$0];return $get$0$0;
            } else {
              m$5 = null;$9: for (var _iterator2 = classes$0[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                m$5 = _step2.value;
                var t0$5 = undefined;var t1$2 = undefined;var $targ$13 = undefined;var c$2 = undefined;c$2 = m$5;if (send(preWrappers$0, c$2)) {
                  $targ$13 = send(preWrappers$0, c$2, true)(tag$2, attrs$1, children$1, orig$0, opts$1);t0$5 = $targ$13;if (Array.isArray(t0$5) && (t1$2 = t0$5.length, t1$2 === 3)) {
                    tag$2 = t0$5[0];attrs$1 = t0$5[1];children$1 = t0$5[2];
                  } else {
                    ___match_error($targ$13, "{tag, attrs, children}");
                  }[tag$2, attrs$1, children$1];
                } else {
                  false;
                }
              }if ((ns$0 = send(tag_namespaces$0, [true, String(tag$2)][1]), ns$0)) {
                attrs$1 = __amp__(attrs$1, { namespace: ns$0 });attrs$1;
              }result$1 = toDOM$0.call(orig$0, tag$2, classes$0, attrs$1, children$1, raw$0);m$6 = null;$10: for (var _iterator3 = classes$0[Symbol.iterator](), _step3; !(_step3 = _iterator3.next()).done;) {
                m$6 = _step3.value;
                var c$3 = undefined;c$3 = m$6;if (send(postWrappers$0, c$3)) {
                  result$1 = send(postWrappers$0, c$3, true)(result$1, opts$1);result$1;
                } else {
                  false;
                }
              }if (attrs$1 && attrs$1._refid) {
                return DOM$0(ENode([".tagged-node"], {}, [ENode([".reference"], {}, attrs$1._refid), result$1]));
              } else {
                if (attrs$1 && getChecker(ENode)(orig$0)) {
                  _theid$0 = undefined;Object.defineProperty(orig$0.props, "_refid", __amp____colon__({ configurable: true }, __amp____colon__(($targ$14 = function () {
                    return _theid$0;
                  }, accum$1 = {}, accum$1.get = $targ$14, accum$1), ($targ$15 = function (v$0) {
                    var wrapper$2 = undefined;_theid$0 = v$0;wrapper$2 = DOM$0(ENode([".tagged-node"], {}, ENode([".reference"], {}, _theid$0)));result$1.parentElement.replaceChild(wrapper$2, result$1);return wrapper$2.appendChild(result$1);
                  }, accum$2 = {}, accum$2.set = $targ$15, accum$2))));return result$1;
                } else {
                  return result$1;
                }
              }
            }
          });
        } else {
          return DOM$0(ENode([], {}, x$2), opts$1);
        }
      }
    }
  } else {
    return ___match_error(m$4$0, "{match x, opts = {=}}");
  }
};wrapRepr$0 = function wrapRepr(temp$5$0, process$0) {
  var t0$6 = undefined;var accum$3 = undefined;var astrepr$0 = undefined;var t0$7 = undefined;var x$3 = undefined;var ph$3$0 = undefined;t0$6 = temp$5$0;x$3 = t0$6;ph$3$0 = t0$6;if (!(x$3 && x$3["::lightweight"] && x$3["::lightweight"]()) && process$0.repr.depth >= 3) {
    return ENode(["delayed"], (accum$3 = {}, accum$3.compute = function compute() {
      return process$0.repr.withState({ depth: 0 })(x$3);
    }, accum$3), []);
  } else {
    t0$7 = ph$3$0;if (Array.isArray(t0$7) && (___hasprop(t0$7, "ast") && (t0$7.ast ? true : false))) {
      astrepr$0 = function astrepr(temp$6$0) {
        var t0$8 = undefined;var $$32775$0 = undefined;var m$7 = undefined;var acc$4 = undefined;var temp$7 = undefined;var kind$0 = undefined;var args$1 = undefined;var f$3 = undefined;var ph$5$0 = undefined;var arg$0 = undefined;var x$6 = undefined;var y$0 = undefined;var x$5 = undefined;var x$4 = undefined;var $$32778$0 = undefined;var $$32779$0 = undefined;var $$32780$0 = undefined;var t0$9 = undefined;var t1$3 = undefined;var t2$0 = undefined;var t3$0 = undefined;var t4$0 = undefined;var t5$0 = undefined;var node$1 = undefined;var ph$4$0 = undefined;t0$8 = temp$6$0;node$1 = t0$8;ph$4$0 = t0$8;t0$9 = ph$4$0;t1$3 = t0$9.length;if (t1$3 === 1 && t0$9[0] === "void") {
          return ENode([".ast", ".void"], {}, []);
        } else {
          if (($$32780$0 = t1$3 === 2) && t0$9[0] === "symbol") {
            x$4 = t0$9[1];return ENode([".ast", ".symbol"], {}, process$0.repr(x$4));
          } else {
            if ($$32780$0 && t0$9[0] === "value") {
              x$5 = t0$9[1];return ENode([".ast", ".value"], {}, process$0.repr(x$5));
            } else {
              if (t1$3 === 3 && (t0$9[0] === "send" && (t2$0 = t0$9[1], f$3 = t2$0, Array.isArray(t2$0) && (t3$0 = t2$0.length, t3$0 === 2 && (t2$0[0] === "symbol" && (ph$5$0 = t2$0[1], t4$0 = t0$9[2], arg$0 = t4$0, Array.isArray(t4$0) && (t5$0 = t4$0.length, t5$0 === 3 && t4$0[0] === "data"))))))) {
                x$6 = t4$0[1];y$0 = t4$0[2];if (ph$5$0 === "." && y$0[0] === "symbol") {
                  return ENode([".ast", ".value"], {}, process$0.repr(y$0[1]));
                } else {
                  if (node$1.fromop) {
                    return ENode([".ast", ".oper"], {}, [ENode([".ast", ".buffer"], {}, astrepr$0(x$6)), ENode([".ast", ".buffer"], {}, astrepr$0(f$3)), ENode([".ast", ".buffer"], {}, astrepr$0(y$0))]);
                  } else {
                    return ENode([".ast", ".send"], {}, [ENode([".ast", ".buffer"], {}, astrepr$0(f$3)), ENode([".ast", ".buffer"], {}, astrepr$0(arg$0))]);
                  }
                }
              } else {
                if (t1$3 >= 1 && (t2$0 = t0$9[0], __in__(t2$0, ["send", "data", "multi"]))) {
                  kind$0 = t2$0;args$1 = Array.prototype.slice.call(t0$9, 1);return ENode([".ast", "." + kind$0], {}, (acc$4 = [], temp$7 = null, m$7 = null, (function () {
                    $11: for (var _iterator2 = args$1[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
                      m$7 = _step2.value;
                      var arg$1 = undefined;arg$1 = m$7;temp$7 = ENode([".ast", ".buffer"], {}, astrepr$0(arg$1));acc$4.push(temp$7);
                    }
                  })(), acc$4));
                } else {
                  return process$0(node$1);
                }
              }
            }
          }
        }
      };return astrepr$0(x$3);
    } else {
      return process$0(x$3);
    }
  }
};myrepr$0 = function myrepr() {
  var r$0 = undefined;var result$2 = undefined;var x$7 = undefined;var wrap$0 = undefined;var t0$10 = undefined;var m$8$0 = undefined;m$8$0 = arguments;t0$10 = m$8$0.length;if (t0$10 >= 1 && t0$10 <= 2) {
    x$7 = m$8$0[0];if (1 >= t0$10) {
      wrap$0 = null;
    } else {
      wrap$0 = m$8$0[1];
    }r$0 = repr.create({ wrap: wrap$0 || wrapRepr$0 });result$2 = r$0(x$7);r$0.seen;return result$2;
  } else {
    return ___match_error(m$8$0, "{x, wrap = null}");
  }
};dom_node_clear$0 = function dom_node_clear(x$8) {
  $12: while (x$8.children.length > 0) {
    x$8.removeChild(x$8.children[0]);
  }
};format_error$0 = function format_error() {
  var rval$0 = undefined;var m$10 = undefined;var acc$5 = undefined;var temp$8 = undefined;var hls$0 = undefined;var locs$0 = undefined;var rval$1 = undefined;var loc$1 = undefined;var data$0 = undefined;var other$0 = undefined;var url$0 = undefined;var start$1 = undefined;var end$1 = undefined;var loc$0 = undefined;var source$0 = undefined;var start$0 = undefined;var end$0 = undefined;var args$2 = undefined;var fmt_args$0 = undefined;var stack$0 = undefined;var $$32944$0 = undefined;var $$32945$0 = undefined;var $$32946$0 = undefined;var t0$12 = undefined;var t1$5 = undefined;var t2$1 = undefined;var e$4 = undefined;var ph$7$0 = undefined;var context$0 = undefined;var t0$11 = undefined;var t1$4 = undefined;var m$9$0 = undefined;m$9$0 = arguments;t0$11 = m$9$0.length;if (t0$11 >= 1 && t0$11 <= 2) {
    t1$4 = m$9$0[0];e$4 = t1$4;ph$7$0 = t1$4;if (1 >= t0$11) {
      context$0 = 0;
    } else {
      context$0 = m$9$0[1];
    }fmt_args$0 = function fmt_args(e$5) {
      if (e$5.args && e$5.args.length) {
        return ENode([".error_args"], {}, repr(e$5.args));
      } else {
        return "";
      }
    };stack$0 = ENode(["div"], {}, (rval$0 = false, (function () {
      try {
        rval$0 = e$4.stack;rval$0;
      } catch (excv$0) {
        rval$0 = "Error getting traceback.";rval$0;
      }
    })(), rval$0) || "");t0$12 = ph$7$0;if (getChecker(ErrorFactory(["syntax"]))(t0$12) && (___hasprop(t0$12, "args") && (t1$5 = t0$12.args, Array.isArray(t1$5) && (t2$1 = t1$5.length, t2$1 === 1)))) {
      args$2 = t1$5[0];hls$0 = ["hl1", "hl2", "hl3", "hl4"];acc$5 = [];temp$8 = null;m$10 = null;$13: for (var _iterator2 = enumerate(items(args$2))[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
        m$10 = _step2.value;
        var i$0 = undefined;var key$0 = undefined;var arg$2 = undefined;var t0$13 = undefined;var t1$6 = undefined;var t2$2 = undefined;var t3$1 = undefined;t0$13 = m$10;if (Array.isArray(t0$13) && (t1$6 = t0$13.length, t1$6 === 2 && (i$0 = t0$13[0], t2$2 = t0$13[1], Array.isArray(t2$2) && (t3$1 = t2$2.length, t3$1 === 2 && (key$0 = t2$2[0], arg$2 = t2$2[1], arg$2 && arg$2.location))))) {
          temp$8 = [arg$2.location, send(hls$0, i$0 % 4)];acc$5.push(temp$8);
        } else {
          false;
        }
      }locs$0 = acc$5;return ENode(["div"], {}, [ENode(["div", ".error"], {}, [ENode(["div", ".error_type"], {}, e$4.name), ENode(["div", ".error_message"], {}, e$4.message)]), ENode(["div", ".error_args", ".syntax"], {}, repr(args$2)), highlightLocations$0(locs$0, context$0)]);
    } else {
      if (($$32945$0 = ___hasprop(t0$12, "location")) && (t1$5 = t0$12.location, loc$0 = t1$5, ___hasprop(t1$5, "source") && (source$0 = t1$5.source, ___hasprop(t1$5, "start") && (start$0 = t1$5.start, ___hasprop(t1$5, "end"))))) {
        end$0 = t1$5.end;return ENode(["div"], {}, [ENode(["div", ".error"], {}, [ENode(["div", ".error_type"], {}, e$4.name), ENode(["div", ".error_message"], {}, e$4.message)]), fmt_args$0(e$4), highlightLocations$0([[loc$0, "hl1"]], context$0), ENode(["div", ".traceback"], {}, stack$0)]);
      } else {
        if ($$32945$0 && (Array.isArray(t1$5) && (t2$1 = t1$5.length, t2$1 === 4 && t1$5[0] === "location"))) {
          url$0 = t1$5[1];start$1 = t1$5[2];end$1 = t1$5[3];rval$1 = false;try {
            rval$1 = fs$0.readFileSync(url$0, "utf8");rval$1;
          } catch (excv$1) {
            var e$6 = undefined;e$6 = excv$1;rval$1 = null;rval$1;
          }data$0 = rval$1;if (data$0) {
            loc$1 = Location$0(Source$0(data$0, url$0), start$1, end$1);return ENode(["div"], {}, [ENode(["div", ".error"], {}, [ENode(["div", ".error_type"], {}, e$4.name), ENode(["div", ".error_message"], {}, e$4.message)]), fmt_args$0(e$4), highlightLocations$0([[loc$1, "hl1"]], context$0), ENode(["div", ".traceback"], {}, stack$0)]);
          } else {
            return ENode(["div"], {}, [ENode(["div", ".error"], {}, [ENode(["div", ".error_type"], {}, e$4.name), ENode(["div", ".error_message"], {}, e$4.message)]), fmt_args$0(e$4), ENode(["div", ".traceback"], {}, stack$0)]);
          }
        } else {
          other$0 = ph$7$0;return ENode(["div"], {}, [ENode(["div", ".error"], {}, [ENode(["div", ".error_type"], {}, e$4.name), ENode(["div", ".error_message"], {}, e$4.message)]), fmt_args$0(e$4), ENode(["div", ".traceback"], {}, stack$0)]);
        }
      }
    }
  } else {
    return ___match_error(m$9$0, "{match e, context = 0}");
  }
};$targ$0 = function () {
  return format_error$0(this);
};Error.prototype["::repr"] = $targ$0;GenSym$0 = function GenSym(prefix$0) {
  var id$0 = undefined;id$0 = 0;return function () {
    var r$1 = undefined;var pfx$0 = undefined;var t0$14 = undefined;var m$11$0 = undefined;m$11$0 = arguments;t0$14 = m$11$0.length;if (t0$14 >= 0 && t0$14 <= 1) {
      if (0 >= t0$14) {
        pfx$0 = "";
      } else {
        pfx$0 = m$11$0[0];
      }r$1 = pfx$0 + prefix$0 + [true, String(id$0)][1];id$0++;return r$1;
    } else {
      return ___match_error(m$11$0, "{pfx = \"\"}");
    }
  };
};$targ$16 = DOM$0;exports.DOM = $targ$16;$targ$17 = dom_node_clear$0;exports.dom_node_clear = $targ$17;$targ$18 = myrepr$0;exports.repr = $targ$18;$targ$19 = GenSym$0;exports.GenSym = $targ$19;$targ$20 = format_error$0;exports.format_error = $targ$20;$targ$21 = wait$0;exports.wait = $targ$21;void 0;
//# sourceMappingURL=util.js.map

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"earlgrey-runtime/5":591,"earlgrey-runtime/std/dom":685,"earlgrey-runtime/std/html":686,"fs":697,"jquery":688,"opg":690,"opg/lib/highlight":689}],590:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedOverlay = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedOverlay && measure.clientHeight > 0) {
        if (sWidth == 0) this.overlayHack();
        this.checkedOverlay = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
    },
    overlayHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.minHeight = this.vert.style.minWidth = w;
      var self = this;
      var barMouseDown = function(e) {
        if (e_target(e) != self.vert && e_target(e) != self.horiz)
          operation(self.cm, onMouseDown)(e);
      };
      on(this.vert, "mousedown", barMouseDown);
      on(this.horiz, "mousedown", barMouseDown);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var force = update.force, viewport = update.viewport;
    for (var first = true;; first = false) {
      if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {
        force = true;
      } else {
        force = false;
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    var total = measure.docHeight + cm.display.barHeight;
    cm.display.heightForcer.style.top = total + "px";
    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                             "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // This will be set to an array of strings when copying, so that,
  // when pasting, we know what kind of selections the copied text
  // was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var textLines = splitLines(inserted), multiPaste = null;
    // When pasing N lines into N selections, insert one line per selection
    if (cm.state.pasteIncoming && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.join("\n") == inserted)
        multiPaste = sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
      else if (textLines.length == sel.ranges.length)
        multiPaste = map(textLines, function(l) { return [l]; });
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !cm.state.pasteIncoming) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        var end = changeEnd(changeEvent);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, end.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, end.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", "false");
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function() {
        // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
        // Add a char to the end of textarea before paste occur so that
        // selection doesn't span to the end of textarea.
        if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
          var start = te.selectionStart, end = te.selectionEnd;
          te.value += "$";
          // The selection end needs to be set before the start, otherwise there
          // can be an intermediate non-empty selection between the two, which
          // can override the middle-click paste buffer on linux and cause the
          // wrong thing to get pasted.
          te.selectionEnd = end;
          te.selectionStart = start;
          cm.state.fakedLastChar = true;
        }
        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.join("\n");
            selectInput(te);
          }
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (!cm.state.focused || (hasSelection(input) && !prevInput) ||
          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
        return false;
      // See paste handler for more on the fakedLastChar kludge
      if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
        input.value = input.value.substring(0, input.value.length - 1);
        cm.state.fakedLastChar = false;
      }
      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        if (text.charCodeAt(0) == 0x200b) {
          if (!prevInput) prevInput = "\u200b";
        } else if (prevInput == "\u200b") {
          text = text.slice(1);
          prevInput = "";
        }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText;
      input.wrapper.style.position = "absolute";
      te.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = te.value = "\u200b" + (selected ? te.value : "");
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.position = "relative";
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      div.contentEditable = "true";
      disableBrowserMagic(div);

      on(div, "paste", function(e) {
        var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
        if (pasted) {
          e.preventDefault();
          cm.replaceSelection(pasted, null, "paste");
        }
      });

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (!input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = ranges.text;
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        if (e.clipboardData && !ios) {
          e.preventDefault();
          e.clipboardData.clearData();
          e.clipboardData.setData("text/plain", lastCopied.join("\n"));
        } else {
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
          }, 50);
        }
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        sel.removeAllRanges();
        sel.addRange(rng);
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.view[toIndex].node;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.setAttribute("contenteditable", "false");
    },

    onKeyPress: function(e) {
      e.preventDefault();
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, "left");
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += after.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false;
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join("\n");
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += "\n";
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else if (ie && cm.options.lineWrapping) {
          var rects = range(node, start, end).getClientRects();
          if (rects.length)
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          else
            rect = nullRect;
        } else {
          rect = range(node, start, end).getBoundingClientRect() || nullRect;
        }
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i]();
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection();
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", bind(onFocus, cm));
    on(inp, "blur", bind(onBlur, cm));
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else ensureFocus(cm);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        !sel.ranges[contained].empty())
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) cm.display.input.reset();
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keyname;
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.1.0";

  return CodeMirror;
});

},{}],591:[function(require,module,exports){
module.exports=require(5)
},{"./lib":592,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/5.js":5,"core-js/shim":681,"regenerator/runtime":683}],592:[function(require,module,exports){
module.exports=require(6)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/lib.js":6,"kaiser/reg":682}],593:[function(require,module,exports){
module.exports=require(7)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.array-includes.js":7}],594:[function(require,module,exports){
module.exports=require(8)
},{"./$":614,"./$.ctx":602,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.array-methods.js":8}],595:[function(require,module,exports){
module.exports=require(9)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.assert.js":9}],596:[function(require,module,exports){
module.exports=require(10)
},{"./$":614,"./$.enum-keys":605,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.assign.js":10}],597:[function(require,module,exports){
module.exports=require(11)
},{"./$":614,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.cof.js":11}],598:[function(require,module,exports){
module.exports=require(12)
},{"./$":614,"./$.assert":595,"./$.ctx":602,"./$.for-of":606,"./$.iter":613,"./$.iter-define":611,"./$.mix":616,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-strong.js":12}],599:[function(require,module,exports){
module.exports=require(13)
},{"./$.def":603,"./$.for-of":606,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-to-json.js":13}],600:[function(require,module,exports){
module.exports=require(14)
},{"./$":614,"./$.array-methods":594,"./$.assert":595,"./$.for-of":606,"./$.mix":616,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection-weak.js":14}],601:[function(require,module,exports){
module.exports=require(15)
},{"./$":614,"./$.assert":595,"./$.cof":597,"./$.def":603,"./$.for-of":606,"./$.iter":613,"./$.iter-detect":612,"./$.mix":616,"./$.redef":619,"./$.species":624,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.collection.js":15}],602:[function(require,module,exports){
module.exports=require(16)
},{"./$.assert":595,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.ctx.js":16}],603:[function(require,module,exports){
module.exports=require(17)
},{"./$":614,"./$.redef":619,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.def.js":17}],604:[function(require,module,exports){
module.exports=require(18)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.dom-create.js":18}],605:[function(require,module,exports){
module.exports=require(19)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.enum-keys.js":19}],606:[function(require,module,exports){
module.exports=require(20)
},{"./$.ctx":602,"./$.iter":613,"./$.iter-call":610,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.for-of.js":20}],607:[function(require,module,exports){
module.exports=require(21)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.fw.js":21}],608:[function(require,module,exports){
module.exports=require(22)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.get-names.js":22}],609:[function(require,module,exports){
module.exports=require(23)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.invoke.js":23}],610:[function(require,module,exports){
module.exports=require(24)
},{"./$.assert":595,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-call.js":24}],611:[function(require,module,exports){
module.exports=require(25)
},{"./$":614,"./$.cof":597,"./$.def":603,"./$.iter":613,"./$.redef":619,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-define.js":25}],612:[function(require,module,exports){
module.exports=require(26)
},{"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter-detect.js":26}],613:[function(require,module,exports){
module.exports=require(27)
},{"./$":614,"./$.assert":595,"./$.cof":597,"./$.shared":623,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.iter.js":27}],614:[function(require,module,exports){
module.exports=require(28)
},{"./$.fw":607,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.js":28}],615:[function(require,module,exports){
module.exports=require(29)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.keyof.js":29}],616:[function(require,module,exports){
module.exports=require(30)
},{"./$.redef":619,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.mix.js":30}],617:[function(require,module,exports){
module.exports=require(31)
},{"./$":614,"./$.assert":595,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.own-keys.js":31}],618:[function(require,module,exports){
module.exports=require(32)
},{"./$":614,"./$.assert":595,"./$.invoke":609,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.partial.js":32}],619:[function(require,module,exports){
module.exports=require(33)
},{"./$":614,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.redef.js":33}],620:[function(require,module,exports){
module.exports=require(34)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.replacer.js":34}],621:[function(require,module,exports){
module.exports=require(35)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.same.js":35}],622:[function(require,module,exports){
module.exports=require(36)
},{"./$":614,"./$.assert":595,"./$.ctx":602,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.set-proto.js":36}],623:[function(require,module,exports){
module.exports=require(37)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.shared.js":37}],624:[function(require,module,exports){
module.exports=require(38)
},{"./$":614,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.species.js":38}],625:[function(require,module,exports){
module.exports=require(39)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-at.js":39}],626:[function(require,module,exports){
module.exports=require(40)
},{"./$":614,"./$.string-repeat":627,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-pad.js":40}],627:[function(require,module,exports){
module.exports=require(41)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.string-repeat.js":41}],628:[function(require,module,exports){
module.exports=require(42)
},{"./$":614,"./$.cof":597,"./$.ctx":602,"./$.dom-create":604,"./$.invoke":609,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.task.js":42}],629:[function(require,module,exports){
module.exports=require(43)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.throws.js":43}],630:[function(require,module,exports){
module.exports=require(44)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.uid.js":44}],631:[function(require,module,exports){
module.exports=require(45)
},{"./$":614,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.unscope.js":45}],632:[function(require,module,exports){
module.exports=require(46)
},{"./$":614,"./$.shared":623,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/$.wks.js":46}],633:[function(require,module,exports){
module.exports=require(47)
},{"./$":614,"./$.array-includes":593,"./$.array-methods":594,"./$.assert":595,"./$.cof":597,"./$.def":603,"./$.dom-create":604,"./$.invoke":609,"./$.replacer":620,"./$.throws":629,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es5.js":47}],634:[function(require,module,exports){
module.exports=require(48)
},{"./$":614,"./$.def":603,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.copy-within.js":48}],635:[function(require,module,exports){
module.exports=require(49)
},{"./$":614,"./$.def":603,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.fill.js":49}],636:[function(require,module,exports){
module.exports=require(50)
},{"./$.array-methods":594,"./$.def":603,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.find-index.js":50}],637:[function(require,module,exports){
module.exports=require(51)
},{"./$.array-methods":594,"./$.def":603,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.find.js":51}],638:[function(require,module,exports){
module.exports=require(52)
},{"./$":614,"./$.ctx":602,"./$.def":603,"./$.iter":613,"./$.iter-call":610,"./$.iter-detect":612,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.from.js":52}],639:[function(require,module,exports){
module.exports=require(53)
},{"./$":614,"./$.iter":613,"./$.iter-define":611,"./$.uid":630,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.iterator.js":53}],640:[function(require,module,exports){
module.exports=require(54)
},{"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.of.js":54}],641:[function(require,module,exports){
module.exports=require(55)
},{"./$.species":624,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.array.species.js":55}],642:[function(require,module,exports){
module.exports=require(56)
},{"./$":614,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.function.has-instance.js":56}],643:[function(require,module,exports){
module.exports=require(57)
},{"./$":614,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.function.name.js":57}],644:[function(require,module,exports){
module.exports=require(58)
},{"./$.collection":601,"./$.collection-strong":598,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.map.js":58}],645:[function(require,module,exports){
module.exports=require(59)
},{"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.math.js":59}],646:[function(require,module,exports){
module.exports=require(60)
},{"./$":614,"./$.redef":619,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.number.constructor.js":60}],647:[function(require,module,exports){
module.exports=require(61)
},{"./$":614,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.number.statics.js":61}],648:[function(require,module,exports){
module.exports=require(62)
},{"./$.assign":596,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.assign.js":62}],649:[function(require,module,exports){
module.exports=require(63)
},{"./$.def":603,"./$.same":621,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.is.js":63}],650:[function(require,module,exports){
module.exports=require(64)
},{"./$.def":603,"./$.set-proto":622,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.set-prototype-of.js":64}],651:[function(require,module,exports){
module.exports=require(65)
},{"./$":614,"./$.def":603,"./$.get-names":608,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.statics-accept-primitives.js":65}],652:[function(require,module,exports){
module.exports=require(66)
},{"./$":614,"./$.cof":597,"./$.redef":619,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.object.to-string.js":66}],653:[function(require,module,exports){
module.exports=require(67)
},{"./$":614,"./$.assert":595,"./$.cof":597,"./$.ctx":602,"./$.def":603,"./$.for-of":606,"./$.iter-detect":612,"./$.mix":616,"./$.same":621,"./$.set-proto":622,"./$.species":624,"./$.task":628,"./$.uid":630,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.promise.js":67}],654:[function(require,module,exports){
module.exports=require(68)
},{"./$":614,"./$.assert":595,"./$.def":603,"./$.iter":613,"./$.own-keys":617,"./$.set-proto":622,"./$.uid":630,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.reflect.js":68}],655:[function(require,module,exports){
module.exports=require(69)
},{"./$":614,"./$.cof":597,"./$.redef":619,"./$.replacer":620,"./$.species":624,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.regexp.js":69}],656:[function(require,module,exports){
module.exports=require(70)
},{"./$.collection":601,"./$.collection-strong":598,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.set.js":70}],657:[function(require,module,exports){
module.exports=require(71)
},{"./$.def":603,"./$.string-at":625,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.code-point-at.js":71}],658:[function(require,module,exports){
module.exports=require(72)
},{"./$":614,"./$.cof":597,"./$.def":603,"./$.throws":629,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.ends-with.js":72}],659:[function(require,module,exports){
module.exports=require(73)
},{"./$":614,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.from-code-point.js":73}],660:[function(require,module,exports){
module.exports=require(74)
},{"./$":614,"./$.cof":597,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.includes.js":74}],661:[function(require,module,exports){
module.exports=require(75)
},{"./$":614,"./$.iter":613,"./$.iter-define":611,"./$.string-at":625,"./$.uid":630,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.iterator.js":75}],662:[function(require,module,exports){
module.exports=require(76)
},{"./$":614,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.raw.js":76}],663:[function(require,module,exports){
module.exports=require(77)
},{"./$.def":603,"./$.string-repeat":627,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.repeat.js":77}],664:[function(require,module,exports){
module.exports=require(78)
},{"./$":614,"./$.cof":597,"./$.def":603,"./$.throws":629,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.string.starts-with.js":78}],665:[function(require,module,exports){
module.exports=require(79)
},{"./$":614,"./$.assert":595,"./$.cof":597,"./$.def":603,"./$.enum-keys":605,"./$.get-names":608,"./$.keyof":615,"./$.redef":619,"./$.shared":623,"./$.uid":630,"./$.wks":632,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.symbol.js":79}],666:[function(require,module,exports){
module.exports=require(80)
},{"./$":614,"./$.collection":601,"./$.collection-weak":600,"./$.redef":619,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.weak-map.js":80}],667:[function(require,module,exports){
module.exports=require(81)
},{"./$.collection":601,"./$.collection-weak":600,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es6.weak-set.js":81}],668:[function(require,module,exports){
module.exports=require(82)
},{"./$.array-includes":593,"./$.def":603,"./$.unscope":631,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.array.includes.js":82}],669:[function(require,module,exports){
module.exports=require(83)
},{"./$.collection-to-json":599,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.map.to-json.js":83}],670:[function(require,module,exports){
module.exports=require(84)
},{"./$":614,"./$.def":603,"./$.own-keys":617,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":84}],671:[function(require,module,exports){
module.exports=require(85)
},{"./$":614,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.object.to-array.js":85}],672:[function(require,module,exports){
module.exports=require(86)
},{"./$.def":603,"./$.replacer":620,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.regexp.escape.js":86}],673:[function(require,module,exports){
module.exports=require(87)
},{"./$.collection-to-json":599,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.set.to-json.js":87}],674:[function(require,module,exports){
module.exports=require(88)
},{"./$.def":603,"./$.string-at":625,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.at.js":88}],675:[function(require,module,exports){
module.exports=require(89)
},{"./$.def":603,"./$.string-pad":626,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.lpad.js":89}],676:[function(require,module,exports){
module.exports=require(90)
},{"./$.def":603,"./$.string-pad":626,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/es7.string.rpad.js":90}],677:[function(require,module,exports){
module.exports=require(91)
},{"./$":614,"./$.ctx":602,"./$.def":603,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/js.array.statics.js":91}],678:[function(require,module,exports){
module.exports=require(92)
},{"./$":614,"./$.iter":613,"./$.wks":632,"./es6.array.iterator":639,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.dom.iterable.js":92}],679:[function(require,module,exports){
module.exports=require(93)
},{"./$.def":603,"./$.task":628,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.immediate.js":93}],680:[function(require,module,exports){
module.exports=require(94)
},{"./$":614,"./$.def":603,"./$.invoke":609,"./$.partial":618,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/modules/web.timers.js":94}],681:[function(require,module,exports){
module.exports=require(95)
},{"./modules/$":614,"./modules/es5":633,"./modules/es6.array.copy-within":634,"./modules/es6.array.fill":635,"./modules/es6.array.find":637,"./modules/es6.array.find-index":636,"./modules/es6.array.from":638,"./modules/es6.array.iterator":639,"./modules/es6.array.of":640,"./modules/es6.array.species":641,"./modules/es6.function.has-instance":642,"./modules/es6.function.name":643,"./modules/es6.map":644,"./modules/es6.math":645,"./modules/es6.number.constructor":646,"./modules/es6.number.statics":647,"./modules/es6.object.assign":648,"./modules/es6.object.is":649,"./modules/es6.object.set-prototype-of":650,"./modules/es6.object.statics-accept-primitives":651,"./modules/es6.object.to-string":652,"./modules/es6.promise":653,"./modules/es6.reflect":654,"./modules/es6.regexp":655,"./modules/es6.set":656,"./modules/es6.string.code-point-at":657,"./modules/es6.string.ends-with":658,"./modules/es6.string.from-code-point":659,"./modules/es6.string.includes":660,"./modules/es6.string.iterator":661,"./modules/es6.string.raw":662,"./modules/es6.string.repeat":663,"./modules/es6.string.starts-with":664,"./modules/es6.symbol":665,"./modules/es6.weak-map":666,"./modules/es6.weak-set":667,"./modules/es7.array.includes":668,"./modules/es7.map.to-json":669,"./modules/es7.object.get-own-property-descriptors":670,"./modules/es7.object.to-array":671,"./modules/es7.regexp.escape":672,"./modules/es7.set.to-json":673,"./modules/es7.string.at":674,"./modules/es7.string.lpad":675,"./modules/es7.string.rpad":676,"./modules/js.array.statics":677,"./modules/web.dom.iterable":678,"./modules/web.immediate":679,"./modules/web.timers":680,"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/core-js/shim.js":95}],682:[function(require,module,exports){
module.exports=require(96)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/kaiser/reg.js":96}],683:[function(require,module,exports){
module.exports=require(97)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/regenerator/runtime.js":97,"_process":707}],684:[function(require,module,exports){

function dir(arg) {
    function helper(arg) {
        if (typeof(arg) === "number")
            return helper(Number.prototype);
        else if (typeof(arg) === "string")
            return helper(String.prototype);
        else if (arg === true || arg === false)
            return helper(Boolean.prototype);
        else {
            var curr = arg;
            var results = [];
            while (curr && (arg === Object || curr !== Object)) {
                var props = Object.getOwnPropertyNames(curr);
                for (var i = 0; i < props.length; i++) {
                    var k = props[i];
                    if (!k.match(/^toString|^__|^::/)) {
                        try {
                            results.push([k, arg[k]]);
                        }
                        catch (e) {
                            results.push([k, e]);
                        }
                    }
                }
                curr = Object.getPrototypeOf(curr);
            }
            return object(results.sort());
        }
    }
    return helper(arg);
}

module.exports = dir;

},{}],685:[function(require,module,exports){
(function (__filename){

var _util = require("../util");
var convertHTML = _util.convertHTML;
var normalize = _util.normalize;


function toDOM(tag, classes, attrs, children, raw) {

    if (tag === null) {
        if (children instanceof Element)
            return children;
        else
            return document.createTextNode(String(children));
    }
    
    if (tag == "top") tag = "";

    if (!tag && (equal(classes, []) && equal(attrs, {}))) {
        if (children.length == 1)
            return children[0];
        else {
            var node = document.createElement("div");
            children.forEach(function (x) {
                node.appendChild(x);
            });
            return node;
        }
    }

    tag = tag || "div";

    if (attrs.namespace)
        var node = document.createElementNS(attrs.namespace, tag);
    else
        var node = document.createElement(tag);

    if (attrs.id)
        node.id = attrs.id;

    if (classes.length > 0)
        node.className = classes.join(" ");

    if (raw) {
        node.innerHTML = raw;
    }

    items(attrs).forEach(function (kv) {
        if (kv[0].startsWith("on"))
            node[kv[0]] = kv[1];
        else
            node.setAttribute(kv[0], kv[1]);
    });

    children.forEach(function (c) {
        node.appendChild(c);
    });

    return node;
}


function DOM(enode, converter) {
    if (!converter)
        converter = toDOM;
    var res = convertHTML(enode, converter);
    if (Array.isArray(res))
        res = converter("top", [], {}, res, null);
    return res;
}

function DOMNode(tags, props, children) {
    if (!Array.isArray(children))
        children = [children];
    return toDOM.apply(null, normalize(tags, props, children));
}

function percentMacro(expr) {
    var DOMNode = this.deps.DOMNode;
    return ["multi",
            ["send", ["symbol", "="],
             ["data",
              ["send", ["symbol", "let"], ["symbol", "ENode"]],
              DOMNode]],
            ["send",
             ["symbol", "%"],
             ["data", expr[1], expr[2]]]]
}
percentMacro.__deps = {DOMNode: "ENode"};
percentMacro.__path = __filename;

module.exports = DOM;
DOM.DOM = DOM;
DOM.toDOM = toDOM;
DOM.ENode = DOMNode;
DOM["%"] = percentMacro;
DOM.normalize = normalize;

}).call(this,"/node_modules/repple/node_modules/earlgrey-runtime/std/dom.js")
},{"../util":687}],686:[function(require,module,exports){
(function (__filename){

var _util = require("../util");
var convertHTML = _util.convertHTML;
var normalize = _util.normalize;

function escapeHTML(s) {
    var repl = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
    }
    return s.replace(/[&<>]/g, function (x) { return repl[x]; });
}

function quotify(s) {
    return '"' + s.replace(/["\\]/g, function (x) { return "\\" + x; }) + '"';
}

var voidTags = [
    "area", "base", "br", "col", "command", "embed", "hr",
    "img", "input", "keygen", "link", "meta", "param", "source",
    "track", "wbr"
]

function toHTML(tag, classes, attrs, children, raw) {
    if (tag === null)
        return escapeHTML(String(children));

    var result = "";

    if (tag == "top") tag = "";

    if (!equal(classes, [])) {
        attrs["class"] = classes.join(" ");
    }
    if (!tag && (!equal(classes, []) || !equal(attrs, {}))) {
        tag = "div";
    }

    if (tag) result += "<" + tag;
    items(attrs).forEach(function (kv) {
        if (kv[1] === true) {
            result += " " + kv[0];
        }
        else if (kv[1] !== false) {
            result += " " + kv[0] + "=" + quotify(String(kv[1]));
        }
    });
    if (tag) result += ">";

    var closeTag = tag && voidTags.indexOf(tag) == -1;

    if (raw !== null) {
        result += raw;
        closeTag = !!tag;
    }
    else if (children.length > 0) {
        children.forEach(function (c) {
            result += c;
        });
        closeTag = !!tag;
    }

    if (closeTag)
        result += "</" + tag + ">"

    return result;
}

function HTML(enode, converter) {
    if (!converter)
        converter = toHTML;
    var res = convertHTML(enode, converter);
    if (Array.isArray(res))
        res = converter("top", [], {}, res, null);
    return res;
}

function HTMLNode(tags, props, children) {
    if (!Array.isArray(children))
        children = [children];
    return toHTML.apply(null, normalize(tags, props, children));
}

function percentMacro(expr) {
    var HTMLNode = this.deps.HTMLNode;
    return ["multi",
            ["send", ["symbol", "="],
             ["data",
              ["send", ["symbol", "let"], ["symbol", "ENode"]],
              HTMLNode]],
            ["send",
             ["symbol", "%"],
             ["data", expr[1], expr[2]]]]
}
percentMacro.__deps = {HTMLNode: "ENode"};
percentMacro.__path = __filename;

module.exports = HTML;
HTML.HTML = HTML;
HTML.toHTML = toHTML;
HTML.ENode = HTMLNode;
HTML["%"] = percentMacro;
HTML.normalize = normalize;

}).call(this,"/node_modules/repple/node_modules/earlgrey-runtime/std/html.js")
},{"../util":687}],687:[function(require,module,exports){
module.exports=require(100)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/util.js":100}],688:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],689:[function(require,module,exports){
module.exports=require(552)
},{"./util":694,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/highlight.js":552}],690:[function(require,module,exports){
module.exports=require(553)
},{"./location.js":691,"./parse.js":692,"./tokenize.js":693,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/index.js":553}],691:[function(require,module,exports){
module.exports=require(554)
},{"../package":696,"./highlight":689,"./util":694,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/location.js":554,"fs":697,"kaiser/reg":695}],692:[function(require,module,exports){
module.exports=require(555)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/parse.js":555}],693:[function(require,module,exports){
module.exports=require(556)
},{"./location":691,"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/tokenize.js":556}],694:[function(require,module,exports){
module.exports=require(557)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/lib/util.js":557}],695:[function(require,module,exports){
module.exports=require(96)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey-runtime/node_modules/kaiser/reg.js":96}],696:[function(require,module,exports){
module.exports=require(559)
},{"/home/olivier/eg/quaint-repple/node_modules/earlgrey/node_modules/opg/package.json":559}],697:[function(require,module,exports){

},{}],698:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":723}],699:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":700,"ieee754":701,"is-array":702}],700:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],701:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],702:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],703:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],704:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],705:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],706:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":707}],707:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],708:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":709}],709:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":711,"./_stream_writable":713,"_process":707,"core-util-is":714,"inherits":704}],710:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":712,"core-util-is":714,"inherits":704}],711:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"_process":707,"buffer":699,"core-util-is":714,"events":703,"inherits":704,"isarray":705,"stream":719,"string_decoder/":720}],712:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":709,"core-util-is":714,"inherits":704}],713:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":709,"_process":707,"buffer":699,"core-util-is":714,"inherits":704,"stream":719}],714:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":699}],715:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":710}],716:[function(require,module,exports){
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":709,"./lib/_stream_passthrough.js":710,"./lib/_stream_readable.js":711,"./lib/_stream_transform.js":712,"./lib/_stream_writable.js":713,"stream":719}],717:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":712}],718:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":713}],719:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":703,"inherits":704,"readable-stream/duplex.js":708,"readable-stream/passthrough.js":715,"readable-stream/readable.js":716,"readable-stream/transform.js":717,"readable-stream/writable.js":718}],720:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":699}],721:[function(require,module,exports){
exports.isatty = function () { return false; };

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.WriteStream = WriteStream;

},{}],722:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],723:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":722,"_process":707,"inherits":704}],724:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":725}],725:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"quaint-repple-earlgrey":[function(require,module,exports){
(function (global){
"use strict";

require("earlgrey-runtime/5");var $targ$1 = undefined;var eg$0 = undefined;var $1$0 = undefined;var topscope$0 = undefined;var earlmode$0 = undefined;var common$0 = undefined;var fade__minus__in$0 = undefined;var Into$0 = undefined;var Cards$0 = undefined;var make__minus__eval$0 = undefined;var stdrepl$0 = undefined;var stdeditor$0 = undefined;var stdsetup$0 = undefined;var setup$0 = undefined;eg$0 = require("earlgrey/5");$1$0 = require("earlgrey/lib5/expand");topscope$0 = getProperty($1$0, "topscope", "earlgrey/lib5/expand");earlmode$0 = require("./earlmode");common$0 = require("./common");fade__minus__in$0 = getProperty(common$0, "fadeIn", "common");Into$0 = getProperty(common$0, "Into", "common");Cards$0 = getProperty(common$0, "Cards", "common");make__minus__eval$0 = getProperty(common$0, "makeEval", "common");stdrepl$0 = getProperty(common$0, "stdrepl", "common");stdeditor$0 = getProperty(common$0, "stdeditor", "common");stdsetup$0 = getProperty(common$0, "stdsetup", "common");setup$0 = function setup(config$0) {
  return spawn.call(this, regeneratorRuntime.mark(function callee$1$0() {
    var accum$0, globvar$0, gene$0, _ev$0, glob$0, evaluate$0, setenv$0;

    return regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          accum$0 = undefined;
          globvar$0 = undefined;
          gene$0 = undefined;
          _ev$0 = undefined;
          glob$0 = undefined;
          evaluate$0 = undefined;
          setenv$0 = undefined;
          globvar$0 = "$eg$global";gene$0 = eg$0.Generator({ interactive: true, globvar: globvar$0, es5: true, runtime: "earlgrey-runtime" });_ev$0 = eg$0.evaluator({ globvar: globvar$0, global: global, filename: "<repl>", showname: "<repl>", cwd: "<repl>" });glob$0 = global;evaluate$0 = function evaluate(text$0) {
            return spawn.call(this, regeneratorRuntime.mark(function callee$3$0() {
              var code$0;
              return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    code$0 = undefined;
                    code$0 = gene$0.generateInteractive(eg$0.Source(text$0, "<repl>"));return context$4$0.abrupt("return", _ev$0(code$0));

                  case 3:
                  case "end":
                    return context$4$0.stop();
                }
              }, callee$3$0, this);
            }));
          };setenv$0 = function setenv(values$0) {
            var m$0 = undefined;m$0 = null;$2: for (var _iterator = items(values$0)[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
              m$0 = _step.value;
              var $targ$0 = undefined;var name$0 = undefined;var value$0 = undefined;var t0$0 = undefined;var t1$0 = undefined;t0$0 = m$0;if (Array.isArray(t0$0) && (t1$0 = t0$0.length, t1$0 === 2)) {
                name$0 = t0$0[0];value$0 = t0$0[1];gene$0.env.bind(topscope$0, name$0, ["variable", name$0]);$targ$0 = value$0;glob$0[name$0] = $targ$0;void 0;
              } else {
                ___match_error(m$0);
              }
            }return undefined;
          };return context$2$0.abrupt("return", stdsetup$0(__amp__(config$0, __amp____colon__({ evaluate: evaluate$0, setenv: setenv$0 }, __amp____colon__((accum$0 = {}, accum$0.continuate = function continuate(temp$0$0) {
            var t0$1 = undefined;var $$22593$0 = undefined;var m$1$0 = undefined;var state$0 = undefined;var e$0 = undefined;var $$22567$0 = undefined;var cm$0 = undefined;var ph$0$0 = undefined;t0$1 = temp$0$0;cm$0 = t0$1;ph$0$0 = t0$1;e$0 = cm$0.lineCount() - 1;if (cm$0.getCursor().line < e$0) {
              return true;
            } else {
              state$0 = cm$0.getStateAfter(e$0);m$1$0 = null;if (state$0.mode !== "code" || state$0.nest.length > 1 || getChecker(RegExp("lowprio|op", ""))(state$0.previous) || state$0.nest[0][2] > 0 && !getChecker(RegExp("^\\s*$", ""))(cm$0.getLine(e$0))) {
                return true;
              } else {
                return false;
              }
            }
          }, accum$0), { lang: "earlgrey", theme: config$0.theme })))));

        case 14:
        case "end":
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  }));
};$targ$1 = setup$0;exports.setup = $targ$1;void 0;
//# sourceMappingURL=earlgrey.js.map

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./common":1,"./earlmode":2,"earlgrey-runtime/5":5,"earlgrey/5":101,"earlgrey/lib5/expand":104}]},{},[]);
