
provide:
   GenSym, gensym, uuid
   identity
   ;; items, keys, enumerate
   binsearch
   classify, classify_contiguous
   neighbours
   ;; zip
   partition
   construct
   mkset
   make_object
   product

GenSym{prefix} =
   id = 0
   {pfx = null} ->
      r = [pfx or ""] + prefix + [String! id]
      id++
      r

;; gensym = GenSym{"È£"}
gensym = GenSym{"$"}

uuid{} =
   gensym{"#"}


identity{x} = x


;; items{obj} =
;;    results = {}
;;    for [k in obj]:
;;       if Object.prototype.hasOwnProperty.call{obj, k}:
;;          results.push with {k, obj[k]}
;;    results

;; keys{obj} =
;;    results = {}
;;    for [k in obj]:
;;       if Object.prototype.hasOwnProperty.call{obj, k}:
;;          results.push with k
;;    results

;; enumerate{arr} =
;;    results = {}
;;    l = arr.length
;;    for [i = 0, i < l, i++]:
;;       results.push with {i, arr[i]}
;;    results

binsearch{xs, x} =
   var lo = 0
   var hi = xs.length - 1
   while [lo <= hi]:
      mid = lo + [[hi - lo] >> 1]
      v = xs[mid]
      match xs[mid]:
         [< x] ->
            set lo = mid + 1
         [> x] ->
            set hi = mid - 1
         [_] ->
            return [mid + 1]
   lo

__classify{var xs} =
   results = {=}
   while xs.length:
      match xs.shift{}:
         #splice{newxs} ->
            set xs = newxs ++ xs
         {cls, x} ->
            if [not results[cls]]:
               results[cls] = {}
            results[cls].push with x
   results

classify{*classes, var xs} =
   results = {rest = {}}
   classes each cls ->
      results[cls] = {}
   while xs.length:
      match xs.shift{}:
         #splice{*newxs} ->
            set xs = newxs ++ xs
         #ignore ->
            null
         {cls, x} when results[cls] ->
            results[cls].push with x
         other ->
            results.rest.push with other
   results

classify_contiguous{xs, classifier} =
   groups = {}
   var currcls = null
   var curr = null
   xs each x ->
      cls = classifier{x}
      if [cls === currcls]:
         then: curr.push with x
         else:
            if curr:
               groups.push with curr
            set curr = {cls, x}
            set currcls = cls
   if curr:
      groups.push with curr
   groups


neighbours{match} =
   {} -> {}
   {x} -> {}
   {x, y, *rest} ->
      {{x, y}} ++ neighbours{{y} ++ rest}


;; zip{xs, ys} =
;;    enumerate{xs} each {i, x} ->
;;       {x, ys[i]}


partition{xs, predicate} =
   t = {}
   f = {}
   xs each
      x when predicate{x} -> t.push{x}
      x -> f.push{x}
   {t, f}


construct{match, fn, zero} =
   {} -> zero
   {x} -> x
   {x, *rest} ->
      fn{x, construct{rest, fn, zero}}


mkset{xs} =
   rval = {=}
   xs each x ->
      rval[x] = true
   rval

make_object{pairs} =
   rval = {=}
   pairs each {k, v} ->
      rval[k] = v
   rval

product{a, b} =
   results = {}
   a each x ->
      results ++=
         b each y -> {x, y}
   results
