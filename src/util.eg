
provide:
   GenSym, gensym, uuid
   identity
   items, keys, enumerate
   binsearch
   classify, classify_contiguous
   neighbours
   zip
   partition
   construct
   set

GenSym{prefix} =
   id = 0
   {pfx = null} ->
      r = [pfx or ""] + prefix + [String! id]
      id++
      r

;; gensym = GenSym{"È£"}
gensym = GenSym{"$"}

uuid{} =
   gensym{"#"}


identity{x} = x


items{obj} =
   results = {}
   for [k in obj]:
      if Object.prototype.hasOwnProperty.call{obj, k}:
         results.push with {k, obj[k]}
   results

keys{obj} =
   results = {}
   for [k in obj]:
      if Object.prototype.hasOwnProperty.call{obj, k}:
         results.push with k
   results

enumerate{arr} =
   results = {}
   l = arr.length
   for [i = 0, i < l, i++]:
      results.push with {i, arr[i]}
   results

binsearch{xs, x} =
   lo = 0
   hi = xs.length - 1
   while [lo <= hi]:
      mid = lo + [[hi - lo] >> 1]
      v = xs[mid]
      match xs[mid]:
         [< x] ->
            lo := mid + 1
         [> x] ->
            hi := mid - 1
         [_] ->
            return [mid + 1]
   lo

__classify{xs} =
   results = {=}
   while xs.length:
      match xs.shift{}:
         #splice{newxs} ->
            xs := newxs ++ xs
         {cls, x} ->
            if [not results[cls]]:
               results[cls] := {}
            results[cls].push with x
   results

classify{*classes, xs} =
   results = {rest = {}}
   classes each cls ->
      results[cls] := {}
   while xs.length:
      match xs.shift{}:
         #splice{*newxs} ->
            xs := newxs ++ xs
         #ignore ->
            null
         {cls, x} when results[cls] ->
            results[cls].push with x
         other ->
            results.rest.push with other
   results

classify_contiguous{xs, classifier} =
   groups = {}
   currcls = null
   curr = null
   xs each x ->
      cls = classifier{x}
      if [cls == currcls]:
         then: curr.push with x
         else:
            if curr:
               groups.push with curr
            curr := {cls, x}
            currcls := cls
   if curr:
      groups.push with curr
   groups


neighbours{match} =
   {} -> {}
   {x} -> {}
   {x, y, *rest} ->
      {{x, y}} ++ neighbours{{y} ++ rest}


zip{xs, ys} =
   enumerate{xs} each {i, x} ->
      {x, ys[i]}


partition{xs, predicate} =
   t = {}
   f = {}
   xs each
      x when predicate{x} -> t.push{x}
      x -> f.push{x}
   {t, f}


construct{match, fn, zero} =
   {} -> zero
   {x} -> x
   {x, *rest} ->
      fn{x, construct{rest, fn, zero}}


set{xs} =
   rval = {=}
   xs each x ->
      rval[x] := true
   rval

