
require:
   "./earl-grey" as eg
   fs, path, vm


usage = "
usage:

earl translate <file> [outfile]
  Translate a source file, output to outfile. Without outfile
  specified, print to standard out.

earl translate <directory> <outdir>
  Translate all the .eg files in the specified directory.

earl run [file] [arguments...]
  Run the specified file as a script.
"

walk{dir, partial, f} =
   stats = fs.statSync{dir}
   if stats.isDirectory{}:
      then:
         f{.dir, partial}
         fs.readdirSync{dir} each file ->
            walk{newdir, newpartial, f} where
               newdir = path.join{dir, file}
               newpartial = path.join{partial, file}
      else:
         f{.file, partial}

copy{src, dest} =
   data = fs.readFileSync{src, .binary}
   fs.writeFileSync{dest, data, .binary}


libdata = fs.readFileSync{path.join{__dirname, "lib.raw.js"}}

run{match} =

   {.quack, src, dest} ->
      walk{src, "/"} with {*match} ->
         {.dir, d} ->
            from = path.join{src, d}
            to = path.join{dest, d}
            fs.mkdirSync{to} !! "ignore error"
         {.file, f} ->
            from = path.join{src, f}
            to = path.join{dest, f}
            copy{from, to}

   {} or {.i or "in" or .interactive} ->
      require: repl
      vm.runInThisContext{libdata, "stdin"}
      settings = {
         prompt = "<> "
         ignoreUndefined = true
         eval{input, context, filename, callback} =
            text = eg.generate{input.slice{1, -1}}
            result = vm.runInThisContext{text, "stdin"} !!
               e -> console.log{e.stack}
            callback{null, result}
      }
      run = repl.start with settings
      run.on{.exit} with {} -> run.outputStream.write{"\n"}

   {.run, file} ->
      data = fs.readFileSync{file, .utf8}
      code = eg.generate{data, libdata}
      ;; vm.runInThisContext{code, file}
      eval{code}

   {.tr or .translate, file, *args} ->

      out = args[0]

      stats = fs.statSync{file}

      ? | stats.isDirectory{} =>
           walk{file, "/"} with {*match} ->
              {.dir, d} ->
                 from = path.join{file, d}
                 to = path.join{out, d}
                 fs.mkdirSync{to} !! "ignore error"
              {.file, match} ->
                 R'[start, {*any}, ".eg", end]! {x, name} ->
                    from = path.join{file, x}
                    to = path.join{out, name + ".js"}
                    data = fs.readFileSync{from, .utf8}
                    fs.writeFileSync{to} with
                       [eg.generate{data, ...} + "\n"] with
                          if{R'[".raw.eg", end]? x, "", libdata}
                 f ->
                    from = path.join{file, f}
                    to = path.join{out, f}
                    copy{from, to}

        | out =>
           data = fs.readFileSync{file, .utf8}
           fs.writeFileSync{out} with
              eg.generate{data, libdata} + "\n"

        | else =>
           data = fs.readFileSync{file, .utf8}
           console.log with eg.generate{data, ""} ;; libdata}


   {.tok, s} ->
      eg.tokenize{eg.Source{s, null}} each token ->
         <> token
         <> token.location.ref{}
         <> token.location.highlight{}

   {.pa, s} ->
      walkloc{node and match} =
         ~symbol{x} ->
            <> node
            <> node.location and node.location.highlight{}
         ~value{x} ->
            <> node
            <> node.location and node.location.highlight{}
         {type, *args} ->
            <> node
            <> node.location and node.location.highlight{}
            args each arg -> walkloc{arg}

      walkloc with
         eg.parse{eg.Source{s, null}}

   {.runs, data} ->
      code = eg.generate{data, libdata}
      ;; vm.runInThisContext{code, file}
      eval{code}

   other ->
      console.log with usage


exports.run := run

