
require:
   "./earl-grey" as eg
   "./pp" ->
      <>
   "./location" ->
      Source
      display_error
   fs, path, vm, module

provide:
   run


usage = "
usage:

earl run [options] [file] [arguments...]
  Run the specified file as a script. The arguments are available in
  process.argv.slice{2} of the script.
  Options:
    -e <code>    Run the provided code instead of reading from a file.
    -p           Print the result of the evaluation to standard out.
    -i           Start an interactive interpreter after execution
                 in the global environment of the script.

earl translate <file> [outfile]
  Translate a source file, output to outfile. Without outfile
  specified, print to standard out.

earl translate <directory> <outdir>
  Translate all the .eg files in the specified directory.
"

usage_error{message} =
   console.error{message}
   console.error{usage}
   process.exit{1}


extract_options{clone! argv, opttable, optmessage} =
   results = {=}
   var associate = null

   process_option{original, opt, last} =
      match opttable[opt]:
         undefined? ->
            ;; throw E.option{"Unrecognized option: " + original, original}
            usage_error{"Unrecognized " + optmessage + ": " + original}
         #flag{name} ->
            results[name] = true
         #value{name} when last ->
            associate = name
         #value{name} ->
            results[name] = true

   while argv.length:
      arg = argv.shift{}
      match arg:
         R"^--([a-zA-Z_\\-]+)=(.*)"! {_, opt, value} ->
            process_option{arg, opt, true}
            results[associate] = value
            associate = null

         R"^--([a-zA-Z_\\-]+)"! {_, opt} ->
            process_option{arg, opt, true}

         R"^-([a-zA-Z_]+)"! {_, opts} ->
            opts each
               last ch ->
                  process_option{arg, ch, true}
               ch ->
                  process_option{arg, ch}

         other when associate ->
            results[associate] = other
            associate = null

         other ->
            argv.unshift{other}
            break

   {results, argv}





walk{dir, partial, f} =
   stats = fs.statSync{dir}
   if stats.isDirectory{}:
      then:
         f{.dir, partial}
         fs.readdirSync{dir} each file ->
            walk{newdir, newpartial, f} where
               newdir = path.join{dir, file}
               newpartial = path.join{partial, file}
      else:
         f{.file, partial}

copy{src, dest} =
   data = fs.readFileSync{src, .binary}
   fs.writeFileSync{dest, data, .binary}


gen{text, file} =
   g = eg.Generator{}
   g.generate{Source{text, path.resolve{file}}}


evaluator{options} =

   paths = module._nodeModulePaths{options.cwd}

   e_module = new module{options.showname}
   e_module &: {
      filename = options.filename
      paths = paths
   }

   e_require{path} =
      module._load{path, e_module, true}
   e_require &: {
      main = e_module
      resolve{path} =
         module._resolveFileName{path, e_module}
      paths = paths
      cache = require.cache
   }

   global &: {
      __filename = options.filename
      __dirname = path.dirname{options.filename}
      module = e_module
      require = e_require
   }

   {code} ->
      script = vm.createScript{code, options.showname}
      script.runInThisContext{}


interactive{g, e} =
   require: repl
   g.interactive = true
   settings = {
      prompt = "<> "
      ignoreUndefined = true
      eval{input, context, filename, callback} =
         result = [execute{} !! e -> handle{e}] where
            execute{} =
               text = g.generate{Source{input.slice{1, -1}, "<interactive>"}}
               e{text}
            handle{e} =
               display_error{e}
               undefined
         callback{null, result}
   }
   runner = repl.start with settings
   runner.on{.exit} with {} -> runner.outputStream.write{"\n"}


run{argv} =
   {opts, cmd} =
      extract_options{argv, {=}, "global option"}
   _run{cmd, opts} !!
      e ->
         display_error{e}
         process.exit{1}


_run{match, opts} =

   {} or {.run} ->
      _run{{.run, "-i"}, opts}

   {.run, *rawargs} ->

      {o, rest} = extract_options{rawargs, ..., "option for run"} with {
         e = #value{.evaluate}
         eval = #value{.evaluate}

         p = #flag{.print}
         print = #flag{.print}

         i = #flag{.interactive}
         interactive = #flag{.interactive}
      }

      {file, wd, data, args} =
         if o.evaluate:
            then:
               {"<repl>", process.cwd{}, o.evaluate, rest}
            else:
               match rest.shift{}:
                  undefined? when o.interactive ->
                     {"<repl>", process.cwd{}, "", rest}
                  undefined? ->
                     usage_error{"No filename specified."}
                  path.resolve! file ->
                     {file, file, data, rest} where
                        data = fs.readFileSync{file, .utf8}

      e = evaluator with {
         filename = file
         showname = file
         cwd = file
      }

      g = eg.Generator{o.interactive}
      result = e with g.generate{Source{data, file}}
      if o.print:
         console.log with result
      if o.interactive:
         interactive{g, e}


   {.tr or .translate, file, *args} ->

      out = args[0]

      stats = fs.statSync{file}

      match:
         when stats.isDirectory{} ->
            walk{file, "/"} with {*match} ->
               {.dir, d} ->
                  from = path.join{file, d}
                  to = path.join{out, d}
                  fs.mkdirSync{to} !! e -> "ignore error"
               {.file, match} ->
                  R'[start, {*any}, ".eg", end]! results when results ->
                     {x, name} = results
                     from = path.join{file, x}
                     to = path.join{out, name + ".js"}
                     data = fs.readFileSync{from, .utf8}
                     fs.writeFileSync{to} with
                        gen{data, from} + "\n"
                  f ->
                     from = path.join{file, f}
                     to = path.join{out, f}
                     copy{from, to}

         when out ->
            data = fs.readFileSync{file, .utf8}
            fs.writeFileSync{out} with
               gen{data, file} + "\n"

         otherwise ->
            require: "js-beautify" -> js as beaut
            data = fs.readFileSync{file, .utf8}
            console.log with beaut{gen{data, file}}


   {.tok, s} ->
      eg.tokenize{Source{s, null}} each token ->
         <> token
         <> token.location.ref{}
         <> token.location.highlight{}

   {.pa, s} ->
      walkloc{match node} =
         #symbol{x} ->
            <> node
            <> node.location and node.location.highlight{}
         #value{x} ->
            <> node
            <> node.location and node.location.highlight{}
         {type, *args} ->
            <> node
            <> node.location and node.location.highlight{}
            args each arg -> walkloc{arg}

      walkloc with
         eg.parse{tokens} where
            tokens = eg.tokenize{Source{s, null}}

   ;; {.test, file} ->
   ;;    require: "js-beautify" -> js as beaut
   ;;    data = fs.readFileSync{file, .utf8}
   ;;    code = eg.generate2{Source{data, "<test>"}}
   ;;    ;; console.log with beaut{code}
   ;;    ;; console.log with eval{code}
   ;;    <> eval{code}

   ;; {.inspect, file} ->
   ;;    require: "js-beautify" -> js as beaut
   ;;    data = fs.readFileSync{file, .utf8}
   ;;    code = eg.generate2{Source{data, "<test>"}}
   ;;    console.log with beaut{code}

   ;; {.tests, s} ->
   ;;    require: "js-beautify" -> js as beaut
   ;;    code = eg.generate2{Source{s, "<test>"}}
   ;;    console.log with beaut{code}
   ;;    console.log with eval{code}
   ;;    <> eval{code}

   {.runs, data} ->
      code = gen{data, "<command>"}
      ;; console.log with code
      ;; console.log with eval{code}
      <> eval{code}

   {.trs, data} ->
      code = gen{data, "<command>"}
      ;; console.log with code
      ;; console.log with eval{code}
      <> code

   other ->
      console.error with usage

