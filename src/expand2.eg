
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" ->
      classify, items, enumerate, neighbours

provide:
   Env, nullenv, stdenv
   Scope, topscope
   track_location
   expand, step, step_all
   GenSym, gensym
   bind_ast


GenSym{prefix} =
   id = 0
   {pfx = null} ->
      r = #variable{[pfx or prefix] + [String! id]}
      id++
      r

gensym = GenSym{"___t"}

uuid{} =
   #variable{s} = gensym{}
   s


class Scope:

   constructor{parent = null} =
      #variable{name} = gensym{"scope"}
      @name := name
      @parent := parent
      @options := {=}

   getopt{opt} =
      match:
         when opt in @options ->
            @options[opt]
         when @parent == null ->
            undefined
         otherwise ->
            @parent.getopt{opt}

   setopt{opt, value} =
      @options[opt] := value

   toString{} =
      "Scope{" + @name + "}"


class Env:

   constructor{} =
      @scopes := {=}

   resolve{scope, name} =
      if [scope == null]:
         return undefined
      scope_data = @scopes[scope.name]
      if [scope_data and scope_data[name]]:
         then: scope_data[name]
         else: @resolve{scope.parent, name}

   bind{scope, name, value} =
      if [not @scopes[scope.name]]:
         @scopes[scope.name] := {=}
      @scopes[scope.name][name] := value

   fork{} =
      e = Env{}
      items{@scopes} each {scope, bindings} ->
         items{bindings} each {k, v} ->
            if [not e.scopes[scope]]:
               e.scopes[scope] := {=}
            e.scopes[scope][k] := v
      e

   toString{} =
      "Env{...}"


nullenv = Env{}


bind_ast{expr and match, env} =
   {env => e} ->
      expr
   #symbol or #value or #variable or #macro or #void ->
      expr &: {env = env}
   {type, *args} ->
      args each arg -> bind_ast{arg, env}
      expr &: {env = env}
   other ->
      expr &: {env = env}


track_location{f} = 
   f2{context, scope, expr} =
      rval = f{context, scope, expr} !!
         e ->
            e <<: expr
            throw e
      match rval:
         #bounce{v} ->
            f2{context, scope, v <<: expr}
         other ->
            other <<: expr
   f2


run_macro{m, context, scope, form, arg} =
   rval = m{context, scope, form, arg}
   bind_ast{rval, stdenv.fork{}}
   rval



;; Perform one step of expansion.

;; Essentially, if the given expression is a macro call, it will be
;; expanded. If it is a plain macro, it will also be expanded, with
;; #void{} as its argument. Nothing else is expanded, and step does
;; not keep going recursively.

;; step is appropriate for use in macros that process specific node
;; types. For instance, pattern matching recognizes the #check{...}
;; node. expand will refuse that node, because it doesn't recognize
;; it, but step will let macros produce #check nodes and will leave
;; them untouched, so that the pattern matching macro can do something
;; with it and produce legal nodes.

;; context: the context in which the expression is evaluated (#expr,
;; #pattern, #blocktest, etc.)

;; scope: the scope in which we are located

;; expr: the expression to expand (one step)

step = track_location{...} with

   {context, scope, expr and match} ->

      #symbol{s} ->
         {=> env} = expr
         match env.resolve{scope, s}:
            #macro{m} ->
               match context:
                  #expr{.head} ->
                     #macro{m}
                  other ->
                     #bounce with run_macro{m, context, scope, expr, #void{}}
            other ->
               expr

      #macro{m} ->
         match context:
            #expr{.head} ->
               expr
            other ->
               #bounce with run_macro{m, context, scope, expr, #void{}}

      #send{f, arg} ->
         match step{#expr{.head}, scope, f}:
            #macro{m} ->
               #bounce with run_macro{m, context, scope, expr, arg}
            other ->
               expr

      #nostep{x} ->
         x

      other ->
         expr


;; Equivalent of step for a list of expressions. It recognizes
;; additional instructions:

;; #splice{...} -> splice expressions into the stream, expand them

;; #float{expr} -> float the expression to the top. If multiple floats
;;    are found, the first occurrences will be higher

;; #sink{expr} -> sinks the expression to the bottom. If multiple sinks
;;    are found, the first occurrences will be higher up

;; #multimacro{m} -> m is a macro that should take the remaining
;;    expressions in the list (those that come after itself), and
;;    return a new list of expressions.

step_all{context, scope, {*stmts}} =
   pre = {}
   bulk = {}
   post = {}
   while stmts.length:
      current = stmts.shift{}
      match step{context, scope, current}:
         #splice{*prepend} ->
            stmts := prepend ++ stmts
         #float{stmt} ->
            pre ++= step_all{context, scope, {stmt}}
         #sink{stmt} ->
            post ++= step_all{context, scope, {stmt}}
         #multimacro{m} ->
            stmts := m{context, scope, current, stmts}
         x ->
            bulk.push with x
   [pre ++ bulk] ++ post


;; Compute the full expansion of the provided expression. expand is,
;; more or less, the handler for the #expr context.

generic_nodes = {
   .if
   .js_while, .js_for, .js_for_in
   .js_break, .js_continue, .js_return
   .js_delete, .js_throw, .js_try, .js_new
}

expand = track_location{...} with

   {context, scope, expr} ->

      expr := step{context, scope, expr}

      match expr:

         #symbol{s} ->
            {=> env} = expr
            match env.resolve{scope, s}:
               undefined? ->
                  throw E.syntax.undeclared{"Undeclared variable: " + s, {node = expr}}
               other ->
                  #bounce{other}

         #value{_} ->
            expr

         #variable{_} ->
            expr

         #void{} ->
            expr

         #send{f, arg} ->
            #send with 
               expand{#expr{.head}, scope, f}
               expand{#expr{.tail}, scope, arg}

         #array{*args} ->
            newargs = step_all{#expr{.array}, scope, args} each arg ->
               expand{#expr{.expr}, scope, arg}
            #array{*newargs}

         #object2{*args} ->
            newargs = step_all{#expr{.object}, scope, args} each {k, v} ->
               {expand{#expr{.expr}, scope, k}
                expand{#expr{.expr}, scope, v}}
            #object2{*newargs}

         #multi{*args} ->
            newscope = Scope{scope}
            stepscope =
               if{expr.nonrecursive, scope, newscope}
            {=> newargs, => vars} = classify{.newargs, .vars} with
               step_all{#expr{.multi}, stepscope, args} each
                  #option{opt, value} ->
                     newscope.setopt{opt, value}
                     #ignore
                  #declare{variable and #symbol{s}, value = null} ->
                     {=> env} = variable
                     v = gensym{s} <<: variable
                     env.bind{newscope, s} with v
                     if value:
                        then:
                           #splice with
                              #newargs{#assign{v, value}}
                              #vars{v}
                        else:
                           #vars{variable}
                  other ->
                     #newargs{other}
            if vars.length:
               then:
                  #scope{vars, #multi{* ...}} with
                     newargs each arg -> expand{#expr{.expr}, newscope, arg}
               else:
                  #multi{* ...} with
                     newargs each arg -> expand{#expr{.expr}, scope, arg}

         #data{*args} ->

            is_obj = false
            obj = #object2{}
            arr = #array{}
            parts = {}

            newpart{} =
               match arr:
                  #array{} -> false
                  other ->
                     parts.push{arr}
                     arr := #array{}

            step_all{#expr{.data}, scope, args} each
               #assoc{} ->
                  is_obj := true
               #assoc{k, v} ->
                  is_obj := true
                  obj.push with {k, v}
               #dynsplice{expr} ->
                  newpart{}
                  parts.push{expr}
               other ->
                  arr.push{other}

            newpart{}

            r = match parts:
               {} when is_obj ->
                  obj
               {} ->
                  #array{}
               {arr and #array{*things}} ->
                  if is_obj:
                     throw E.syntax.array.object{"Cannot mix array and object notations."}
                     ;; arr.push{obj}
                  arr
               other ->
                  if is_obj:
                     throw E.syntax.array.object{"Cannot mix array and object notations."}
                     ;; parts.push{#array{obj}}

                  bind_ast{construct{parts}, stdenv} where
                     construct{match} =
                        {} -> #array{}
                        {arg} -> arg
                        {*rest, arg} ->
                           '[^construct{rest}].concat{^arg}

            expand{context, scope, r}

         #assign{target, value} ->
            #assign with
               expand{#expr, scope, target}
               expand{#expr, scope, value}

         #lambda{bindings, body} ->
            newscope = Scope{scope}
            #lambda with
               bindings each
                  #symbol{b} and {=> env} ->
                     [env.bind{newscope, b, v}, v] where
                        v = gensym{b}
                  other ->
                     throw E.syntax.lambda.binding{"Not a valid binding.", {node = other}}
               expand{#expr{.expr}, newscope, body}

         #use{newscope, x} ->
            expand{context, newscope, x}

         {type, *args} when [generic_nodes.indexOf{type} != -1] ->
            {type} ++
               args each arg ->
                  expand{#expr{.expr}, scope, arg}

         other ->
            throw E.syntax.illegal_node{"An illegal node was found.", {node = other}}


class Embedded:
   constructor{code} =
      @code := bind_ast{code, stdenv.fork{}}
      @"::id" := uuid{}
   "::serialize_ast"{} =
      expand{#top, topscope, @code}


topscope = Scope{null}

stdenv = nullenv.fork{}

[{...} each k -> stdenv.bind{topscope, k, #variable{k}}] with
   "+", "-", "*", "/", "mod"
   ".&", ".|", ".^"
   "and", "or", "not"
   "==", "!=", "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   .true, .false, .null, .undefined

   .typeof, .String, .Array, .Number
   .parseInt
   .Error, .TypeError, .ReferenceError
   .console

   .___js_fetch


overridable{f}{match and context, scope, form, arg} =
   #pattern ->
      #nostep{form}
   other ->
      f{context, scope, form, arg}

protected_value{name, value}{match, scope, form, arg} =
   #pattern ->
      throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
   other ->
      match arg:
         #void{} ->
            #value{value}
         other ->
            #send{#value{value}, arg}


[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #macro{v}}] with

   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}

   "*"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #dynsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #dynsplice{val}
         {_, #void{}} ->
            #variable{"*"}
         other ->
            #send{#variable{"*"}, expr}

   "_"{#pattern, scope, form, #void{}} =
      #ignore{}

   "and"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #all{lhs, rhs}
      other ->
         #send{#variable{"and"}, arg}

   "or"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #any{lhs, rhs}
      other ->
         #send{#variable{"or"}, arg}

   "."{context, scope, form, match} =
      #data{#void{}, #symbol{s}} ->
         #value{s}
      #data{#void{}, other} or other ->
         throw E.syntax.dot{"Argument to '.' must be a symbol", {argument = other}}

   "="{match, scope, form, #data{lhs, rhs}} =
      #expr{.multi} ->
         pp = PatternParser{scope, lhs}
         exec = pp.process{#use{scope, rhs}} with {
            assign{v, value} =
               #multi with
                  #assign{v, value} <<: v
                  #value{true}
            wrap{pattern, result} =
               ;; ;; <> "-------------"
               ;; ;; <> pattern
               ;; if result.location:
               ;;    then: <> result.location.highlight{}
               ;;    else: <> "NO LOCATION"
               result
         }
         match {pp.vars, exec}:
            {{v}, #multi{#assign{_, value}, #value{== true}}} ->
               #declare{v, value}
            other ->
               #splice{*decls, test} where
                  decls = pp.vars each v -> #declare{v, #value{undefined}}
                  test = 'if{^exec, true, throw Error{"mismatch"}}
      #expr{.data} ->
         #symbol{s} or #value{s} = lhs
         #assoc{#value{s}, rhs}
      #pattern ->
         #default{lhs, rhs}
      other ->
         throw E.syntax.declare{"A variable cannot be declared at that location"}

   "=>"{match, scope, form, #data{lhs, rhs, => env}} =
      #pattern ->
         match {lhs, rhs}:
            {#void, #symbol{k} or #value{k}} ->
               #assoc{#value{k}, #symbol{k} &: {env = env}}
            {#symbol{k} or #value{k}, rhs} ->
               #assoc{#value{k}, rhs}

   ":="{context, scope, form, #data{lhs, rhs}} =
      #assign{lhs, rhs}

   "->"{context, scope, form, match} =
      #data{#data{*args}, rhs} ->
         #lambda{args, rhs}
      other ->
         throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

   if{context, scope, form, match} =
      #data{test, a, b} ->
         #if{test, a, b}
      #data{test, #multi! {*match}} ->
         {'then{^a}, 'else{^b}} ->
            #if{test, a, b}
         {*s1, 'else{^b}} ->
            #if{test, #multi{*s1}, b}
         other ->
            #if{test, #multi{*other}, #value{null}}

   while{context, scope, form, #data{test, body}} =
      {.js_while, test, body}

   for{context, scope, form, #data{match, body}} =
      #multi{a, b, c} ->
         #multi with
            a
            #js_for{#value{null}, b, c, body}
      '[^a in ^b] ->
         #multi with
            #declare{a, #value{null}} ;; this is to show the symbol as resolved
            #js_for_in{a, b, body}

   let{context, scope, form, #data{#multi! {*bindings}, body}} =
      construct{match} =
         {} -> body
         {x, *xs} ->
            #multi{x, construct{xs}} &: {nonrecursive = true}
      construct{bindings}
      ;; #multi{*bindings, body} &: {nonrecursive = true}

   [where]{context, scope, form, #data{body, bindings}} =
      'let{^bindings, ^body}

   "break" => overridable with
      {context, scope, form, #void{}} ->
         #js_break{}

   "throw" => overridable with
      {context, scope, form, arg} ->
         #js_throw{arg}

   "?"{context, scope, form, #data{expr, #void{}}} =
      checker = match expr:
         'String -> mac1 with {x} -> '[typeof{^x} == "string"]
         'Number -> mac1 with {x} -> '[typeof{^x} == "number"]
         'true -> mac1 with {x} -> x
         'false -> mac1 with {x} -> '[not ^x]
         'null -> mac1 with {x} -> '[^x == ^=null]
         'undefined -> mac1 with {x} -> '[^x == ^=undefined]
         other -> '___checker{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #check{checker, #ignore{}}
               other ->
                  #check{checker, expr}
         other -> '[^checker]{^expr}

   "!"{context, scope, form, #data{expr, #void{}}} =
      projector = match expr:
         'String -> mac1 with {x} -> '{true, String{^x}}
         'Number -> mac1 with {x} -> '{true, parseFloat{^x}}
         other -> '___projector{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #project{projector, #ignore{}}
               other ->
                  #project{projector, expr}
         other -> '[^projector]{^expr}[1]

   "<==>"{context, scope, form, #data{a, b}} =
      ' | temp = ^a
        | ^a := ^b
        | ^b := temp

   numbers{context, scope, form, #data{body, => env}} =
      nums = "zero one two three four five six seven eight nine ten".split{" "}
      syms = nums each n ->
         #symbol{n} &: {env = env}
      rval = #multi ++
         enumerate{syms} each {i, sym} -> #declare{sym, #value{i}}
      rval.push with body
      rval

   right{context, env, form, expr} =
      #value{"yes"}

   wrong{context, env, form, #value{0}} =
      #wrong{123}


mac1{f} = 
   #macro with {context, scope, form, #data{expr}} ->
      f{expr}

class PatternParser:

   constructor{scope, pattern} =
      @arguments := null
      @vars := {}
      @pattern := @expand{scope, pattern, true}

   parse_specs{scope, specs} =
      rest = undefined
      rval = classify{.fw, .bw, .keys, .defaults} with
         step_all{#pattern, scope, specs} each
            #dynsplice{variable} ->
               rest := @expand{scope, variable}
               #ignore
            #assoc{key} ->
               #keys with {key, @expand{scope, key}}
            #assoc{key, subp} ->
               #keys with {key, @expand{scope, subp}}
            #default{variable, value} ->
               if rest:
                  then: throw E.syntax.pattern{"No default arguments after rest arg."}
                  else: #defaults with {@expand{scope, variable}, value}
            v when rest == undefined ->
               #fw with @expand{scope, v}
            v ->
               #bw with @expand{scope, v}
      rval.rest := rest
      rval

   expand{scope, pattern, toplevel = false, checked = false} =
      expr = step{#pattern, scope, pattern}
      rval = match expr:
         #void ->
            #check{mac1{{x} -> '[^x == ^=null]}, #ignore}
         #ignore or #special ->
            expr
         #symbol or #variable ->
            @vars.push with expr
            #assign{expr}
         #value{v} ->
            #check{mac1{{x} -> '[^x == ^=v]}, #ignore}

         #test{condition, subp} ->
            #test{condition, @expand{scope, subp, toplevel, false}}
         #project{projector, subp} ->
            #project{projector, @expand{scope, subp, toplevel, true}}
         #check{checker, subp} ->
            #check{checker, @expand{scope, subp, toplevel, true}}

         #send{f, arg} when not toplevel ->
            throw E.syntax.pattern{msg, {node = expr, arg = arg}} where
               msg = "Function arguments can only be declared as a top level pattern."
         #send{f, #data and arguments} ->
            @arguments := arguments
            @expand{scope, f, false, false}
         #send{f, arg} ->
            throw E.syntax.pattern{msg, {node = expr, arg = arg}} where
               msg = {"Function must be declared with an array of arguments"
                      "(did you mean to use ':='?)"}.join{" "}

         #all{*xs} ->
            #all ++ [xs each x -> @expand{scope, x}]

         #any{*xs} ->
            normalize{vars} =
               [...].sort{}.join{","} with
                  vars each #symbol{v} -> v
            pps = xs each x ->
               PatternParser{scope, x}
            neighbours{pps} each {pp1, pp2} ->
               pps each pp -> normalize{pp.vars}
               if [normalize{pp1.vars} != normalize{pp2.vars}]:
                  throw E.syntax.pattern{
                     "Both branches of 'or' must contain the same variables"
                     {vars1 = pp1.vars.sort{} <<: pp1.pattern
                      vars2 = pp2.vars.sort{} <<: pp2.pattern}
                  }
            {{=> vars}, *} = pps
            @vars ++= vars
            #any{*patts} where patts = pps each pp -> pp.pattern

         #data{*args} ->
            specs = @parse_specs{scope, args}
            match specs:
               {=> keys, fw => {}, bw => {}, defaults => {}, rest => undefined?} ->
                  #object_pattern{*keys}
                  ;; each {k, v} -> {k, @expand{scope, v, false, false}}}
               {keys => {}, => fw, => bw, => defaults, => rest} ->
                  patt = #array_pattern{fw, bw, defaults, rest} <<: pattern
                  if checked:
                     then: patt
                     else: #check{mac1{{x} -> '[^x instanceof Array]}, patt}
               other ->
                  throw E.syntax.pattern{msg, {node = expr, specs = specs}} where
                     msg = "Pattern must be an array or an object."

         other ->
            throw E.syntax.pattern{"Illegal pattern", {node = other}}

      rval <<: pattern

   process{rhs, fns} =
      @process_helper{@pattern, ..., fns} with
         if @arguments:
            then: '[^[@arguments] -> ^rhs]
            else: rhs

   construct_conj{all} =
      match all:
         {} -> 'true
         {x} -> x
         {x, *xs} -> '[^x and ^[@construct_conj{xs}]]

   construct_disj{all} =
      match all:
         {} -> 'true
         {x} -> x
         {x, *xs} -> '[^x or ^[@construct_disj{xs}]]

   process_helper{pattern, rhs, fns} =
      rval = match pattern:
         #ignore ->
            '[^rhs or true]
         #assign{sym} ->
            fns.assign{sym, rhs}
         #test{condition, subp} ->
            '[^condition and ^[@process_helper{subp, rhs, fns}]]
         #check{checker, subp} ->
            ' | let [temp = ^rhs]:
                 [^checker]{temp} and ^[@process_helper{subp, 'temp, fns}]
         #project{projector, subp} ->
            ' | let [res = [^projector]{^rhs}]:
                 res[0] and ^[@process_helper{subp, 'res[1], fns}]

         #all{*xs} ->
            '[let [temp = ^rhs]: ^ @construct_conj{...}] with
               xs each x -> @process_helper{x, 'temp, fns}

         #any{*xs} ->
            '[let [temp = ^rhs]: ^ @construct_disj{...}] with
               xs each x -> @process_helper{x, 'temp, fns}

         #object_pattern{*subp} ->
            '[let [temp = ^rhs]: ^ @construct_conj{...}] with
               subp each {#value{k}, v} ->
                  @process_helper{v, 'temp[^=k], fns}

         #array_pattern{fw, bw, dflt, rest} ->
            ;; {a, b, c = 123, *rest, d, e}
            ;;  ^^^^  ^^^^^^^  ^^^^^  ^^^^
            ;;  fw    dflt     rest   bw

            nfw = fw.length
            nbw = bw.length
            ndflt = dflt.length

            extract_length = true
            check_length = true

            lo = nfw + nbw
            hi = lo + ndflt

            parts = patch_array with
               enumerate{fw} each {i, m} ->
                  @process_helper{m, 'temp[^=i], fns}
               enumerate{dflt} each {i, {patt, value}} ->
                  idx = i + nfw
                  @process_helper{patt, 'if{^=idx >= len, ^value, temp[^=idx]}, fns}
               if [rest != undefined]:
                  then:
                     slice = if{nbw > 0, '{^=pos, ^=[-nbw]}, '{^=pos}} where
                        pos = nfw + ndflt
                     {@process_helper{rest, '[temp.slice ^slice], fns}}
                  else: {}
               enumerate{bw} each {i, m} ->
                  @process_helper{m, '___js_fetch{temp, len - ^=[nbw - i]}, fns}

            test_length =
               match rest:
                  true? ->
                     '[len >= ^=lo]
                  when lo == hi ->
                     '[len == ^=lo]
                  otherwise ->
                     '[len >= ^=lo and len <= ^=hi]

            ' let [temp = ^rhs, len = temp.length]:
               ^test_length and ^[@construct_conj{parts}]

      fns.wrap{pattern, rval <<: pattern}


[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #value{v}}] with

   "&:" => Embedded with '
      {dest, values} ->
         for [k in values]:
            if values.hasOwnProperty{k}:
               dest[k] := ___js_fetch{values, k}
         dest

   "___checker" => Embedded with '
      {type} ->
         f = type["::check"]
         if [f == undefined]:
            then: {value} -> value instanceof type
            else: {value} -> f.call{type, value}


   ;; "patch" =>
   ;;    Embedded with '
   ;;       {} ->
   ;;          r = {}
   ;;          for [i = 0, i < arguments.length, i++]:
   ;;             r := r.concat{___js_fetch{arguments, i}}
   ;;          r

   ;; "___checker" =>
   ;;    Embedded with '[1 + 2 + 3]




   ;; "patch"{context, scope, form, match} =
   ;;    #array{*args} ->
   ;;       construct{args} where
   ;;          construct{match} =
   ;;             {} -> #array{}
   ;;             {arg} -> arg
   ;;             {*rest, arg} ->
   ;;                '[^construct{rest}].concat{^arg}
   ;;    other ->
   ;;       E.syntax.patch{"Cannot patch", {arg = other}}





