
require:
   "./location" ->
      <<:, ++:

provide:
   parse
   ;; order
   oparse
   finalize
   DONE
   NONE
   LEFT
   RIGHT
   BOTH



transform{expr, cb} =
   tr{x} = transform{x, cb}
   result = cb.call{tr, expr} !! e ->
      match expr:
         #void{} -> #void{}
         #symbol{s} -> expr
         #value{v} -> expr
         {name, *args} ->
            {name, *args.map{tr}}
   result <<: expr



class OperatorGroups:

   constructor{groups} =

      itg = items{groups}
      @gnames := itg each {name, _} -> name
      @groups := itg each {name, descrs} ->
         [++][descrs each descr -> parse_op_description{descr}]
      @fns := {}
      @to_gid := {
         IFX = {wide = {=}, short = {=}}
         PFX = {wide = {=}, short = {=}}
         SFX = {wide = {=}, short = {=}}
      }
      enumerate{@groups} each {i, group} ->
         group each
            {fixity, width, name} ->
               @to_gid[fixity][width][name] := i
            f ->
               @fns.push with {f, i}

   get_name{o} =
      @gnames[@get{o}]

   get{o and {fixity, width, name}} =
      attempt = @to_gid[fixity][width][name]
      if [undefined? attempt]:
         then:
            @fns each {f, i} ->
               if f{o}:
                  return i
            throw E.syntax.unknown_operator{
               "Unknown operator: " + [String! o]
               {operator = o}
            }
         else:
            attempt


parse_op_description{match} =
   do: rx = R'[start, {?"X"}, {? in " _"}, {* not in " _Y"}
               {? in " _"}, {? "Y"}, end]
   Function? f -> f
   rx! {_, x, w1, op, w2, y} ->
      {fixity, short} =
         match:
            when x === "" ->
               {.PFX, w2 === ""}
            when y === "" ->
               {.SFX, w1 === ""}
            otherwise ->
               {.IFX, w1 === "" or w2 === ""}
      if [w1 === "_" or w2 === "_"]:
         then: {{fixity, .short, op}, {fixity, .wide, op}}
         else: {{fixity, if{short, .short, .wide}, op}}
   other ->
      throw E.invalid_op_description with
         "Invalid operator description: " + other


;; POSSIBLE BUG: do all JS engines preserve the order of properties?
;; If they don't, custom might be triggered before pfx/sfx and that
;; would be a problem.
eg_groups = OperatorGroups with {
    ;; High priority
    tokenpfx = {".Y", "#Y", "@Y"}
    sjuxt = {"XWHITEY"}
    ifx = {{match} -> [#IFX{.short, _} -> true, _ -> false]}
    pfx = {{match} -> [#PFX{.short, _} -> true, _ -> false]}
    sfx = {{match} -> [#SFX{.short, _} -> true, _ -> false]}

    ;; Arithmetic
    pow = {"X ** Y"}
    mul = {"X * Y", "X / Y", "X // Y", "X mod Y", "+ Y", "- Y"}
    add = {"X + Y", "X - Y"}
    cmp = {"X < Y", "X <= Y", "X == Y"
           "X > Y", "X >= Y", "X != Y"}

    ;; Collection
    cat = {"X ++ Y"}
    union = {"X & Y"}
    range = {"X .. Y", "X ..", ".. Y"}
    [in] = {"X in Y"}

    ;; Other
    wjuxt = {"X WHITE Y"}
    colon = {"X_:_Y"}

    ;; Logic
    [and] = ["X and Y"]
    [or] = ["X or Y"]
    [not] = ["not Y"]

    ;; Low priority
    "with" = {"X with Y"}
    decl = {"X -> Y", "X = Y", "X := Y", "X => Y", "X where Y", "X when Y", "X each Y"}

    ;; Brackets
    brack = {"X_,_Y"
             "(_Y", "[_Y", "{_Y"
             "X_)", "X_]", "X_}"}

    ;; Custom
    custom = {{x} -> true}
}


class SimplePriority:

   constructor{groups, priorities} =
      @groups := groups
      _i = 0
      tracks = {=}
      @prio := groups.gnames each name ->
         {{Array! ltracks, lp}, {Array! rtracks, rp}} = priorities[name]
         {lt, rt} = {ltracks, rtracks} each tr ->
            rval = 0
            tr each
               .all -> rval := 2**31 - 1
               t when not tracks[t] ->
                  rval := rval |. 2**_i
                  tracks[t] := _i++
               t ->
                  rval := rval |. 2**tracks[t]
            rval
         {{lt, lp}, {rt, rp}}

   compare{op1, op2} =
      i1 = @groups.get{op1}
      i2 = @groups.get{op2}
      {_, {code1, ord1}} = @prio[i1]
      {{code2, ord2}, _} = @prio[i2]
      match:
         when [[code1 &. code2] === 0] ->
            throw E.syntax.order{...} with
               "Cannot mix operators in the given order"
               {left = op1, right = op2}
         when [ord1 > ord2]  -> LEFT
         when [ord1 < ord2]  -> RIGHT
         when [ord1 === ord2] -> BOTH


MAX = 1/0

eg_order = SimplePriority{eg_groups, eg_prio} where

   eg_groups = OperatorGroups{{...}} with

      sh_ifx = {{match} -> [#IFX{.short, _} -> true, _ -> false]}
      sh_pfx = {{match} -> [#PFX{.short, _} -> true, _ -> false]}
      sh_sfx = {{match} -> [#SFX{.short, _} -> true, _ -> false]}
      wi_ifx = {{match} -> [#IFX{.wide, _} -> true, _ -> false]}
      wi_pfx = {{match} -> [#PFX{.wide, _} -> true, _ -> false]}
      wi_sfx = {{match} -> [#SFX{.wide, _} -> true, _ -> false]}

      comma = {"X_,_Y"}
      obrack = {"(_Y", "[_Y", "{_Y"}
      cbrack = {"X_)", "X_]", "X_}"}

      "with" = {"X with Y"}
      lowprio = {"X each Y", "X each? Y", "X where Y"
                 "X !! Y", "X |> Y"
                 "X -> Y", "X => Y", "X = Y"
                 "X := Y", "X += Y", "X -= Y", "X *= Y", "X /= Y"
                 "X <<= Y", "X >>= Y", "X >>>= Y", "X ++= Y", "X ?= Y"
                 "X or= Y", "X and= Y", "X each= Y"
                 "X % Y"}
      "when" = {"X when Y"}
      "or" = {"X or Y"}
      "and" = {"X and Y"}
      "not" = {"not Y"}
      cmp = {"X == Y", "X != Y"
             "X >= Y", "X <= Y"
             "X > Y", "X < Y"}
      binxor = {"X ^. Y"}
      binor = {"X |. Y"}
      binand = {"X &. Y"}
      shift = {"X << Y", "X >> Y", "X >>> Y"}
      add = {"X + Y", "X - Y"}
      mul = {"X * Y", "X / Y", "X // Y", "X mod Y"}
      exp = {"X ** Y"}
      sjuxt = {"XWHITEY"}
      wjuxt = {"X WHITE Y"}
      colon = {"X_:_Y"}

      pfx = {"._Y", "#_Y", "@_Y"}
      when2 = {"when Y"}
      pp = {"<> Y"}


   eg_prio = {...} with
      comma   = {#all{1}, #all{1}}
      obrack  = {#all{MAX}, #all{1}}
      cbrack  = {#all{1}, #all{MAX}}

      "with"  = {#all{1999}, #all{10}}
      lowprio = {#all{11}, #all{10}}
      "when"  = {#all{100}, #all{101}}
      "or"    = {#all{110}, #all{111}}
      "and"   = {#all{120}, #all{121}}
      "not"   = {#all{MAX}, #all{131}}
      cmp     = {#all{200}, #all{201}}
      binxor  = {#all{400}, #all{401}}
      binor   = {#all{410}, #all{411}}
      binand  = {#all{420}, #all{421}}
      shift   = {#arith{500}, #arith{501}}
      add     = {#arith{550}, #arith{551}}
      mul     = {#arith{560}, #arith{561}}
      exp     = {#arith{571}, #arith{570}}
      wjuxt   = {#all{1002}, #all{1001}}
      colon   = {#all{1001}, #all{2}}

      sjuxt   = {#all{2000}, #all{2001}}

      pfx     = {#all{MAX}, #all{3000}}
      pp      = {#all{MAX}, #all{5}}
      when2   = {#all{MAX}, #all{101}}

      sh_ifx  = {#all{1800}, #all{1801}}
      sh_pfx  = {#all{MAX}, #all{1901}}
      sh_sfx  = {#all{1900}, #all{MAX}}
      wi_ifx  = {#customl{900}, #customr{901}}
      wi_pfx  = {#all{MAX}, #all{901}}
      wi_sfx  = {#all{900}, #all{MAX}}





;; order_map = {
;;    IFX = {
;;       wide = {
;;          ","     => {{2r1111, 1}, {2r1111, 1}}

;;          "with"  => {{2r1111, 1999}, {2r1111, 10}}
;;          "each"  => {{2r1111, 11},  {2r1111, 10}}
;;          "each?" => {{2r1111, 11},  {2r1111, 10}}
;;          "where" => {{2r1111, 11},  {2r1111, 10}}
;;          "!!"    => {{2r1111, 11},  {2r1111, 10}}
;;          "|>"    => {{2r1111, 11},  {2r1111, 10}}
;;          "->"    => {{2r1111, 11},  {2r1111, 10}}
;;          "=>"    => {{2r1111, 11},  {2r1111, 10}}
;;          "="     => {{2r1111, 11},  {2r1111, 10}}
;;          ":="    => {{2r1111, 11},  {2r1111, 10}}
;;          "+="    => {{2r1111, 11},  {2r1111, 10}}
;;          "-="    => {{2r1111, 11},  {2r1111, 10}}
;;          "*="    => {{2r1111, 11},  {2r1111, 10}}
;;          "/="    => {{2r1111, 11},  {2r1111, 10}}
;;          "<<="   => {{2r1111, 11},  {2r1111, 10}}
;;          ">>="   => {{2r1111, 11},  {2r1111, 10}}
;;          ">>>="  => {{2r1111, 11},  {2r1111, 10}}
;;          "++="   => {{2r1111, 11},  {2r1111, 10}}
;;          "?="    => {{2r1111, 11},  {2r1111, 10}}
;;          "or="   => {{2r1111, 11},  {2r1111, 10}}
;;          "and="  => {{2r1111, 11},  {2r1111, 10}}
;;          "each=" => {{2r1111, 11},  {2r1111, 10}}

;;          ;; Misc
;;          "%"     => {{2r1111, 11}, {2r1111, 10}}

;;          ;; Logical
;;          "when" => {{2r1111, 100}, {2r1111, 101}}
;;          ;; "||"   => {{2r1111, 110}, {2r1111, 111}}
;;          ;; "&&"   => {{2r1111, 120}, {2r1111, 121}}
;;          "or"   => {{2r1111, 110}, {2r1111, 111}}
;;          "and"  => {{2r1111, 120}, {2r1111, 121}}
;;          "not"  => {{2r1111, 130}, {2r1111, 131}}

;;          ;; Comparison
;;          "==" => {{2r1111, 200}, {2r1111, 201}}
;;          "!=" => {{2r1111, 200}, {2r1111, 201}}
;;          ">=" => {{2r1111, 200}, {2r1111, 201}}
;;          "<=" => {{2r1111, 200}, {2r1111, 201}}
;;          ">"  => {{2r1111, 200}, {2r1111, 201}}
;;          "<"  => {{2r1111, 200}, {2r1111, 201}}

;;          ;; Binary
;;          "^." => {{2r1111, 400}, {2r1111, 401}}
;;          "|." => {{2r1111, 410}, {2r1111, 411}}
;;          "&." => {{2r1111, 420}, {2r1111, 421}}

;;          ;; Arithmetic
;;          "<<"  => {{2r0001, 500}, {2r0001, 501}}
;;          ">>"  => {{2r0001, 500}, {2r0001, 501}}
;;          ">>>" => {{2r0001, 500}, {2r0001, 501}}
;;          "+"   => {{2r0001, 550}, {2r0001, 551}}
;;          "-"   => {{2r0001, 550}, {2r0001, 551}}
;;          "*"   => {{2r0001, 560}, {2r0001, 561}}
;;          "/"   => {{2r0001, 560}, {2r0001, 561}}
;;          "mod" => {{2r0001, 560}, {2r0001, 561}}
;;          "**"  => {{2r0001, 571}, {2r0001, 570}}

;;          ;; Others
;;          DEFAULT = {{2r1000, 900}, {2r0100, 901}}
;;          WHITE   = {{2r1111, 1002}, {2r1111, 1001}}
;;          ":"    => {{2r1111, 1001}, {2r1111, 2}}
;;       }
;;       short = {
;;          DEFAULT = {{2r1111, 1800}, {2r1111, 1801}}
;;          WHITE   = {{2r1111, 2000}, {2r1111, 2001}}
;;          ","    => {{2r1111, 1},    {2r1111, 1}}
;;          ":"    => {{2r1111, 1001}, {2r1111, 2}}
;;       }
;;    }

;;    PFX = {
;;       wide = {
;;          DEFAULT = {{2r1111, MAX}, {2r1111, 900}}
;;          "when" => {{2r1111, MAX}, {2r1111, 101}}
;;          "not"  => {{2r1111, MAX}, {2r1111, 131}}
;;          "." => {{2r1111, MAX}, {2r1111, 3000}}
;;          "#" => {{2r1111, MAX}, {2r1111, 3000}}
;;          ;; "~" => {{2r1111, MAX}, {2r1111, 3000}}
;;          "@" => {{2r1111, MAX}, {2r1111, 3000}}
;;          "<>" => {{2r1111, MAX}, {2r1111, 5}}
;;          "(" => {{2r1111, MAX}, {2r1111, 1}}
;;          "[" => {{2r1111, MAX}, {2r1111, 1}}
;;          "{" => {{2r1111, MAX}, {2r1111, 1}}
;;       }
;;       short = {
;;          DEFAULT = {{2r1111, MAX}, {2r1111, 1901}}
;;          "." => {{2r1111, MAX}, {2r1111, 3000}}
;;          "#" => {{2r1111, MAX}, {2r1111, 3000}}
;;          ;; "~" => {{2r1111, MAX}, {2r1111, 3000}}
;;          "@" => {{2r1111, MAX}, {2r1111, 3000}}
;;          "(" => {{2r1111, MAX}, {2r1111, 1}}
;;          "[" => {{2r1111, MAX}, {2r1111, 1}}
;;          "{" => {{2r1111, MAX}, {2r1111, 1}}
;;       }
;;    }

;;    SFX = {
;;       wide = {
;;          DEFAULT = {{2r1111, 901}, {2r1111, MAX}}
;;          ")" => {{2r1111, 1}, {2r1111, MAX}}
;;          "]" => {{2r1111, 1}, {2r1111, MAX}}
;;          "}" => {{2r1111, 1}, {2r1111, MAX}}
;;       }
;;       short = {
;;          DEFAULT = {{2r1111, 1900}, {2r1111, MAX}}
;;          ")" => {{2r1111, 1}, {2r1111, MAX}}
;;          "]" => {{2r1111, 1}, {2r1111, MAX}}
;;          "}" => {{2r1111, 1}, {2r1111, MAX}}
;;       }
;;    }
;; }



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3


oparse{next, order, finalize} =
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true:
      o =
         if [not left_op and not right_op]:
            then: DONE
            else: [not left_op and RIGHT]
                  \ or [not right_op and LEFT]
                  \ or order{left_op, right_op}

      match o:
         [=== DONE] ->
            return between

         [=== LEFT] ->
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1

         [=== RIGHT] ->
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}

         [=== BOTH] ->
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}

         ;; [=== NONE] ->
         ;;    throw ["Undefined priority between " + left_op + " and " + right_op]

         other ->
            throw E.should_never_happen{
               "undefined priority"
               {left = left_op, right = right_op}
            }


;; consult{{fixity, width, op}} =
;;    map = order_map[fixity][width]
;;    map[op] or map.DEFAULT


;; order{o1, o2} =
;;    {code1, ord1} = consult{o1}[1]
;;    {code2, ord2} = consult{o2}[0]
;;    match:
;;       when [[code1 &. code2] === 0] ->
;;          throw E.syntax.order{...} with
;;             "Cannot mix operators in the given order"
;;             {left = o1, right = o2}
;;       when [ord1 > ord2]  -> LEFT
;;       when [ord1 < ord2]  -> RIGHT
;;       when [ord1 === ord2] -> BOTH

finalize{match token} =

   #ID{value} -> #symbol{value} <<: token
   #NUM{value} -> #value{value} <<: token
   #STR{value} -> #value{value} <<: token
   #VOID{} -> #void{} <<: token

   {ops, *args} ->
      sumloc = ops[0].location
      ops.slice{1} each op ->
         sumloc := sumloc ++: op
      args each arg ->
         sumloc := sumloc ++: arg

      orig_ops = ops
      ops := ops each o -> o[2]
      op = ops[0]

      match {ops, args}:

         {{"WHITE", ":"}, {f, arg, body}} ->
            #send{f, #data{arg, body} <<: [arg ++: body]} <<: sumloc

         {{":"}, {f, body}} ->
            #send{f, #data{body} <<: body} <<: sumloc

         {{"with"}, {target, _b and #multi! {*body}}} ->

            inserted = false
            result = transform{target} with {match expr} ->
               #symbol{"..."} -> [inserted := true, #multi{*body} <<: _b]
               [x when x.fromop] and #send{f, #data{a, b}} ->
                   #send{this{f}, #data{this{a}, this{b}} <<: [a ++: b]}
               #data{*args} ->
                   tr = this
                   res = #data
                   args each
                      #symbol{"..."} -> [inserted := true, res ++= body]
                      other -> res.push with [tr{other} <<: other]
                   res <<: expr

            if [not inserted]:
               then:
                  match target:
                     #void{} ->
                        #data{*body} <<: sumloc
                     when target.fromop ->
                        #send{target, #data{*body} <<: _b} <<: sumloc
                     #send{f, orig_args and #data{*args}} ->
                        #send{f, #data{*args, *body} <<: [orig_args ++: _b]} <<: sumloc
                     #data{*args} ->
                        [target ++ body] <<: sumloc
                     other ->
                        #send{target, #data{*body} <<: _b} <<: sumloc
               else:
                  result <<: sumloc

         {{"[" or ",", *_}, _} ->
            if [op === "["]:
               args := args.slice{1, -1}

            args := args.filter{f} where
               f{match} = | #void{} -> false
                          | other -> true

            result = match args:
               {} -> #value{undefined}
               ;; throw ["At least one expression must be enclosed in []"]
               {x} ->
                  ;; Force x's location to include its surrounding []s
                  ;; Highlighted snippets will look strange otherwise when
                  ;; then span multiple nodes: for instance, [a] + [b]
                  ;;                                          ^^^^^^^
                  ;; Note that <<: only sets location if it's not already set
                  globals: isNaN
                  if [not isNaN{sumloc.start} and not isNaN{sumloc.end}]:
                     x.location := sumloc
                  x
               other -> #multi{*args}
            result <<: sumloc

         {{"{", *_}, _} ->
            #data{*args.slice{1, -1}.filter{f}} <<: sumloc where
               f{match} = | #void{} -> false
                          | other -> true

         {{.WHITE}, _} ->
            #send{*args} <<: sumloc

         {{_}, match} ->
            {#void{}, #void{}} -> #symbol{op} <<: orig_ops[0]
            {a, b} ->
               oloc = orig_ops[0].location
               abloc = [a ++: b]
               oabloc = [orig_ops[0] ++: abloc]
               rval = #send{#symbol{op} <<: oloc
                            #data{a, b} <<: abloc} <<: [oloc ++: abloc]
               rval.fromop := true
               rval

         other ->
            throw E.should_never_happen{
               "unknown node"
               {node = token}
            }

   other ->
      throw E.should_never_happen{
         "unknown node (B)"
         {node = token}
      }


parse{tokens} =
   next{} = tokens.shift{}
   ;; oparse{next, order, finalize}
   oparse{next, eg_order.compare.bind{eg_order}, finalize}


