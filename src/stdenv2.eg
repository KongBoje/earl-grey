
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" as util ->
      classify, items, keys as iterkeys, enumerate
      neighbours, zip
      GenSym, gensym, uuid
   "./pattern" ->
      PatternParser, PatternProcessor
      parse_pattern, parse_clauses
   "./expand2" as mt ->
      Expander, Scope, Env, nullenv, bind_ast


provide:
   topscope
   bind_ast
   stdenv
   expander
   expand


class Embedded:
   constructor{code} =
      @code := bind_ast{code, mkstdenv{}}
      @"::id" := uuid{}
   "::serialize_ast"{} =
      expand{#top, topscope, @code}

topscope = Scope{null, .top}

stdenv = Env{}

mkstdenv{} =
   e = Env{}
   e.scopes[.top] := stdenv.scopes[.top]
   e

[{...} each k -> stdenv.bind{topscope, k, #variable{k}}] with
   "+", "-", "*", "/", "mod"
   ".&", ".|", ".^"
   "and", "or", "not"
   "==", "!=", "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   .true, .false, .null, .undefined

   .typeof, .String, .Array, .Number, .Object, .RegExp
   .parseInt, .parseFloat, .Math
   .Error, .TypeError, .ReferenceError
   .console

   .___js_fetch

   .arguments, .this, .exports


overridable{f}{match and context, scope, form, arg} =
   #pattern ->
      #nostep{form}
   other ->
      f{context, scope, form, arg}

protected_value{name, value}{match, scope, form, arg} =
   #pattern ->
      throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
   other ->
      match arg:
         #void{} ->
            #value{value}
         other ->
            #send{#value{value}, arg}


setup_label{label, env, body} =
   #bind{'break &: {env = env}, #macro{break_mac{label}}
         #bind{'continue &: {env = env}, #macro{continue_mac{label}}
               #js_label{#value{label}, body}}}

break_mac{default_label} = overridable with
   {context, scope, form, match and expr} ->
      #void{} when default_label -> #js_break{#value{default_label}}
      #void{} -> #js_break{}
      #value{v} -> #js_break{expr}
      #symbol{v} -> #js_break{#value{v}}

continue_mac{default_label} = overridable with
   {context, scope, form, match and expr} ->
      #void{} when default_label -> #js_continue{#value{default_label}}
      #void{} -> #js_continue{}
      #value{v} -> #js_continue{expr}
      #symbol{v} -> #js_continue{#value{v}}

var_operator{name} = {context, scope, form, expr} ->
   {=> env} = form
   sym = #symbol{name} &: {env = env}
   match expr:
      #void{} ->
         sym
      #data{#void, match} ->
         #symbol{s} ->
            #send{sym, #value{s}}
         other ->
            #send{sym, other}

accum_flags{mac} =
   make{flags}{context, scope, form, match} =
      #value{flag} or '[. ^[#symbol{flag}]] ->
         #macro{make{flags ++ {flag}}}
      other ->
         mac{context, scope, form, other, flags}
   make{{}}

pattern_constructors = {=}


disregard_specials{#special{kind} and expr, value} =
   throw E.syntax.pattern.special with
      "Special token cannot be used here"
      {special = expr}

pattern_handlers = {

   declare_variables = {
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{v, value} =
         #do{#assign{v, value} <<: v}
      finalize = true
      declare{vars} =
         vars each v -> #declare{v}
      success = #multi{}
      failure = '[throw Error{"Mismatch"}]
   }

   build_object = {
      strings_as_variables = true
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{#symbol{v} or #value{v}, value} =
         #do{#assign{'accum[^=v], value} <<: v}
      finalize = true
      declare{vars} = {#declare{'accum, '{=}}}
      success = 'accum
      failure = '[throw Error{"Mismatch"}]
   }

}


;; Note about lbl:

;; The "for" macro rebinds break and continue to refer to its
;; own label in either the environment it is created in or in
;; the environment of the label it is given. This means,
;; roughly speaking, that break/continue in user code will
;; jump over macro-generated loops (and the macro's will jump
;; over the user's), unless the macro explicitly makes sure
;; that break/continue are redefined in the user
;; environment. To do so, we create a random label and give
;; it the same environment as the argument to "each". This
;; means "break" will jump out of "each" and not out of an
;; outer loop.

build_loop{scope, env, li, clauses, wrap, pre, post} =
   lbl =
      if env:
         then: #value{gensym{}} &: {env = env}
         else: #value{gensym{}}
   ' | ^pre
     | let [temp = ^li, len = temp.length]:
        for[^lbl] [i = 0, i < len, i++]:
           m = ___js_fetch{temp, i}
           ^ | parse_clauses with
                expander, scope, 'm, clauses
                {fallback = 'false
                 wrap = wrap}
     | ^post



[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #macro{v}}] with

   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}

   "++"{context, scope, form, match} =
      #data{#void{}, x} -> #send{#variable{"++"}, #data{#void{}, x}}
      #data{x, #void{}} -> #send{#variable{"++"}, #data{x, #void{}}}
      #data{x, y} -> '[^x].concat{^y}
      #void{} -> '[{x, y} -> x.concat{y}]

   ".."{context, scope, form, match} =
      #data{#void{}, x} -> 'range{1, ^x}
      #data{x, #void{}} -> 'range{^x}
      #data{x, y} -> 'range{^x, ^y}
      #void{} -> 'range

   "//"{context, scope, form, #data{a, b}} =
      'Math.floor{^a / ^b}

   "*"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #dynsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #dynsplice{val}
         {_, #void{}} ->
            #variable{"*"}
         other ->
            #send{#variable{"*"}, expr}

   "**"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #objsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #objsplice{val}
         {_, #void{}} ->
            'Math.pow
         {_, #data{a, b}} ->
            'Math.pow{^a, ^b}

   "_"{#pattern, scope, form, #void{}} =
      #ignore{}

   "and"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #all{lhs, rhs}
      other ->
         #send{#variable{"and"}, arg}

   "or"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #any{lhs, rhs}
      other ->
         #send{#variable{"or"}, arg}

   "when"{context, scope, form, #data{match, condition}} =
      #void{} -> #test{condition, #ignore{}}
      other -> #test{condition, other}

   "."{context, scope, form, match} =
      #data{#void{}, #symbol{s}} ->
         #value{s}
      #data{#void{}, other} or other ->
         throw E.syntax.dot{"Argument to '.' must be a symbol", {argument = other}}

   "="{context, scope, form, expr} =

      match context:

         #expr{.multi} ->
            #data{lhs, rhs} = expr
            parse_pattern{expander, scope, lhs, #use{scope, rhs}} with
               pattern_handlers.declare_variables

         #expr{.data} ->
            match expr:
               #void{} ->
                  #assoc{}
               #data{#symbol{s}, rhs} ->
                  ;; special case for the most common situation
                  #assoc{#value{s}, rhs}
               #data{lhs, rhs} ->
                  #objsplice with #multi with
                     parse_pattern{expander, scope, lhs, #use{scope, rhs}} with
                        pattern_handlers.build_object

         #pattern ->
            #data{lhs, rhs} = expr
            #default{lhs, rhs}

         other ->
            throw E.syntax.declare{"A variable cannot be declared at that location"}

   "=>"{match, scope, {=> env}, #data{lhs, rhs}} =
      #pattern ->
         match {lhs, rhs}:
            {#void, #symbol{k} or #value{k}} ->
               #assoc{#value{k}, #symbol{k} &: {env = env}}
            {#symbol{k} or #value{k}, rhs} ->
               #assoc{#value{k}, rhs}
      #test ->
         #multi! {*stmts} = rhs
         #blocktest{lhs, stmts}
      other ->
         #assoc{lhs, rhs}

   ":="{context, scope, form, #data{lhs, rhs}} =
      #assign{lhs, rhs}

   "->"{match, scope, form, expr} =
      #clause ->
         #data{lhs, rhs} = expr
         #clause{lhs, rhs}
      other ->
         match expr:
            #data{#data{*args} and arg, rhs} ->
               pp = PatternParser{expander, scope, arg, {...}} with
                  indexable = true
                  allow_nested = true
               match pp.pattern:
                  #array_pattern{fw, {}, {}, undefined?} -> ;; when not pp.specials.match ->
                     decls = if{pp.specials.match, {#declare{'ph}}, {}}
                     newargs = zip{fw, args} each {x, arg} -> match x:
                        #assign{expr and #symbol{v}} ->
                           expr
                        other ->
                           newv = #symbol{gensym{.temp}} &: {env = stdenv}
                           decls.push with
                              parse_pattern{expander, scope, arg, newv} with
                                 pattern_handlers.declare_variables &+ {
                                    special = {#special{match} and expr, value} ->
                                       .match ->
                                          placeholder := 'ph
                                          #assign{placeholder}
                                       other ->
                                          throw E.syntax.pattern.special with
                                             "Special token cannot be used here"
                                             {special = expr}
                                 }
                           newv
                     #lambda{newargs, #multi{*decls, ...}} with
                        if pp.specials.match:
                           then: '[match ph: ^rhs]
                           else: rhs
                  other ->
                     #lambda{{}, body} where
                        body = ' | match.indexable arguments:
                                    ^arg -> ^rhs

            #data{#data{*args}, rhs} ->
               #lambda{args, rhs}

            other ->
               throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

   "match" => accum_flags with {match, scope, form, expr, flags} ->
      #pattern ->
         match expr:
            #void{} -> #special{.match}
            other -> #all{other <<: expr, #special{.match} <<: form}
      other ->
         opt = util.set{flags}
         to_match = #symbol{gensym{.m}} &: {single_assignment = true}
         {value, body} = match expr:
            #data{#multi! {*b}} -> {#value{null}, b}
            #data{v, #multi! {*b}} -> {v, b}
         '[let [^to_match = ^value]: ^mbody] where mbody =
            parse_clauses with
               expander, scope, to_match, body
               opt &+ {
                  fallback = '[throw Error{"mismatch!!"}]
                  wrap = {x} -> x
               }


   "each"{match, scope, form and {=> env}, #data{li, #multi! {*clauses}}} =

      #test ->
         #test_factory{li, clauses} &: {env = env}

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.
         build_loop{scope, env, li, clauses, {x} -> x, #splice{}, #splice{}}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.
         build_loop{scope, env, li, clauses, {x} -> 'acc.push{^x}, '[acc = {}], 'acc}

   "!!"{match, scope, form, #data{expr, #multi! {*clauses}}} =
      #expr{.multi} ->
         #nostep{form}
      #expr{.ignore} ->
         clauses.push with
            bind_ast{'[e -> throw e], mkstdenv{}}
         #js_try{expr, ..., #void{}} with
            ' | {excv} ->
                 ^ | parse_clauses with
                      expander, scope, 'excv, clauses
                      {wrap = {x} -> x}
      other ->
         clauses.push with
            bind_ast{'[e -> throw e], mkstdenv{}}
         ' | let [rval = false]:
              ^ #js_try{'[rval := ^expr], ..., #void{}} with
                 ' | {excv} ->
                      ^ | parse_clauses with
                           expander, scope, 'excv, clauses
                           {wrap = {x} -> '[rval := ^x]}
              rval

   "@" => var_operator{gensym{"it"}}

   chain{context, scope, form, #data{defn and {=> env}, #multi! {*body}}} =
      it = '[@] &: {env = env}
      construct{match} =
         {x} -> x
         {x, *rest} ->
            ' | let [^it = ^x]:
                 ^construct{rest}
      construct{{defn} ++ body}

   using{context, scope, form, #data{defn and {=> env}, body}} =
      it = '[@] &: {env = env}
      ' | let [^it = ^defn]:
           ^body
      

   do{match, scope, form, #data{body}} =
      #clause ->
         #block{body}
      #test ->
         #multi! {*stmts} = body
         #do{#splice{*stmts}}
      other ->
         #multi{body}

   ifneeded{match, scope, form, #data{yes, no}} =
      #expr{match} ->
         x ->
            <> x
            yes
         .multi -> #nostep{form}
         .ignore -> no
         other -> yes
      other ->
         <> other
         yes

   if{context, scope, form, match} =
      #data{test, a, b} ->
         #if{test, a, b}
      #data{test, #multi! {*match}} ->
         {'then{^a}} ->
            #if{test, a, #value{undefined}}
         {'then{^a}, 'else{^b}} ->
            #if{test, a, b}
         {*s1, 'else{^b}} ->
            #if{test, #multi{*s1}, b}
         other ->
            #if{test, #multi{*other}, #value{undefined}}

   while{context, scope, form, match and {=> env}} =
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{test, body}} ->
            setup_label{label, env, #js_while{test, body}}
      #data{test, body} ->
         setup_label{gensym{}, env, #js_while{test, body}}

   for{context, scope, form, expr} =
      setup_for{label, env, match, body} =
         #multi{a, b, c} ->
            #multi with
               a
               setup_label{label, env, #js_for{#value{null}, b, c, body}}
         '[^a in ^b] ->
            #multi with
               #declare{a, #value{null}} ;; this is to show the symbol as resolved
               setup_label{label, env, #js_for_in{a, b, body}}
      match expr:
         '[. ^[#symbol{label}]] or #value{label} ->
            #macro with {context, scope, form, #data{spec, body}} ->
               setup_for{label, expr.env, spec, body}
         #data{spec, body} ->
            setup_for{gensym{}, form.env, spec, body}

   let{context, scope, form, #data{#multi! {*bindings}, body}} =
      construct{match} =
         {} -> body
         {x, *xs} ->
            #multi{x, construct{xs}} &: {nonrecursive = true}
      construct{bindings}
      ;; #multi{*bindings, body} &: {nonrecursive = true}

   [where]{context, scope, form, #data{body, bindings}} =
      'let{^bindings, ^body}

   "break" => break_mac{null}
   ;; "break" => overridable with
   ;;    {context, scope, form, match and expr} ->
   ;;       #void{} -> #js_break{}
   ;;       #value{v} -> #js_break{expr}
   ;;       #symbol{v} -> #js_break{#value{v}}

   "continue" => continue_mac{null}
   ;; "continue" => overridable with
   ;;    {context, scope, form, #void{}} ->
   ;;       #js_continue{}

   "throw" => overridable with
      {context, scope, form, arg} ->
         #js_throw{arg}

   "return" => overridable with
      {context, scope, form, arg} ->
         #js_return{arg}

   "new" => overridable with
      {context, scope, form, arg} ->
         #js_new{arg}

   "delete" => overridable with
      {context, scope, form, arg} ->
         #js_delete{arg}

   "?"{context, scope, form, #data{expr, #void{}}} =
      checker = match expr:
         'String -> mt.checker.String
         'Number -> mt.checker.Number
         'true -> mt.checker.true
         'false -> mt.checker.false
         'null -> mt.checker.null
         'undefined -> mt.checker.undefined
         other -> '___checker{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #check{checker, #ignore{}}
               other ->
                  #check{checker, expr}
         other -> '[^checker]{^expr}

   "!"{context, scope, form, #data{expr, #void{}}} =
      projector = match expr:
         'String -> mt.mac1 with {x} -> '{true, String{^x}}
         'Number -> mt.mac1 with {x} -> '{true, parseFloat{^x}}
         other -> '___projector{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #project{projector, #ignore{}}
               other ->
                  #project{projector, expr}
         other -> '[^projector]{^expr}[1]

   "#"{context, scope, form, #data{#void{}, #symbol{tag}}} =
      tag := #value{tag}
      #macro{f} where f{match, scope, form, expr} =
         #pattern ->
            checker_mac = #macro with {context, scope, form, #data{expr}} ->
               ' | let [x = ^expr]:
                    [x instanceof Array and x[0] == ^tag]
            match expr:
               #data{*subp} -> '{^tag, ^*subp}
               #void{} -> #check{checker_mac, #ignore{}}
               other -> #check{checker_mac, expr}
         _ ->
            match expr:
               #void{} ->
                  '{^tag}
               #data{*args} ->
                  '{^tag, ^*args}
               other ->
                  throw E.syntax"#" with
                     "Illegal argument for #"
                     {form = form
                      argument = expr}

   require{context, scope, form, #data{expr}} =

      req = #variable{.require}
      stmts = {}

      topfetch{pkg, v} =
         stmts.push with '[^v = [^req]{^=pkg}]
         v

      produce{match, fetch} =

         expr and #symbol{s} ->
            fetch{s, expr}

         #value{String? s} ->
            fetch{s, gensym{}}

         #multi{*subp} or #data{*subp} ->
            subp each p -> produce{p, fetch}

         #send{#symbol{"as"}, #data{#value{pkg} or #symbol{pkg}, s}} ->
            fetch{pkg, s}

         #send{#symbol{"->"}, #data{pkg, subp}} ->
            pkgv = produce{pkg, fetch}
            produce{subp} with {pkg, v} ->
                stmts.push with '[^v = ^pkgv ^=pkg]

      produce{expr, topfetch}
      #splice{*stmts}

   provide{context, scope, form, #data{#multi! {*expr}}} =
      #sink with
         #multi ++
            expr each
               s and #symbol{name} ->
                  '[exports[^=name] := ^s]
               '[^s as ^[#symbol{name} or #value{name}]] ->
                  '[exports[^=name] := ^s]
               other ->
                  throw E.syntax.provide with
                     "Each clause of provide must be 'sym' or 'sym as name'"

   ;; constructor{match, scope, form, expr} =
   ;;    #pattern ->
   ;;       ;; <> {"ok?", expr}
   ;;       #project{#macro{m}, #send{#value{"constructor"}, expr}} where
   ;;          m{context, scope, form, #data{match}} =
   ;;             '[^args -> ^body] ->
   ;;                '{true, ...} with
   ;;                   ^args ->
   ;;                      console.log{"yay"}
   ;;                      ;; ^body
   ;;             other ->
   ;;                throw E.syntax.constructor{"Constructor must be a function"}

   class{context, scope, form, expr} =

      helper{name, stmts} =
         statics = {}
         ctor = {#data{}, #multi{}}
         new_stmts = stmts each
            'static{^[#multi! {*methods}]} ->
               statics ++= methods
            '[constructor[^args] = ^body] or '[constructor = ^args -> ^body] ->
               ctor := {args, body}
               #splice{}
            '[^lhs = ^rhs] ->
               parse_pattern{expander, scope, lhs, rhs} with
                  pattern_handlers.build_object &+ {
                     allow_nested = false
                     assign{#symbol{v} or #value{v}, value} =
                        #do{#assign{'[^name].prototype[^=v], value} <<: v}
                     declare{vars} = {}
                     wrap_target{match} =
                        '[^args -> ^body] ->
                           {=> env} = body
                           it = #symbol{"@"} &: {env = env}
                           ' | ^args ->
                                let [^it = this]:
                                   ^body
                        other ->
                           other
                     success = #splice{}
                     failure = '[throw Error{"Mismatch"}]
                  }

         {ctor_args, ctor_body} = ctor
         ctor_body :=
            {env => env2} = ctor_body
            it = #symbol{"@"} &: {env = env2}
            ' | let [^it = if{not [^name]? this, Object.create{[^name].prototype}, this}]:
                 ^ctor_body
                 ^it

         #splice with
            ' | ^name = ^ctor_args -> ^ctor_body
            ' | ^*new_stmts
            ' | [^name] &: {=, ^*statics}
            ' | ^name

      match expr:
         #data{name, #multi! {*stmts}} ->
            helper{name, stmts}
         #data{#multi! {*stmts}} ->
            helper{#symbol{gensym{}}, stmts}



   numbers{context, scope, form, #data{body, => env}} =
      nums = "zero one two three four five six seven eight nine ten".split{" "}
      syms = nums each n ->
         #symbol{n} &: {env = env}
      rval = #multi ++
         enumerate{syms} each {i, sym} -> #declare{sym, #value{i}}
      rval.push with body
      rval

   "<==>"{context, scope, form, #data{a, b}} =
      ' | temp = ^a
        | ^a := ^b
        | ^b := temp



blocktest_wrap{expr} =
   ' | value = [[...] !! e -> #error{e}] with
        match [^expr]:
           true? x -> #success{x}
           false? x -> #failure{x}
     | acc.push with
        #test_result{label, value}

blocktest_mac{scope, tests} =

   exptests = enumerate{expander.step_all{#test, scope, tests}}
   n = exptests.length
   stmts = exptests each

      {i, #do{stmt}} ->
         stmt

      {i, #blocktest{more_labels, more_tests}} ->
         ' | let [label = label.concat{Array! ^more_labels}]:
              acc := acc.concat with
                 ^blocktest_mac{scope, more_tests}

      {i, #test_factory{elements, clauses} and {=> env}} ->
         build_loop{scope, env, elements, clauses, wrap, #splice{}, #splice{}} where
            wrap{expr} =
               ' | let [label = label.concat{{i}}]:
                    ^blocktest_wrap{expr}

      {i, expr} ->
         lbl = if{n == 1, '{}, '{^=i}}
         ' | let [label = label.concat{^lbl}]:
              ^blocktest_wrap{expr}

   ' | let [acc = {}]:
        [[...] !! e -> acc.concat{{#error{label, e}}}] with
           [^*stmts, acc]


stdenv.bind{topscope, "blocktest", #macro{...}} with
   {context, scope, form, #data{*args}} ->
      ;; acc = gensym{}
      ;; labv = gensym{}
      ;; stmts = #multi with '[^acc = {}]
      match args:
         {#multi! {*tests}} ->
            ' | label = {}
              | ^blocktest_mac{scope, tests}
         {labels, #multi! {*tests}} ->
            ' | label = Array! ^labels
              | ^blocktest_mac{scope, tests}




class RegexBuilder:

   wrap{x} =
      "(?:" + x + ")"

   quote{x} =
      x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

   quote_charset{x} =
      x.replace{R.g'{in "[](){}^"}, "\\$1"}

   build{expr} =
      match expr:
         #symbol{match} ->
            .any -> "."
            .start -> "^"
            .end -> "$"
            .alpha -> "\\a"
            .digit -> "\\d"
            .word -> "\\w"
            .space -> "\\s"
            .boundary -> "\\b"
            .a -> "\\a"
            .d -> "\\d"
            .w -> "\\w"
            .s -> "\\s"
            .b -> "\\b"

         #value{x} -> @quote{x}

         #send{#symbol{"raw"}, #value{s}} ->
             s

         #send{#symbol{match}, #data{a, b}} ->
            "||" ->
               @wrap{@build{a} + "|" + @build{b}}
            "or" ->
               @wrap{@build{a} + "|" + @build{b}}
            "*" ->
               #void{} = a
               @wrap{@build{b} + "*"}
            "+" ->
               #void{} = a
               @wrap{@build{b} + "+"}
            "?" ->
               #void{} = a
               @wrap{@build{b} + "?"}
            "in" ->
               #void{} = a
               #value{v} = b
               ["[" + x + "]"] where
                  x = @quote_charset{v}
            "not" ->
               #void{} = a
               b as #send{#symbol{"in"}, #data{#void{}, #value{v}}}
               ["[^" + x + "]"] where
                  x = @quote_charset{v}

         #data{*args} ->
            "(" + [args each arg -> @build{arg}].join{""} + ")"
         #multi{*args} ->
            "(?:" + [args each arg -> @build{arg}].join{""} + ")"

         other ->
            E.syntax.regexp with
               "Illegal regular expression"
               {expr = expr}

build_regexp{x} = RegexBuilder{}.build{x}

stdenv.bind{topscope, "R", #macro{accum_flags{mac}}} where
   mac{context, scope, form, match, flags} =
      #value{String? v} ->
         'RegExp{^=v, ^=[flags.join{""}]}
      #send{#symbol{"'"}, #data{#void{}, arg}} ->
         'RegExp{^=build_regexp{arg}, ^=[flags.join{""}]}
         ;; #value{rx} where
         ;;    rx = RegExp{build_regexp{arg}, [flags.join{""}]}



[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #value{v}}] with

   "&:" => Embedded with '
      {dest, values} ->
         for [k in values]:
            if values.hasOwnProperty{k}:
               dest[k] := ___js_fetch{values, k}
         dest

   "&+" => Embedded with '
      {a, b} ->
         dest = {=}
         for [k in a]:
            if a.hasOwnProperty{k}:
               dest[k] := ___js_fetch{a, k}
         for [k in b]:
            if b.hasOwnProperty{k}:
               dest[k] := ___js_fetch{b, k}
         dest

   "___checker" => Embedded with '
      {type} ->
         f = type["::check"]
         if [f == undefined]:
            then: {value} -> value instanceof type
            else: {value} -> f.call{type, value}

   "___projector" => Embedded with '
      {type} -> {value} ->
         f = type[":::project"]
         if [f == undefined]:
            then:
               f = type["::project"]
               if [f == undefined]:
                  then: {true, type{value}}
                  else: {true, f{value}} !! e -> {false, null}
            else:
               f.call{type, value}

   "___hasprop" => Embedded with '
      {match, key} ->
         null? or undefined? -> false
         String? x -> key in String.prototype
         Number? x -> key in Number.prototype
         x -> key in x

   "range" => Embedded with '
      {from, to} ->
         rval = {}
         for [i = from, i <= to, i++]:
            rval.push{i}
         rval



generic_nodes = {
   .if
   .js_while, .js_for, .js_for_in, .js_label
   .js_break, .js_continue, .js_return
   .js_delete, .js_throw, .js_try, .js_new
}

expander = Expander{mkstdenv, generic_nodes}
expand = expander.expand.bind{expander}

