
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" as util ->
      classify, items, keys as iterkeys, enumerate
      neighbours, zip
      GenSym, gensym, uuid
   "./pattern" ->
      PatternParser, PatternProcessor
      process_pattern, assemble_pattern, pattern_with_variables
      process_pattern2, assemble_pattern2, pattern_with_variables2
      parse_pattern, parse_clauses
   "./expand2" as mt ->
      Expander, Scope, Env, nullenv, bind_ast


provide:
   topscope
   bind_ast
   stdenv
   expander
   expand


class Embedded:
   constructor{code} =
      @code := bind_ast{code, mkstdenv{}}
      @"::id" := uuid{}
   "::serialize_ast"{} =
      expand{#top, topscope, @code}

topscope = Scope{null, .top}

stdenv = Env{}

mkstdenv{} =
   e = Env{}
   e.scopes[.top] := stdenv.scopes[.top]
   e

[{...} each k -> stdenv.bind{topscope, k, #variable{k}}] with
   "+", "-", "*", "/", "mod"
   ".&", ".|", ".^"
   "and", "or", "not"
   "==", "!=", "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   .true, .false, .null, .undefined

   .typeof, .String, .Array, .Number, .RegExp
   .parseInt, .parseFloat
   .Error, .TypeError, .ReferenceError
   .console

   .___js_fetch

   .arguments, .this, .exports


overridable{f}{match and context, scope, form, arg} =
   #pattern ->
      #nostep{form}
   other ->
      f{context, scope, form, arg}

protected_value{name, value}{match, scope, form, arg} =
   #pattern ->
      throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
   other ->
      match arg:
         #void{} ->
            #value{value}
         other ->
            #send{#value{value}, arg}


setup_label{label, env, body} =
   #bind{'break &: {env = env}, #macro{break_mac{label}}
         #bind{'continue &: {env = env}, #macro{continue_mac{label}}
               #js_label{#value{label}, body}}}

break_mac{default_label} = overridable with
   {context, scope, form, match and expr} ->
      #void{} when default_label -> #js_break{#value{default_label}}
      #void{} -> #js_break{}
      #value{v} -> #js_break{expr}
      #symbol{v} -> #js_break{#value{v}}

continue_mac{default_label} = overridable with
   {context, scope, form, match and expr} ->
      #void{} when default_label -> #js_continue{#value{default_label}}
      #void{} -> #js_continue{}
      #value{v} -> #js_continue{expr}
      #symbol{v} -> #js_continue{#value{v}}

var_operator{name} = {context, scope, form, expr} ->
   {=> env} = form
   sym = #symbol{name} &: {env = env}
   match expr:
      #void{} ->
         sym
      #data{#void, match} ->
         #symbol{s} ->
            #send{sym, #value{s}}
         other ->
            #send{sym, other}

accum_flags{mac} =
   make{flags}{context, scope, form, match} =
      #value{flag} or '[. ^[#symbol{flag}]] ->
         #macro{make{flags ++ {flag}}}
      other ->
         mac{context, scope, form, other, flags}
   make{{}}

pattern_constructors = {=}


disregard_specials{#special{kind} and expr, value} =
   throw E.syntax.pattern.special with
      "Special token cannot be used here"
      {special = expr}

pattern_handlers = {

   declare_variables = {
      allow_arguments = true
      special = disregard_specials
      assign{v, value} =
         #do{#assign{v, value} <<: v}
      finalize = true
      declare{vars} =
         vars each v -> #declare{v}
      success = #multi{}
      failure = '[throw Error{"Mismatch"}]
   }

   build_object = {
      allow_arguments = true
      special = disregard_specials
      assign{#symbol{v} or #value{v}, value} =
         #do{#assign{'accum[^=v], value} <<: v}
      finalize = true
      declare{vars} = {#declare{'accum, '{=}}}
      success = 'accum
      failure = '[throw Error{"Mismatch"}]
   }

}



[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #macro{v}}] with

   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}

   "*"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #dynsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #dynsplice{val}
         {_, #void{}} ->
            #variable{"*"}
         other ->
            #send{#variable{"*"}, expr}

   "**"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #objsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #objsplice{val}
         {_, #void{}} ->
            #variable{"**"}
         other ->
            #send{#variable{"**"}, expr}

   "_"{#pattern, scope, form, #void{}} =
      #ignore{}

   "and"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #all{lhs, rhs}
      other ->
         #send{#variable{"and"}, arg}

   "or"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #any{lhs, rhs}
      other ->
         #send{#variable{"or"}, arg}

   "when"{context, scope, form, #data{match, condition}} =
      #void{} -> #test{condition, #ignore{}}
      other -> #test{condition, other}

   "."{context, scope, form, match} =
      #data{#void{}, #symbol{s}} ->
         #value{s}
      #data{#void{}, other} or other ->
         throw E.syntax.dot{"Argument to '.' must be a symbol", {argument = other}}

   "="{context, scope, form, expr} =

      match context:

         #expr{.multi} ->
            #data{lhs, rhs} = expr
            parse_pattern{expander, scope, lhs, #use{scope, rhs}} with
               pattern_handlers.declare_variables
               ;; , stdargs &+ {...}} with
               ;; assign{v, value} =
               ;;    #do{#assign{v, value} <<: v}
               ;; declare{vars} =
               ;;    vars each v -> #declare{v}
               ;; success = #multi{}
               ;; failure = '[throw Error{"Mismatch"}]

         #expr{.data} ->
            match expr:
               #void{} ->
                  #assoc{}
               #data{#symbol{s}, rhs} ->
                  ;; special case for the most common situation
                  #assoc{#value{s}, rhs}
               #data{lhs, rhs} ->
                  #objsplice with #multi with
                     parse_pattern{expander, scope, lhs, #use{scope, rhs}} with
                        pattern_handlers.declare_variables
                        ;; , stdargs &+ {...}} with
                        ;; assign{#symbol{v} or #value{v}, value} =
                        ;;    #do{#assign{'accum[^=v], value} <<: v}
                        ;; declare{vars} = {#declare{'accum, '{=}}}
                        ;; success = 'accum
                        ;; failure = '[throw Error{"Mismatch"}]

         #pattern ->
            #default{lhs, rhs}

         other ->
            throw E.syntax.declare{"A variable cannot be declared at that location"}

   "=>"{match, scope, form, #data{lhs, rhs, => env}} =
      #pattern ->
         match {lhs, rhs}:
            {#void, #symbol{k} or #value{k}} ->
               #assoc{#value{k}, #symbol{k} &: {env = env}}
            {#symbol{k} or #value{k}, rhs} ->
               #assoc{#value{k}, rhs}

   ":="{context, scope, form, #data{lhs, rhs}} =
      #assign{lhs, rhs}

   "->"{match, scope, form, expr} =
      #clause ->
         #data{lhs, rhs} = expr
         #clause{lhs, rhs}
      other ->
         match expr:
            #data{#data{*args} and arg, rhs} ->
               pp = PatternParser{expander, scope, arg, {indexable = true}}
               match pp.pattern:
                  #array_pattern{fw, {}, {}, undefined?}
                         \ when not pp.specials.match ->
                     decls = {}
                     newargs = zip{fw, args} each {x, arg} -> match x:
                        #assign{expr and #symbol{v}} ->
                           expr
                        other ->
                           newv = #symbol{gensym{.temp}} &: {env = stdenv}
                           decls.push with '[^arg = ^newv]                           
                           newv
                     #lambda{newargs, #multi{*decls, rhs}}
                  other ->
                     #lambda{{}, body} where
                        body = ' | match.indexable arguments:
                                    ^arg -> ^rhs

            #data{#data{*args}, rhs} ->
               #lambda{args, rhs}

            other ->
               throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

   "match" => accum_flags with {match, scope, form, expr, flags} ->
      #pattern ->
         match expr:
            #void{} -> #special{.match}
            other -> #all{other <<: expr, #special{.match} <<: form}
      other ->
         opt = util.set{flags}
         to_match = #symbol{gensym{.m}} &: {single_assignment = true}
         {value, body} = match expr:
            #data{#multi! {*b}} -> {#value{null}, b}
            #data{v, #multi! {*b}} -> {v, b}
         '[let [^to_match = ^value]: ^mbody] where mbody =
            parse_clauses with
               expander, scope, to_match, body
               '[throw Error{"mismatch!!"}]
               {x} -> x
               opt


   "each"{match, scope, form, #data{li, #multi! {*clauses}} and {=> env}} =

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.

         ;; Note about lbl:

         ;; The "for" macro rebinds break and continue to refer to its
         ;; own label in either the environment it is created in or in
         ;; the environment of the label it is given. This means,
         ;; roughly speaking, that break/continue in user code will
         ;; jump over macro-generated loops (and the macro's will jump
         ;; over the user's), unless the macro explicitly makes sure
         ;; that break/continue are redefined in the user
         ;; environment. To do so, we create a random label and give
         ;; it the same environment as the argument to "each". This
         ;; means "break" will jump out of "each" and not out of an
         ;; outer loop.

         lbl = #value{gensym{}} &: {env = env}
         ' | let [temp = ^li, len = temp.length]:
              for[^lbl] [i = 0, i < len, i++]:
                 m = ___js_fetch{temp, i}
                 ^ | parse_clauses with
                      expander, scope, 'm, clauses
                      'false
                      {x} -> x
                      {=}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.

         lbl = #value{gensym{}} &: {env = env}
         ' | let [temp = ^li, len = temp.length, accum = {}]:
              for[^lbl] [i = 0, i < len, i++]:
                 m = ___js_fetch{temp, i}
                 ^ | parse_clauses with
                      expander, scope, 'm, clauses
                      'false
                      {x} -> 'accum.push{^x}
                      {=}
              accum

   "!!"{match, scope, form, #data{expr, #multi! {*clauses}}} =
      #expr{.multi} ->
         #nostep{form}
      #expr{.ignore} ->
         clauses.push with
            bind_ast{'[e -> throw e], mkstdenv{}}
         #js_try{expr, ..., #void{}} with
            ' | {excv} ->
                 ^ | parse_clauses with
                      expander, scope, 'excv, clauses
                      'false
                      {x} -> x
                      {=}
      other ->
         clauses.push with
            bind_ast{'[e -> throw e], mkstdenv{}}
         ' | let [rval = false]:
              ^ #js_try{expr, ..., #void{}} with
                 ' | {excv} ->
                      ^ | parse_clauses with
                           expander, scope, 'excv, clauses
                           'false
                           {x} -> '[rval := ^x]
                           {=}
              rval

   "@" => var_operator{gensym{"it"}}

   chain{context, scope, form, #data{defn and {=> env}, #multi! {*body}}} =
      it = '[@] &: {env = env}
      construct{match} =
         {x} -> x
         {x, *rest} ->
            ' | let [^it = ^x]:
                 ^construct{rest}
      construct{{defn} ++ body}

   using{context, scope, form, #data{defn and {=> env}, body}} =
      it = '[@] &: {env = env}
      ' | let [^it = ^defn]:
           ^body
      

   do{match, scope, form, #data{body}} =
      #clause ->
         #block{body}
      other ->
         #multi{body}

   ifneeded{match, scope, form, #data{yes, no}} =
      #expr{match} ->
         x ->
            <> x
            yes
         .multi -> #nostep{form}
         .ignore -> no
         other -> yes
      other ->
         <> other
         yes

   if{context, scope, form, match} =
      #data{test, a, b} ->
         #if{test, a, b}
      #data{test, #multi! {*match}} ->
         {'then{^a}} ->
            #if{test, a, #value{undefined}}
         {'then{^a}, 'else{^b}} ->
            #if{test, a, b}
         {*s1, 'else{^b}} ->
            #if{test, #multi{*s1}, b}
         other ->
            #if{test, #multi{*other}, #value{undefined}}

   while{context, scope, form, match and {=> env}} =
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{test, body}} ->
            setup_label{label, env, #js_while{test, body}}
      #data{test, body} ->
         setup_label{gensym{}, env, #js_while{test, body}}

   for{context, scope, form, expr} =
      setup_for{label, env, match, body} =
         #multi{a, b, c} ->
            #multi with
               a
               setup_label{label, env, #js_for{#value{null}, b, c, body}}
         '[^a in ^b] ->
            #multi with
               #declare{a, #value{null}} ;; this is to show the symbol as resolved
               setup_label{label, env, #js_for_in{a, b, body}}
      match expr:
         '[. ^[#symbol{label}]] or #value{label} ->
            #macro with {context, scope, form, #data{spec, body}} ->
               setup_for{label, expr.env, spec, body}
         #data{spec, body} ->
            setup_for{gensym{}, form.env, spec, body}

   let{context, scope, form, #data{#multi! {*bindings}, body}} =
      construct{match} =
         {} -> body
         {x, *xs} ->
            #multi{x, construct{xs}} &: {nonrecursive = true}
      construct{bindings}
      ;; #multi{*bindings, body} &: {nonrecursive = true}

   [where]{context, scope, form, #data{body, bindings}} =
      'let{^bindings, ^body}

   "break" => break_mac{null}
   ;; "break" => overridable with
   ;;    {context, scope, form, match and expr} ->
   ;;       #void{} -> #js_break{}
   ;;       #value{v} -> #js_break{expr}
   ;;       #symbol{v} -> #js_break{#value{v}}

   "continue" => continue_mac{null}
   ;; "continue" => overridable with
   ;;    {context, scope, form, #void{}} ->
   ;;       #js_continue{}

   "throw" => overridable with
      {context, scope, form, arg} ->
         #js_throw{arg}

   "return" => overridable with
      {context, scope, form, arg} ->
         #js_return{arg}

   "new" => overridable with
      {context, scope, form, arg} ->
         #js_new{arg}

   "delete" => overridable with
      {context, scope, form, arg} ->
         #js_delete{arg}

   "?"{context, scope, form, #data{expr, #void{}}} =
      checker = match expr:
         'String -> mt.checker.String
         'Number -> mt.checker.Number
         'true -> mt.checker.true
         'false -> mt.checker.false
         'null -> mt.checker.null
         'undefined -> mt.checker.undefined
         other -> '___checker{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #check{checker, #ignore{}}
               other ->
                  #check{checker, expr}
         other -> '[^checker]{^expr}

   "!"{context, scope, form, #data{expr, #void{}}} =
      projector = match expr:
         'String -> mac1 with {x} -> '{true, String{^x}}
         'Number -> mac1 with {x} -> '{true, parseFloat{^x}}
         other -> '___projector{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #project{projector, #ignore{}}
               other ->
                  #project{projector, expr}
         other -> '[^projector]{^expr}[1]

   "#"{context, scope, form, #data{#void{}, #symbol{tag}}} =
      tag := #value{tag}
      #macro{f} where f{match, scope, form, expr} =
         #pattern ->
            checker_mac = #macro with {context, scope, form, #data{expr}} ->
               ' | let [x = ^expr]:
                    [x instanceof Array and x[0] == ^tag]
            match expr:
               #data{*subp} -> '{^tag, ^*subp}
               #void{} -> #check{checker_mac, #ignore{}}
               other -> #check{checker_mac, expr}
         _ ->
            match expr:
               #void{} ->
                  '{^tag}
               #data{*args} ->
                  '{^tag, ^*args}
               other ->
                  throw E.syntax"#" with
                     "Illegal argument for #"
                     {form = form
                      argument = expr}

   require{context, scope, form, #data{expr}} =

      req = #variable{.require}
      stmts = {}

      topfetch{pkg, v} =
         stmts.push with '[^v = [^req]{^=pkg}]
         v

      produce{match, fetch} =

         expr and #symbol{s} ->
            fetch{s, expr}

         #value{String? s} ->
            fetch{s, gensym{}}

         #multi{*subp} or #data{*subp} ->
            subp each p -> produce{p, fetch}

         #send{#symbol{"as"}, #data{#value{pkg} or #symbol{pkg}, s}} ->
            fetch{pkg, s}

         #send{#symbol{"->"}, #data{pkg, subp}} ->
            pkgv = produce{pkg, fetch}
            produce{subp} with {pkg, v} ->
                stmts.push with '[^v = ^pkgv ^=pkg]

      produce{expr, topfetch}
      #splice{*stmts}

   provide{context, scope, form, #data{#multi! {*expr}}} =
      #sink with
         #multi ++
            expr each
               s and #symbol{name} ->
                  '[exports[^=name] := ^s]
               '[^s as ^[#symbol{name} or #value{name}]] ->
                  '[exports[^=name] := ^s]
               other ->
                  throw E.syntax.provide with
                     "Each clause of provide must be 'sym' or 'sym as name'"







   numbers{context, scope, form, #data{body, => env}} =
      nums = "zero one two three four five six seven eight nine ten".split{" "}
      syms = nums each n ->
         #symbol{n} &: {env = env}
      rval = #multi ++
         enumerate{syms} each {i, sym} -> #declare{sym, #value{i}}
      rval.push with body
      rval

   "<==>"{context, scope, form, #data{a, b}} =
      ' | temp = ^a
        | ^a := ^b
        | ^b := temp



;; blocktest_wrap{label, expr, accumulator} =
;;    ' | value = [[...] !! e -> #error{e}] with
;;         match [^expr]:
;;            true? x -> #success{x}
;;            false? x -> #failure{x}
;;      | [^accumulator].push with
;;         #test_result{^label, value}

;; blocktest_mac{scope, label, tests, acc} =
;;    ;; ok = gensym{}
;;    ;; stmts = {}
;;    ;; stmts.push with ' | ^ok = true

;;    stmts = step_all{#test, scope, tests} each

;;       stmt and #send{#symbol{"do"}, _} ->
;;          ' | ^stmt !! e ->
;;               [^acc].push with #error{^label, e}
;;               ok := false

;;       #send{#symbol{"=>"}, #data{new_label, aslist! new_tests}} ->
;;          labv = gensym{}
;;          stmts.push with
;;             ' | ^labv = ^label ++ [Array! ^new_label]
;;               | ^ #multi{*blocktest_mac{labv, new_tests, acc}}

;;       #send{#symbol{"each"}, #data{sources, aslist! clauses}} ->
;;          loopvar = gensym{}
;;          clauses := clauses each clause ->
;;             clause as #send{#symbol{"->"}, #data{lhs, rhs}}
;;             '[^lhs -> ^[#multi{*x}]] where x =
;;                blocktest_mac with
;;                   '[^label ++ {^loopvar}]
;;                   aslist! rhs
;;                   acc
;;          clauses.push with
;;             ' | __no ->
;;                  [^acc].push with
;;                     #error{^label, "No handler for test case", __no}
;;          stmts.push with build_each with
;;             sources
;;             #multi{*clauses}
;;             #multi{}
;;             #multi{}
;;             loopvar

;;       expr ->
;;          stmts.push with
;;             ' if [^ok]:
;;                  then: ^blocktest_wrap{label, expr, acc}
;;                  else: [^acc].push with #aborted{^label, ' ^expr}
;;    stmts.push{acc}
;;    stmts

;; stdenv.register_macro{"blocktest"} with {{context, env}, #data{*args}} ->
;;    acc = gensym{}
;;    labv = gensym{}
;;    stmts = #multi with '[^acc = {}]
;;    rval = match args:
;;       {aslist! tests} ->
;;          stmts.push with '[^labv = {}]
;;          stmts := stmts ++ blocktest_mac{labv, tests, acc}
;;       {labels, aslist! tests} ->
;;          stmts.push with '[^labv = [Array! ^labels]]
;;          stmts := stmts ++ blocktest_mac{labv, tests, acc}
;;    rval









;; inject_below_uses{match, fn} =
;;    #use{scope, x} ->
;;       #use{scope, inject_below_uses{x, fn}}
;;    other ->
;;       fn{other}


;; class PatternParser:

;;    constructor{scope, pattern, strings_as_variables = false} =
;;       @sav := strings_as_variables
;;       @arguments := {}
;;       @vars := {}
;;       @specials := {=}
;;       @pattern := @expand{scope, pattern, true}

;;    parse_specs{scope, specs} =
;;       rest = undefined
;;       rval = classify{.fw, .bw, .keys, .defaults} with
;;          step_all{#pattern, scope, specs} each
;;             #dynsplice{variable} ->
;;                rest := @expand{scope, variable}
;;                #ignore
;;             #assoc{key} ->
;;                #keys with {key, @expand{scope, key}}
;;             #assoc{key, subp} ->
;;                #keys with {key, @expand{scope, subp}}
;;             #default{variable, value} ->
;;                if rest:
;;                   then: throw E.syntax.pattern{"No default arguments after rest arg."}
;;                   else: #defaults with {@expand{scope, variable}, value}
;;             v when rest == undefined ->
;;                #fw with @expand{scope, v}
;;             v ->
;;                #bw with @expand{scope, v}
;;       rval.rest := rest
;;       rval

;;    expand{scope, pattern, toplevel = false, checked = false} =
;;       expr = step{#pattern, scope, pattern}
;;       rval = match expr:
;;          #void ->
;;             #check{__chk_null, #ignore}
;;          #ignore ->
;;             expr
;;          #special{type} ->
;;             @specials[type] := true
;;             expr
;;          #symbol or #variable ->
;;             @vars.push with expr
;;             #assign{expr}
;;          #value{v} when @sav ->
;;             @vars.push with expr
;;             #assign{expr}
;;          #value{v} ->
;;             #check{mkchecker{v}, #ignore}
;;             ;; #check{mac1{{x} -> '[^x == ^=v]}, #ignore}

;;          #test{condition, subp} ->
;;             #test{condition, @expand{scope, subp, toplevel, false}}
;;          #project{projector, subp} ->
;;             #project{projector, @expand{scope, subp, toplevel, true}}
;;          #check{checker, subp} ->
;;             #check{checker, @expand{scope, subp, toplevel, true}}

;;          #send{f, arg} when not toplevel ->
;;             throw E.syntax.pattern{msg, {node = expr, arg = arg}} where
;;                msg = "Function arguments can only be declared as a top level pattern."
;;          #send{f, #data and arguments} ->
;;             @arguments.push with arguments
;;             @expand{scope, f, true, false}
;;          #send{f, arg} ->
;;             throw E.syntax.pattern{msg, {node = expr, arg = arg}} where
;;                msg = {"Function must be declared with an array of arguments"
;;                       "(did you mean to use ':='?)"}.join{" "}

;;          #all{*xs} ->
;;             #all ++ [xs each x -> @expand{scope, x}]

;;          #any{*xs} ->
;;             canon{all} =
;;                all.sort{}.join{","}
;;             normalize{vars} =
;;                canon{...} with
;;                   vars each #symbol{v} -> v
;;             pps = xs each x ->
;;                PatternParser{scope, x}
;;             neighbours{pps} each {pp1, pp2} ->
;;                pps each pp -> normalize{pp.vars}
;;                if [normalize{pp1.vars} != normalize{pp2.vars}]:
;;                   throw E.syntax.pattern{
;;                      "Both branches of 'or' must contain the same variables"
;;                      {vars1 = pp1.vars.sort{} <<: pp1.pattern
;;                       vars2 = pp2.vars.sort{} <<: pp2.pattern}
;;                   }
;;                if [canon{iterkeys{pp1.specials}} != canon{iterkeys{pp2.specials}}]:
;;                   throw E.syntax.pattern{
;;                      "Both branches of 'or' must contain the same special tokens"
;;                      {special1 = iterkeys{pp1.specials}.sort{} <<: pp1.pattern
;;                       special2 = iterkeys{pp2.specials}.sort{} <<: pp2.pattern}
;;                   }
;;             {{=> vars}, *} = pps
;;             @vars ++= vars
;;             #any{*patts} where patts = pps each pp -> pp.pattern

;;          #data{*args} ->
;;             specs = @parse_specs{scope, args}
;;             match specs:
;;                {=> keys, fw => {}, bw => {}, defaults => {}, rest => undefined?} ->
;;                   #object_pattern{*keys}
;;                   ;; each {k, v} -> {k, @expand{scope, v, false, false}}}
;;                {keys => {}, => fw, => bw, => defaults, => rest} ->
;;                   patt = #array_pattern{fw, bw, defaults, rest} <<: pattern
;;                   if checked:
;;                      then: patt
;;                      else: #check{__chk_Array, patt}
;;                other ->
;;                   throw E.syntax.pattern{msg, {node = expr, specs = specs}} where
;;                      msg = "Pattern must be an array or an object."

;;          other ->
;;             throw E.syntax.pattern{"Illegal pattern", {node = other}}

;;       rval <<: pattern


;; class PatternProcessor:

;;    constructor{} =
;;       @temps := {}
;;       @parts := {}
;;       @gen := GenSym{"t"}

;;    do{part} =
;;       @parts.push with #do{part}

;;    check{part} =
;;       @parts.push with #check{part}

;;    temp{x, v = null} =
;;       match x:
;;          [#variable or #symbol] and [not v] and {single_assignment => true?} ->
;;             x
;;          init ->
;;             ;; v = #variable{gensym{"t"}}
;;             v := v or #symbol{@gen{}}
;;             v.single_assignment := true
;;             @temps.push with v
;;             @do with '[^v := ^init]
;;             v

;;    process{pattern, rhs, fns} =
;;       rval = match pattern:
;;          #ignore ->
;;             @do{rhs}
;;          #assign{sym} ->
;;             @parts.push with fns.assign{sym, rhs}
;;          #special{kind} ->
;;             @process{..., rhs, fns} with
;;                fns.special{pattern, rhs}

;;          #test{condition, subp} ->
;;             @process{subp, rhs, fns}
;;             @check with condition

;;          #check{checker, #ignore} ->
;;             @check with '[^checker]{^rhs}
;;          #check{checker, subp} ->
;;             t = @temp{rhs}
;;             @check with '[^checker]{^t}
;;             @process{subp, t, fns}

;;          #project{projector, subp} ->
;;             t = @temp{'[^projector]{^rhs}}
;;             @check with '[^t][0]
;;             @process{subp, '[^t][1], fns}

;;          #all{*xs} ->
;;             t = @temp{rhs}
;;             xs each x -> @process{x, t, fns}
;;             null

;;          #any{*xs} ->
;;             t = @temp{rhs, #symbol{gensym{"bridge"}}}
;;             ;; t = #symbol{gensym{"bridge"}}
;;             ;; @temps.push with t
;;             ;; @do with '[^t := ^rhs]
;;             @check with
;;                construct_oper{'[or], 'false, ...} with
;;                   xs each x ->
;;                      pp = PatternProcessor{}
;;                      pp.process{x, t, fns}
;;                      assemble_pattern{pp}

;;          #object_pattern{*subp} ->
;;             t = @temp{rhs}
;;             subp each {#value{k}, v} ->
;;                @check with '[___hasprop{^t, ^=k}]
;;                @process{v, '[^t][^=k], fns}

;;          #array_pattern{fw, bw, dflt, rest} ->
;;             ;; {a, b, c = 123, *rest, d, e}
;;             ;;  ^^^^  ^^^^^^^  ^^^^^  ^^^^
;;             ;;  fw    dflt     rest   bw

;;             nfw = fw.length
;;             nbw = bw.length
;;             ndflt = dflt.length

;;             extract_length = true
;;             check_length = true

;;             lo = nfw + nbw
;;             hi = lo + ndflt

;;             t = @temp{rhs}
;;             len = @temp{'[^t].length}

;;             @check with
;;                match rest:
;;                   true? ->
;;                      '[^len >= ^=lo]
;;                   when lo == hi ->
;;                      '[^len == ^=lo]
;;                   otherwise ->
;;                      '[^len >= ^=lo and ^len <= ^=hi]

;;             enumerate{fw} each {i, m} ->
;;                @process{m, '[^t][^=i], fns}

;;             enumerate{dflt} each {i, {patt, value}} ->
;;                idx = i + nfw
;;                @process{patt, 'if{^=idx >= ^len, ^value, [^t][^=idx]}, fns}

;;             if [rest != undefined]:
;;                then:
;;                   slice = if{nbw > 0, '{^=pos, ^=[-nbw]}, '{^=pos}} where
;;                      pos = nfw + ndflt
;;                   @process{rest, '[[^t].slice ^slice], fns}
;;                else: {}

;;             enumerate{bw} each {i, m} ->
;;                @process{m, '___js_fetch{^t, ^len - ^=[nbw - i]}, fns}

;;       ;; fns.wrap{pattern, rval <<: pattern}
;;       rval


;; assemble_pattern2{match, t, f = null} =
;;    {} ->
;;       t
;;    {#do{x}, *rest} ->
;;       #multi{x, assemble_pattern2{rest, t, f}}
;;    parts ->
;;       construct{match} =
;;          {} -> #value{true}
;;          {#do{x}, *rest} ->
;;             #multi{x, construct{rest}}
;;          {#check{x}} -> x
;;          {#check{x}, *rest} ->
;;             '[^x and ^construct{rest}]
;;       test = construct{parts}
;;       if f:
;;          then: 'if{^test, ^t, ^f}
;;          else: 'if{^test, ^t}



;; parse_clauses_original{scope, target, stmts, fallback, wrap} =

;;    construct{match} =
;;       {} ->
;;          fallback
;;       {match, *rest} ->

;;          #clause{pattern, body} ->
;;             placeholder = undefined
;;             special_fn{#special{match} and expr, value} =
;;                .match ->
;;                   placeholder := 'ph
;;                   #assign{placeholder}
;;                other ->
;;                   throw E.syntax.pattern.special with
;;                      "Special token cannot be used here"
;;                      {special = expr}

;;             {pp, exec} = pattern_with_variables{scope, pattern, target, special_fn}
;;             vars = pp.vars
;;             if placeholder:
;;                vars.push with placeholder

;;             ;; We are nesting the clauses, but we don't want the variables
;;             ;; of a clause to leak into the next one (which they would
;;             ;; because they belong to the same environment). So what we
;;             ;; do is that we tag the outer scope (#tagscope{"back", ...}),
;;             ;; then we revert to it with #use{"back", ...}, which erases
;;             ;; any variables in any environment declared in-between.

;;             ;; Without this trick, "match a: [b -> 1, c -> b]" would not
;;             ;; throw a reference error, because it would produce something
;;             ;; akin to if{b = a, 1, if{c = a, b, fail}} and the second clause
;;             ;; would see the variable "b" declared by the first. This is not
;;             ;; acceptable.

;;             #tagscope{.back, #multi{*decls, test}} where
;;                decls = vars each v -> #declare{v, #value{undefined}}
;;                test = 'if{^exec, ^bod, ^ #use{.back, construct{rest}}} where
;;                   bod =
;;                      if placeholder:
;;                         then:
;;                            parse_clauses with
;;                               expander, scope, placeholder, [#multi! body].slice{1}
;;                               fallback, wrap
;;                         else: wrap{body}

;;          #block{#multi! {*body}} ->
;;             '[^*body, ^construct{rest}]

;;          other ->
;;             throw E.syntax.clause with
;;                "Illegal clause"
;;                {clause = other}

;;    construct with step_all{#clause, scope, stmts}


class RegexBuilder:

   wrap{x} =
      "(?:" + x + ")"

   quote{x} =
      x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

   quote_charset{x} =
      x.replace{R.g'{in "[](){}^"}, "\\$1"}

   build{expr} =
      match expr:
         #symbol{match} ->
            .any -> "."
            .start -> "^"
            .end -> "$"
            .alpha -> "\\a"
            .digit -> "\\d"
            .word -> "\\w"
            .space -> "\\s"
            .boundary -> "\\b"
            .a -> "\\a"
            .d -> "\\d"
            .w -> "\\w"
            .s -> "\\s"
            .b -> "\\b"

         #value{x} -> @quote{x}

         #send{#symbol{"raw"}, #value{s}} ->
             s

         #send{#symbol{match}, #data{a, b}} ->
            "||" ->
               @wrap{@build{a} + "|" + @build{b}}
            "or" ->
               @wrap{@build{a} + "|" + @build{b}}
            "*" ->
               #void{} = a
               @wrap{@build{b} + "*"}
            "+" ->
               #void{} = a
               @wrap{@build{b} + "+"}
            "?" ->
               #void{} = a
               @wrap{@build{b} + "?"}
            "in" ->
               #void{} = a
               #value{v} = b
               ["[" + x + "]"] where
                  x = @quote_charset{v}
            "not" ->
               #void{} = a
               b as #send{#symbol{"in"}, #data{#void{}, #value{v}}}
               ["[^" + x + "]"] where
                  x = @quote_charset{v}

         #data{*args} ->
            "(" + [args each arg -> @build{arg}].join{""} + ")"
         #multi{*args} ->
            "(?:" + [args each arg -> @build{arg}].join{""} + ")"

         other ->
            E.syntax.regexp with
               "Illegal regular expression"
               {expr = expr}

build_regexp{x} = RegexBuilder{}.build{x}

stdenv.bind{topscope, "R", #macro{accum_flags{mac}}} where
   mac{context, scope, form, match, flags} =
      #value{String? v} ->
         'RegExp{^=v, ^=[flags.join{""}]}
      #send{#symbol{"'"}, #data{#void{}, arg}} ->
         'RegExp{^=build_regexp{arg}, ^=[flags.join{""}]}
         ;; #value{rx} where
         ;;    rx = RegExp{build_regexp{arg}, [flags.join{""}]}



[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #value{v}}] with

   "&:" => Embedded with '
      {dest, values} ->
         for [k in values]:
            if values.hasOwnProperty{k}:
               dest[k] := ___js_fetch{values, k}
         dest

   "&+" => Embedded with '
      {a, b} ->
         dest = {=}
         for [k in a]:
            if a.hasOwnProperty{k}:
               dest[k] := ___js_fetch{a, k}
         for [k in b]:
            if b.hasOwnProperty{k}:
               dest[k] := ___js_fetch{b, k}
         dest

   "___checker" => Embedded with '
      {type} ->
         f = type["::check"]
         if [f == undefined]:
            then: {value} -> value instanceof type
            else: {value} -> f.call{type, value}

   "___projector" => Embedded with '
      {type} -> {value} ->
         f = type[":::project"]
         if [f == undefined]:
            then:
               f = type["::project"]
               if [f == undefined]:
                  then: {true, type{value}}
                  else: {true, f{value}} !! e -> {false, null}
            else:
               f.call{type, value}

   "___hasprop" => Embedded with '
      {match, key} ->
         null? or undefined? -> false
         String? x -> key in String.prototype
         Number? x -> key in Number.prototype
         x -> key in x



generic_nodes = {
   .if
   .js_while, .js_for, .js_for_in, .js_label
   .js_break, .js_continue, .js_return
   .js_delete, .js_throw, .js_try, .js_new
}

expander = Expander{mkstdenv, generic_nodes}
expand = expander.expand.bind{expander}

