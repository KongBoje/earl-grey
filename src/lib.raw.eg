

items{obj} =
   results = {}
   for [k in obj]:
      results.push with {k, obj[k]}
   results

enumerate{arr} =
   results = {}
   l = arr.length
   for [i = 0, i < l, i++]:
      results.push with {i, arr[i]}
   results


send{obj, msg} =
   msg |>
      [String? or Number?] -> ___js_fetch{obj, msg}
      other -> obj["::send"]{msg}

Function.prototype["::send"] := {args} ->
   this.apply{this, args}


augment{dest, values} =
   for [k in values]:
      dest[k] := values[k]
   dest



;; create_node{tag, id, classes, kv, Array! contents} =
;;    classes := classes each R'[+any]? x -> x
;;    accum = {"<", tag}
;;    ? | id => accum := accum.concat with
;;           " id=\"", id, "\""
;;    ? | classes.length => accum := accum.concat with
;;           " class=\"", classes.join{" "}, "\""
;;    ? | kv => kv each {k, v} ->
;;           accum := accum.concat with {" ", k, "=\"", v, "\""}
;;    accum.concat{x}.join{""} where x =
;;       {">", *contents, "</", tag, ">"}

patch_array{} =
   r = {}
   for [i = 0, i < arguments.length, i++]:
      r := r.concat{___js_fetch{arguments, i}}
   r

range{from, to} =
   rval = {}
   for [i = from, i <= to, i++]:
      rval.push{i}
   rval

StructFactory{name} =
   make{} =
      r = Array.prototype.slice.call{arguments, 0}
      r["#"] := name
      r
   make[":::project"] := {value} ->
      ? | [value instanceof Array and value["#"] == name] =>
          {true, value}
        | else =>
          {true, make{value}}
   make["::check"] := {value} ->
      ? | [value instanceof Array and value["#"] == name] =>
          true
        | else =>
          false
   make[":::deconstruct"] := {value} ->
      ? | [value instanceof Array and value["#"] == name] =>
          {true, value.slice{0}}
        | else =>
          {false, false}

   make

Struct{name} =
   r = Array.prototype.slice.call{arguments, 1}
   r["#"] := name
   r

Struct["::check"] := {value} ->
   ? | [value instanceof Array] => value["#"] != undefined
     | else => false

Struct[":::deconstruct"] := {value} ->
   ? | [value instanceof Array and value["#"] != undefined] =>
        {true, {value["#"]}.concat{value.slice{0}}}
     | else => {false, null} ;; throw "cannot deconstruct"


pr_terminus{node} =
   r = produce_html{node, .span}
   pre = String.fromCharCode{27} + "[?0;7y+h <div class=\"ug\">"
   post = "</div>" + String.fromCharCode{7}
   console.log with [pre + r + post]

pr{|>, r} =
   Node? n ->
      pr_terminus{n}
   x ->
      pr_terminus{[r or repr]{x}}


repr{x and |>, Function? recur or repr as recur} =
   == true -> .special.true % "true"
   == false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   String? -> .str % x
   Struct? {tag, *entries} ->
      .struct % {.sym % tag, .sequence % [entries each x -> recur{x, repr}]}
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   when x["::repr"] ->
      x["::repr"]{recur}
   other ->
      .unknown % other.toString{}



___checker{type} =
   type["::check"] |>
      undefined? ->
         {value} -> value instanceof type
      f ->
         {value} -> f.call{type, value}
checker = ___checker

___projector{type} = {value} ->
   type[":::project"] |>
      undefined? ->
         type["::project"] |>
            undefined? ->
               {true, type{value}}
            f ->
               {true, f{value}} !! {false, null}
      f -> f.call{type, value}
projector = ___projector

___deconstructor{type} = {value} ->
   type[":::deconstruct"] |>
      undefined? ->
         type["::deconstruct"] |>
            undefined? ->
               ? | [value instanceof Array] => {true, value}
                 | else => {false, null}
            f ->
               {true, f.call{type, value}} !! {false, null}
      f -> f.call{type, value}
deconstructor = ___deconstructor

Array[":::project"] := {value} -> value |>
   Array? -> {true, value}
   _ -> {true, {value}}


RegExp.prototype["::check"] := {value} ->
   value.match{this}

RegExp.prototype[":::project"] := {value} ->
   value.match{this} |>
      null? m -> {false, null}
      m -> {true, m}

RegExp.prototype[":::deconstruct"] := {value} ->
   value.match{this} |>
      null? m -> {false, null}
      m -> {true, m}


class Node:

   static:
      "::deconstruct"{x} =
         {x.classes, x.children}

   constructor{Array! classes, Array! children} =
      @classes := classes.sort{}
      @children := children

   "::check"{n} =
      @classes each c when n.classes.indexOf{c} == -1 ->
         return false
      true


escape_html{s} =
   repl = with
      "&" => "&amp;"
      "<" => "&lt;"
      ">" => "&gt;"
   s.replace{R.g"[&<>]", {x} -> repl[x]}

quotify{s} =
   s.replace{R.g"[\"\\\\]", {x} -> "\\" + x}


produce_html{|>, default_tag} =

   String? s ->
      escape_html{s}

   Node? {tags, children} ->
      tag = default_tag or "span"
      classes = {}
      id = null
      kv = {}
      sub = {}
      tags each
         #assoc{k, v} ->
            kv.push with {k, v}
         R'[start, "+", {*any}]? {_, m} ->
            tag := m
         R'[start, "#", {*any}]? {_, m} ->
            id := m
         String? s ->
            classes.push with s

      accum = {"<", tag}
      ? | id => accum := accum.concat with
             " id=\"", id, "\""
      ? | classes.length => accum := accum.concat with
             " class=\"", quotify{classes.join{" "}}, "\""
      ? | kv => kv each {k, v} ->
             accum := accum.concat with {" ", k, "=\"", quotify{v}, "\""}

      accum.concat{x}.join{""} where x =
         {">", *[children each c -> produce_html{c}], "</", tag, ">"}

   other ->
      produce_html{String! other}
