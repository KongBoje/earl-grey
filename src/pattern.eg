
require:
   "./pp" ->
      <>
   "./location" ->
      [<<:]
   "./util" as util ->
      GenSym, gensym
      ;; _neighbours
      classify, classify_contiguous
      identity
      Body
   "./expand" ->
      checker_db

provide:
   PatternParser
   PatternProcessor
   parse_clauses, parse_pattern
   Handlers


class Handlers:
   constructor{@info, @opt} =
      @handlers = {}
   push{x} =
      @handlers.push with x
   merge{handlers} =
      @handlers ++= handlers.handlers
   wrap{expr} =
      @handlers.sort with {x, y} -> x.wrapOrder < y.wrapOrder
      var x = expr
      @handlers each handler ->
         x = handler.wrap{x, @info, @opt}
      x


class PatternParser:

   constructor{info, pattern, opt} =
      @opt = opt
      @arguments = {}
      @vars = {}
      @specials = {=}
      @handlers = Handlers{info, opt}
      tags = clone{opt.tags or {=}}
      tags.group_id or= gensym{.group}
      @pattern = @expand{info, pattern, tags, true, @opt.indexable}

   parse_specs{info, specs, tags} =
      var rest = undefined
      var has_defaults = false
      rval = classify{.fw, .bw, .keys, .defaults} with
         info.step_all{#pattern, specs} each
            #dynsplice{variable} ->
               set rest = @expand{info, variable, tags}
               #ignore
            #assoc{key} ->
               #keys with {key, @expand{info, key, tags}}
            #assoc{key, subp} ->
               #keys with {key, @expand{info, subp, tags}}
            #default{variable, value} ->
               set has_defaults = true
               if rest:
                  then: throw E.syntax.pattern{"No default arguments after rest arg."}
                  else: #defaults with {@expand{info, variable, tags}, value}
            v when rest === undefined and not has_defaults ->
               #fw with @expand{info, v, tags}
            v ->
               #bw with @expand{info, v, tags}
      rval.rest = rest
      rval

   regspecial{special and #special{name, handler}} =
      match @specials[name]:
         undefined? ->
            @specials[name] = handler
         === handler ->
            pass
         else ->
            throw E.syntax.pattern.incompatible_specials{
               "Special directive '" + name + "' was given two incompatible handlers."
               {special = special}
            }

   expand{info, pattern, tags, toplevel = false, checked = false} =
      expr = info.step{#pattern, pattern}
      rval = match expr:
         #void ->
            #check{checker_db.null, #ignore}
         #ignore ->
            expr
         #special{type, handler} ->
            ;; @regspecial{expr}
            @specials[type] = true
            expr
         #specialX{handler} ->
            @handlers.push with handler
            @expand{info, handler.expand{info}, tags, toplevel, false}
         #symbol or #variable ->
            variable = expr & tags
            @vars.push with variable
            #assign{variable}
         #value{v} when @opt.strings_as_variables ->
            ;; @vars.push with expr
            ;; @vars.push with #symbol{v} <<: expr
            variable = [#symbol{v} & tags] <<: expr
            @vars.push with variable
            #assign{variable}
         #value{v} ->
            #check{checker_db{v}, #ignore}
            ;; #check{mac1{{x} -> '[^x === ^=v]}, #ignore}

         #test{condition, subp} ->
            #test{condition, @expand{info, subp, tags, toplevel, false}}
         #project{projector, subp, unconditional = false} ->
            #project{projector
                     @expand{info, subp, tags, toplevel, true}
                     unconditional}
         #check{checker, subp} ->
            #check{checker, @expand{info, subp, tags, toplevel, true}}

         #send{f, #data and arguments} ->
            if toplevel:
               then:
                  @arguments.unshift with arguments
                  @expand{info, f, tags, true, false}
               else:
                  throw E.syntax.pattern{msg, {node = expr, arg = arguments}} where
                     msg = "Function arguments can only be declared as a top level pattern."
                  
         #send{f, arg} ->
            #assign{expr}
            ;; throw E.syntax.pattern{msg, {node = expr, arg = arg}} where
            ;;    msg = {"Function must be declared with an array of arguments"
            ;;           "(did you mean to use ':='?)"}.join{" "}

         when not @opt.allow_nested ->
            throw E.syntax.pattern{msg, {node = expr}} where
               msg = "Nested patterns are not allowed here."

         #neg{x} ->
            #neg{@expand{info, x, tags}}

         #all{*xs} ->
            #all ++ [xs each x -> @expand{info, x, tags}]

         #any{*xs} ->
            canon{all} =
               all.sort{}.join{","}
            normalize{vars} =
               canon{...} with
                  vars each #symbol{v} -> v
            pps = xs each x ->
               PatternParser{info, x, @opt & {tags = tags}}
            neighbours{pps} each {pp1, pp2} ->
               pps each pp -> normalize{pp.vars}
               if [normalize{pp1.vars} !== normalize{pp2.vars}]:
                  throw E.syntax.pattern{
                     "Both branches of 'or' must contain the same variables"
                     {vars1 = pp1.vars.sort{} <<: pp1.pattern
                      vars2 = pp2.vars.sort{} <<: pp2.pattern}
                  }
               if keys{pp1.specials} != {} or keys{pp2.specials} != {}:
                  throw E.syntax.pattern{
                     "Neither branch of 'or' may contain special tokens."
                     {special1 = keys{pp1.specials}.sort{} <<: pp1.pattern
                      special2 = keys{pp2.specials}.sort{} <<: pp2.pattern}
                  }
               ;; if [canon{keys{pp1.specials}} !== canon{keys{pp2.specials}}]:
               ;;    throw E.syntax.pattern{
               ;;       "Both branches of 'or' must contain the same special tokens"
               ;;       {special1 = keys{pp1.specials}.sort{} <<: pp1.pattern
               ;;        special2 = keys{pp2.specials}.sort{} <<: pp2.pattern}
               ;;    }
            {{=> vars}, *} = pps
            @vars ++= vars
            #any{*patts} where patts = pps each pp -> pp.pattern

         #data{*args} ->
            specs = @parse_specs{info, args, tags}
            match specs:
               {keys => {}, => fw, => bw, => defaults, => rest} ->
                  patt = #array_pattern{fw, bw, defaults, rest} <<: pattern
                  if checked:
                     then: patt
                     else: #check{checker_db.Array, patt}
               {=> keys, fw => {}, bw => {}, defaults => {}, rest => undefined?} ->
                  #object_pattern{*keys}
                  ;; each {k, v} -> {k, @expand{info, v, false, false}}}
               other ->
                  throw E.syntax.pattern{msg, {node = expr, specs = specs}} where
                     msg = "Pattern must be an array or an object."

         #mode{mode, subp} ->
            @expand{info, subp, tags & {declare_mode = mode}, toplevel, checked}

         other ->
            throw E.syntax.pattern{"Illegal pattern: " + other, {node = other}}

      [@opt.wrap_pattern or identity]{rval <<: pattern, toplevel}


class PatternProcessor:

   constructor{} =
      @temps = {}
      @parts = {}
      @gen = GenSym{"t"}

   "do"{part} =
      @parts.push with #do{part}

   check{part, tags = {=}} =
      @parts.push with #check{part} & tags

   temp{x, var v = null} =
      match x:
         [#variable or #symbol] and {single_assignment => true?} when not v ->
            x
         init ->
            ;; v = #variable{gensym{"t"}}
            set v = v or #symbol{@gen{}}
            v.single_assignment = true
            @temps.push with v
            @do with '[set ^v = ^init]
            v

   process{pattern, rhs, fns} =
      rval = match pattern:
         #ignore ->
            @do{rhs}
         #assign{sym} ->
            @parts.push with fns.assign{sym, rhs}
         #special{kind, handler} ->
            @process{..., rhs, fns} with
               fns.special{pattern, rhs}

         #test{condition, subp} ->
            @process{subp, rhs, fns}
            @check{condition, {test = true}}

         #check{checker, #ignore} ->
            @check with '[^checker]{^rhs}
         #check{checker, subp} ->
            t = @temp{rhs}
            @check with '[^checker]{^t}
            @process{subp, t, fns}

         #project{projector, subp, match unconditional} ->
            true? ->
               t = @temp{'[^projector]{^rhs}}
               @process{subp, t, fns}
            else ->
               t = @temp{'[^projector]{^rhs}}
               @check with '[^t][0]
               @process{subp, '[^t][1], fns}

         #neg{patt} ->
            @check{'[not ^[...]]} with
               pp = PatternProcessor{}
               pp.process{patt, rhs, fns}
               assemble_conditions{pp}

         #all{*xs} ->
            t = @temp{rhs}
            xs each x -> @process{x, t, fns}
            null

         #any{*xs} ->
            t = @temp{rhs, #symbol{gensym{"bridge"}}}
            ;; t = #symbol{gensym{"bridge"}}
            ;; @temps.push with t
            ;; @do with '[^t := ^rhs]
            @check with
               util.construct{parts, fn, 'false} where
                  fn{x, rest} = '[^x or ^rest]
                  parts = xs each x ->
                     pp = PatternProcessor{}
                     pp.process{x, t, fns}
                     assemble_conditions{pp}

         #object_pattern{*subp} ->
            t = @temp{rhs}
            subp each {#value{k}, v} ->
               @check with '[___hasprop{^t, ^=k}]
               @process{v, '[^t][^=k], fns}

         #array_pattern{fw, bw, dflt, rest} ->
            ;; {a, b, c = 123, *rest, d, e}
            ;;  ^^^^  ^^^^^^^  ^^^^^  ^^^^
            ;;  fw    dflt     rest   bw

            nfw = fw.length
            nbw = bw.length
            ndflt = dflt.length

            extract_length = true
            check_length = true

            lo = nfw + nbw
            hi = lo + ndflt

            t = @temp{rhs}
            len = @temp{'[^t].length}

            @check with
               match rest:
                  true? ->
                     '[^len >= ^=lo]
                  when lo === hi ->
                     '[^len === ^=lo]
                  otherwise ->
                     '[^len >= ^=lo and ^len <= ^=hi]

            enumerate{fw} each {i, m} ->
               @process{m, '[^t][^=i], fns}

            enumerate{dflt} each {i, {patt, value}} ->
               idx = i + nfw
               @process{patt, 'if{^=[idx + nbw] >= ^len, ^value, [^t][^=idx]}, fns}

            if [rest !== undefined]:
               then:
                  ;; slice = if{nbw > 0, '{^=pos, ^=[-nbw]}, '{^=pos}} where
                  ;;    pos = nfw + ndflt
                  ;; @process{rest, '[[^t].slice ^slice], fns}
                  pos = nfw + ndflt
                  @process{rest, 'Array.prototype.slice.call{^t, ^=pos, ^*end}, fns} where
                     end = if{nbw > 0, {#value{-nbw}}, {}}
               else: {}

            enumerate{bw} each {i, m} ->
               @process{m, '___js_fetch{^t, ^len - ^=[nbw - i]}, fns}

      ;; fns.wrap{pattern, rval <<: pattern}
      rval

assemble_conditions{pp} =
   construct{match} =
      {} -> #value{true}
      {#do{x}, *rest} ->
         #multi{x, construct{rest}}
      {#check{x}} -> x
      {#check{x}, *rest} ->
         '[^x and ^construct{rest}]
   if pp.temps.length:
      then:
         #multi{*decls, construct{pp.parts}} where
            decls = pp.temps each t -> #declare{t}
      else:
         construct{pp.parts}

assemble_pattern{parts, t, f = null} =
   lead = {}
   parts.slice{0} each
      #do{x} ->
         lead.push{x}
         parts.shift{}
      #check{x} -> break

   trail = {}
   parts.slice{0}.reverse{} each
      #do{x} ->
         trail.unshift{x}
         parts.pop{}
      #check{x} -> break

   construct{match} =
      {} -> #value{true}
      {#do{x}, *rest} ->
         #multi{x, construct{rest}}
      {#check{x}} -> x
      {#check{x}, *rest} ->
         '[^x and ^construct{rest}]
      other ->
         throw E.oops{"?!?", other}

   if parts.length:
      then:
         test = construct{parts}
         #multi{*lead, ...} with
            if f:
               then: 'if{^test, [^*trail, ^t], ^f}
               else: 'if{^test, [^*trail, ^t]}
      else:
         #multi{*lead, *trail, t}


inject_below_uses{match, fn} =
   #use{scope, x} ->
      #use{scope, inject_below_uses{x, fn}}
   other ->
      fn{other}

;; Options:
;; strings_as_variables => treat strings as if they were variable names?
;; wrap_target{x} => called on the value the pattern will be applied to:
;;    either rhs, or args -> rhs, if args were found embedded in the pattern
;; finalize => finalize the pattern?
;; (if finalizing:)
;; declare{vars} => preparation code to declare the variables
;; success => what to return on success
;; failure => what to return on failure

find_target{rhs, match pattern} =
   #project{projector, subp, === true} ->
      find_target{'[^projector]{^rhs}, subp}
   else ->
      {rhs, pattern}


parse_pattern{info, pattern, rhs, opt} =
   parse = PatternParser{info, pattern, opt}
   if [not opt.allow_arguments and parse.arguments.length]:
      throw E.syntax.pattern.arguments with
         "Arguments cannot be declared in this pattern"
         {args = parse.arguments[0]}
   [opt.wrap_target or identity]! real_rhs =
      if parse.arguments.length:
         then:
            inject_below_uses{rhs} with {x} ->
               util.construct{parse.arguments ++ {x}} with
                  {args, rest} -> '[^args -> ^rest]
         else:
            rhs
   {var target, pattern} = find_target{real_rhs, parse.pattern}

   var expr = null
   match target:
      #symbol or #variable ->
         pass
      else ->
         {target, expr} = {#variable{info.gensym{"$targ"}}, target}

   proc = PatternProcessor{}
   proc.process{pattern, target, opt}

   if opt.finalize:
      then:
         succ = opt.success{target}
         fail = opt.failure{target}
         assembly = assemble_pattern{proc.parts, succ, fail}
         #splice with
            ;; if{expr === null, #splice{}, '[^target = ^expr]}
            if expr === null:
               then: #splice{}
               else: #splice{#declare{target}, #assign{target, expr}}
            *opt.declare{info, parse.vars}
            #multi with
               *[proc.temps each t -> #declare{t}]
               assembly
      else:
         {parse.vars, parse.handlers, proc.temps, proc.parts}




checkall = {.send, .data, .multi, .assign, .void, .check, .do}

same_block{match, ban1, ban2} =
   {#variable{v1}, #variable{v2}} ->
      v1 === v2
   {#symbol{s1}, #symbol{s2}} ->
      not ban1[s1] and not ban2[s2] and s1 === s2
   {#value{v1}, #value{v2}} ->
      v1 === v2
   {#macro{m1}, #macro{m2}} ->
      m1 === m2
   {{type1, *args1}, {type2, *args2}} when checkall.indexOf{type1} !== -1 ->
      if [type1 === type2 and args1.length === args2.length]:
         then:
            zip{args1, args2} each pair ->
               if [not same_block{pair, ban1, ban2}]:
                  return false
            true
         else:
            false
   other ->
      false

parse_clauses{info, target, stmts, opt} =

   var all_temps = {}

   the_parts = info.step_all{#clause, stmts} each

      #clause{pattern, body} ->
         var placeholder = undefined
         special_fn{#special{match, handler} and expr, value} =
            .match ->
               set placeholder = #symbol{info.gensym{.ph}} <<: expr
               #assign{placeholder}
            other ->
               throw E.syntax.pattern.special with
                  "Special token cannot be used here"
                  {special = expr}

         {vars, handlers, temps, blocks} =
            parse_pattern{info, pattern, target} with
               opt & {
                  allow_arguments = false
                  allow_nested = true
                  special = special_fn
                  assign{v, value} =
                     #do{#assign{v, value} <<: v}
                  finalize = false
               }

         all_temps ++= temps
         if placeholder:
            vars.push with placeholder

         vars2 = {=}
         vars each
            #symbol{xxx} ->
               vars2[xxx] = true
            other ->
               throw E.syntax.unexpected{}

         if opt.wrap:
            handlers.push with opt
            ;; handlers.push with {
            ;;    wrapOrder = 0
            ;;    wrap{expr, subwrap, info, opt} =
            ;;       opt.wrap{expr}
            ;; }

         ;; handlers.sort with {x, y} -> x.wrapOrder < y.wrapOrder

         ;; #clause{vars, vars2, blocks, bod} where bod =
         ;;    var x = body
         ;;    handlers each handler ->
         ;;       body = handler.wrap{info, opt, body}
         ;;    body

         #clause{vars, vars2, blocks, bod} where
            bod =
               if placeholder:
                  then:
                     ;; parse_clauses with
                     ;;    info, placeholder, [Body! body]
                     ;;    opt
                     r = parse_clauses with
                        info, placeholder, [Body! body]
                        opt & {wrap = null}
                     if{opt.wrap, opt.wrap{r}, r}
                  else:
                     handlers.wrap{body}
                     ;; var x = body
                     ;; handlers each handler ->
                     ;;    x = handler.wrap{x, info, opt}
                     ;; x

      #block b ->
         b

      other ->
         throw E.syntax.clause with
            "Illegal clause"
            {clause = other}

   if opt.fallback:
      the_parts.push with #block{opt.fallback{target}}
   unique_temps = keys{util.mkset{all_temps each #symbol{t} -> t}}
   #multi{*decls, weave_clauses{the_parts}} where
      decls = unique_temps each t -> #declare{#symbol{t} &: {mutable = true}}


opt_clauses{clauses} =

   shares = enumerate{clauses.slice{1}} each
      {i, #clause{vars, varsd, blocks, body}} ->
         #clause{_, varsd0, blocks0, _} = clauses[i]
         share = 0
         var idx = 0
         blocks each b ->
            if same_block{{blocks0[share], b}, varsd0, varsd}:
               then:
                  share++
                  match b:
                     #do -> null
                     #check -> set idx = share
                     other -> <> other
               else:
                  break
         {share, idx}

   max = Math.max[shares each {x, _} -> x]
   shares.push{{0, 0}}

   temps = [1 .. max] each _ -> #symbol{gensym{}}

   var shared_last = 0
   var idx_last = 0
   new_clauses = enumerate{clauses} each
      {i, #clause{vars, varsd, blocks, body}} ->
         {share, idx} = shares[i]
         shared = if{idx_last, {#check{temps[idx_last - 1]}}, {}}
         n_to_share = Math.max{shared_last, share}

         to_share = enumerate{blocks.slice{shared_last, n_to_share}} each
            {j, #check{x}} -> #check{#assign{temps[shared_last + j], x}}
            {j, #do{x}} -> #do{x}

         set shared_last = share
         set idx_last = idx
         #clause{vars, varsd, newblocks, body} where newblocks =
            shared.concat{to_share}.concat{rest} where
               rest = blocks.slice{n_to_share}
      other ->
         throw E.oops{"what", {value = other}}

   {temps, new_clauses}


weave_clauses{parts} =

   groups = classify_contiguous{parts} with {{cls, *}} -> cls

   var reassemble = {}
   var new_temps = {}
   groups each
      #clause{*elems} ->
         {ts, new_clauses} = opt_clauses{elems}
         new_temps ++= ts
         reassemble ++= new_clauses
      #block{*elems} ->
         reassemble ++= elems

   helper{match} =

      {} ->
         #multi{}

      {#block{Body! {*body}}, *rest} ->
         '[^*body, ^helper{rest}]

      {#clause{vars, varsd, blocks, body}, *rest} ->
         decls = vars each v -> ;;#declare{v}
            match v.declare_mode:
               .set -> #splice{}
               .let -> #declare{v & {mutable = false}}
               .var -> #declare{v & {mutable = true}}
               .unqualified or undefined? ->
                  #declare{v & {mutable = false}}
         #tagscope{.back} with
            ' | ^*decls
              | ^ | assemble_pattern with
                     blocks
                     body
                     #use{.back, helper{rest}}

   #multi with
      *[new_temps each t -> #declare{t}]
      helper{reassemble}
