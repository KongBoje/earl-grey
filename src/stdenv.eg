
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" as util ->
      neighbours, zip
      uuid
   "./pattern" ->
      PatternParser, PatternProcessor
      parse_pattern, parse_clauses
   "./expand" as mt ->
      Expander, Scope, Env, nullenv ;;, bind_ast
      mac1, checker_db


provide:
   topscope
   stdenv
   expander
   expand
   stdprelude


generic_nodes = {
   .if
   .js_while, .js_for, .js_for_in, .js_label
   .js_break, .js_continue, .js_return
   .js_delete, .js_throw, .js_try, .js_new
}

class Embedded:
   constructor{code} =
      @code := mkstdenv{}.convert{code}
      @"::id" := uuid{}
   "::serialize_ast"{} =
      expand{#top, topscope, @code}


stdenv = Env{}

mkstdenv{} =
   e = Env{}
   e.scopes[.top] := stdenv.scopes[.top]
   e

expander = Expander{mkstdenv, generic_nodes}
expand = expander.expand.bind{expander}

topscope = Scope{null, .top, expander}


[{...} each k -> stdenv.bind{topscope, k, #variable{k}}] with
   "+", "-", "*", "/", "mod"
   "&.", "|.", "^."
   "and", "or", "not"
   ;; "==", "!="
   "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   .true, .false, .null, .undefined

   .typeof, .String, .Array, .Number, .Object, .RegExp, .Function
   .parseInt, .parseFloat, .Math
   .Error, .TypeError, .ReferenceError
   .console, .process, .eval

   .setTimeout, .clearTimeout

   .___js_fetch, .___node

   .arguments, .this, .exports


embed_location{match} =
   {location => {source => {=> url}, => start, => end}} ->
      '[#location{^=url, ^=start, ^=end}]
   other ->
      '[#location{null, 0, 0}]

error_embed_location{error, target} =
   '[throw [^error &: {location = ^embed_location{target}}]]

match_error{match target} =
   {location => {source => {=> url}, => start, => end}} ->
      '___match_error{^target, ^=url, ^=start, ^=end}
   other ->
      '___match_error{^other}


drop_ctx{f}{context, scope, form, arg} =
   f{context, scope, form, arg} !!
      E.match? {args => {{value => [=== context and not #expr{.expr}]}}} ->
         #nostep{form}

expr_mac{f}{match, scope, form, arg} =
   #expr{.expr} or #expr{.head} ->
      f{scope, form, arg}
   otherwise ->
      #nostep{form}


overridable{f}{match context, scope, form, arg} =
   #pattern ->
      #nostep{form}
   #expr{.multi} ->
      #nostep{form}
   other ->
      f{context, scope, form, arg}

protected_value{name, value}{match, scope, form, arg} =
   #pattern ->
      throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
   other ->
      match arg:
         #void{} ->
            #value{value}
         other ->
            #send{#value{value}, arg}


setup_label{label, env, body} =
   #bind{'break & {env = env}, #macro{break_mac{label}}
         #bind{'continue & {env = env}, #macro{continue_mac{label}}
               #js_label{#value{label}, body}}}

break_mac{default_label} = overridable with
   {context, scope, form, match expr} ->
      #void{} when default_label -> #js_break{#value{default_label}}
      #void{} -> #js_break{}
      #value{v} -> #js_break{expr}
      #symbol{v} -> #js_break{#value{v}}

continue_mac{default_label} = overridable with
   {context, scope, form, match expr} ->
      #void{} when default_label -> #js_continue{#value{default_label}}
      #void{} -> #js_continue{}
      #value{v} -> #js_continue{expr}
      #symbol{v} -> #js_continue{#value{v}}

var_operator{name} = {context, scope, form, expr} ->
   {=> env} = form
   sym = #symbol{name} & {env = env}
   match expr:
      #void{} ->
         sym
      #data{#void, match} ->
         #symbol{s} ->
            #send{sym, #value{s}}
         other ->
            #send{sym, other}

accum_flags{mac, also_values = true} =
   make{flags}{context, scope, form, match} =
      #value{flag} when also_values ->
         #macro{make{flags ++ {flag}}}
      '[. ^[#symbol{flag}]] ->
         #macro{make{flags ++ {flag}}}
      other ->
         mac{context, scope, form, other, flags}
   make{{}}

pattern_constructors = {=}


disregard_specials{#special{kind} and expr, value} =
   throw E.syntax.pattern.special with
      "Special token cannot be used here"
      {special = expr}

pattern_handlers = {

   declare_variables = {
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{v, value} =
         #do{#assign{v, value} <<: v}
      finalize = true
      declare{vars} =
         vars each v -> #declare{v}
      success{_} = #multi{}
      failure{target} =
         match_error{target}
         ;; error_embed_location{..., target} with
         ;;    'E.match{"Could not find a match for value", {value = ^target}}
   }

   build_object = {
      strings_as_variables = true
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{#symbol{v} or #value{v}, value} =
         #do{#assign{'accum[^=v], value} <<: v}
      finalize = true
      declare{vars} = {#declare{'accum, '{=}}}
      success{_} = 'accum
      failure{target} =
         match_error{target}
         ;; error_embed_location{..., target} with
         ;;    'E.match{"Could not find a match for value", {value = ^target}}
   }

}


;; Note about lbl:

;; The "for" macro rebinds break and continue to refer to its
;; own label in either the environment it is created in or in
;; the environment of the label it is given. This means,
;; roughly speaking, that break/continue in user code will
;; jump over macro-generated loops (and the macro's will jump
;; over the user's), unless the macro explicitly makes sure
;; that break/continue are redefined in the user
;; environment. To do so, we create a random label and give
;; it the same environment as the argument to "each". This
;; means "break" will jump out of "each" and not out of an
;; outer loop.

build_loop{scope, env, form, li, clauses, wrap, pre, post, opt} =
   lbl =
      if env:
         then: #value{scope.gensym{}} & {env = env}
         else: #value{scope.gensym{}}

   ;; freshenv = scope.expander.mkenv{}
   ;; i = 'i & {env = freshenv}
   ;; len = 'len & {env = freshenv}
   i = '$index & {env = env}
   len = '$length & {env = env}

   drop_ctx! first_mac{#pattern, scope, form, subp} =
      #test{'[^i === 0], subp}
   drop_ctx! last_mac{#pattern, scope, form, subp} =
      #test{'[^i === [^len - 1]], subp}

   newscope = Scope{scope}
   env.bind{newscope, "first", #macro{first_mac}}
   env.bind{newscope, "last", #macro{last_mac}}

   m = 'm <<: form ;; transfer location, for error printing purposes
   ' | ^pre
     | let [temp = ^li, ^len = temp.length]:
        for[^lbl] [^i = 0, ^i < ^len, ^i++]:
           ^m = ___js_fetch{temp, ^i}
           ^ | parse_clauses with
                newscope, m, clauses
                opt & {wrap{x} = wrap{x, i}}
     | ^post


partial_pattern{operator} =
   op =
      match operator:
         #symbol -> operator
         String? -> #variable{operator}
   {context, scope, form, expr} ->
      match {context, expr}:
         {#pattern, #data{#void{}, val}} ->
            #check{m, #ignore{}} where
               m = mac1 with {x} -> '[^op]{^x, ^val}
         {_, #void{}} ->
            op
         other ->
            #send{op, expr}

make_assigner{op}{context, scope, form, #data{a, b}} =
   #assign{a, #send{#symbol{op}, #data{a, b}}}


[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #macro{v}}] with

   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}

   "===" => partial_pattern{"==="}
   "!==" => partial_pattern{"!=="}
   "==" => partial_pattern{#symbol{"___equal"}}
   "!=" => partial_pattern{#symbol{"___nequal"}}
   "<=" => partial_pattern{"<="}
   ">=" => partial_pattern{">="}
   "<" => partial_pattern{"<"}
   ">" => partial_pattern{">"}

   "-"{context, scope, form, match expr} =
      #data{#void{}, #value{Number? n}} ->
         #value{-n}
      #void{} ->
         #variable{"-"}
      other ->
         #send{#variable{"-"}, expr}

   "++"{context, scope, form, match} =
      #data{#void{}, x} -> #send{#variable{"++"}, #data{#void{}, x}}
      #data{x, #void{}} -> #send{#variable{"++"}, #data{x, #void{}}}
      #data{x, y} -> '[^x].concat{^y}
      #void{} -> '[{x, y} -> x.concat{y}]
      other -> '[___build_array{^other}]

   ".."{context, scope, form, match} =
      #data{#void{}, x} -> 'range{1, ^x}
      #data{x, #void{}} -> 'range{^x}
      #data{x, y} -> 'range{^x, ^y}
      #void{} -> 'range

   "//"{context, scope, form, #data{a, b}} =
      'Math.floor{^a / ^b}

   "*"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #dynsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #dynsplice{val}
         {_, #void{}} ->
            #variable{"*"}
         other ->
            #send{#variable{"*"}, expr}

   "**"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #objsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #objsplice{val}
         {_, #void{}} ->
            'Math.pow
         {_, #data{a, b}} ->
            'Math.pow{^a, ^b}

   "_"{#pattern, scope, form, #void{}} =
      #ignore{}

   "not"{match, scope, form, #data{#void{}, rhs} and arg} =
      #pattern ->
         #neg{rhs}
      other ->
         #send{#variable{"not"}, arg}

   "and"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #all{lhs, rhs}
      other ->
         #send{#variable{"and"}, arg}

   "or"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #any{lhs, rhs}
      other ->
         #send{#variable{"or"}, arg}

   "when"{context, scope, form, #data{match, condition}} =
      #void{} -> #test{condition, #ignore{}}
      other -> #test{condition, other}

   "."{context, scope, form, #data{#void{}, expr}} =
      f{expr} where f{match} =
         #symbol{x} or #value{x} ->
            #value{x}
         #data{*args} ->
            #data{*[args each arg -> f{arg}]}
         other ->
            throw E.syntax.dot{"Argument to '.' must be a symbol or an array"
                               {argument = other}}

   "="{context, scope, form, expr} =

      match context:

         #expr{.multi} ->
            #data{lhs, rhs} = expr
            parse_pattern{scope, lhs, #use{scope, rhs} <<: rhs} with
               pattern_handlers.declare_variables

         #expr{.data} ->
            match expr:
               #void{} ->
                  #assoc{}
               #data{#symbol{s}, rhs} ->
                  ;; special case for the most common situation
                  #assoc{#value{s}, rhs}
               #data{lhs, rhs} ->
                  #objsplice with #multi with
                     parse_pattern{scope, lhs, #use{scope, rhs} <<: rhs} with
                        pattern_handlers.build_object

         #pattern ->
            #data{lhs, rhs} = expr
            #default{lhs, rhs}

         ;; other ->
         ;;    throw E.syntax.declare{"A variable cannot be declared at that location"}

   "=>"{match, scope, {=> env}, #data{lhs, rhs}} =
      #pattern ->
         match {lhs, rhs}:
            {#void, #symbol{k} or #value{k}} ->
               #assoc{#value{k}, #symbol{k} & {env = env}}
            {#symbol{k} or #value{k}, rhs} ->
               #assoc{#value{k}, rhs}
      #test ->
         #multi! {*stmts} = rhs
         #blocktest{lhs, stmts}
      other ->
         #assoc{lhs, rhs}

   ":="{context, scope, form, #data{lhs, rhs}} =
      #assign{lhs, rhs}

   "+=" => make_assigner{"+"}
   "-=" => make_assigner{"-"}
   "*=" => make_assigner{"*"}
   "/=" => make_assigner{"/"}
   "<<=" => make_assigner{"<<"}
   ">>=" => make_assigner{">>"}
   ">>>=" => make_assigner{">>>"}
   "++=" => make_assigner{"++"}
   "?=" => make_assigner{"match"}

   "or=" => make_assigner{"or"}
   "and=" => make_assigner{"and"}
   "each=" => make_assigner{"each"}

   "->"{match, scope, form, expr} =
      #clause ->
         #data{lhs, rhs} = expr
         #clause{lhs, rhs}
      other ->
         match expr:
            #data{#data{*args} and arg, rhs} ->
               pp = PatternParser{scope, arg, {...}} with
                  indexable = true
                  allow_nested = true
               match pp.pattern:
                  #array_pattern{fw, {}, {}, undefined?} -> ;; when not pp.specials.match ->
                     decls = if{pp.specials.match, {#declare{'ph}}, {}}
                     newargs = zip{fw, args} each {match, arg} ->
                        #assign{expr and #symbol{v}} ->
                           expr
                        other ->
                           newv = #symbol{scope.gensym{.temp}} & {env = stdenv}
                           decls.push with
                              parse_pattern{scope, arg, newv} with
                                 pattern_handlers.declare_variables & {
                                    special = {#special{match} and expr, value} ->
                                       .match ->
                                          #assign{'ph}
                                       other ->
                                          throw E.syntax.pattern.special with
                                             "Special token cannot be used here"
                                             {special = expr}
                                 }
                           newv
                     #lambda{newargs, #multi{*decls, ...}} with
                        if pp.specials.match:
                           then: '[match ph: ^rhs]
                           else: rhs
                  other ->
                     a = 'arguments <<: arg
                     #lambda{{}, body} where
                        body = ' | match.indexable [^a]:
                                    ^arg -> ^rhs

            #data{#data{*args}, rhs} ->
               #lambda{args, rhs}

            other ->
               throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

   "match" => accum_flags with {match, scope, form, expr, flags} ->
      #pattern ->
         match expr:
            #void{} -> #special{.match}
            other -> #all{other <<: expr, #special{.match} <<: form}
      other ->
         opt = util.set{flags}
         to_match = #symbol{scope.gensym{.m}} & {single_assignment = true}
         {value, body} = match expr:
            #data{#multi! {*b}} -> {#value{null}, b}
            #data{v, #multi! {*b}} -> {v, b}
         '[let [^to_match = ^value]: ^mbody] where mbody =
            parse_clauses with
               scope, to_match, body
               opt & {
                  fallback{target} =
                     match_error{target}
                     ;; error_embed_location{..., target} with
                     ;;    'E.match{"Could not find a match for value", {value = ^target}}
                  wrap = {x} -> x
               }


   "each"{match, scope, form and {=> env}, #data{li, #multi! {*clauses}}} =

      do:
         ends_with_test = false
         _build_loop{wrap, pre, post} =
            build_loop{scope, env, form, li, clauses
                       wrap, pre, post
                       {...}} with
               wrap_pattern{x, toplevel} =
                  ends_with_test :=
                     match x:
                        #test -> toplevel
                        other -> false
                  x
               fallback{target} =
                  if ends_with_test:
                     then: 'false
                     else: match_error{target}

      #test ->
         #test_factory{li, clauses} & {env = env}

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.
         _build_loop{{x} -> x, #splice{}, #splice{}}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.
         _build_loop{{x} -> 'acc.push{^x}, '[acc = {}], 'acc}


   "each?"{match, scope, form and {=> env}, #data{li, #multi! {*clauses}}} =

      #test ->
         #test_factory{li, clauses} & {env = env}

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.
         build_loop{scope, env, form, li, clauses
                    {x} -> x, #splice{}, #splice{}
                    {fallback = {target} -> 'false}}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.
         build_loop{scope, env, form, li, clauses
                    {x} -> 'acc.push{^x}, '[acc = {}], 'acc
                    {fallback = {target} -> 'false}}


   "!!"{match, scope, form, #data{expr, #multi! {*clauses}}} =
      #expr{.multi} ->
         #nostep{form}
      #expr{.ignore} ->
         clauses.push with
            mkstdenv{}.convert{'[e -> throw e]}
         #js_try{expr, ..., #void{}} with
            ' | {excv} ->
                 ^ | parse_clauses with
                      scope, 'excv, clauses
                      {wrap = {x} -> x}
      other ->
         clauses.push with
            mkstdenv{}.convert{'[e -> throw e]}
         ' | let [rval = false]:
              ^ #js_try{'[rval := ^expr], ..., #void{}} with
                 ' | {excv} ->
                      ^ | parse_clauses with
                           scope, 'excv, clauses
                           {wrap = {x} -> '[rval := ^x]}
              rval

   "@" => var_operator{expander.gensym{"it"}}

   expr_mac! "chain"{scope, form, #data{defn and {=> env}, #multi! {*body}}} =
      it = '[@] & {env = env}
      construct{match} =
         {x} -> x
         {x, *rest} ->
            ' | let [^it = ^x]:
                 ^construct{rest}
      construct{{defn} ++ body}

   expr_mac! "using"{scope, form, #data{defn and {=> env}, body}} =
      it = '[@] & {env = env}
      ' | let [^it = ^defn]:
           ^body

   overridable! "do"{match, scope, form, #data{body}} =
      #clause ->
         #block{body}
      #test ->
         #multi! {*stmts} = body
         #do{#splice{*stmts}}
      #expr ->
         #multi{body}

   ;; ifneeded{match, scope, form, #data{yes, no}} =
   ;;    #expr{match} ->
   ;;       x ->
   ;;          <> x
   ;;          yes
   ;;       .multi -> #nostep{form}
   ;;       .ignore -> no
   ;;       other -> yes
   ;;    other ->
   ;;       <> other
   ;;       yes

   expr_mac! "if"{scope, form, match} =
      #data{test, a, b} ->
         #if{test, a, b}
      #data{test, #multi! {*match}} ->
         {'then{^a}} ->
            #if{test, a, #value{undefined}}
         {'then{^a}, 'else{^b}} ->
            #if{test, a, b}
         {*s1, 'else{^b}} ->
            #if{test, #multi{*s1}, b}
         other ->
            #if{test, #multi{*other}, #value{undefined}}

   expr_mac! "while"{scope, form, match {=> env}} =
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{test, body}} ->
            setup_label{label, env, #js_while{test, body}}
      #data{test, body} ->
         setup_label{scope.gensym{}, env, #js_while{test, body}}

   "for"{context, scope, form, match expr} =
      do: setup_for{label, env, match, body} =
         #multi{a, b, c} ->
            #multi with
               a
               setup_label{label, env, #js_for{#multi{}, b, c, body}}
         '[^a in ^b] ->
            #multi with
               #declare{a, #value{null}} ;; this is to show the symbol as resolved
               setup_label{label, env, #js_for_in{a, b, body}}
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{spec, body}} ->
            setup_for{label, expr.env, spec, body}
      #data{spec, body} ->
         setup_for{scope.gensym{}, form.env, spec, body}

   expr_mac! "let"{scope, form, #data{#multi! {*bindings}, body}} =
      construct{match} =
         {} -> body
         {x, *xs} ->
            #multi{x, construct{xs}} & {nonrecursive = true}
      construct{bindings}
      ;; #multi{*bindings, body} & {nonrecursive = true}

   expr_mac! "letrec"{scope, form, #data{#multi! {*bindings}, body}} =
      #multi{*bindings, body}

   "where"{context, scope, form, #data{body, bindings}} =
      'letrec{^bindings, ^body}

   "break" => break_mac{null}

   "continue" => continue_mac{null}

   expr_mac! "throw"{scope, form, arg} =
      #js_throw{arg}

   expr_mac! "return"{scope, form, arg} =
      #js_return{arg}

   expr_mac! "new"{scope, form, arg} =
      #js_new{arg}

   expr_mac! "delete"{scope, form, arg} =
      #js_delete{arg}

   "?"{context, scope, form, #data{expr, #void{}}} =
      checker = match expr:
         'String -> checker_db.String
         'Number -> checker_db.Number
         'true -> checker_db.true
         'false -> checker_db.false
         'null -> checker_db.null
         'undefined -> checker_db.undefined
         other -> '___checker{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #check{checker, #ignore{}}
               other ->
                  #check{checker, expr}
         other -> '[^checker]{^expr}

   "!"{context, scope, form, #data{expr, #void{}}} =
      projector = match expr:
         'String -> mac1 with {x} -> '{true, String{^x}}
         'Number -> mac1 with {x} -> '{true, parseFloat{^x}}
         other -> '___projector{^expr}

      #macro{...} with {match, env, form, expr} ->
         #pattern ->
            match expr:
               #void{} ->
                  #project{projector, #ignore{}}
               other ->
                  #project{projector, expr}
         other -> '[^projector]{^expr}[1]

   "#"{context, scope, form, #data{#void{}, #symbol{tag}}} =
      tag := #value{tag}
      #macro{f} where f{match, scope, form, expr} =
         #pattern ->
            checker_mac = #macro with {context, scope, form, #data{expr}} ->
               ' | let [x = ^expr]:
                    [x instanceof Array and x[0] === ^tag]
            match expr:
               #data{*subp} -> '{^tag, ^*subp}
               #void{} -> #check{checker_mac, #ignore{}}
               other -> #check{checker_mac, expr}
         _ ->
            match expr:
               #void{} ->
                  '{^tag}
               #data{*args} ->
                  '{^tag, ^*args}
               other ->
                  '{^tag}[^other]
                  ;; throw E.syntax"#" with
                  ;;    "Illegal argument for #"
                  ;;    {form = form
                  ;;     argument = expr}

   "require"{context, scope, form, #data{expr}} =

      req = #variable{.require}
      stmts = {}

      topfetch{pkg, v} =
         stmts.push with '[^v = [^req]{^pkg}]
         v

      produce{match expr, fetch} =

         #symbol{s} ->
            fetch{#value{s}, expr}

         #value{String? s} ->
            fetch{expr, #symbol{scope.gensym{}}}

         #multi{*subp} or #data{*subp} ->
            subp each p -> produce{p, fetch}

         #send{#symbol{"^"}, #data{#void{}, name}} ->
            fetch{name, #symbol{scope.gensym{}}}

         #send{#symbol{"as"}, #data{pkg, s}} ->
            produce{pkg} with {the_pkg, _} ->
               fetch{the_pkg, s}

         #send{#symbol{"->"}, #data{pkg, subp}} ->
            pkgv = produce{pkg, fetch}
            produce{subp} with {pkg, v} ->
                stmts.push with '[^v = ^pkgv ^pkg]

      produce{expr, topfetch}
      #splice{*stmts}

   "provide"{context, scope, form, #data{#multi! {*expr}}} =
      #sink with
         #multi ++
            expr each
               s and #symbol{name} ->
                  '[exports[^=name] := ^s]
               '[^s as ^[#symbol{name} or #value{name}]] ->
                  '[exports[^=name] := ^s]
               other ->
                  throw E.syntax.provide with
                     "Each clause of provide must be 'sym' or 'sym as name'"

   "class"{context, scope, {=> env}, expr} =

      helper{name, stmts} =
         statics = #data{'[=]}
         ctor = {#data{}, #multi{} & {env = env}}
         new_stmts = stmts each
            #send{'static, #data{#multi! {*methods}}} ->
               statics ++= methods
            '[constructor[^args] = ^body] or '[constructor = ^args -> ^body] ->
               ctor := {args, body}
               #splice{}
            '[^lhs = ^rhs] ->
               parse_pattern{scope, lhs, rhs} with
                  pattern_handlers.build_object & {
                     allow_nested = false
                     assign{#symbol{v} or #value{v}, value} =
                        #do{#assign{'[^name].prototype[^=v], value} <<: v}
                     declare{vars} = {}
                     wrap_target{match} =
                        '[^args -> ^body] ->
                           {=> env} = body
                           it = #symbol{"@"} & {env = env}
                           ' | ^args ->
                                let [^it = this]:
                                   ^body
                        other ->
                           other
                     success{_} = #splice{}
                  }

         {ctor_args, ctor_body} = ctor
         ctor_body :=
            {env => env2} = ctor_body
            it = #symbol{"@"} & {env = env2}
            ' | let [^it = if{not [^name]? this, Object.create{[^name].prototype}, this}]:
                 ^ctor_body
                 ^it

         node =
            #splice with
               ' | ^name = ^ctor_args -> ^ctor_body
               ' | ^*new_stmts
               ' | [^name] &: ^statics
               ' | ^name
         match context:
            #expr{.multi} -> node
            other -> #multi{node}

      match expr:
         #data{name, #multi! {*stmts}} ->
            helper{name, stmts}
         #data{#multi! {*stmts}} ->
            helper{#symbol{scope.gensym{}}, stmts}


   "%"{context, scope, form, #data{descr, contents}} =
      tags = #data{}

      parse{match} =
         #void{} -> null
         #symbol{s} -> tags.push with #value{"+" + s}
         #value{x} ->
            tags.push with #value{"+" + x}
         #send{#symbol{"."}, #data{#void{}, #symbol{x} or #value{x}}} ->
            tags.push with #value{x}
         #send{#symbol{"#"}, #data{#void{}, #symbol{x} or #value{x}}} ->
            tags.push with #value{"#" + x}
         #send{#symbol{"="}, #data{#symbol{prop} or #value{prop}, value}} ->
            tags.push with '[#assoc{^=prop, ^value}]
         #send{expr, rest} ->
            parse{expr}, parse{rest}
         #multi{*args} or #data{*args} ->
            args.forEach{parse}

      parse{descr}
      contents ?=
         #void{} -> #data{}
         #multi{*args} -> #data{*args}
         x -> x

      'Node{^tags, ^contents}


   "globals"{context, scope, form, #data{#multi! {*vars}}} =
      #splice{* ...} with
         vars each var and #symbol{s} -> #declare_raw{var, #variable{s}}



blocktest_wrap{expr} =
   ' | value = [[...] !! e -> #error{e}] with
        match [^expr]:
           true? x -> #success{x}
           false? x -> #failure{x}
     | acc.push with
        #test_result{label, value}

blocktest_mac{scope, tests} =

   exptests = enumerate{scope.step_all{#test, tests}}
   n = exptests.length
   stmts = exptests each

      {i, #do{stmt}} ->
         stmt

      {i, #blocktest{more_labels, more_tests}} ->
         ' | let [label = label.concat{Array! ^more_labels}]:
              acc := acc.concat with
                 ^blocktest_mac{scope, more_tests}

      {i, #test_factory{elements, clauses} and {=> env}} ->
         build_loop{scope, env, #void{}
                    elements, clauses, wrap, #splice{}, #splice{}
                    {fallback = fall}} where
            wrap{expr, index} =
               ' | let [label = label.concat{{^index}}]:
                    ^blocktest_wrap{expr}
            fall{target} =
               match_error{target}

      {i, expr} ->
         lbl = if{n === 1, '{}, '{^=i}}
         ' | let [label = label.concat{^lbl}]:
              ^blocktest_wrap{expr}

   ' | let [acc = {}]:
        [[...] !! e -> acc.concat{{#error{label, e}}}] with
           [^*stmts, acc]


stdenv.bind{topscope, "blocktest", #macro{...}} with
   {context, scope, form, #data{*args}} ->
      match args:
         {#multi! {*tests}} ->
            ' | label = {}
              | ^blocktest_mac{scope, tests}
         {labels, #multi! {*tests}} ->
            ' | label = Array! ^labels
              | ^blocktest_mac{scope, tests}


qqstruct{name, args} =
   #data{#value{name}, *args}

qq{match expr} =
   #symbol{s} -> qqstruct{.symbol, {#value{s}}}
   #void{} -> qqstruct{.void, {}}
   #value{v} ->
      qqstruct{.value, {expr}}
   #send{#symbol{"^"}, #data{#void{}, insert}} ->
      insert
   #send{#symbol{"^="}, #data{#void{}, insert}} ->
      qqstruct{.value, {insert}}
   #send{#symbol{"^*"}, #data{#void{}, insert}} ->
      '[* ^insert]
   {name, *args} ->
      qqstruct{name, args each arg -> qq{arg}}

stdenv.bind{topscope, "'", #macro{...}} with
   {context, scope, form, #data{#void{}, expr}} ->
      qq{expr}



class RegexBuilder:

   wrap{x} =
      "(?:" + x + ")"

   quote{x} =
      x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

   quote_charset{x} =
      x.replace{R.g'{in "[](){}^"}, "\\$1"}

   build{expr} =
      match expr:
         #symbol{match} ->
            .any -> "."
            .start -> "^"
            .end -> "$"
            .alpha -> "\\a"
            .digit -> "\\d"
            .word -> "\\w"
            .space -> "\\s"
            .boundary -> "\\b"
            .a -> "\\a"
            .d -> "\\d"
            .w -> "\\w"
            .s -> "\\s"
            .b -> "\\b"

         #value{x} -> @quote{x}

         #send{#symbol{"raw"}, #value{s}} ->
             s

         #send{#symbol{match}, #data{a, b}} ->
            "||" ->
               @wrap{@build{a} + "|" + @build{b}}
            "or" ->
               @wrap{@build{a} + "|" + @build{b}}
            "*" ->
               #void{} = a
               @wrap{@build{b} + "*"}
            "+" ->
               #void{} = a
               @wrap{@build{b} + "+"}
            "?" ->
               #void{} = a
               @wrap{@build{b} + "?"}
            "in" ->
               #void{} = a
               #value{v} = b
               ["[" + x + "]"] where
                  x = @quote_charset{v}
            "not" ->
               #void{} = a
               #send{#symbol{"in"}, #data{#void{}, #value{v}}} = b
               ["[^" + x + "]"] where
                  x = @quote_charset{v}

         #data{*args} ->
            "(" + [args each arg -> @build{arg}].join{""} + ")"
         #multi{*args} ->
            "(?:" + [args each arg -> @build{arg}].join{""} + ")"

         other ->
            E.syntax.regexp with
               "Illegal regular expression"
               {expr = expr}

build_regexp{x} = RegexBuilder{}.build{x}

stdenv.bind{topscope, "R", #macro{accum_flags{mac, false}}} where
   mac{context, scope, form, match, flags} =
      #value{String? v} ->
         'RegExp{^=v, ^=[flags.join{""}]}
      #send{#symbol{"'"}, #data{#void{}, arg}} ->
         'RegExp{^=build_regexp{arg}, ^=[flags.join{""}]}
         ;; #value{rx} where
         ;;    rx = RegExp{build_regexp{arg}, [flags.join{""}]}


errf_macro{tags}{context, scope, form, match} =
   #void{} ->
      'ErrorFactory{{^*tags}}
   #data{*args} ->
      'ErrorFactory{{^*tags}}.create{^*args}
   other ->
      #macro with errf_macro{tags ++ {other}}

stdenv.bind{topscope, "E", #macro{errf_macro{{}}}}





[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #value{v}}] with

   "___build_array" => Embedded with '
      {arrays} ->
         results = {}
         arrays each a -> results := results.concat{a}
         results

   "items" => Embedded with '
      {obj} ->
         results = {}
         for [k in obj]:
            if Object.prototype.hasOwnProperty.call{obj, k}:
               results.push with {k, obj[k]}
         results

   "keys" => Embedded with '
      {obj} ->
         results = {}
         for [k in obj]:
            if Object.prototype.hasOwnProperty.call{obj, k}:
               results.push with k
         results

   "enumerate" => Embedded with '
      {arr} ->
         results = {}
         l = arr.length
         for [i = 0, i < l, i++]:
            results.push with {i, arr[i]}
         results

   "zip" => Embedded with '
      {xs, ys} ->
         enumerate{xs} each {i, x} ->
            {x, ys[i]}

   "predicate" => Embedded with '
      {f} ->
         f["::check"] := f
         f

   "___nequal" => Embedded with '
      {x, y} -> not [x == y]

   "___equal" => Embedded with '
      {match a, b} ->
         === b ->
            true
         Number? or String? or null? or undefined? ->
            false
         Array? ->
            if [not Array? b or a.length !== b.length]:
               return false
            for [i = 0, i < a.length, i++]:
               if [not [___js_fetch{a, i} == ___js_fetch{b, i}]]:
                  return false
            true
         when [Object.getPrototypeOf{a} === Object.prototype
               \ and Object.getPrototypeOf{b} === Object.prototype] ->
            ka = keys{a}
            if [not [ka.sort{} == keys{b}.sort{}]]:
               return false
            ka each k ->
               if [not [___js_fetch{a, k} == ___js_fetch{b, k}]]:
                  return false
            true
         {"::serialize" => _} ->
            match b:
               {"::serialize" => _} ->
                  a["::serialize"]{} == b["::serialize"]{}
               otherwise ->
                  false
         otherwise ->
            false

   "&:" => Embedded with '
      {dest, values} ->
         for [k in values]:
            if values.hasOwnProperty{k}:
               dest[k] := ___js_fetch{values, k}
         dest

   ;; "&+" => Embedded with '
   ;;    {a, b} ->
   ;;       dest = {=}
   ;;       for [k in a]:
   ;;          if a.hasOwnProperty{k}:
   ;;             dest[k] := ___js_fetch{a, k}
   ;;       for [k in b]:
   ;;          if b.hasOwnProperty{k}:
   ;;             dest[k] := ___js_fetch{b, k}
   ;;       dest

   "&" => Embedded with '
      {a, b} ->
         dest = clone{a}
         for [k in b]:
            if Object.prototype.hasOwnProperty.call{b, k}:
               dest[k] := ___js_fetch{b, k}
         dest

   "&+" => Embedded with '
      {a, b} ->
         dest = clone{a}
         for [k in b]:
            if Object.prototype.hasOwnProperty.call{b, k}:
               dest[k] := ___js_fetch{b, k}
         dest

   "clone" => Embedded with '
      {match x} ->
         undefined? or null? or String? or Number? ->
            x
         {"::clone" => _} ->
            x["::clone"]{}
         when Object.getPrototypeOf{x} === Object.prototype ->
            dest = {=}
            for [k in x]:
               if Object.prototype.hasOwnProperty.call{x, k}:
                  dest[k] := ___js_fetch{x, k}
            dest
         other ->
            throw E.clone{"Object cannot be cloned", {obj = x}}

   "___checker" => Embedded with '
      {type} ->
         f = type["::check"]
         if [f === undefined]:
            then: {value} -> value instanceof type
            else: {value} -> f.call{type, value}

   "___projector" => Embedded with '
      {type} -> {value} ->
         f = type[":::project"]
         if [f === undefined]:
            then:
               f = type["::project"]
               if [f === undefined]:
                  then: {true, type{value}}
                  else: {true, f{value}} !! e -> {false, null}
            else:
               f.call{type, value}

   "___hasprop" => Embedded with '
      {match, key} ->
         null? or undefined? -> false
         String? x -> key in String.prototype
         Number? x -> key in Number.prototype
         x -> key in x

   "range" => Embedded with '
      {from, to} ->
         rval = {}
         for [i = from, i <= to, i++]:
            rval.push{i}
         rval

   "___serialize_ast" => Embedded with '
      {match} ->
         String? x or Number? x ->
            #value{x}
         other ->
            other["::serialize_ast"]{}

   "___match_error" => Embedded with '
      {value, url, start, end} ->
         err = E.match{"Could not find a match for value", {value = value}}
         if url:
            err.location := #location{url, start, end}
         throw err


   "ErrorFactory" => Embedded with '
      class:

         constructor{tags} =
            @tags := tags

         create{message = "", *args} =
            e = Error{message}
            e["::tags"] := @tags
            e.args := args
            e.name := [{.E} ++ @tags].join{"."}
            e

         "::check"{e} =
            if [not e or not Error? e]:
               return false
            tags = e["::tags"] or {}
            @tags each? tag when tags.indexOf{tag} === -1 ->
               return false
            true

         "::deconstruct"{e} =
            e.args


   "Node" => Embedded with '
      class:
         static:
            "::check"{x} =
               x and x.classes and x.children
            "::deconstruct"{x} =
               {x.classes, x.children}

         constructor{Array! classes, Array! children} =
            @classes := classes.sort{}
            @children := children

         "::check"{n} =
            @classes each? c when n.classes.indexOf{c} === -1 ->
               return false
            true


stdprelude = Embedded with '

   send{obj, match msg} =
      [String? or Number?] -> ___js_fetch{obj, msg}
      other -> obj["::send"]{msg}

   Array[":::project"] := {match value} ->
      Array? -> {true, value}
      _ -> {true, {value}}

   Array.prototype["::check"] := {value} ->
      if [value instanceof Array]:
         then:
            for [i = 0, i < this.length, i++]:
               if [this[i] !== value[i]]:
                  return false
            true
         else:
            false

   Array.prototype["::clone"] := {} ->
      this.slice{0}

   Array.prototype[":::project"] := {value} ->
      if [value instanceof Array]:
         then:
            for [i = 0, i < this.length, i++]:
               if [this[i] !== value[i]]:
                  return {true, {value}}
            {true, value.slice{this.length}}
         else:
            {true, {value}}

   Array.prototype["::serialize_ast"] := {} ->
      #array{*this.map{___serialize_ast}}

   RegExp.prototype["::check"] := {value} ->
      value.match{this}

   RegExp.prototype[":::project"] := {value} ->
      match value.match{this}:
         null? m -> {false, null}
         m -> {true, m}

   Function.prototype["::send"] := {args} ->
      this.apply{this, args}

   ;; Error.prototype["::clone"] := {} ->
   ;;    e = Error{this.message}
   ;;    e.message := this.message
   ;;    e.stack := this.stack
   ;;    e.name := this.name
   ;;    items{this} each {k, v} ->
   ;;       e[k] := v
   ;;    e


expander.utils := {
   var_operator = var_operator
}

