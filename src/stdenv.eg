
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" as util ->
      GenSym
      neighbours
      classify_contiguous
      Body
   "./pattern" ->
      PatternParser, PatternProcessor
      parse_pattern, parse_clauses
   "./expand" as mt ->
      Expander, Scope, Env, nullenv ;;, bind_ast
      mac1, checker_db


provide:
   topscope
   stdenv
   expander
   expand
   stdprelude


generic_nodes = {
   .if
   .js_while, .js_for, .js_for_in, .js_label
   .js_break, .js_continue, .js_return
   .js_delete, .js_throw, .js_try, .js_new
}


mkid = GenSym{"#"}


class Embedded:
   constructor{code} =
      @code = mkstdenv{}.mark{code}
      @"::id" = mkid{}
   "::serialize_ast"{} =
      expand{#top, topscope, @code}


stdenv = Env{}

mkstdenv{} =
   e = Env{}
   e.scopes[.top] = stdenv.scopes[.top]
   e

expander = Expander{mkstdenv, generic_nodes}
expand = expander.expand.bind{expander}

topscope = Scope{null, .top, expander}


[{...} each k -> stdenv.bind{topscope, k, #variable{k} & {mutable = false, assigned = true}}] with
   "+", "-", "*", "/", "mod"
   "&.", "|.", "^."
   "and", "or", "not"
   ;; "==", "!="
   "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   .true, .false, .null, .undefined

   .typeof
   .String, .Array, .Number, .Boolean, .Object
   .RegExp, .Function, .Date
   .parseInt, .parseFloat, .Math
   .Error, .TypeError, .ReferenceError
   .console, .process, .eval

   .setTimeout, .clearTimeout
   .setInterval, .clearInterval

   .___js_fetch, .___node

   .arguments, .this, .exports
   .global

stdenv.bind{topscope, .pass, #variable{.undefined}}


embed_location{match} =
   {location => {source => {=> url}, => start, => end}} ->
      '[#location{^=url, ^=start, ^=end}]
   other ->
      '[#location{null, 0, 0}]

error_embed_location{error, target} =
   '[throw [^error &: {location = ^embed_location{target}}]]

match_error{match target} =
   {location => {source => {=> url}, => start, => end}} ->
      '___match_error{^target, ^=url, ^=start, ^=end}
   other ->
      '___match_error{^other}


drop_ctx{f}{context, scope, form, arg} =
   f{context, scope, form, arg} !!
      E.match? {args => {{value => [=== context and not #expr{.expr}]}}} ->
         #nostep{form}

expr_mac{f}{match, scope, form, arg} =
   #expr{.expr} or #expr{.head} ->
      f{scope, form, arg}
   otherwise ->
      #nostep{form}


overridable{f}{match context, scope, form, arg} =
   #pattern ->
      #nostep{form}
   #expr{.multi} ->
      #nostep{form}
   other ->
      f{context, scope, form, arg}

protected_value{name, value}{match, scope, form, arg} =
   #pattern ->
      throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
   other ->
      match arg:
         #void{} ->
            #value{value}
         other ->
            #send{#value{value}, arg}


setup_label{label, env, body} =
   #bind{'break & {env = env}, #macro{break_mac{label}}
         #bind{'continue & {env = env}, #macro{continue_mac{label}}
               #js_label{#value{label}, body}}}

break_mac{default_label} = overridable with
   {context, scope, form, match expr} ->
      #void{} when default_label -> #js_break{#value{default_label}}
      #void{} -> #js_break{}
      #value{v} -> #js_break{expr}
      #symbol{v} -> #js_break{#value{v}}

continue_mac{default_label} = overridable with
   {context, scope, form, match expr} ->
      #void{} when default_label -> #js_continue{#value{default_label}}
      #void{} -> #js_continue{}
      #value{v} -> #js_continue{expr}
      #symbol{v} -> #js_continue{#value{v}}

var_operator{name} = {context, scope, form, expr} ->
   {=> env} = form
   sym = #symbol{name} & {env = env}
   match expr:
      #void{} ->
         sym
      #data{#void, match} ->
         #symbol{s} ->
            #send{sym, #value{s}}
         other ->
            #send{sym, other}

accum_flags{mac, also_values = true} =
   make{flags}{context, scope, form, match} =
      #value{flag} when also_values ->
         #macro{make{flags ++ {flag}}}
      '[. ^[#symbol{flag}]] ->
         #macro{make{flags ++ {flag}}}
      other ->
         mac{context, scope, form, other, flags}
   make{{}}

pattern_constructors = {=}


disregard_specials{#special{kind} and expr, value} =
   throw E.syntax.pattern.special with
      "Special token cannot be used here"
      {special = expr}

pattern_handlers = {

   declare_variables = {
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{match v, value} =
         #symbol{name} ->
            #do{#assign{v, value &: {name = name}} <<: v}
         v ->
            #do{#assign{v, value} <<: v}
      finalize = true
      tags = {declare_mode = .unqualified}
      declare{scope, vars} =
         vars each v ->
            match v.declare_mode:
               .set -> #splice{}
               .let -> #declare{v & {mutable = false}}
               .var -> #declare{v & {mutable = true}}
               .unqualified ->
                  #declare{v & {mutable = false, use_previous = true}}
                  ;; match v.env.resolve{scope, v[1]}:
                  ;;    undefined? ->
                  ;;       #declare{v & {mutable = false}}
                  ;;    {mutable => true?} ->
                  ;;       #splice{}
                  ;;    other ->
                  ;;       throw E.syntax.redeclaring{msg, {variable = v}} where
                  ;;          msg = "Variable was declared read-only. Declare with 'var' to make it mutable."
      success{_} = #multi{}
      failure{target} =
         match_error{target}
         ;; error_embed_location{..., target} with
         ;;    'E.match{"Could not find a match for value", {value = ^target}}
   }

   build_object = {
      strings_as_variables = true
      allow_nested = true
      allow_arguments = true
      special = disregard_specials
      assign{#symbol{v} or #value{v}, value, _} =
         #do{#assign{'accum[^=v], value} <<: v}
      finalize = true
      declare{scope, vars} =
         {#declare{'accum, '{=}}}
      success{_} = 'accum
      failure{target} =
         match_error{target}
         ;; error_embed_location{..., target} with
         ;;    'E.match{"Could not find a match for value", {value = ^target}}
   }

}


;; Note about lbl:

;; The "for" macro rebinds break and continue to refer to its
;; own label in either the environment it is created in or in
;; the environment of the label it is given. This means,
;; roughly speaking, that break/continue in user code will
;; jump over macro-generated loops (and the macro's will jump
;; over the user's), unless the macro explicitly makes sure
;; that break/continue are redefined in the user
;; environment. To do so, we create a random label and give
;; it the same environment as the argument to "each". This
;; means "break" will jump out of "each" and not out of an
;; outer loop.

build_loop{scope, env, form, li, clauses, wrap, pre, post, opt} =
   lbl =
      if env:
         then: #value{scope.gensym{}} & {env = env}
         else: #value{scope.gensym{}}

   ;; freshenv = scope.expander.mkenv{}
   ;; i = 'i & {env = freshenv}
   ;; len = 'len & {env = freshenv}
   i = '$index & {env = env}
   len = '$length & {env = env}

   drop_ctx! first_mac{#pattern, scope, form, subp} =
      #test{'[^i === 0], subp}
   drop_ctx! last_mac{#pattern, scope, form, subp} =
      #test{'[^i === [^len - 1]], subp}

   newscope = Scope{scope}
   env.bind{newscope, "first", #macro{first_mac}}
   env.bind{newscope, "last", #macro{last_mac}}

   m = 'm <<: form ;; transfer location, for error printing purposes
   ' | ^pre
     | let [temp = ^li, ^len = temp.length]:
        for[^lbl] [var ^i = 0, ^i < ^len, ^i++]:
           ^m = ___js_fetch{temp, ^i}
           ^ | parse_clauses with
                newscope, m, clauses
                opt & {wrap{x} = wrap{x, i}}
     | ^post


partial_pattern{operator} =
   op =
      match operator:
         #symbol -> operator
         String? -> #variable{operator}
   {context, scope, form, expr} ->
      match {context, expr}:
         {#pattern, #data{#void{}, val}} ->
            #check{m, #ignore{}} where
               m = mac1 with {x} -> '[^op]{^x, ^val}
         {_, #void{}} ->
            op
         other ->
            #send{op, expr}

make_assigner{op}{context, scope, form, #data{a, b}} =
   #assign{a, #send{#symbol{op}, #data{a, b}}}


[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #macro{v}}] with

   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}

   "===" => partial_pattern{"==="}
   "!==" => partial_pattern{"!=="}
   "==" => partial_pattern{#symbol{"___equal"}}
   "!=" => partial_pattern{#symbol{"___nequal"}}
   "<=" => partial_pattern{"<="}
   ">=" => partial_pattern{">="}
   "<" => partial_pattern{"<"}
   ">" => partial_pattern{">"}

   "-"{context, scope, form, match expr} =
      #data{#void{}, #value{Number? n}} ->
         #value{-n}
      #void{} ->
         #variable{"-"}
      other ->
         #send{#variable{"-"}, expr}

   "++"{context, scope, form, match} =
      #data{#void{}, x} -> #send{#variable{"++"}, #data{#void{}, x}}
      #data{x, #void{}} -> #send{#variable{"++"}, #data{x, #void{}}}
      #data{x, y} -> '[^x].concat{^y}
      #void{} -> '[{x, y} -> x.concat{y}]
      other -> '[___build_array{^other}]

   ".."{context, scope, form, match} =
      #data{#void{}, x} -> 'range{1, ^x}
      #data{x, #void{}} -> 'range{^x}
      #data{x, y} -> 'range{^x, ^y}
      #void{} -> 'range

   "//"{context, scope, form, #data{a, b}} =
      'Math.floor{^a / ^b}

   "*"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #dynsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #dynsplice{val}
         {_, #void{}} ->
            #variable{"*"}
         other ->
            #send{#variable{"*"}, expr}

   "**"{context, scope, form, expr} =
      match {context, expr}:
         {#pattern, #void{}} ->
            #objsplice{#ignore{}}
         {#pattern or #expr{.data}, #data{#void{}, val}} ->
            #objsplice{val}
         {_, #void{}} ->
            'Math.pow
         {_, #data{a, b}} ->
            'Math.pow{^a, ^b}

   "_"{#pattern, scope, form, #void{}} =
      #ignore{}

   "else"{match, scope, form, _} =
      #pattern ->
         #ignore{}
      else ->
         throw E.syntax.else{msg, {node = form}} where
            msg = "'else' should be found inside an 'if' block"

   "not"{match, scope, form, #data{#void{}, rhs} and arg} =
      #pattern ->
         #neg{rhs}
      other ->
         #send{#variable{"not"}, arg}

   "and"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #all{lhs, rhs}
      other ->
         #send{#variable{"and"}, arg}

   "or"{match, scope, form, #data{lhs, rhs} and arg} =
      #pattern ->
         #any{lhs, rhs}
      other ->
         #send{#variable{"or"}, arg}

   "when"{context, scope, form, #data{match, condition}} =
      #void{} -> #test{condition, #ignore{}}
      other -> #test{condition, other}

   "."{context, scope, form, #data{#void{}, expr}} =
      f{expr} where f{match} =
         #symbol{x} ->
            #value{x}
         #data{*args} ->
            #data{*[args each arg -> f{arg}]}
         other ->
            throw E.syntax.dot{"Argument to '.' must be a symbol or an array"
                               {argument = other}}

   "="{context, scope, form, expr} =

      match context:

         #pattern ->
            #data{lhs, rhs} = expr
            #default{lhs, rhs}

         #expr{.data} ->
            match expr:
               #void{} ->
                  #assoc{}
               #data{#symbol{s}, rhs} ->
                  ;; special case for the most common situation
                  #assoc{#value{s}, rhs}
               #data{lhs, rhs} ->
                  #objsplice with #multi with
                     parse_pattern{scope, lhs, #use{scope, rhs} <<: rhs} with
                        pattern_handlers.build_object

         ;; #expr{.multi} ->
         other ->
            #data{lhs, rhs} = expr
            parse_pattern{scope, lhs, #use{scope, rhs} <<: rhs} with
               pattern_handlers.declare_variables

         ;; other ->
         ;;    throw E.syntax.declare{"A variable cannot be declared at that location"}

   "=>"{match, scope, {=> env}, #data{lhs, rhs}} =
      #pattern ->
         match {lhs, rhs}:
            {#void, #symbol{k} or #value{k}} ->
               #assoc{#value{k}, [#symbol{k} <<: rhs] & {env = env}}
            {#symbol{k} or #value{k}, rhs} ->
               #assoc{#value{k}, rhs}
      #test ->
         Body! {*stmts} = rhs
         #blocktest{lhs, stmts}
      other ->
         #assoc{lhs, rhs}

   ":="{context, scope, form, #data{lhs, rhs}} =
      #assign{lhs, rhs}

   "+=" => make_assigner{"+"}
   "-=" => make_assigner{"-"}
   "*=" => make_assigner{"*"}
   "/=" => make_assigner{"/"}
   "<<=" => make_assigner{"<<"}
   ">>=" => make_assigner{">>"}
   ">>>=" => make_assigner{">>>"}
   "++=" => make_assigner{"++"}
   "?=" => make_assigner{"match"}

   "or=" => make_assigner{"or"}
   "and=" => make_assigner{"and"}
   "each=" => make_assigner{"each"}


   "_lambda"{context, scope, form, #data{#data{*args} and arg, pre, body, post}} =
      wrap{body2} =
         if{pre == #value{null}, body3, #multi{pre, body3}} where
            body3 = if{post == #value{null}, body2, #multi{body2, post}}
      pp = PatternParser{scope, arg, {...}} with
         indexable = true
         allow_nested = true
      match pp.pattern:
         #array_pattern{fw, {}, {}, undefined?} -> ;; when not pp.specials.match ->
            decls = if{pp.specials.match, {#declare{'ph}}, {}}
            newargs = zip{fw, args} each {match, arg} ->
               #assign{expr and #symbol{v}} ->
                  expr
               other ->
                  newv = #symbol{scope.gensym{.temp}} & {env = stdenv}
                  decls.push with
                     parse_pattern{scope, arg, newv} with
                        pattern_handlers.declare_variables & {
                           tags = {declare_mode = .let}
                           special = {#special{match} and expr, value} ->
                              .match ->
                                 #assign{'ph}
                              other ->
                                 throw E.syntax.pattern.special with
                                    "Special token cannot be used here"
                                    {special = expr}
                        }
                  newv
            #lambda{newargs, wrap{#multi{*decls, ...}}} with
               if pp.specials.match:
                  then: '[match ph: ^body]
                  else: body
         other ->
            a = 'arguments <<: arg
            #lambda{{}, wrap{body2}} where
               body2 = ' | match.indexable [^a]:
                            ^arg -> ^body


   "->"{match, scope, form, expr} =
      do:
         if form.name:
            console.log with form.name
      #clause ->
         #data{lhs, rhs} = expr
         #clause{lhs, rhs}
      other ->
         match expr:
            #data{args, body} ->
               '_lambda{^args, ^=null, ^body, ^=null}

            ;; #data{#data{*args} and arg, rhs} ->
            ;;    pp = PatternParser{scope, arg, {...}} with
            ;;       indexable = true
            ;;       allow_nested = true
            ;;    match pp.pattern:
            ;;       #array_pattern{fw, {}, {}, undefined?} -> ;; when not pp.specials.match ->
            ;;          decls = if{pp.specials.match, {#declare{'ph}}, {}}
            ;;          newargs = zip{fw, args} each {match, arg} ->
            ;;             #assign{expr and #symbol{v}} ->
            ;;                expr
            ;;             other ->
            ;;                newv = #symbol{scope.gensym{.temp}} & {env = stdenv}
            ;;                decls.push with
            ;;                   parse_pattern{scope, arg, newv} with
            ;;                      pattern_handlers.declare_variables & {
            ;;                         tags = {declare_mode = .let}
            ;;                         special = {#special{match} and expr, value} ->
            ;;                            .match ->
            ;;                               #assign{'ph}
            ;;                            other ->
            ;;                               throw E.syntax.pattern.special with
            ;;                                  "Special token cannot be used here"
            ;;                                  {special = expr}
            ;;                      }
            ;;                newv
            ;;          #lambda{newargs, #multi{*decls, ...}} with
            ;;             if pp.specials.match:
            ;;                then: '[match ph: ^rhs]
            ;;                else: rhs
            ;;       other ->
            ;;          a = 'arguments <<: arg
            ;;          #lambda{{}, body} where
            ;;             body = ' | match.indexable [^a]:
            ;;                         ^arg -> ^rhs

            ;; #data{#data{*args}, rhs} ->
            ;;    #lambda{args, rhs}

            other ->
               throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

   "match" => accum_flags with {match, scope, form, expr, flags} ->
      #pattern ->
         match expr:
            #void{} -> #special{.match}
            other -> #all{other <<: expr, #special{.match} <<: form}
      other ->
         opt = util.mkset{flags}
         to_match = #symbol{scope.gensym{.m}} & {single_assignment = true}
         {value, body} = match expr:
            #data{Body! {*b}} -> {#value{null}, b}
            #data{v, Body! {*b}} -> {v, b}
         '[let [^to_match = ^value]: ^mbody] where mbody =
            parse_clauses with
               scope, to_match, body
               opt & {
                  fallback{target} =
                     match_error{target}
                     ;; error_embed_location{..., target} with
                     ;;    'E.match{"Could not find a match for value", {value = ^target}}
                  wrap = {x} -> x
               }


   "each"{match, scope, form and {=> env}, #data{li, Body! {*clauses}}} =

      do:
         var ends_with_test = false
         _build_loop{wrap, pre, post} =
            build_loop{scope, env, form, li, clauses
                       wrap, pre, post
                       {...}} with
               wrap_pattern{x, toplevel} =
                  set ends_with_test =
                     match x:
                        #test -> toplevel
                        other -> false
                  x
               fallback{target} =
                  if ends_with_test:
                     then: 'false
                     else: match_error{target}

      #test ->
         #test_factory{li, clauses} & {env = env}

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.
         _build_loop{{x} -> x, #splice{}, #splice{}}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.
         _build_loop{{x} -> 'acc.push{^ #multi{x}}, '[var acc = {}], 'acc}


   "each?"{match, scope, form and {=> env}, #data{li, Body! {*clauses}}} =

      #test ->
         #test_factory{li, clauses} & {env = env}

      #expr{.multi} ->
         ;; expand{#multi} will call this macro again with either
         ;; #expr{.ignore} or #expr{.expr}, depending on whether we
         ;; are in the middle of a block or at the end of one. We want
         ;; to specialize on that information, so we pass our turn.
         #nostep{form}

      #expr{.ignore} ->
         ;; Middle of a block. This means we don't have to accumulate
         ;; the values.
         build_loop{scope, env, form, li, clauses
                    {x} -> x, #splice{}, #splice{}
                    {fallback = {target} -> 'false}}

      other ->
         ;; Middle of a block. We have to accumulate the values in
         ;; order to return them. Right now, this plays poorly with
         ;; break and continue.
         build_loop{scope, env, form, li, clauses
                    {x} -> 'acc.push{^x}, '[var acc = {}], 'acc
                    {fallback = {target} -> 'false}}

   "try"{match, scope, form, #data{Body! {*parts}}} =
      do:
         grouped = classify_contiguous{parts} with {match} ->
            '[finally: ^b] -> .finally
            '[^e -> ^b] -> .clause
            other -> .stmt
         {stmts, clauses, finally} = match grouped:
            {#stmt{*a}, #clause{*b}, #finally{'[finally: ^c]}} ->
               {a, b, c}
            {#stmt{*a}, #clause{*b}} ->
               {a, b, null}
            {#stmt{*a}, #finally{'[finally: ^c]}} ->
               {a, {}, c}
            otherwise ->
               throw E.syntax.try{msg, {node = form}} where
                  msg = {"try expects a list of statements"
                         "and one or more catch clauses and/or"
                         "a finally clause"}.join{" "}

      #expr{.multi} ->
         #nostep{form}
      #expr{.ignore} ->
         clauses.push with
            mkstdenv{}.mark{'[e -> throw e]}
         #js_try{#multi{*stmts}, ..., finally or #void{}} with
            ' | {excv} ->
                 ^ | parse_clauses with
                      scope, 'excv, clauses
                      {wrap = {x} -> x}
      other ->
         clauses.push with
            mkstdenv{}.mark{'[e -> throw e]}
         ' | let [var rval = false]:
              ^ #js_try{'[set rval = ^[#multi{*stmts}]], ..., finally or #void{}} with
                 ' | {excv} ->
                      ^ | parse_clauses with
                           scope, 'excv, clauses
                           {wrap = {x} -> '[set rval = ^x]}
              rval

   "!!"{match, scope, form, #data{expr, Body! {*clauses}}} =
      #expr{.multi} ->
         #nostep{form}
      #expr{.ignore} ->
         clauses.push with
            mkstdenv{}.mark{'[e -> throw e]}
         #js_try{expr, ..., #void{}} with
            ' | {excv} ->
                 ^ | parse_clauses with
                      scope, 'excv, clauses
                      {wrap = {x} -> x}
      other ->
         clauses.push with
            mkstdenv{}.mark{'[e -> throw e]}
         ' | let [var rval = false]:
              ^ #js_try{'[set rval = ^expr], ..., #void{}} with
                 ' | {excv} ->
                      ^ | parse_clauses with
                           scope, 'excv, clauses
                           {wrap = {x} -> '[set rval = ^x]}
              rval

   "@" => var_operator{expander.gensym{"it"}}

   expr_mac! "chain"{scope, form, #data{defn and {=> env}, Body! {*body}}} =
      it = '[@] & {env = env}
      construct{match} =
         {x} -> x
         {x, *rest} ->
            ' | let [^it = ^x]:
                 ^construct{rest}
      construct{{defn} ++ body}

   expr_mac! "using"{scope, form, #data{defn and {=> env}, body}} =
      it = '[@] & {env = env}
      ' | let [^it = ^defn]:
           ^body

   overridable! "do"{match, scope, form, #data{body}} =
      #clause ->
         #block{body}
      #test ->
         Body! {*stmts} = body
         #do{#splice{*stmts}}
      #expr ->
         #multi{body}

   ;; ifneeded{match, scope, form, #data{yes, no}} =
   ;;    #expr{match} ->
   ;;       x ->
   ;;          <> x
   ;;          yes
   ;;       .multi -> #nostep{form}
   ;;       .ignore -> no
   ;;       other -> yes
   ;;    other ->
   ;;       <> other
   ;;       yes

   ;; expr_mac! "if"{scope, form, match} =
   ;;    #data{test, a, b} ->
   ;;       #if{test, a, b}
   ;;    #data{test, Body! {*match}} ->
   ;;       {'then{^a}} ->
   ;;          #if{test, a, #value{undefined}}
   ;;       {'then{^a}, 'else{^b}} ->
   ;;          #if{test, a, b}
   ;;       {*s1, 'else{^b}} ->
   ;;          #if{test, #multi{*s1}, b}
   ;;       other ->
   ;;          #if{test, #multi{*other}, #value{undefined}}

   "if"{ctx, scope, form, match} =

      #data{test, a, b} ->
         #if{test, a, b}

      #data{test, #multi! #multi{*match}} ->
         {'then{^a}} ->
            #if{test, a, #value{undefined}}
         {'then{^a}, 'else{^b}} ->
            #if{test, a, b}
         {*s1, 'else{^b}} ->
            #if{test, #multi{*s1}, b}

         ;; other ->
         ;;    #if{test, #multi{*other}, #value{undefined}}

         body ->
            piece_together{conditions} =
               var rval = #value{undefined}
               conditions.reverse{} each {match, bod} ->
                  null? ->
                     rval = bod
                  test ->
                     rval = #if{test, bod, rval}
               rval

            conditions = {{test, #multi{*body}}}

            match ctx:
               #expr{.multi} ->
                  #restmacro with {stmts} ->
                     while stmts.length:
                        match stmts.shift{}:
                           'elif{^cond, ^body} ->
                              conditions.push with {cond, body}
                           'else{^body} ->
                              conditions.push with {null, body}
                           x ->
                              stmts.unshift{x}
                              break
                     {piece_together{conditions}} ++ stmts

               else ->
                  piece_together{conditions}

   expr_mac! "while"{scope, form, match {=> env}} =
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{test, body}} ->
            setup_label{label, env, #js_while{test, body}}
      #data{test, body} ->
         setup_label{scope.gensym{}, env, #js_while{test, body}}

   "for"{context, scope, form, match expr} =
      do: setup_for{label, env, match, body} =
         #multi{a, b, c} ->
            #multi with
               a
               setup_label{label, env, #js_for{#multi{}, b, c, body}}
         '[^a in ^b] ->
            #multi with
               #declare{a, #value{null}} ;; this is to show the symbol as resolved
               setup_label{label, env, #js_for_in{a, b, body}}
      '[. ^[#symbol{label}]] or #value{label} ->
         #macro with {context, scope, form, #data{spec, body}} ->
            setup_for{label, expr.env, spec, body}
      #data{spec, body} ->
         setup_for{scope.gensym{}, form.env, spec, body}

   "var"{#pattern, scope, form, argument} =
      #mode{.var, argument}

   "set"{#pattern, scope, form, argument} =
      #mode{.set, argument}

   "let"{match, scope, form, argument} =
      #pattern ->
         #mode{.let, argument}
      other ->
         match argument:
            #data{Body! {*bindings}, body} ->
               construct{match} =
                  {} -> body
                  ;; {x, *xs} ->
                  ;;    #multi{x, construct{xs}} & {nonrecursive = true}
                  {'[^bind = ^val], *xs} ->
                     #multi{'[let ^bind = ^val], construct{xs}} & {nonrecursive = true}
               construct{bindings}
               ;; #multi{*bindings, body} & {nonrecursive = true}

   expr_mac! "letrec"{scope, form, #data{Body! {*bindings}, body}} =
      #multi{*let_bindings, body} where
         let_bindings = bindings each '[^b = ^v] -> '[let ^b = ^v]

   "where"{context, scope, form, #data{body, bindings}} =
      'letrec{^bindings, ^body}

   "break" => break_mac{null}

   "continue" => continue_mac{null}

   expr_mac! "throw"{scope, form, arg} =
      #js_throw{arg}

   expr_mac! "return"{scope, form, arg} =
      #js_return{arg}

   expr_mac! "new"{scope, form, arg} =
      #js_new{arg}

   "delete"{context, scope, form, match arg} =
      #symbol{s} ->
         #undeclare{arg}
      other ->
         #js_delete{other}

   "splice"{context, scope, form, #data{Body! {*stmts}}} =
      #splice{*stmts}

   "?"{context, scope, form, match} =

      #data{expr, #void{}} ->
         checker = match expr:
            'String -> checker_db.String
            'Number -> checker_db.Number
            'true -> checker_db.true
            'false -> checker_db.false
            'null -> checker_db.null
            'undefined -> checker_db.undefined
            other -> '___checker{^expr}

         #macro{...} with {match, env, form, expr} ->
            #pattern ->
               match expr:
                  #void{} ->
                     #check{checker, #ignore{}}
                  other ->
                     #check{checker, expr}
            other -> '[^checker]{^expr}

      #data{chk, target} ->
         checker = match chk:
            'String -> checker_db.String
            'Number -> checker_db.Number
            'true -> checker_db.true
            'false -> checker_db.false
            'null -> checker_db.null
            'undefined -> checker_db.undefined
            other -> '___checker{^chk}
         match context:
            #pattern ->
               match target:
                  #void{} ->
                     #check{checker, #ignore{}}
                  other ->
                     #check{checker, target}
            other -> '[^checker]{^target}

   "!"{context, scope, form, match} =

      #data{expr, #void{}} ->
         projector = match expr:
            'String -> mac1 with {x} -> '{true, String{^x}}
            'Number -> mac1 with {x} -> '{true, parseFloat{^x}}
            other -> '___projector{^expr}

         #macro{...} with {match, env, form, expr} ->
            #pattern ->
               match expr:
                  #void{} ->
                     #project{projector, #ignore{}}
                  other ->
                     #project{projector, expr}
            other -> '[^projector]{^expr}[1]

      #data{prj, target} ->
         projector = match prj:
            'String -> mac1 with {x} -> '{true, String{^x}}
            'Number -> mac1 with {x} -> '{true, parseFloat{^x}}
            other -> '___projector{^prj}

         match context:
            #pattern ->
               match target:
                  #void{} ->
                     #project{projector, #ignore{}}
                  other ->
                     #project{projector, target}
            other -> '[^projector]{^target}[1]


   "#"{context, scope, form, #data{#void{}, #symbol{var tag}}} =
      set tag = #value{tag}
      #macro{f} where f{match, scope, form, expr} =
         #pattern ->
            checker_mac = #macro with {context, scope, form, #data{expr}} ->
               ' | let [x = ^expr]:
                    [[instanceof]{x, Array} and x[0] === ^tag]
            match expr:
               #data{*subp} -> '{^tag, ^*subp}
               #void{} -> #check{checker_mac, #ignore{}}
               other -> #check{checker_mac, expr}
         _ ->
            match expr:
               #void{} ->
                  '{^tag}
               #data{*args} ->
                  '{^tag, ^*args}
               other ->
                  '{^tag}[^other]
                  ;; throw E.syntax"#" with
                  ;;    "Illegal argument for #"
                  ;;    {form = form
                  ;;     argument = expr}

   "require"{context, scope, form, match} =

      #data{expr} ->
         req = #variable{.require}
         stmts = {}

         topfetch{pkg, v} =
            stmts.push with '[^v = [^req]{^pkg}]
            v

         produce{match expr, fetch} =

            #symbol{s} ->
               fetch{#value{s}, expr}

            #value{String? s} ->
               fetch{expr, #symbol{scope.gensym{}}}

            #multi{*subp} or #data{*subp} ->
               subp each p -> produce{p, fetch}
               null

            #send{#symbol{"^"}, #data{#void{}, name}} ->
               fetch{name, #symbol{scope.gensym{}}}

            #send{#symbol{"as"}, #data{pkg, s}} ->
               produce{pkg} with {the_pkg, _} ->
                  fetch{the_pkg, s}

            #send{#symbol{"->"}, #data{pkg, subp}} ->
               pkgv = produce{pkg, fetch}
               produce{subp} with {pkg, v} ->
                   stmts.push with '[^v = ^pkgv ^pkg]
                   v

         produce{expr, topfetch}
         #splice{*stmts}

      #void{} ->
         #variable{.require}

      arg ->
         #send{#variable{.require}, arg}

   "provide"{context, scope, form, #data{Body! {*expr}}} =
      exp = form.env.mark{'exports}
      #sink with
         #multi ++
            expr each
               s and #symbol{name} ->
                  '[[^exp][^=name] = ^s]
               '[^s as ^[#symbol{name} or #value{name}]] ->
                  '[[^exp][^=name] = ^s]
               other ->
                  throw E.syntax.provide with
                     "Each clause of provide must be 'sym' or 'sym as name'"

   "inject"{context, scope, form, #data{Body! {*expr}}} =
      #restmacro with {stmts} ->
         exp = form.env.mark{'exports}
         {'[
             globals: module
             module.exports{^*expr} =
                var ^exp = {=}
                ^[#multi{*stmts}]
                ^exp
          ]}

   "class"{context, scope, {=> env}, expr} =

      helper{name, super, stmts} =
         var statics = #data{'[=]}
         var ctor = {#data{}, #multi{} & {env = env}}
         new_stmts = stmts each
            #send{'static, #data{Body! {*methods}}} ->
               statics ++= methods
            '[constructor[^args] = ^body] or '[constructor = ^args -> ^body] ->
               set ctor = {args, body}
               #splice{}
            '[^lhs = ^rhs] ->
               parse_pattern{scope, lhs, rhs} with
                  pattern_handlers.build_object & {
                     allow_nested = false
                     assign{#symbol{v} or #value{v}, value} =
                        #do{#assign{'[^name].prototype[^=v], value} <<: v}
                     declare{vars} = {}
                     wrap_target{match} =
                        '[^args -> ^body] ->
                           {env => other_env} = body
                           it = #symbol{"@"} & {env = other_env}
                           it2 = #symbol{"self"} & {env = other_env}
                           ' | _lambda with
                                ^args
                                splice: [let ^it = this, let ^it2 = this]
                                ^body
                                ^=null
                        other ->
                           other
                     success{_} = #splice{}
                  }
            when false -> pass

         {ctor_args, ctor_body} = ctor
         ctor_expr =
            {env => env2} = ctor_body
            it = #symbol{"@"} & {env = env2}
            cls =
               ' | _lambda with
                    ^ctor_args
                    ^it = if{not [^name]? this, Object.create{[^name].prototype}, this}
                    ^ctor_body
                    ^it
            if super:
               then: '___extend{^cls, ^super}
               else: cls

         ;; set ctor_body =
         ;;    {env => env2} = ctor_body
         ;;    it = #symbol{"@"} & {env = env2}
         ;;    ' | let [^it = if{not [^name]? this, Object.create{[^name].prototype}, this}]:
         ;;         ^ctor_body
         ;;         ^it

         match name:
            #symbol{name_str} ->
               statics.push with
                  '["::name" = ^=name_str]
            else ->
               pass

         statics.push with
            '["::egclass" = true]

         node =
            #splice with
               ' | let ^name = ^ctor_expr
               ' | ^*new_stmts
               ' | [^name] &: ^statics
               ' | ^name

         match context:
            #expr{.multi} -> node
            other -> #multi{node}

         ;; '[
         ;;    ^name =
         ;;        var ^name = ^ctor_expr
         ;;        ^*new_stmts
         ;;        [^name] &: ^statics
         ;;        ^name
         ;; ]

      match expr:
         #data{match, Body! {*stmts}} ->
            '[^name {^super}] ->
               helper{name, super, stmts}
            '[^name {}] or [#symbol{_} and name] ->
               helper{name, null, stmts}
         #data{Body! {*stmts}} ->
            helper{#symbol{scope.gensym{}}, null, stmts}

   ;; "%"{context, scope, form, #data{descr, var contents}} =
   ;;    tags = #data{}

   ;;    parse{match toparse} =
   ;;       #void{} -> null
   ;;       #symbol{s} -> tags.push with #value{"+" + s}
   ;;       #value{x} ->
   ;;          tags.push with #value{"+" + x}
   ;;       #send{#symbol{"."}, #data{#void{}, #symbol{x} or #value{x}}} ->
   ;;          tags.push with #value{x}
   ;;       #send{#symbol{"#"}, #data{#void{}, #symbol{x} or #value{x}}} ->
   ;;          tags.push with #value{"#" + x}
   ;;       #send{#symbol{"="}, #data{#symbol{prop} or #value{prop}, value}} ->
   ;;          tags.push with '[#assoc{^=prop, ^value}]
   ;;       ;; '[^k = ^v] ->
   ;;       ;;    tags.push with toparse
   ;;       #send{expr, rest} ->
   ;;          parse{expr}, parse{rest}
   ;;       #multi{*args} or #data{*args} ->
   ;;          args.forEach{parse}

   ;;    parse{descr}
   ;;    contents ?=
   ;;       #void{} -> #data{}
   ;;       #multi{*args} -> #data{*args}
   ;;       x -> x

   ;;    'Node{^tags, ^contents}


   "%"{context, scope, {=> env}, #data{descr, var contents}} =
      var tags = #data{}
      kv = '{=}

      parse{match whole} =
         #void{} -> null
         #symbol{s} ->
            tags.push with #value{s}
         #value{String! x} ->
            tags.push with #value{x}
         '[. ^[#symbol{x} or #value{String! x}]] ->
            tags.push with #value{"." + x}
         #send{#symbol{"^"}, #data{#void{}, expr}} ->
            tags.push with expr
         '[^_ = ^_] ->
            kv.push with whole
         #send{expr, rest} ->
            parse{expr}, parse{rest}
         #multi{*args} or #data{*args} ->
            args each arg -> parse{arg}

      parse{descr}

      contents ?=
         #void{} -> #array{}
         #multi{*args} ->
            xs = {}
            args each
               pair and '[^k = ^v] ->
                  kv.push with pair
               spl and '[** ^_] ->
                  kv.push with spl
               other ->
                  xs.push with other
            #array{*xs}
         pair and '[^k = ^v] ->
            kv.push with pair
            #array{}
         x -> x

      'Node{^tags, ^kv, ^contents}


   "globals"{context, scope, form, #data{Body! {*vars}}} =
      #splice{*[...]} with
         vars each variable and #symbol{s} -> #declare_raw{variable, #variable{s}}


   "S"{context, scope, form, arg} =
      #value with
         match arg.location.text{}:
            R"^\[(.|\n)*\]$"? text -> text.substring{1, text.length - 1}
            text -> text


blocktest_wrap{expr} =
   ' | value = [[...] !! e -> #error{e}] with
        match [^expr]:
           true? x -> #success{x}
           false? x -> #failure{x}
     | acc.push with
        #test_result{label, value}

blocktest_mac{scope, tests} =

   exptests = enumerate{scope.step_all{#test, tests}}
   n = exptests.length
   stmts = exptests each

      {i, #do{stmt}} ->
         stmt

      {i, #blocktest{more_labels, more_tests}} ->
         ' | let [label = label.concat{Array! ^more_labels}]:
              set acc = acc.concat with
                 ^blocktest_mac{scope, more_tests}

      {i, #test_factory{elements, clauses} and {=> env}} ->
         build_loop{scope, env, #void{}
                    elements, clauses, wrap, #splice{}, #splice{}
                    {fallback = fall}} where
            wrap{expr, index} =
               ' | let [label = label.concat{{^index}}]:
                    ^blocktest_wrap{expr}
            fall{target} =
               match_error{target}

      {i, expr} ->
         lbl = if{n === 1, '{}, '{^=i}}
         ' | let [label = label.concat{^lbl}]:
              ^blocktest_wrap{expr}

   ' | let [var acc = {}]:
        [[...] !! e -> acc.concat{{#error{label, e}}}] with
           [^*stmts, acc]


stdenv.bind{topscope, "blocktest", #macro{...}} with
   {context, scope, form, #data{*args}} ->
      match args:
         {Body! {*tests}} ->
            ' | label = {}
              | ^blocktest_mac{scope, tests}
         {labels, Body! {*tests}} ->
            ' | label = Array! ^labels
              | ^blocktest_mac{scope, tests}


qqstruct{name, args} =
   #data{#value{name}, *args}

qq{match expr} =
   #symbol{s} -> qqstruct{.symbol, {#value{s}}}
   #char{s} -> qqstruct{.char, {#value{s}}}
   #void{} -> qqstruct{.void, {}}
   #value{v} ->
      qqstruct{.value, {expr}}
   #send{#symbol{"^"}, #data{#void{}, insert}} ->
      insert
   #send{#symbol{"^="}, #data{#void{}, insert}} ->
      qqstruct{.value, {insert}}
   #send{#symbol{"^*"}, #data{#void{}, insert}} ->
      '[* ^insert]
   #mismix{ops, *args} ->
      qqstruct{.mismix
               {#data{*[ops each op -> qq{op}]}
                *[args each arg -> qq{arg}]}}
   {name, *args} ->
      qqstruct{name, args each arg -> qq{arg}}

stdenv.bind{topscope, "'", #macro{...}} with
   {context, scope, form, #data{#void{}, expr}} ->
      qq{expr}



class RegexBuilder:

   wrap{x} =
      "(?:" + x + ")"

   quote{x} =
      x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

   quote_charset{x} =
      x.replace{R.g'{in "[](){}^"}, "\\$1"}

   build{expr} =
      match expr:
         #symbol{match} ->
            .any -> "."
            .start -> "^"
            .end -> "$"
            .alpha -> "\\a"
            .digit -> "\\d"
            .word -> "\\w"
            .space -> "\\s"
            .boundary -> "\\b"
            .a -> "\\a"
            .d -> "\\d"
            .w -> "\\w"
            .s -> "\\s"
            .b -> "\\b"

         #value{x} -> @quote{x}

         #send{#symbol{"raw"}, #value{s}} ->
             s

         #send{#symbol{match}, #data{a, b}} ->
            "||" ->
               @wrap{@build{a} + "|" + @build{b}}
            "or" ->
               @wrap{@build{a} + "|" + @build{b}}
            "*" ->
               #void{} = a
               @wrap{@build{b} + "*"}
            "+" ->
               #void{} = a
               @wrap{@build{b} + "+"}
            "?" ->
               #void{} = a
               @wrap{@build{b} + "?"}
            "in" ->
               #void{} = a
               #value{v} = b
               ["[" + x + "]"] where
                  x = @quote_charset{v}
            "not" ->
               #void{} = a
               #send{#symbol{"in"}, #data{#void{}, #value{v}}} = b
               ["[^" + x + "]"] where
                  x = @quote_charset{v}

         #data{*args} ->
            "(" + [args each arg -> @build{arg}].join{""} + ")"
         #multi{*args} ->
            "(?:" + [args each arg -> @build{arg}].join{""} + ")"

         other ->
            E.syntax.regexp with
               "Illegal regular expression"
               {expr = expr}

build_regexp{x} = RegexBuilder{}.build{x}

stdenv.bind{topscope, "R", #macro{accum_flags{mac, false}}} where
   mac{context, scope, form, match arg, flags} =
      #value{String? v} ->
         text =
            match arg.location.text{}:
               R"^\".*\"$"? text -> text.substring{1, text.length - 1}
               text -> text
         'RegExp{^=text, ^=[flags.join{""}]}
      #send{#symbol{"'"}, #data{#void{}, arg}} ->
         'RegExp{^=build_regexp{arg}, ^=[flags.join{""}]}


errf_macro{tags}{context, scope, form, match} =
   #void{} ->
      'ErrorFactory{{^*tags}}
   #data{*args} ->
      'ErrorFactory{{^*tags}}.create{^*args}
   other ->
      #macro with errf_macro{tags ++ {other}}

stdenv.bind{topscope, "E", #macro{errf_macro{{}}}}





[items{{...}} each {k, v} -> stdenv.bind{topscope, k, #value{v}}] with

   "___build_array" => Embedded with '
      {arrays} ->
         var results = {}
         arrays each a -> set results = results.concat{a}
         results

   "object" => Embedded with '
      {pairs} ->
         rval = {=}
         pairs each {k, v} ->
            rval[k] = v
         rval

   "items" => Embedded with '
      {obj} ->
         results = {}
         for [k in obj]:
            if Object.prototype.hasOwnProperty.call{obj, k}:
               results.push with {k, obj[k]}
         results

   "dir" => Embedded with '
      {arg} ->
         rec{arg} where rec{match} =
            Number? n -> rec{Number.prototype}
            String? s -> rec{String.prototype}
            === true or === false ->
               rec{Boolean.prototype}
            obj ->
               var curr = obj
               var results = {}
               while [curr and [obj === Object or curr !== Object]]:
                  results ++=
                     Object.getOwnPropertyNames{curr} each
                        k when not RegExp{"^toString$|^__|^::"}? k ->
                           {k, obj[k]}
                  curr = Object.getPrototypeOf{curr}
               object{results.sort{}}

   "keys" => Embedded with 'Object.keys

   "enumerate" => Embedded with '
      {arr} ->
         results = {}
         l = arr.length
         for [i = 0, i < l, i++]:
            results.push with {i, arr[i]}
         results

   "zip" => Embedded with '
      {xs, ys} ->
         enumerate{xs} each {i, x} ->
            {x, ys[i]}

   "neighbours" => Embedded with '
      {match} ->
         ;; Takes an array and returns an array of pairs of consecutive elements.
         ;; Example:
         ;;   neighbours{{1, 7, 10, 3, 7}}
         ;;     ==> {{1, 7}, {7, 10}, {10, 3}, {3, 7}}
         {} -> {}
         {x} -> {}
         {x, y, *rest} ->
            {{x, y}} ++ neighbours{{y} ++ rest}

   "predicate" => Embedded with '
      {f} ->
         f["::check"] = f
         f

   "___nequal" => Embedded with '
      {x, y} -> not [x == y]

   "___equal" => Embedded with '
      {match a, b} ->
         === b ->
            true
         Number? or String? or null? or undefined? or ===true or ===false ->
            false
         Array? ->
            if [not Array? b or a.length !== b.length]:
               return false
            for [i = 0, i < a.length, i++]:
               if [not [___js_fetch{a, i} == ___js_fetch{b, i}]]:
                  return false
            true
         when [Object.getPrototypeOf{a} === Object.prototype
               \ and Object? b
               \ and Object.getPrototypeOf{b} === Object.prototype] ->
            ka = keys{a}
            if [not [ka.sort{} == keys{b}.sort{}]]:
               return false
            ka each k ->
               if [not [___js_fetch{a, k} == ___js_fetch{b, k}]]:
                  return false
            true
         {"::serialize" => _} ->
            match b:
               {"::serialize" => _} ->
                  a["::serialize"]{} == b["::serialize"]{}
               otherwise ->
                  false
         otherwise ->
            false

   "&:" => Embedded with '
      {dest, values} ->
         for [k in values]:
            if values.hasOwnProperty{k}:
               dest[k] = ___js_fetch{values, k}
         dest

   ;; "&+" => Embedded with '
   ;;    {a, b} ->
   ;;       dest = {=}
   ;;       for [k in a]:
   ;;          if a.hasOwnProperty{k}:
   ;;             dest[k] := ___js_fetch{a, k}
   ;;       for [k in b]:
   ;;          if b.hasOwnProperty{k}:
   ;;             dest[k] := ___js_fetch{b, k}
   ;;       dest

   "&" => Embedded with '
      {a, b} ->
         dest = clone{a}
         for [k in b]:
            if Object.prototype.hasOwnProperty.call{b, k}:
               dest[k] = ___js_fetch{b, k}
         dest

   "&+" => Embedded with '
      {a, b} ->
         dest = clone{a}
         for [k in b]:
            if Object.prototype.hasOwnProperty.call{b, k}:
               dest[k] = ___js_fetch{b, k}
         dest

   "|>" => Embedded with '
      {f, g} -> {x} ->
         g{f{x}}

   "clone" => Embedded with '
      {match x} ->
         undefined? or null? or String? or Number? ->
            x
         {"::clone" => _} ->
            x["::clone"]{}
         when Object.getPrototypeOf{x} === Object.prototype ->
            dest = {=}
            for [k in x]:
               if Object.prototype.hasOwnProperty.call{x, k}:
                  dest[k] = ___js_fetch{x, k}
            dest
         other ->
            throw E.clone{"Object cannot be cloned", {obj = x}}

   "___checker" => Embedded with '
      {type} ->
         f = type["::check"]
         if [f === undefined]:
            then: {value} -> [instanceof]{value, type}
            else: {value} -> f.call{type, value}

   "___projector" => Embedded with '
      {type} -> {value} ->
         var f = type[":::project"]
         if [f === undefined]:
            then:
               set f = type["::project"]
               if [f === undefined]:
                  then: {true, type{value}}
                  else: {true, f{value}} !! e -> {false, null}
            else:
               f.call{type, value}

   "___hasprop" => Embedded with '
      {match, key} ->
         null? or undefined? -> false
         String? x -> key in String.prototype
         Number? x -> key in Number.prototype
         x -> key in x

   "range" => Embedded with '
      {from, to} ->
         rval = {}
         for [i = from, i <= to, i++]:
            rval.push{i}
         rval

   "___serialize_ast" => Embedded with '
      {match} ->
         String? x or Number? x ->
            #value{x}
         other ->
            other["::serialize_ast"]{}

   "___match_error" => Embedded with '
      {value, url, start, end} ->
         err = E.match{"Could not find a match for value", {value = value}}
         if url:
            err.location = #location{url, start, end}
         throw err

   "___extend" => Embedded with '
      {child, parent} ->
         ;; copy static fields
         items{parent} each {key, value} ->
            child[key] = value
         child.prototype = Object.create{parent.prototype}
         child.prototype.constructor = child
         child["::super"] = parent.prototype
         child

   "ErrorFactory" => Embedded with '
      class:

         constructor{tags} =
            @tags = tags

         create{message = "", *args} =
            e = Error{message}
            e["::tags"] = @tags
            e.args = args
            enumerate{args} each {i, arg} ->
               e[i] = arg
            e.length = args.length
            e.name = [{.E} ++ @tags].join{"."}
            e

         "::check"{e} =
            if [not e or not Error? e]:
               return false
            tags = e["::tags"] or {}
            @tags each? tag when tags.indexOf{tag} === -1 ->
               return false
            true

         "::deconstruct"{e} =
            e.args


   ;; "Node" => Embedded with '
   ;;    class:
   ;;       static:
   ;;          "::check"{x} =
   ;;             x and x.classes and x.children
   ;;          "::deconstruct"{x} =
   ;;             {x.classes, x.children}

   ;;       constructor{Array! classes, Array! children} =
   ;;          @classes = classes.sort{}
   ;;          @children = children

   ;;       "::check"{n} =
   ;;          @classes each? c when n.classes.indexOf{c} === -1 ->
   ;;             return false
   ;;          true


   "Node" => Embedded with '
      class:
         static:
            "::check"{x} =
               x and x.tags and x.props and x.children
            ":::project"{match} =
               {=> tags, => props, => children} ->
                  {true, {tags, props, children}}
               else ->
                  {false, null}

         constructor{Array! @tags, @props, Array! @children} =
            pass

         "::check"{match} =
            Node? n ->
               @tags each? c when n.tags.indexOf{c} === -1 ->
                  return false
               true
            else ->
               false

         ":::project"{match} =
            [@]? n ->
               {true, {n.tags, n.props, n.children}}
            else ->
               {false, null}

            ;; if [not n]: return {false, null}
            ;; @tags each? c when n.tags.indexOf{c} === -1 ->
            ;;    return {false, null}
            ;; {true, {n.tags, n.props, n.children}}


stdprelude = Embedded with '

   send{obj, match msg} =
      [String? or Number?] -> ___js_fetch{obj, msg}
      other -> obj["::send"]{msg}

   Array[":::project"]{match value} =
      Array? -> {true, value}
      _ -> {true, {value}}

   __array_methods = {
      "::check"{value} =
         if [instanceof]{value, Array}:
            then:
               for [i = 0, i < this.length, i++]:
                  if [this[i] !== value[i]]:
                     return false
               true
            else:
               false

      "::clone"{} =
         this.slice{0} &: this

      ":::project"{value} =
         if [instanceof]{value, Array}:
            then:
               for [i = 0, i < this.length, i++]:
                  if [this[i] !== value[i]]:
                     return {true, this ++ {value}}
               {true, value}
            else:
               {true, this ++ {value}}

      "::serialize_ast"{} =
         #array{*this.map{___serialize_ast}}
   }

   items{__array_methods} each {k, v} ->
      if [not Array.prototype[k]]:
         Object.defineProperty{Array.prototype, k} with {
            enumerable = false
            value = v
         }

   __re_methods = {
      "::check"{match} =
         String? value ->
            if{value.match{this}, true, false}
         other ->
            false

      ":::project"{match} =
         String? value ->
            match value.match{this}:
               null? m -> {false, null}
               m -> {true, m}
         other ->
            {false, null}
   }

   items{__re_methods} each {k, v} ->
      if [not RegExp.prototype[k]]:
         Object.defineProperty{RegExp.prototype, k} with {
            enumerable = false
            value = v
         }

   if [not Function.prototype["::send"]]:
      Object.defineProperty{Function.prototype, "::send"} with {
         enumerable = false
         value{args} =
            this.apply{this, args}
      }

   ;; Error.prototype["::clone"] := {} ->
   ;;    e = Error{this.message}
   ;;    e.message := this.message
   ;;    e.stack := this.stack
   ;;    e.name := this.name
   ;;    items{this} each {k, v} ->
   ;;       e[k] := v
   ;;    e


expander.utils = {
   var_operator = var_operator
}

