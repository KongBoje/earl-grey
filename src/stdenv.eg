
require:
   "./pp" ->
      <>
   "./location" ->
      <<:
   "./util" as util ->
      GenSym
      classify_contiguous
      Body
   "./pattern" ->
      PatternParser
      parse_pattern, parse_clauses
   "./expand" as mt ->
      Expander, Scope, Info, Env, nullenv
      mac1, checker_db, topscope
   "./macros/helpers" ->
      embed_location
      error_embed_location
      match_error
      drop_ctx
      expr_mac
      expr_mac2
      ctx_mac
      value_mac
      overridable
      protected_value
      var_operator
      accum_flags
      build_loop
      partial_pattern
      make_assigner
      pattern_handlers


provide:
   stdenv
   make_expander


stdstore = {=}


global_variables = {

   "+", "-", "*", "/", "mod"
   "&.", "|.", "^."
   "and", "or", "not"
   ;; "==", "!="
   "===", "!=="
   "<", ">", "<=", ">="
   "<<", ">>", ">>>"
   "in", "instanceof", "--"
   "++"

   ;; .true, .false, .null, .undefined

   .typeof
   ;; .String, .Number, .Boolean
   .Array, .Object
   .RegExp, .Function, .Date
   .parseInt, .parseFloat, .Math
   .Error, .TypeError, .ReferenceError
   .console, .process, .eval

   .setTimeout, .clearTimeout
   .setInterval, .clearInterval

   .___js_fetch, .___node

   .arguments, .this, .exports

   .send
   .object, .keys, .items, .enumerate
   .zip, .product, .neighbours, .range
   .predicate
   "==", "!="
   .equal, .nequal
   "&", "&:"
   .clone, .dir
   .getProjector, .getChecker
   .ErrorFactory, .Node

   .___build_array
   .___hasprop
   .___extend
   .___match_error
   .___serialize_ast

   .Set, .Map
   .Promise, .promisify, .spawn

   .Buffer

   .global
}

;; embed_location{match} =
;;    {location => {source => {=> url}, => start, => end}} ->
;;       '[#location{^=url, ^=start, ^=end}]
;;    other ->
;;       '[#location{null, 0, 0}]

;; error_embed_location{error, target} =
;;    '[throw [^error &: {location = ^embed_location{target}}]]

;; match_error{match target} =
;;    {location => {source => {=> url}, => start, => end}} ->
;;       '___match_error{^target, ^=url, ^=start, ^=end}
;;    other ->
;;       '___match_error{^other}

;; drop_ctx{f}{context, info, form, arg} =
;;    f{context, info, form, arg} !!
;;       E.match? {args => {{value => [=== context and not #expr{.expr}]}}} ->
;;          #nostep{form}

;; expr_mac{f}{match, info, form, arg} =
;;    #expr{.expr} or #expr{.head} ->
;;       f{info, form, arg}
;;    otherwise ->
;;       #nostep{form}

;; expr_mac2{mac}{match, info, f, e} =
;;    #project{match} ->
;;       #pattern ->
;;          #unconditional{#macro{mac3}} where
;;             mac3{c, info, f, #data{match}} =
;;                #use{env, x} ->
;;                   #use{env, mac.call{info, #data{x} <<: e}}
;;                x ->
;;                   mac.call{info, #data{x} <<: x}
;;       else ->
;;          mac.call{info, e}
;;    #expr ->
;;       mac.call{info, e}

;; ctx_mac{mac}{ctx, info, f, e} =
;;    mac.call{info, ctx, e}


;; _default_proj{name}{x} =
;;    '[throw E.project{"Cannot project a value with '" + ^=name + "!'"}]
;; value_mac{name, chk, proj = _default_proj{name}}{match ctx, _, form, arg} =
;;    #check ->
;;       #nostep{#macro{m}} where
;;          m{*, #data{x}} = chk{x}
;;    #project ->
;;       #nostep{#macro{m}} where
;;          m{*, #data{x}} = proj{x}
;;    ctx ->
;;       match arg:
;;          #void -> #variable{name}
;;          else -> #send{#variable{name}, arg}


;; overridable{f}{match context, info, form, arg} =
;;    #pattern ->
;;       #nostep{form}
;;    #expr{.multi} ->
;;       #nostep{form}
;;    other ->
;;       f{context, info, form, arg}

;; protected_value{name, value}{match, _, form, arg} =
;;    #pattern ->
;;       throw E.syntax.pattern{"'"+name+"' is not a valid pattern and cannot be redeclared"}
;;    other ->
;;       match arg:
;;          #void{} ->
;;             #value{value}
;;          other ->
;;             #send{#value{value}, arg}


;; setup_label{label, env, body} =
;;    #bind{'break & {env = env}, #macro{break_mac{label}}
;;          #bind{'continue & {env = env}, #macro{continue_mac{label}}
;;                #js_label{#value{label}, body}}}

;; break_mac{default_label} = overridable with
;;    {context, _, form, match expr} ->
;;       #void{} when default_label -> #js_break{#value{default_label}}
;;       #void{} -> #js_break{}
;;       #value{v} -> #js_break{expr}
;;       #symbol{v} -> #js_break{#value{v}}

;; continue_mac{default_label} = overridable with
;;    {context, _, form, match expr} ->
;;       #void{} when default_label -> #js_continue{#value{default_label}}
;;       #void{} -> #js_continue{}
;;       #value{v} -> #js_continue{expr}
;;       #symbol{v} -> #js_continue{#value{v}}


;; var_operator{name} = {context, {=> env}, form, expr} ->
;;    ;; {=> env} = form
;;    sym = #symbol{name} & {env = env}
;;    match expr:
;;       #void{} ->
;;          sym
;;       #data{#void, match} ->
;;          #symbol{s} ->
;;             #send{sym, #value{s}}
;;          other ->
;;             #send{sym, other}

;; accum_flags{mac, also_values = true} =
;;    make{flags}{context, info, form, match} =
;;       #value{flag} when also_values ->
;;          #macro{make{flags ++ {flag}}}
;;       '[. ^[#symbol{flag}]] ->
;;          #macro{make{flags ++ {flag}}}
;;       other ->
;;          mac{context, info, form, other, flags}
;;    make{{}}

pattern_constructors = {=}


;; disregard_specials{#special{kind} and expr, value} =
;;    throw E.syntax.pattern.special with
;;       "Special token cannot be used here"
;;       {special = expr}

;; pattern_handlers = {

;;    declare_variables = {
;;       allow_nested = true
;;       allow_arguments = true
;;       special = disregard_specials
;;       assign{match v, value} =
;;          #symbol{name} ->
;;             #do{#assign{v, value &: {name = name}} <<: v}
;;          v ->
;;             #do{#assign{v, value} <<: v}
;;       finalize = true
;;       tags = {declare_mode = .unqualified}
;;       declare{_, vars} =
;;          vars each v ->
;;             match v.declare_mode:
;;                .set -> #splice{}
;;                .let -> #declare{v & {mutable = false}}
;;                .var -> #declare{v & {mutable = true}}
;;                .unqualified ->
;;                   #declare{v & {mutable = false, use_previous = true}}
;;       success{_} = #multi{}
;;       failure{target} =
;;          match_error{target}
;;          ;; error_embed_location{..., target} with
;;          ;;    'E.match{"Could not find a match for value", {value = ^target}}
;;    }

;;    build_object = {
;;       strings_as_variables = true
;;       allow_nested = true
;;       allow_arguments = true
;;       special = disregard_specials
;;       assign{#symbol{v} or #value{v}, value, _} =
;;          #do{#assign{'accum[^=v], value} <<: v}
;;       finalize = true
;;       declare{_, vars} =
;;          {#declare{'accum, '{=}}}
;;       success{_} = 'accum
;;       failure{target} =
;;          match_error{target}
;;          ;; error_embed_location{..., target} with
;;          ;;    'E.match{"Could not find a match for value", {value = ^target}}
;;    }

;; }


;; ;; Note about lbl:

;; ;; The "for" macro rebinds break and continue to refer to its
;; ;; own label in either the environment it is created in or in
;; ;; the environment of the label it is given. This means,
;; ;; roughly speaking, that break/continue in user code will
;; ;; jump over macro-generated loops (and the macro's will jump
;; ;; over the user's), unless the macro explicitly makes sure
;; ;; that break/continue are redefined in the user
;; ;; environment. To do so, we create a random label and give
;; ;; it the same environment as the argument to "each". This
;; ;; means "break" will jump out of "each" and not out of an
;; ;; outer loop.

;; build_loop{info, env, form, li, clauses, wrap, pre, post, opt} =
;;    lbl =
;;       if env:
;;          then: #value{info.gensym{}} & {env = env}
;;          else: #value{info.gensym{}}

;;    freshenv = info.expander.mkenv{}
;;    i = 'i & {env = freshenv}
;;    len = 'len & {env = freshenv}

;;    drop_ctx! first_mac{#pattern, _, form, subp} =
;;       #test{'[^i === 0], subp}
;;    drop_ctx! last_mac{#pattern, _, form, subp} =
;;       #test{'[^i === [^len - 1]], subp}

;;    newscope = Scope{info.scope}
;;    env.bind{newscope, "first", #macro{first_mac}}
;;    env.bind{newscope, "last", #macro{last_mac}}

;;    m = 'm <<: form ;; transfer location, for error printing purposes
;;    if opt.forof:
;;       '[^pre
;;         for[^lbl] [^m of ^li]:
;;            ^parse_clauses{
;;                 info.with_scope{newscope}, m, clauses
;;                 opt & {wrap{x} = wrap{x, '0}}
;;             }
;;         ^post]
;;    else:
;;       '[^pre
;;         let [temp = ^li, ^len = temp.length]:
;;            for[^lbl] [var ^i = 0, ^i < ^len, ^i++]:
;;               ^m = ___js_fetch{temp, ^i}
;;               ^parse_clauses{
;;                    info.with_scope{newscope}, m, clauses
;;                    opt & {wrap{x} = wrap{x, i}}
;;                }
;;         ^post]


;; partial_pattern{operator} =
;;    op =
;;       match operator:
;;          #symbol -> operator
;;          String? -> #variable{operator}
;;    {context, _, form, expr} ->
;;       match {context, expr}:
;;          {#pattern, #data{#void{}, val}} ->
;;             #check{m, #ignore{}} where
;;                m = mac1 with {x} -> '[^op]{^x, ^val}
;;          {_, #void{}} ->
;;             op
;;          other ->
;;             #send{op, expr}

;; make_assigner{op}{context, _, form, #data{a, b}} =
;;    #assign{a, #send{#symbol{op}, #data{a, b}}}



global_variables each gvar ->
   stdstore[gvar] = #variable{gvar} & {mutable = false, assigned = true}

stdstore &: {
   true = protected_value{.true, true}
   false = protected_value{.false, false}
   null = protected_value{.null, null}
   undefined = protected_value{.undefined, undefined}
   pass = #variable{.undefined}
}

mac{name}{m} =
   stdstore[name] = #macro{m}
   m

;; [items{{...}} each {k, v} -> mac{k}{v}] with

;;    "===" => partial_pattern{"==="}
;;    "!==" => partial_pattern{"!=="}
;;    "==" => partial_pattern{"equal"}
;;    "!=" => partial_pattern{"nequal"}
;;    "<=" => partial_pattern{"<="}
;;    ">=" => partial_pattern{">="}
;;    "<" => partial_pattern{"<"}
;;    ">" => partial_pattern{">"}

"core operators loop quote regexp modularity
 testing misc macrodef async logic".split{R"[\n ]+"} each
   m -> require{^["./macros/" + m]}{mac}

;; [require: "./macros/operators"]{mac}
;; [require: "./macros/loop"]{mac}
;; [require: "./macros/quote"]{mac}
;; [require: "./macros/regexp"]{mac}
;; [require: "./macros/modularity"]{mac}
;; [require: "./macros/testing"]{mac}
;; [require: "./macros/misc"]{mac}
;; [require: "./macros/macrodef"]{mac}

;; mac{"-"}! minus_mac{context, _, form, match expr} =
;;    #data{#void{}, #value{Number? n}} ->
;;       #value{-n}
;;    #void{} ->
;;       #variable{"-"}
;;    other ->
;;       #send{#variable{"-"}, expr}

;; mac{"++"}! append_mac{context, _, form, match} =
;;    #data{#void{}, x} -> #send{#variable{"++"}, #data{#void{}, x}}
;;    #data{x, #void{}} -> #send{#variable{"++"}, #data{x, #void{}}}
;;    #data{x, y} -> '[^x].concat{^y}
;;    #void{} -> '[{x, y} -> x.concat{y}]
;;    other -> '[___build_array{^other}]

;; mac{".."}! range_mac{context, _, form, match} =
;;    #data{#void{}, x} -> 'range{1, ^x}
;;    #data{x, #void{}} -> 'range{^x}
;;    #data{x, y} -> 'range{^x, ^y}
;;    #void{} -> 'range

;; mac{"//"}! floor_mac{context, _, form, #data{a, b}} =
;;    'Math.floor{^a / ^b}

;; mac{"*"}! times_mac{context, _, form, expr} =
;;    match {context, expr}:
;;       {#pattern, #void{}} ->
;;          #dynsplice{#ignore{}}
;;       {#pattern or #expr{.data}, #data{#void{}, val}} ->
;;          #dynsplice{val}
;;       {_, #void{}} ->
;;          #variable{"*"}
;;       other ->
;;          #send{#variable{"*"}, expr}

;; mac{"**"}! exp_mac{context, _, form, expr} =
;;    match {context, expr}:
;;       {#pattern, #void{}} ->
;;          #objsplice{#ignore{}}
;;       {#pattern or #expr{.data}, #data{#void{}, val}} ->
;;          #objsplice{val}
;;       {_, #void{}} ->
;;          'Math.pow
;;       {_, #data{a, b}} ->
;;          'Math.pow{^a, ^b}

mac{"_"}! placeholder_mac{#pattern, _, form, #void{}} =
   #ignore{}

;; mac{"else"}! else_mac{match, _, form, _} =
;;    #pattern ->
;;       #ignore{}
;;    else ->
;;       throw E.syntax.else{msg, {node = form}} where
;;          msg = "'else' should be found inside an 'if' block"

;; mac{"not"}! not_mac{match, _, form, #data{#void{}, rhs} and arg} =
;;    #check or #project ->
;;       #nostep{form}
;;    #pattern ->
;;       #neg{rhs}
;;    other ->
;;       #send{#variable{"not"}, arg}

;; mac{"and"}! and_mac{match, _, form, #data{lhs, rhs} and arg} =
;;    #check or #project ->
;;       #nostep{form}
;;    #pattern ->
;;       #all{lhs, rhs}
;;    other ->
;;       #send{#variable{"and"}, arg}

;; mac{"or"}! or_mac{match, _, form, #data{lhs, rhs} and arg} =
;;    #check or #project ->
;;       #nostep{form}
;;    #pattern ->
;;       #any{lhs, rhs}
;;    other ->
;;       #send{#variable{"or"}, arg}

;; mac{"when"}! when_mac{context, _, form, #data{match, condition}} =
;;    #void{} -> #test{condition, #ignore{}}
;;    other -> #test{condition, other}

;; mac{"."}! dot_mac{context, _, form, #data{#void{}, expr}} =
;;    f{expr} where f{match} =
;;       #symbol{x} ->
;;          #value{x}
;;       #data{*args} ->
;;          #data{*[args each arg -> f{arg}]}
;;       other ->
;;          throw E.syntax.dot{"Argument to '.' must be a symbol or an array"
;;                             {argument = other}}

;; mac{"="}! equal_mac{match, info, form, expr} =
;;    #pattern ->
;;       #data{lhs, rhs} = expr
;;       #default{lhs, rhs}
;;    #expr{.data} ->
;;       match expr:
;;          #void{} ->
;;             #assoc{}
;;          #data{#symbol{s}, rhs} ->
;;             ;; special case for the most common situation
;;             #assoc{#value{s}, rhs}
;;          #data{lhs, rhs} ->
;;             #objsplice with #multi with
;;                parse_pattern{info, lhs, #use{info.scope, rhs} <<: rhs} with
;;                   pattern_handlers.build_object
;;    other ->
;;       #data{lhs, rhs} = expr
;;       parse_pattern{info, lhs, #use{info.scope, rhs} <<: rhs} with
;;          pattern_handlers.declare_variables

;; mac{"=>"}! fat_arrow_mac{match, {=> env}, _, #data{lhs, rhs}} =
;;    #pattern ->
;;       match {lhs, rhs}:
;;          {#void, #symbol{k} or #value{k}} ->
;;             #assoc{#value{k}, [#symbol{k} <<: rhs] & {env = env}}
;;          {#symbol{k} or #value{k}, rhs} ->
;;             #assoc{#value{k}, rhs}
;;    #test ->
;;       Body! {*stmts} = rhs
;;       #blocktest{lhs, stmts}
;;    other ->
;;       #assoc{lhs, rhs}


;; [items{{...}} each {k, v} -> mac{k}{v}] with

;;    "+=" => make_assigner{"+"}
;;    "-=" => make_assigner{"-"}
;;    "*=" => make_assigner{"*"}
;;    "/=" => make_assigner{"/"}
;;    "<<=" => make_assigner{"<<"}
;;    ">>=" => make_assigner{">>"}
;;    ">>>=" => make_assigner{">>>"}
;;    "++=" => make_assigner{"++"}
;;    "?=" => make_assigner{"match"}
;;    "or=" => make_assigner{"or"}
;;    "and=" => make_assigner{"and"}
;;    "each=" => make_assigner{"each"}


;; mac{"_lambda"}! _lambda_mac{context, info, form, match} =
;;    #data{#data{*args} and arg, pre, body, post, generator = #value{false}} ->
;;       wrap{body2} =
;;          if{pre == #value{null}, body3, #multi{pre, body3}} where
;;             body3 = if{post == #value{null}, body2, #multi{body2, post}}
;;       pp = PatternParser{info, arg, {...}} with
;;          indexable = true
;;          allow_nested = true
;;       match pp.pattern:
;;          #array_pattern{fw, {}, {}, undefined?} -> ;; when not pp.specials.match ->
;;             decls = if{pp.specials.match, {#declare{'ph}}, {}}
;;             newargs = zip{fw, args} each {match, arg} ->
;;                #assign{expr and #symbol{v}} ->
;;                   expr
;;                other ->
;;                   newv = #symbol{info.gensym{.temp}} & {env = stdenv}
;;                   decls.push with
;;                      parse_pattern{info, arg, newv} with
;;                         pattern_handlers.declare_variables & {
;;                            tags = {declare_mode = .let}
;;                            special = {#special{match} and expr, value} ->
;;                               .match ->
;;                                  #assign{'ph}
;;                               other ->
;;                                  throw E.syntax.pattern.special with
;;                                     "Special token cannot be used here"
;;                                     {special = expr}
;;                         }
;;                   newv
;;             #lambda{newargs, wrap{#multi{*decls, ...}}, generator} with
;;                if pp.specials.match:
;;                   then: '[match ph: ^body]
;;                   else: body
;;          other ->
;;             a = 'arguments <<: arg
;;             #lambda{{}, wrap{body2}, generator} where
;;                body2 = ' | match.indexable [^a]:
;;                             ^arg -> ^body

;; mac{"*->"}! genarrow_mac{ctx, _, form, match} =
;;    #data{args, body} ->
;;       '_lambda{^args, ^=null, ^body, ^=null, ^=true}
;;    other ->
;;       throw E.syntax.lambda{"Bad lambda syntax", {node = other}}

;; mac{"->"}! arrow_mac{match, _, form, expr} =
;;    do:
;;       if form.name:
;;          console.log with form.name
;;    #clause ->
;;       #data{lhs, rhs} = expr
;;       #clause{lhs, rhs}
;;    other ->
;;       match expr:
;;          #data{args, body} ->
;;             '_lambda{^args, ^=null, ^body, ^=null}
;;          other ->
;;             throw E.syntax.lambda{"Bad lambda syntax", {node = other}}


;; accum_flags! mac{"match"}! match_mac{match, info, form, expr, flags} =
;;    #pattern ->
;;       match expr:
;;          #void{} -> #special{.match}
;;          other -> #all{other <<: expr, #special{.match} <<: form}
;;    other ->
;;       opt = util.mkset{flags}
;;       to_match = #symbol{info.gensym{.m}} & {single_assignment = true}
;;       {value, body} = match expr:
;;          #data{Body! {*b}} -> {#value{null}, b}
;;          #data{v, Body! {*b}} -> {v, b}
;;       '[let [^to_match = ^value]: ^mbody] where mbody =
;;          parse_clauses with
;;             info, to_match, body
;;             opt & {
;;                fallback{target} =
;;                   match_error{target}
;;                   ;; error_embed_location{..., target} with
;;                   ;;    'E.match{"Could not find a match for value", {value = ^target}}
;;                wrap = {x} -> x
;;             }

;; mac{"each"}! each_mac{match, info and {=> env}, form, #data{li, Body! {*clauses}}} =
;;    do:
;;       var ends_with_test = false
;;       _build_loop{wrap, pre, post} =
;;          build_loop{info, env, form, li, clauses
;;                     wrap, pre, post
;;                     {...}} with
;;             forof = false
;;             wrap_pattern{x, toplevel} =
;;                set ends_with_test =
;;                   match x:
;;                      #test -> toplevel
;;                      other -> false
;;                x
;;             fallback{target} =
;;                if ends_with_test:
;;                   then: 'false
;;                   else: match_error{target}

;;    #test ->
;;       #test_factory{li, clauses} & {env = env}

;;    #expr{.multi} ->
;;       ;; expand{#multi} will call this macro again with either
;;       ;; #expr{.ignore} or #expr{.expr}, depending on whether we
;;       ;; are in the middle of a block or at the end of one. We want
;;       ;; to specialize on that information, so we pass our turn.
;;       #nostep{form}

;;    #expr{.ignore} ->
;;       ;; Middle of a block. This means we don't have to accumulate
;;       ;; the values.
;;       _build_loop{{x} -> x, #splice{}, #splice{}}

;;    other ->
;;       ;; Middle of a block. We have to accumulate the values in
;;       ;; order to return them. Right now, this plays poorly with
;;       ;; break and continue.
;;       _build_loop{{x} -> 'acc.push{^ #multi{x}}, '[var acc = {}], 'acc}


;; mac{"each+"}! eachp_mac{match, info and {=> env}, form, #data{li, Body! {*clauses}}} =
;;    do:
;;       var ends_with_test = false
;;       _build_loop{wrap, pre, post} =
;;          build_loop{info, env, form, li, clauses
;;                     wrap, pre, post
;;                     {...}} with
;;             forof = true
;;             wrap_pattern{x, toplevel} =
;;                set ends_with_test =
;;                   match x:
;;                      #test -> toplevel
;;                      other -> false
;;                x
;;             fallback{target} =
;;                if ends_with_test:
;;                   then: 'false
;;                   else: match_error{target}

;;    #test ->
;;       #test_factory{li, clauses} & {env = env}

;;    #expr{.multi} ->
;;       ;; expand{#multi} will call this macro again with either
;;       ;; #expr{.ignore} or #expr{.expr}, depending on whether we
;;       ;; are in the middle of a block or at the end of one. We want
;;       ;; to specialize on that information, so we pass our turn.
;;       #nostep{form}

;;    #expr{.ignore} ->
;;       ;; Middle of a block. This means we don't have to accumulate
;;       ;; the values.
;;       _build_loop{{x} -> x, #splice{}, #splice{}}

;;    other ->
;;       ;; Middle of a block. We have to accumulate the values in
;;       ;; order to return them. Right now, this plays poorly with
;;       ;; break and continue.
;;       _build_loop{{x} -> 'acc.push{^ #multi{x}}, '[var acc = {}], 'acc}


;; mac{"try"}! try_mac{match, info, form, #data{Body! {*parts}}} =
;;    do:
;;       grouped = classify_contiguous{parts} with {match} ->
;;          '[finally: ^b] -> .finally
;;          '[^e -> ^b] -> .clause
;;          other -> .stmt
;;       {stmts, clauses, finally} = match grouped:
;;          {#stmt{*a}, #clause{*b}, #finally{'[finally: ^c]}} ->
;;             {a, b, c}
;;          {#stmt{*a}, #clause{*b}} ->
;;             {a, b, null}
;;          {#stmt{*a}, #finally{'[finally: ^c]}} ->
;;             {a, {}, c}
;;          otherwise ->
;;             throw E.syntax.try{msg, {node = form}} where
;;                msg = {"try expects a list of statements"
;;                       "and one or more catch clauses and/or"
;;                       "a finally clause"}.join{" "}

;;    #expr{.multi} ->
;;       #nostep{form}
;;    #expr{.ignore} ->
;;       clauses.push with
;;          info.mkenv{}.mark{'[e -> throw e]}
;;       #js_try{#multi{*stmts}, ..., finally or #void{}} with
;;          ' | {excv} ->
;;               ^ | parse_clauses with
;;                    info, 'excv, clauses
;;                    {wrap = {x} -> x}
;;    other ->
;;       clauses.push with
;;          info.mkenv{}.mark{'[e -> throw e]}
;;       ' | let [var rval = false]:
;;            ^ #js_try{'[set rval = ^[#multi{*stmts}]], ..., finally or #void{}} with
;;               ' | {excv} ->
;;                    ^ | parse_clauses with
;;                         info, 'excv, clauses
;;                         {wrap = {x} -> '[set rval = ^x]}
;;            rval

;; mac{"!!"}! tryop_mac{match, info, form, #data{expr, Body! {*clauses}}} =
;;    #expr{.multi} ->
;;       #nostep{form}
;;    #expr{.ignore} ->
;;       clauses.push with
;;          info.mkenv{}.mark{'[e -> throw e]}
;;       #js_try{expr, ..., #void{}} with
;;          ' | {excv} ->
;;               ^ | parse_clauses with
;;                    info, 'excv, clauses
;;                    {wrap = {x} -> x}
;;    other ->
;;       clauses.push with
;;          info.mkenv{}.mark{'[e -> throw e]}
;;       ' | let [var rval = false]:
;;            ^ #js_try{'[set rval = ^expr], ..., #void{}} with
;;               ' | {excv} ->
;;                    ^ | parse_clauses with
;;                         info, 'excv, clauses
;;                         {wrap = {x} -> '[set rval = ^x]}
;;            rval


;; [items{{...}} each {k, v} -> mac{k}{v}] with
;;    "@" => var_operator{"$it"}

;; expr_mac! mac{"chain"}! chain_mac{_, form, #data{defn and {=> env}, Body! {*body}}} =
;;    it = '[@] & {env = env}
;;    construct{match} =
;;       {x} -> x
;;       {x, *rest} ->
;;          ' | let [^it = ^x]:
;;               ^construct{rest}
;;    construct{{defn} ++ body}

;; expr_mac! mac{"using"}! using_mac{_, form, #data{defn and {=> env}, body}} =
;;    it = '[@] & {env = env}
;;    ' | let [^it = ^defn]:
;;         ^body

;; overridable! mac{"do"}! do_mac{match, _, form, #data{body}} =
;;    #clause ->
;;       #block{body}
;;    #test ->
;;       Body! {*stmts} = body
;;       #do{#splice{*stmts}}
;;    #expr ->
;;       #multi{body}


;; mac{"if"}! if_mac{ctx, _, form, match} =
;;    #data{test, a, b} ->
;;       #if{test, a, b}

;;    #data{test, #multi! #multi{*match}} ->
;;       {'then{^a}} ->
;;          #if{test, a, #value{undefined}}
;;       {'then{^a}, 'else{^b}} ->
;;          #if{test, a, b}
;;       body ->
;;          piece_together{conditions} =
;;             var rval = #value{undefined}
;;             conditions.reverse{} each {match, bod} ->
;;                null? ->
;;                   rval = bod
;;                test ->
;;                   rval = #if{test, bod, rval}
;;             rval

;;          conditions = {{test, #multi{*body}}}

;;          match ctx:
;;             #expr{.multi} ->
;;                #restmacro with {stmts} ->
;;                   while stmts.length:
;;                      match stmts.shift{}:
;;                         'elif{^cond, ^body} ->
;;                            conditions.push with {cond, body}
;;                         'else{^body} ->
;;                            conditions.push with {null, body}
;;                         x ->
;;                            stmts.unshift{x}
;;                            break
;;                   {piece_together{conditions}} ++ stmts

;;             else ->
;;                piece_together{conditions}



;; expr_mac! mac{"while"}! while_mac{info, form, match {=> env}} =
;;    '[. ^[#symbol{label}]] or #value{label} ->
;;       #macro with {context, _, form, #data{test, body}} ->
;;          setup_label{label, env, #js_while{test, body}}
;;    #data{test, body} ->
;;       setup_label{info.gensym{}, env, #js_while{test, body}}

;; mac{"for"}! for_mac{context, info, form, match expr} =
;;    do: setup_for{label, env, match, body} =
;;       #multi{a, b, c} ->
;;          #multi with
;;             a
;;             setup_label{label, env, #js_for{#multi{}, b, c, body}}
;;       '[^a in ^b] ->
;;          #multi with
;;             #declare{a, #value{null}} ;; this is to show the symbol as resolved
;;             setup_label{label, env, #js_for_in{a, b, body}}
;;       '[of]{^a, ^b} ->
;;          #multi with
;;             #declare{a, #value{null}} ;; this is to show the symbol as resolved
;;             setup_label{label, env, #js_for_of{a, b, body}}
;;    '[. ^[#symbol{label}]] or #value{label} ->
;;       #macro with {context, _, form, #data{spec, body}} ->
;;          setup_for{label, expr.env, spec, body}
;;    #data{spec, body} ->
;;       setup_for{info.gensym{}, form.env, spec, body}


;; mac{"var"}! var_mac{#pattern, _, form, argument} =
;;    #mode{.var, argument}

;; mac{"set"}! set_mac{#pattern, _, form, argument} =
;;    #mode{.set, argument}

;; mac{"let"}! let_mac{match, _, form, argument} =
;;    #pattern ->
;;       #mode{.let, argument}
;;    other ->
;;       match argument:
;;          #data{Body! {*bindings}, body} ->
;;             construct{match} =
;;                {} -> body
;;                ;; {x, *xs} ->
;;                ;;    #multi{x, construct{xs}} & {nonrecursive = true}
;;                {'[^bind = ^val], *xs} ->
;;                   #multi{'[let ^bind = ^val], construct{xs}} & {nonrecursive = true}
;;             construct{bindings}
;;             ;; #multi{*bindings, body} & {nonrecursive = true}

;; expr_mac! mac{"letrec"}! letrec_mac{_, form, #data{Body! {*bindings}, body}} =
;;    #multi{*let_bindings, body} where
;;       let_bindings = bindings each '[^b = ^v] -> '[let ^b = ^v]

;; mac{"where"}! where_mac{context, _, form, #data{body, bindings}} =
;;    'letrec{^bindings, ^body}


;; [items{{...}} each {k, v} -> mac{k}{v}] with

;;    "break" => break_mac{null}
;;    "continue" => continue_mac{null}


;; expr_mac! mac{"yield"}! yield_mac{_, form, match} =
;;    'all[^arg] -> #js_yield{arg, #value{true}}
;;    arg -> #js_yield{arg, #value{false}}

;; expr_mac! mac{"await"}! await_mac{_, form, match} =
;;    'all[^arg] -> #js_yield{'Promise.all{^arg}, #value{false}}
;;    'any[^arg] -> #js_yield{'Promise.race{^arg}, #value{false}}
;;    arg -> #js_yield{arg, #value{false}}

;; expr_mac2! mac{"gen"}! gen_mac{match} =
;;    '{^arg -> ^body} ->
;;       '[^arg *-> ^body]
;;    '{_lambda{^arg, ^pre, ^body, ^post, ^_}} ->
;;       '_lambda{^arg, ^pre, ^body, ^post, ^=true}

;; expr_mac2! mac{"async"}! async_mac{match} =
;;    '{^arg -> ^body} ->
;;       '[^arg -> spawn{{} *-> ^body}]
;;    '{_lambda{^arg, ^pre, ^body, ^post, ^_}} ->
;;       ;; TODO: this is wrong; post should be inside the spawn
;;       '_lambda{^arg, ^pre, spawn{{} *-> ^body}, ^post, ^=false}


;; expr_mac! mac{"throw"}! throw_mac{_, form, arg} =
;;    #js_throw{arg}

;; expr_mac! mac{"return"}! return_mac{_, form, arg} =
;;    #js_return{arg}

;; expr_mac! mac{"new"}! new_mac{_, form, arg} =
;;    #js_new{arg}

;; mac{"delete"}! delete_mac{context, _, form, match arg} =
;;    #symbol{s} ->
;;       #undeclare{arg}
;;    other ->
;;       #js_delete{other}

;; mac{"splice"}! splice_mac{context, _, form, #data{Body! {*stmts}}} =
;;    #splice{*stmts}


[items{kv} each {k, v} -> mac{k}{v}] where kv = {

   "null" = value_mac{.null, chk} where
      chk{x} = '[^x === ^=null]
   "undefined" = value_mac{.undefined, chk} where
      chk{x} = '[^x === ^=undefined]
   "true" = value_mac{.true, chk} where
      chk{x} = 'if{^x, true, false}
   "false" = value_mac{.false, chk} where
      chk{x} = '[not ^x]
   "String" = value_mac{.String, chk, proj} where
      chk{x} = '[typeof{^x} === .string]
      proj{x} = '{true, String{^x}}
   "Number" = value_mac{.Number, chk, proj} where
      chk{x} = '[typeof{^x} === .number]
      proj{x} = '{true, parseFloat{^x}}
   "Boolean" = value_mac{.Boolean, chk, proj} where
      chk{x} = '[typeof{^x} === .boolean]
      proj{x} = '{true, Boolean{^x}}

}

;; mac{"?"}! check_mac{match context, info, form, #data{chk, target}} =
;;    do:
;;       checker = match info.step{#check{context}, chk}:
;;          === chk -> 'getChecker{^chk}
;;          checker -> checker
;;    #pattern ->
;;       subp = if{target == #void, #ignore, target}
;;       match checker:
;;          #raw{projector} ->
;;             checker
;;          else ->
;;             #check{checker, subp}
;;    when target == #void ->
;;       checker
;;    other ->
;;       '[^checker]{^target}

;; mac{"!"}! project_mac{match context, info, form, #data{proj, target}} =
;;    do:
;;       projector = match info.step{#project{context}, proj}:
;;          === proj -> 'getProjector{^proj}
;;          projector -> projector
;;    #pattern ->
;;       subp = if{target == #void, #ignore, target}
;;       match projector:
;;          #raw{projector} ->
;;             projector
;;          #unconditional{projector} ->
;;             #project{projector, subp, true}
;;          else ->
;;             #project{projector, subp}
;;    when target == #void ->
;;       '[{x} -> [^projector]{x}[1]]
;;    other ->
;;       '[^projector]{^target}[1]

;; mac{"#"}! hash_mac{context, _, form, #data{#void{}, #symbol{var tag}}} =
;;    set tag = #value{tag}
;;    #macro{f} where f{match, _, form, expr} =
;;       #pattern ->
;;          checker_mac = #macro with {context, _, form, #data{expr}} ->
;;             ' | let [x = ^expr]:
;;                  [[instanceof]{x, Array} and x[0] === ^tag]
;;          match expr:
;;             #data{*subp} -> '{^tag, ^*subp}
;;             #void{} -> #check{checker_mac, #ignore{}}
;;             other -> #check{checker_mac, expr}
;;       #check ->
;;          'getChecker{{^tag}}
;;       #project ->
;;          'getProjector{{^tag}}
;;       _ ->
;;          match expr:
;;             #void{} ->
;;                '{^tag}
;;             #data{*args} ->
;;                '{^tag, ^*args}
;;             other ->
;;                '{^tag}[^other]



mac{"class"}! class_mac{context, info and {=> env}, form, expr} =
   helper{name, super, stmts} =
      var statics = #data{'[=]}
      var ctor = {#data{}, #multi{} & {env = env}}
      new_stmts = stmts each
         #send{'static, #data{Body! {*methods}}} ->
            statics ++= methods
         '[constructor[^args] = ^body] or '[constructor = ^args -> ^body] ->
            set ctor = {args, body}
            #splice{}
         '[^lhs = ^rhs] ->
            parse_pattern{info, lhs, rhs} with
               pattern_handlers.build_object & {
                  allow_nested = false
                  assign{#symbol{v} or #value{v}, value} =
                     #do{#assign{'[^name].prototype[^=v], value} <<: v}
                  declare{vars} = {}
                  wrap_target{match} =
                     '[^args -> ^body] ->
                        {env => other_env} = body
                        it = #symbol{"@"} & {env = other_env}
                        it2 = #symbol{"self"} & {env = other_env}
                        '_lambda{
                           ^args
                           splice: [let ^it = this, let ^it2 = this]
                           ^body
                           ^=null
                           ^=false
                        }
                     other ->
                        other
                  success{_} = #splice{}
               }
         when false -> pass

      {ctor_args, ctor_body} = ctor
      ctor_expr =
         {env => env2} = ctor_body
         it = #symbol{"@"} & {env = env2}
         cls =
            '_lambda{
               ^ctor_args
               ^it = if{not [^name]? this, Object.create{[^name].prototype}, this}
               ^ctor_body
               ^it
               ^=false
            }
         if super:
            then: '___extend{^cls, ^super}
            else: cls

      match name:
         #symbol{name_str} ->
            statics.push with
               '["::name" = ^=name_str]
         else ->
            pass

      statics.push with
         '["::egclass" = true]

      node =
         #splice{
            '[let ^name = ^ctor_expr]
            '[^*new_stmts]
            '[[^name] &: ^statics]
            name
         }

      match context:
         #expr{.multi} -> node
         other -> #multi{node}

   match expr:
      #data{match, Body! {*stmts}} ->
         '[^name {^super}] ->
            helper{name, super, stmts}
         '[^name {}] or [#symbol{_} and name] ->
            helper{name, null, stmts}
      #data{Body! {*stmts}} ->
         helper{#symbol{info.gensym{}}, null, stmts}


;; mac{"%"}! buildnode_mac{context, _ and {=> env}, form, #data{descr, var contents}} =
;;    match context:
;;       #check or #project ->
;;          return #nostep{form}
;;       else -> pass

;;    var tags = #data{}
;;    kv = '{=}

;;    parse{match whole} =
;;       #void{} -> null
;;       #symbol{s} ->
;;          tags.push with #value{s}
;;       #value{String! x} ->
;;          tags.push with #value{x}
;;       '[. ^[#symbol{x} or #value{String! x}]] ->
;;          tags.push with #value{"." + x}
;;       #send{#symbol{"^"}, #data{#void{}, expr}} ->
;;          tags.push with expr
;;       '[^_ = ^_] ->
;;          kv.push with whole
;;       #send{expr, rest} ->
;;          parse{expr}, parse{rest}
;;       #multi{*args} or #data{*args} ->
;;          args each arg -> parse{arg}

;;    parse{descr}

;;    contents ?=
;;       #void{} -> #array{}
;;       #multi{*args} ->
;;          xs = {}
;;          args each
;;             pair and '[^k = ^v] ->
;;                kv.push with pair
;;             spl and '[** ^_] ->
;;                kv.push with spl
;;             other ->
;;                xs.push with other
;;          #array{*xs}
;;       pair and '[^k = ^v] ->
;;          kv.push with pair
;;          #array{}
;;       x -> x

;;    'Node{^tags, ^kv, ^contents}

;; mac{"S"}! S_mac{context, info, form, arg} =
;;    #value with
;;       match info.gettext{arg}:
;;          R"^\[(.|\n)*\]$"? text -> text.substring{1, text.length - 1}
;;          text -> text


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ;; REQUIRE/PROVIDE AND GLOBALS ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; mac{"require"}! require_mac{context, info, form, match} =
;;    #data{expr} ->
;;       req = #variable{.require}
;;       stmts = {}

;;       topfetch{pkg, v} =
;;          stmts.push with '[^v = [^req]{^pkg}]
;;          v

;;       produce{match expr, fetch} =

;;          #symbol{s} ->
;;             fetch{#value{s}, expr}

;;          #value{String? s} ->
;;             fetch{expr, #symbol{info.gensym{}}}

;;          #multi{*subp} or #data{*subp} ->
;;             subp each p -> produce{p, fetch}
;;             null

;;          #send{#symbol{"^"}, #data{#void{}, name}} ->
;;             fetch{name, #symbol{info.gensym{}}}

;;          #send{#symbol{"as"}, #data{pkg, s}} ->
;;             produce{pkg} with {the_pkg, _} ->
;;                fetch{the_pkg, s}

;;          #send{#symbol{"->"}, #data{pkg, subp}} ->
;;             pkgv = produce{pkg, fetch}
;;             produce{subp} with {pkg, v} ->
;;                 stmts.push with '[^v = ^pkgv ^pkg]
;;                 v

;;       produce{expr, topfetch}
;;       #splice{*stmts}

;;    #void{} ->
;;       #variable{.require}

;;    arg ->
;;       #send{#variable{.require}, arg}

;; mac{"provide"}! provide_mac{context, _, form, #data{Body! {*expr}}} =
;;    exp = form.env.mark{'exports}
;;    #sink with
;;       #multi ++
;;          expr each
;;             s and #symbol{name} ->
;;                '[[^exp][^=name] = ^s]
;;             '[^s as ^[#symbol{name} or #value{name}]] ->
;;                '[[^exp][^=name] = ^s]
;;             other ->
;;                throw E.syntax.provide with
;;                   "Each clause of provide must be 'sym' or 'sym as name'"

;; mac{"inject"}! inject_mac{context, _, form, #data{Body! {*expr}}} =
;;    #restmacro with {stmts} ->
;;       exp = form.env.mark{'exports}
;;       {'[
;;           globals: module
;;           module.exports{^*expr} =
;;              var ^exp = {=}
;;              ^[#multi{*stmts}]
;;              ^exp
;;        ]}

;; mac{"globals"}! globals_mac{context, _, form, #data{Body! {*vars}}} =
;;    #splice{*[...]} with
;;       vars each variable and #symbol{s} -> #declare_raw{variable, #variable{s}}


;; ;;;;;;;;;;;
;; ;; QUOTE ;;
;; ;;;;;;;;;;;

;; qqstruct{name, args} =
;;    #data{#value{name}, *args}

;; qq{match expr} =
;;    #symbol{s} -> qqstruct{.symbol, {#value{s}}}
;;    #char{s} -> qqstruct{.char, {#value{s}}}
;;    #void{} -> qqstruct{.void, {}}
;;    #value{v} ->
;;       qqstruct{.value, {expr}}
;;    #send{#symbol{"^"}, #data{#void{}, insert}} ->
;;       insert
;;    #send{#symbol{"^="}, #data{#void{}, insert}} ->
;;       qqstruct{.value, {insert}}
;;    #send{#symbol{"^*"}, #data{#void{}, insert}} ->
;;       '[* ^insert]
;;    #mismix{ops, *args} ->
;;       qqstruct{.mismix
;;                {#data{*[ops each op -> qq{op}]}
;;                 *[args each arg -> qq{arg}]}}
;;    {name, *args} ->
;;       qqstruct{name, args each arg -> qq{arg}}

;; mac{"'"}! quote_mac{context, _, form, #data{#void{}, expr}} =
;;    qq{expr}



;; ;;;;;;;;;;;;;;;;;;;;;;;;;
;; ;; REGULAR EXPRESSIONS ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;;

;; class RegexBuilder:

;;    wrap{x} =
;;       "(?:" + x + ")"

;;    quote{x} =
;;       x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

;;    quote_charset{x} =
;;       x.replace{R.g'{in "[](){}^"}, "\\$1"}

;;    build{expr} =
;;       match expr:
;;          #symbol{match} ->
;;             .any -> "."
;;             .start -> "^"
;;             .end -> "$"
;;             .alpha -> "\\a"
;;             .digit -> "\\d"
;;             .word -> "\\w"
;;             .space -> "\\s"
;;             .boundary -> "\\b"
;;             .a -> "\\a"
;;             .d -> "\\d"
;;             .w -> "\\w"
;;             .s -> "\\s"
;;             .b -> "\\b"

;;          #value{x} -> @quote{x}

;;          #send{#symbol{"raw"}, #value{s}} ->
;;              s

;;          #send{#symbol{match}, #data{a, b}} ->
;;             "||" ->
;;                @wrap{@build{a} + "|" + @build{b}}
;;             "or" ->
;;                @wrap{@build{a} + "|" + @build{b}}
;;             "*" ->
;;                #void{} = a
;;                @wrap{@build{b} + "*"}
;;             "+" ->
;;                #void{} = a
;;                @wrap{@build{b} + "+"}
;;             "?" ->
;;                #void{} = a
;;                @wrap{@build{b} + "?"}
;;             "in" ->
;;                #void{} = a
;;                #value{v} = b
;;                ["[" + x + "]"] where
;;                   x = @quote_charset{v}
;;             "not" ->
;;                #void{} = a
;;                #send{#symbol{"in"}, #data{#void{}, #value{v}}} = b
;;                ["[^" + x + "]"] where
;;                   x = @quote_charset{v}

;;          #data{*args} ->
;;             "(" + [args each arg -> @build{arg}].join{""} + ")"
;;          #multi{*args} ->
;;             "(?:" + [args each arg -> @build{arg}].join{""} + ")"

;;          other ->
;;             E.syntax.regexp with
;;                "Illegal regular expression"
;;                {expr = expr}

;; build_regexp{x} = RegexBuilder{}.build{x}

;; accum_flagsf{f} = accum_flags{f, false}
;; accum_flagsf! mac{"R"}! regexp_mac{match, info, form, arg, flags} =
;;    #check or #project ->
;;       #nostep{form}
;;    else ->
;;       match arg:
;;          #value{String? v} ->
;;             text =
;;                ;; match arg.location.text{}:
;;                match info.gettext{arg}:
;;                   R"^\".*\"$"? text -> text.substring{1, text.length - 1}
;;                   text -> text
;;             'RegExp{^=text, ^=[flags.join{""}]}
;;          #send{#symbol{"'"}, #data{#void{}, arg}} ->
;;             'RegExp{^=build_regexp{arg}, ^=[flags.join{""}]}



;;;;;;;;;;;;;;;;;;;
;; ERROR FACTORY ;;
;;;;;;;;;;;;;;;;;;;

mac{"E"}! E_mac = errf_macro{{}} where
   errf_macro{tags}{match, _, form, expr} =
      #check or #project -> #nostep{form}
      ctx ->
         match expr:
            #void{} ->
               'ErrorFactory{{^*tags}}
            #data{*args} ->
               'ErrorFactory{{^*tags}}.create{^*args}
            other ->
               #macro with errf_macro{tags ++ {other}}



;; ;;;;;;;;;;;;;
;; ;; TESTING ;;
;; ;;;;;;;;;;;;;

;; blocktest_wrap{expr} =
;;    ' | value = [[...] !! e -> #error{e}] with
;;         match [^expr]:
;;            true? x -> #success{x}
;;            false? x -> #failure{x}
;;      | acc.push with
;;         #test_result{label, value}

;; _blocktest_mac{info, tests} =

;;    exptests = enumerate{info.step_all{#test, tests}}
;;    n = exptests.length
;;    stmts = exptests each

;;       {i, #do{stmt}} ->
;;          stmt

;;       {i, #blocktest{more_labels, more_tests}} ->
;;          ' | let [label = label.concat{Array! ^more_labels}]:
;;               set acc = acc.concat with
;;                  ^_blocktest_mac{info, more_tests}

;;       {i, #test_factory{elements, clauses} and {=> env}} ->
;;          build_loop{info, env, #void{}
;;                     elements, clauses, wrap, #splice{}, #splice{}
;;                     {fallback = fall}} where
;;             wrap{expr, index} =
;;                ' | let [label = label.concat{{^index}}]:
;;                     ^blocktest_wrap{expr}
;;             fall{target} =
;;                match_error{target}

;;       {i, expr} ->
;;          lbl = if{n === 1, '{}, '{^=i}}
;;          ' | let [label = label.concat{^lbl}]:
;;               ^blocktest_wrap{expr}

;;    ' | let [var acc = {}]:
;;         [[...] !! e -> acc.concat{{#error{label, e}}}] with
;;            [^*stmts, acc]

;; mac{"blocktest"}! blocktest_mac{context, info, form, #data{*match}} =
;;    {Body! {*tests}} ->
;;       ' | label = {}
;;         | ^_blocktest_mac{info, tests}
;;    {labels, Body! {*tests}} ->
;;       ' | label = Array! ^labels
;;         | ^_blocktest_mac{info, tests}


;; mac{"timeit"}! timeit_mac{context, info, form, #data{body}} =
;;    '[t = process.hrtime{}
;;      result = ^body
;;      {s, n} = process.hrtime{t}
;;      {result, s * 1000 + n / 1e6}]


;; ;;;;;;;;;;;;
;; ;; MACROS ;;
;; ;;;;;;;;;;;;

;; wrap_macro{info, mac} =
;;    mac2{c, s, f, e} =
;;       bindings = info.env.list_bindings{info.scope}
;;       env = Env{}
;;       env.scopes[topscope.name] = bindings
;;       r = mac.call{info, c, s, f, e}
;;       env.mark{r}
;;    #macro{mac2}

;; mac{"macro"}! macro_mac{context, info, form, match} =
;;    #data{#send{name and #symbol{sym}, arguments}, ast} ->
;;       let mac = info.go{'[^arguments -> ^ast], .parse, .eval}
;;       #declare_raw{name, wrap_macro{info, mac}}

;; mac{"cmacro"}! cmacro_mac{context, info, form, match} =
;;    #data{#send{name and #symbol{sym}, arguments}, ast} ->
;;       let mac = info.go{'[^arguments -> ^ast], .parse, .eval}
;;       #declare_raw{name, wrap_macro{info, ctx_mac{mac}}}

;; mac{"emacro"}! emacro_mac{context, info, form, match} =
;;    #data{#send{name and #symbol{sym}, argument}, ast} ->
;;       let mac = info.go{'[{^argument} -> ^ast], .parse, .eval}
;;       #declare_raw{name, wrap_macro{info, expr_mac2{mac}}}

;; mac{"macros"}! macros_mac{context, info, form and {=> env}, #data{body}} =
;;    the_macros = info.go{body, .parse, .eval}
;;    #splice{*[...]} with
;;       items{the_macros} each {k, v} ->
;;          #declare_raw{#symbol{k} &: {env = env}, #macro{v}}


stdenv = Env{}

items{stdstore} each {k, v} ->
   stdenv.bind{topscope, k, v}

make_expander{pipeline} =
   Expander{stdenv.fork{}, generic_nodes, pipeline} where
      generic_nodes = {
         .if
         .js_while, .js_for, .js_for_in, .js_for_of, .js_label
         .js_break, .js_continue, .js_return
         .js_delete, .js_throw, .js_try, .js_new
         .js_yield
      }
