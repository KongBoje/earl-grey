
require:
   "./helpers" -> Body

inject: mac

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; REQUIRE/PROVIDE AND GLOBALS ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

mac{"__require"}! __require_mac{context, info, form, expr} =
   req = #variable{.require} &: {top = true}
   `[^req][^expr]`


mac{"require"}! require_mac{context, info, form, match arg} =

   #void{} ->
      #variable{.require}

   #data{expr} or expr is arg ->
      ;; req = #variable{.require} &: {top = true}
      req = info.mark{`__require`}
      stmts = {}

      topfetch{pkg, v, args = null} =
         stmts.push with
            if args:
               then: `^v = [^req]{^pkg}[^args]`
               else: `^v = [^req]{^pkg}`
         v

      produce{match expr, fetch} =

         #symbol{s} ->
            fetch{#value{s}, expr}

         #value{String? s} ->
            fetch{expr, #symbol{info.gensym{}}}

         #multi{*subp} or #data{*subp} ->
            subp each p -> produce{p, fetch}
            null

         #send{#symbol{"^"}, #data{#void{}, name}} ->
            fetch{name, #symbol{info.gensym{}}}

         #send{#symbol{"as"}, #data{pkg, s}} ->
            produce{pkg} with {the_pkg, _, args = null} ->
               fetch{the_pkg, s, args}

         #send{#symbol{"->"}, #data{pkg, subp}} ->
            pkgv = produce{pkg, fetch}
            produce{subp} with {pkg, v, args = null} ->
               stmts.push with
                  if args:
                     then: `^v = [^pkgv][^pkg][^args]`
                     else: `^v = [^pkgv][^pkg]`
               v

         #send{name and #symbol{s}, args and #data{*_}} ->
            fetch{#value{s}, name, args}

      produce{expr, topfetch}
      #splice{*stmts}

   ;; arg ->
   ;;    #send{#variable{.require}, arg}

mac{"provide"}! provide_mac{context, _, form, #data{Body! {*expr}}} =
   exp = form.env.mark{`exports`}
   #sink with
      #multi ++
         expr each
            s and #symbol{name} ->
               `[^exp][^=name] = ^s`
            `^s as ^[#symbol{name} or #value{name}]` ->
               `[^exp][^=name] = ^s`
            other ->
               throw E.syntax.provide with
                  "Each clause of provide must be 'sym' or 'sym as name'"

mac{"inject"}! inject_mac{context, _, form, #data{Body! {*expr}}} =
   #restmacro with {stmts} ->
      exp = form.env.mark{`exports`}
      {```
          globals: module
          module.exports{^*expr} =
             var ^exp = {=}
             ^[#multi{*stmts}]
             ^exp
       ```}

mac{"globals"}! globals_mac{context, _, form, #data{Body! {*vars}}} =
   #splice{*globs, `undefined`} where globs =
      vars each variable and #symbol{s} ->
         #declare_raw{variable, #variable{s} &: {top = true}}
