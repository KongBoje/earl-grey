
require:
   "./helpers" ->
      expr_mac, expr_mac2
      AssignmentHandler

inject: mac


mac{"yield"}! yield_mac{match, _, form, arg} =
   #pattern ->
      #special{AssignmentHandler{subp, w}} where
         subp = if{arg == #void{}, null, arg}
         w{ph} = `yield ^ph`
   #expr{.expr} or #expr{.head} ->
      match arg:
         `all[^arg]` -> #js_yield{arg, #value{true}}
         arg -> #js_yield{arg, #value{false}}
   otherwise ->
      #nostep{form}

mac{"await"}! await_mac{match, _, form, arg} =
   #pattern ->
      #special{AssignmentHandler{subp, w}} where
         subp = if{arg == #void{}, null, arg}
         w{ph} = `await ^ph`
   #expr{.expr} or #expr{.head} ->
      match arg:
         `all[^arg]` -> #js_yield{`Promise.all{^arg}`, #value{false}}
         `any[^arg]` -> #js_yield{`Promise.race{^arg}`, #value{false}}
         arg -> #js_yield{arg, #value{false}}
   otherwise ->
      #nostep{form}

;; expr_mac! mac{"yield"}! yield_mac{_, form, match} =
;;    'all[^arg] -> #js_yield{arg, #value{true}}
;;    arg -> #js_yield{arg, #value{false}}

;; expr_mac! mac{"await"}! await_mac{_, form, match} =
;;    'all[^arg] -> #js_yield{'Promise.all{^arg}, #value{false}}
;;    'any[^arg] -> #js_yield{'Promise.race{^arg}, #value{false}}
;;    arg -> #js_yield{arg, #value{false}}

expr_mac2! mac{"gen"}! gen_mac{match} =
   `{^arg -> ^body}` ->
      `^arg *-> ^body`
   `{_lambda{^arg, ^pre, ^body, ^post, ^_}}` ->
      `_lambda{^arg, ^pre, ^body, ^post, ^=true}`

expr_mac2! mac{"async"}! async_mac{match} =
   `{^arg -> ^body}` ->
      `^arg -> spawn.call{this, {} *-> ^body}`
   `{_lambda{^arg, ^pre, ^body, ^post, ^_}}` ->
      ;; TODO: this is wrong; post should be inside the spawn
      `_lambda{^arg, ^pre, spawn{{} *-> ^body}, ^post, ^=false}`


mac{"genx"}! genx_mac{match, info, form, expr} =
   when expr == #void{} ->
      #nostep{form}
   #pattern ->
      #project{#macro{mac}, expr, true} where mac{*blah, #data{match e}} =
         #use{env, x} ->
            #use{env, mac.call{this, #data{x}}}
         `^arg -> ^body` ->
            `^arg *-> ^body`
         `_lambda{^arg, ^pre, ^body, ^post, ^_}` ->
            ;; TODO: this is wrong; post should be inside the spawn
            `_lambda{^arg, ^pre, ^body, ^post, ^=true}`
         else ->
            throw E.syntax.gen{"gen must decorate a function", {node = e}}
   match is expr ->
      `{^arg -> ^body}` or `^arg -> ^body` ->
         `^arg *-> ^body`
      `{_lambda{^arg, ^pre, ^body, ^post, ^_}}` ->
         ;; TODO: this is wrong; post should be inside the spawn
         `_lambda{^arg, ^pre, ^body, ^post, ^=true}`
      else ->
         throw E.syntax.gen{"gen must be applied on a function", {expr = expr}}

mac{"asyncx"}! async2_mac{match, info, form, expr} =
   when expr == #void{} ->
      #nostep{form}
   #pattern ->
      #project{#macro{mac}, expr, true} where mac{*blah, #data{match e}} =
         #use{env, x} ->
            #use{env, mac.call{this, #data{x}}}
         `^arg -> ^body` ->
            `^arg -> spawn.call{this, {} *-> ^body}`
         `_lambda{^arg, ^pre, ^body, ^post, ^_}` ->
            ;; TODO: this is wrong; post should be inside the spawn
            `_lambda{^arg, ^pre, spawn.call{this, {} *-> ^body}, ^post, ^=false}`
         else ->
            throw E.syntax.async{"async must decorate a function", {node = e}}
   match is expr ->
      `{^arg -> ^body}` or `^arg -> ^body` ->
         `^arg -> spawn.call{this, {} *-> ^body}`
      `{_lambda{^arg, ^pre, ^body, ^post, ^_}}` ->
         ;; TODO: this is wrong; post should be inside the spawn
         `_lambda{^arg, ^pre, spawn.call{this, {} *-> ^body}, ^post, ^=false}`
      `{^x}` or x ->
         `spawn.call{this, {} *-> [try{await ^x}, catch{e, console.error{e.stack}}]}`

