
require:
   "./location" ->
      Location, [<<:]

provide:
   tokenize


special_ops = {
   ;; Operators for which the fixity is predetermined regardless
   ;; of whitespace or other factors.
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
   "'" => .PFX
   "not" => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {numr,   numr_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {op4,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where

  ;; Identifiers
  ;; ex. abc, Abc123, _x, $, a$b$c
  id = R'
     start
     in "a-zA-Z$_"
     * in "a-zA-Z$_0-9"

  id_f = {m, wsb, wsa, last_op} -> #ID{.ID, m[0]}


  ;; Numbers with arbitrary radii
  ;; ex. 2r1110, 36rZ, 4r312.33
  numr = R'
     start
     {+d}, in "rR"
     {+ in"A-Za-z0-9_"}
     ?[".", {+ in "A-Za-z0-9_"}]

  numr_f = {m, wsb, wsa, last_op} ->
     {_, radix, intp, frac} = m
     value = parseInt{intp.replace{R.g"_", ""}, radix}
     if frac:
        frac := frac.replace{R.g"_", ""}
        value := value + parseInt{frac, radix} / Math.pow{radix, frac.length}
     #ID{.NUM, value}


  ;; Base 10 numbers
  num = R'
     start
     {+ in "0-9_"}
     ?[".", {+d}]
     ?[in "eE", {? in "+-", + in "0-9_"}]

  num_f = {m, wsb, wsa, last_op} ->
     #ID{.NUM, parseFloat{m[0].replace{R.g"_", ""}}}


  ;; Strings (no interpolation)
  str = R'
     start
     "\""
     {*["\\\\" or "\\\"" or [not in "\""]]}
     "\""

  str_f = {m, wsb, wsa, last_op} ->
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{R.g'{"\\\"" or "\\\\" or "\\n"}, {m} -> repl[m]}
     #ID{.STR, r}


  ;; Operators
  ;; ex. +, -, **+, ^%, ...
  op = R'
     start
     + in "+\\-*/~^<>=%&|?!@#.:'"

  ;; brackets: [], {}
  op2 = R'
     start
     in "[{}],"

  ;; Word operators: with, each, each?, where%+%, etc.
  op3 = R'
     start
     "with" or "where" or "when"
       \ or "and" or "not" or "or"
       \ or "in" or "mod"
       \ or "each" or "as"
     [+ in "+\\-*/~^<>=%&|?!@#.:'"] or boundary

  ;; `operator`
  op4 = R'
     start
     "`", {+ in "A-Za-z0-9_"}, "`"

  op_f = {m, wsb, wsa, last_op, column} ->
     op = m[1] or m[0]

     match:
        when op === "|" ->
           ;; | is equivalent to an indent to its column
           {.INDENT, column - 1}

        when op in special_ops ->
           ;; These operators have predetermined fixities;
           ;; Refer to special_ops before
           fixity = special_ops[op]
           width =
              match fixity:
                 .IFX -> if{wsb or wsa, .wide, .short}
                 .SFX -> if{wsb, .wide, .short}
                 .PFX -> if{wsa, .wide, .short}
                 other -> throw E.syntax.should_never_happen{"unknown fixity"}
           #OP{fixity, width, op}

        when wsa and wsb ->
           ;; Whitespace on the left and right of the operator means
           ;; that the operator is infix, unless the previous token was
           ;; an operator.
           #OP{if{last_op, .PFX, .IFX}, .wide, op}

        when not wsa and not wsb ->
           ;; Lack of whitespace on the left and right of the operator means
           ;; that the operator is infix, unless the previous token was
           ;; an operator.
           #OP{if{last_op, .PFX, .IFX}, .short, op}

        when wsa and last_op  ->
           ;; If there's whitespace after the op but not before, but that the
           ;; previous token was an op, this is a prefix use
           #OP{.PFX, .wide, op}

        when wsa ->
           ;; If there's whitespace after the op but not before it's suffix
           #OP{.SFX, .short, op}

        when wsb ->
           ;; If there's whitespace before the op but not after it's prefix
           #OP{.PFX, .short, op}

        _ ->
           #OP{.PFX, .short, op}


  ;; Indent
  indent = R'
     start
     +["\n", {*" "}]

  indent_f = {m, wsb, wsa, last_op} ->
     ilen = m[1].length
     #INDENT{ilen}


  ;; Comment
  cmnt = R'
     start
     ";"
     * not in "\n"

  cmnt_f = {m, wsb, wsa, last_op} -> #IGNORE{}


  ;; Anything else is an error
  unkn = R'
     start
     any

  unkn_f = {m, wsb, wsa, last_op} ->
     #ILLEGAL{m[0]}



;; TODO: ignore blank lines before continuation
ws_re = R'[start, *" ", *["\n", *" ", "\\", *" "]]
eol_re = R'[start, *" ", "\n" or end]

indent_tracker{} =
   ;; This returns a function that tracks indentation levels
   ;; as tokens are fed into it. For each token it returns a
   ;; list of tokens including additional commas and brackets
   ;; corresponding to line breaks, indent and dedents.

   curr = false      ;; current indent
   stack = {}        ;; stack of indent levels up to this point
   stacks = {stack}  ;; [ or { start a new stack of indent levels

   ;; We return the following function
   {match token} ->

      #INDENT{match new_indent} ->
         when [curr === false] ->
            ;; This is the first line break, we produce ","
            curr := new_indent
            {#OP{.IFX, .wide, ","}}

         [> curr] ->
            ;; Indent is larger than before, so we push the previous
            ;; and produce "["
            stack.push{curr}
             curr := new_indent
            {#OP{.PFX, .wide, "["}}

         [=== curr] ->
            ;; Same as before, ","
            {#OP{.IFX, .wide, ","}}

         [< curr] ->
            ;; Smaller than before, so we generate "]" until
            ;; the new indent is no larger than the current one
            rval = {}
            while [[stack.length > 0] and [new_indent < curr]]:
               curr := stack.pop{}
               rval.push{#OP{.SFX, .wide, "]"}}
            rval.push{#OP{.IFX, .wide, ","}}
            rval

      #ID{*stuff} -> {token}

      #OP{fixity, width, "[" or "{"} ->
         ;; We restart indent calculation inside each []/{} that
         ;; we find.
         stack.push{curr}
         stacks.push{stack}
         stack := {}
         curr := false
         {token}

      #OP{fixity, width, "]" or "}"} ->
         ;; We close all indented blocks with every closing bracket
         rval = stack each _ -> #OP{.SFX, .short, "]"}
         stack := stacks.pop{}
         curr := stack.pop{}
         rval.push{token}
         rval

      other -> {token}


process_token{src, token, last_op, wsa, wsb, accum} =
   {type, *result} = token
   result <<: token
   match type:
      .IGNORE ->
         last_op

      .ID ->
         if [not last_op]:
            accum.push with
               #IFX{if{wsb, .wide, .short}, .WHITE}
         accum.push{result}
         false

      .OP ->
         if last_op:
            accum.push with #VOID{}
         match result[0]:
            .IFX ->
               accum.push{result}
               true
            .PFX ->
               if [not last_op]:
                  accum.push with
                     #IFX{if{wsb, .wide, .short}, .WHITE}
                     #VOID{}
               accum.push{result}
               true
            .SFX ->
               accum.push with
                  result
                  #VOID{}
               false

      .ILLEGAL ->
         throw E.syntax.illegal{"unknown character", {chr = token}}


      other ->
         throw E.should_never_happen{"unknown token type", {token = token}}


fill_locations{source, stream} =
   to_fill = {}
   start = 0
   fill{end} =
      to_fill each
         first token ->
            token.location := Location{source, start, end}
         token ->
            token.location := Location{source, end, end}
      to_fill := {}
   stream each
      {=> location} when location ->
         fill{location.start}
         start := location.end
      other ->
         to_fill.push with other
   fill{source.text.length}
   stream


tokenize{src} =
   text = src.text
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos = wsb
   column = 0
   indent = indent_tracker{}

   while text:
      ;; regexps each {re, fn} ->
      for [i = 0, i < regexps.length, ++i]:
         {re, fn} = regexps[i]
         m = text.match{re}
         if m:
            skip = m[0].length
            endpos = pos + skip
            column :=
               splits = m[0].split{"\n"}
               if [splits.length > 1]:
                  then: splits[splits.length - 1].length
                  else: column + skip
            text := text.slice{skip}
            wsa = text.match{ws_re}[0].length
            eol = text.match{eol_re} and true
            bwsb = wsb > 0
            bwsa = if{eol, bwsb, wsa > 0}
            ;; bwsb = if{eol, true, wsb > 0}
            ;; bwsa = if{eol, true, wsa > 0}
            token = fn{m, bwsb, bwsa, last_op, column}
            token.location := Location{src, pos, endpos}
            tokens = indent{token}
            tokens each x ->
               ;; x.location := Location{src, pos, endpos}
               last_op := process_token{src, x, last_op, bwsa, bwsb, results}
            text := text.slice{wsa}
            column += wsa
            wsb := wsa
            pos := endpos + wsa
            break

   if last_op:
      results.push with #VOID{}

   fill_locations{src, results}


