
;; TEMP COMPATIBILITY LAYER

;; Void{} = null
;; Void["::check"] := {x} -> null? x
;; qqvoid{} = ~value{null}

Void{} = ~void{}
Void["::check"] := {x} ->
   x |>
      ;; null? -> true
      ~void{} -> true
      other -> false
qqvoid{} = qqstruct{.void, {}}

Symbol{s} = ~symbol{s}
Symbol["::check"] := {|>} ->
   ;;String? x -> true
   ~symbol{x} -> true
   other -> false
Symbol["::deconstruct"] := {|>} ->
   ;;String? x -> {x}
   ~symbol{x} -> {x}
;;qqsym{s} = ~value{s}
qqsym{s} = qqstruct{.symbol, {~value{s}}}

xsym{|>} =
   String? x -> x
   ~symbol{x} -> x




;; Symbol["::check"] := {|>} ->
;;    String? x -> true
;;    ~symbol{x} -> true
;;    other -> false
;; Symbol["::deconstruct"] := {|>} ->
;;    String? x -> {x}
;;    ~symbol{x} -> {x}


special_ops = {
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
   "'" => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {numr,   numr_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {op4,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where

  id = R'
     start
     in "a-zA-Z$_"
     * in "a-zA-Z$_0-9"

  id_f = {m, wsb, wsa, last_op} -> ~ID{.ID, m[0]}


  numr = R'
     start
     {+d}, in "rR"
     {+ in"A-Za-z0-9_"}
     ?[".", {+ in "A-Za-z0-9_"}]

  numr_f = {m, wsb, wsa, last_op} ->
     {_, radix, int, frac} = m
     value := parseInt{int.replace{R.g"_", ""}, radix}
     ? | frac =>
          frac := frac.replace{R.g"_", ""}
          value := value + parseInt{frac, radix} / Math.pow{radix, frac.length}
     ~ID{.NUM, value}


  num = R'
     start
     {+ in "0-9_"}
     ?[".", {+d}]
     ?[in "eE", {? in "+-", + in "0-9_"}]

  num_f = {m, wsb, wsa, last_op} ->
     ~ID{.NUM, parseFloat{m[0].replace{R.g"_", ""}}}


  str = R'
     start
     "\""
     {*["\\\\" or "\\\"" or [not in "\""]]}
     "\""

  str_f = {m, wsb, wsa, last_op} ->
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{R.g'{"\\\"" or "\\\\" or "\\n"}, {m} -> repl[m]}
     ~ID{.STR, r}

  op = R'
     start
     + in "+\\-*/~^<>=%&|?!@#.:'"

  op2 = R'
     start
     in "[{}],"

  op3 = R'
     start
     "with" or "where" or "when"
       \ or "and" or "not" or "or"
       \ or "in" or "instanceof" or "mod"
       \ or "each" or "as"
     boundary

  op4 = R'
     start
     "`", {+ in "A-Za-z0-9_"}, "`"

  op_f = {m, wsb, wsa, last_op, column} ->
     op = m[1] or m[0]
     ? | [op == "|"] =>
          {.INDENT, column - 1}

       | [op in special_ops] =>
          fixity = special_ops[op]
          width =
             fixity |>
                .IFX -> if{wsb or wsa, .wide, .short}
                .SFX -> if{wsb, .wide, .short}
                .PFX -> if{wsa, .wide, .short}
                other -> throw "OopsA"
          ~OP{fixity, width, op}

       | [wsa and wsb] =>
          ~OP{if{last_op, .PFX, .IFX}, .wide, op}

       | [not wsa and not wsb] =>
          ~OP{if{last_op, .PFX, .IFX}, .short, op}

       | [wsa and last_op] =>
          ~OP{.PFX, .wide, op}

       | wsa =>
          ~OP{.SFX, .short, op}

       | wsb =>
          ~OP{.PFX, .short, op}

       | else =>
          ~OP{.PFX, .short, op}

  indent = R'
     start
     +["\n", {*" "}]

  indent_f = {m, wsb, wsa, last_op} ->
     ilen = m[1].length
     ~INDENT{ilen}


  cmnt = R'
     start
     ";"
     * not in "\n"

  cmnt_f = {m, wsb, wsa, last_op} -> ~IGNORE{}


  unkn = R'
     start
     any

  unkn_f = {m, wsb, wsa, last_op} -> throw ["unknown character: " + m[0]]



;; TODO: ignore blank lines before continuation
ws_re = R'[start, *" ", *["\n", *" ", "\\", *" "]]
eol_re = R'[start, *" ", "\n" or end]

indent_tracker{} =
   curr = false
   stack = {}
   stacks = {stack}
   {token and |>} ->

      ~INDENT{new_indent and |>} ->
         when [curr == false] ->
            curr := new_indent
            {~OP{.IFX, .wide, ","}}

         [> curr] ->
            stack.push{curr}
             curr := new_indent
            {~OP{.PFX, .wide, "["}}

         [== curr] ->
            {~OP{.IFX, .wide, ","}}

         [< curr] ->
            rval = {}
            while [[stack.length > 0] and [new_indent < curr]]:
               curr := stack.pop{}
               rval.push{~OP{.SFX, .wide, "]"}}
            rval.push{~OP{.IFX, .wide, ","}}
            rval

      ~ID{*stuff} -> {token}

      ~OP{fixity, width, "[" or "{"} ->
         stack.push{curr}
         stacks.push{stack}
         stack := {}
         curr := false
         {token}

      ~OP{fixity, width, "]" or "}"} ->
         rval = stack each _ -> ~OP{.SFX, .short, "]"}
         stack := stacks.pop{}
         curr := stack.pop{}
         rval.push{token}
         rval

      other -> {token}


process_token{token, last_op, wsa, wsb, pos, endpos, accum} =
   {type, *result} = token
   type |>
      .IGNORE ->
         last_op

      .ID ->
         ? | [not last_op] =>
              w = {.IFX, if{wsb, .wide, .short}, .WHITE}
              w.location := {pos, pos}
              accum.push{w}
         accum.push{result}
         false

      .OP ->
         ? | last_op =>
              v = {.VOID}
              v.location := {pos, pos}
              accum.push{v}
         result[0] |>
            .IFX ->
               accum.push{result}
               true
            .PFX ->
               ? | [not last_op] =>
                    w = {.IFX, if{wsb, .wide, .short}, .WHITE}
                    w.location := {pos, pos}
                    v = {.VOID}
                    v.location := {pos, pos}
                    accum.push{w}
                    accum.push{v}
               accum.push{result}
               true
            .SFX ->
               accum.push{result}
               v = {.VOID}
               v.location := {endpos, endpos}
               accum.push{v}
               false

      other -> throw "OopsB"


tokenize{text} =
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos := wsb
   column := 0
   indent = indent_tracker{}

   while text:
      ;; regexps each {re, fn} ->
      for [i = 0, i < regexps.length, ++i]:
         {re, fn} = regexps[i]
         m = text.match{re}
         ? | m =>
             skip = m[0].length
             endpos = pos + skip
             column :=
                splits = m[0].split{"\n"}
                ? | [splits.length > 1] => splits[splits.length - 1].length
                  | else => column + skip
             text := text.slice{skip}
             wsa = text.match{ws_re}[0].length
             eol = text.match{eol_re} and true
             bwsb = wsb > 0
             bwsa = if{eol, bwsb, wsa > 0}
             ;; bwsb = if{eol, true, wsb > 0}
             ;; bwsa = if{eol, true, wsa > 0}
             token = fn{m, bwsb, bwsa, last_op, column}
             tokens = indent{token}
             tokens each x ->
                last_op := process_token{x, last_op, bwsa, bwsb, pos, endpos, results}
             text := text.slice{wsa}
             column += wsa
             wsb := wsa
             pos := endpos + wsa
             break
   ? | last_op =>
       v = {.VOID}
       v.location := {pos, pos}
       results.push{v}
   results



MAX = 1/0

order_map = {

   IFX = {
      wide = {
         ","     => {{2r1111, 1}, {2r1111, 1}}

         "with"  => {{2r1111, 999}, {2r1111, 10}}
         "each"  => {{2r1111, 11},  {2r1111, 10}}
         "where" => {{2r1111, 11},  {2r1111, 10}}
         "!!"    => {{2r1111, 11},  {2r1111, 10}}
         "|>"    => {{2r1111, 11},  {2r1111, 10}}
         "->"    => {{2r1111, 11},  {2r1111, 10}}
         "=>"    => {{2r1111, 11},  {2r1111, 10}}
         "="     => {{2r1111, 11},  {2r1111, 10}}
         ":="    => {{2r1111, 11},  {2r1111, 10}}
         "+="    => {{2r1111, 11},  {2r1111, 10}}
         "-="    => {{2r1111, 11},  {2r1111, 10}}
         "*="    => {{2r1111, 11},  {2r1111, 10}}
         "/="    => {{2r1111, 11},  {2r1111, 10}}
         "<<="   => {{2r1111, 11},  {2r1111, 10}}
         ">>="   => {{2r1111, 11},  {2r1111, 10}}
         ">>>="  => {{2r1111, 11},  {2r1111, 10}}

         ;; Misc
         "%"     => {{2r1111, 11}, {2r1111, 10}}

         ;; Logical
         "when" => {{2r1111, 100}, {2r1111, 101}}
         "||"   => {{2r1111, 110}, {2r1111, 111}}
         "&&"   => {{2r1111, 120}, {2r1111, 121}}
         "or"   => {{2r1111, 110}, {2r1111, 111}}
         "and"  => {{2r1111, 120}, {2r1111, 121}}
         "not"  => {{2r1111, 130}, {2r1111, 131}}

         ;; Comparison
         "==" => {{2r1111, 200}, {2r1111, 201}}
         "!=" => {{2r1111, 200}, {2r1111, 201}}
         ">=" => {{2r1111, 200}, {2r1111, 201}}
         "<=" => {{2r1111, 200}, {2r1111, 201}}
         ">"  => {{2r1111, 200}, {2r1111, 201}}
         "<"  => {{2r1111, 200}, {2r1111, 201}}

         ;; Binary
         "^." => {{2r1111, 400}, {2r1111, 401}}
         "|." => {{2r1111, 410}, {2r1111, 411}}
         "&." => {{2r1111, 420}, {2r1111, 421}}

         ;; Arithmetic
         "<<"  => {{2r0001, 500}, {2r0001, 501}}
         ">>"  => {{2r0001, 500}, {2r0001, 501}}
         ">>>" => {{2r0001, 500}, {2r0001, 501}}
         "+"   => {{2r0001, 550}, {2r0001, 551}}
         "-"   => {{2r0001, 550}, {2r0001, 551}}
         "*"   => {{2r0001, 560}, {2r0001, 561}}
         "/"   => {{2r0001, 560}, {2r0001, 561}}
         "mod" => {{2r0001, 560}, {2r0001, 561}}
         "**"  => {{2r0001, 571}, {2r0001, 570}}

         ;; Others
         default = {{2r1000, 900}, {2r0100, 901}}
         WHITE   = {{2r1111, 1002}, {2r1111, 1001}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
      short = {
         default = {{2r1111, 1800}, {2r1111, 1801}}
         WHITE   = {{2r1111, 2000}, {2r1111, 2001}}
         ","    => {{2r1111, 1},    {2r1111, 1}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
   }

   PFX = {
      wide = {
         default = {{2r1111, MAX}, {2r1111, 900}}
         "when" => {{2r1111, MAX}, {2r1111, 101}}
         "not"  => {{2r1111, MAX}, {2r1111, 131}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "~" => {{2r1111, MAX}, {2r1111, 3000}}
         "@" => {{2r1111, MAX}, {2r1111, 3000}}
         "<>" => {{2r1111, MAX}, {2r1111, 5}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
      short = {
         default = {{2r1111, MAX}, {2r1111, 1901}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "~" => {{2r1111, MAX}, {2r1111, 3000}}
         "@" => {{2r1111, MAX}, {2r1111, 3000}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
   }

   SFX = {
      wide = {
         default = {{2r1111, 901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
      short = {
         default = {{2r1111, 1900}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
   }
}



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3

oparse{next, order, finalize} =
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true:
      o = ? | [not left_op and not right_op] =>
              DONE
            | else =>
              [not left_op and RIGHT]
               \ or [not right_op and LEFT]
               \ or order{left_op, right_op}
      o |>
         [== DONE] ->
            return between

         [== LEFT] ->
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1

         [== RIGHT] ->
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}

         [== BOTH] ->
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}

         [== NONE] ->
            throw ["Undefined priority between " + left_op + " and " + right_op]

         other -> throw "OopsC"


consult{{fixity, width, op}} =
   map = order_map[fixity][width]
   map[op] or map.default


order{o1, o2} =
   {code1, ord1} = consult{o1}[1]
   {code2, ord2} = consult{o2}[0]
   ? | [[code1 & code2] == 0] => throw {"Cannot mix", o1, o2}
     | [ord1 > ord2]  => LEFT
     | [ord1 < ord2]  => RIGHT
     | [ord1 == ord2] => BOTH


finalize{|>} =
   ;; ~ID{value} -> value
   ~ID{value} -> Symbol{value}
   ~NUM{value} -> ~value{value}
   ~STR{value} -> ~value{value}
   ~VOID{} -> Void{}

   {ops, *args} ->
      ops := ops each o -> o[2]
      op = ops[0]
      {ops, args} |>

         {{"WHITE", ":"}, {f, arg, body}} ->
            ~send{f, ~data{arg, body}}

         {{":"}, {f, body}} ->
            ~send{f, ~data{body}}

         {{"with"}, {target, aslist! body}} ->

            inserted = false
            result = transform{target} with {|>} ->
               Symbol? {"..."} -> [inserted := true, ~multi{*body}]
               [x when x.fromop] and ~send{f, ~data{a, b}} ->
                   ~send{this{f}, ~data{this{a}, this{b}}}
               ~data{*args} ->
                   tr := this
                   ~data{}.concat with patch_array.apply{null} with args each
                      Symbol? {"..."} -> [inserted := true, body]
                      other -> {tr{other}}

            ? | not inserted => target |>
                 Void? ->
                    ~data{*body}
                 when target.fromop ->
                    ~send{target, ~data{*body}}
                 ~send{f, ~data{*args}} ->
                    ~send{f, ~data{*args, *body}}
                 ~data{*args} ->
                    target ++ body
                 other ->
                    ~send{target, ~data{*body}}
              | else => result

         ;; {{"with"}, {target, aslist! body}} ->
         ;;    target |>
         ;;       null? ->
         ;;          {.data}.concat{body}
         ;;       when target.fromop ->
         ;;          ~send{target, {.data}.concat{body}}
         ;;       ~send{f, ~data{*args}} ->
         ;;          ~send{f, {.data}.concat{args}.concat{body}}
         ;;       ~data{*args} ->
         ;;          target.concat{body}
         ;;       other ->
         ;;          ~send{target, {.data}.concat{body}}

         {{"[" or ",", *_}, _} ->
            ? | [op == "["] => args := args.slice{1, -1}
            args := args.filter{f} where
               f{x} = [not Void? x]

            result = args |>
               {} -> ~value{undefined}
               ;; throw ["At least one expression must be enclosed in []"]
               {x} -> x
               other -> ~multi{*args}
            result

         {{"{", *_}, _} ->
            ~data{*args.slice{1, -1}.filter{f}} where
               f{x} = [not Void? x]

         {{.WHITE}, _} ->
            ~send{*args}

         {{_}, |>} ->
            {Void?, Void?} -> Symbol{op}
            {a, b} ->
               rval = ~send{Symbol{op}, ~data{a, b}}
               rval.fromop := true
               rval

         other ->
            throw {"Unknown node", ops, args}

   other -> throw "OopsE"


parse{text} =
   results = tokenize{text}
   next{} = results.shift{}
   oparse{next, order, finalize}


libf{f} =
   ;; ~send{"___lib", ~value{f}}
   ;; f          ;; ORIGINAL
   {.symbol, f}  ;; TRANSITIONAL


Env{parent} =
   store = Object{}
   self{expr} =
      {.bind_env, self, expr}
   self.resolve := {name} ->
      attempt = store[name]
      ? | attempt => attempt
        | else => self.parent.resolve{name}
   self.register := {name, value} ->
      store[name] := value
   self.register_macro := {name, m} ->
      store[name] := ~macro{m}
   self.fork := {} ->
      Env{self}
   self.parent := parent
   self.store := store
   self


js_contexts = {
   js_for = {.multi, .multi, .multi, .multi}
}


expand{{context, env}, expr} =
   expr := expand.step{{context, env}, expr}

   expr |>
      Symbol? {s} -> expr
      ;; {.symbol, s} -> s

      Void? -> Void{}
      undefined? -> throw ["undefined? why?"]

      ~send{f, arg} ->
         f := expand{{.head, env}, f}
         ~send{f, expand{{.tail, env}, arg}}

      ~value{v} -> expr

      {type and [.array or .object], *args} -> ;; or .splice
         arr = {}
         while [args.length > 0]:
            expand.step{{type, env}, args.shift{}} |>
               ~splice{*stmts} ->
                  args := stmts ++ args
               other ->
                  arr.push{other}
         {type} ++
            arr each x -> expand{{type, env}, x}

      ~multi{*args} ->
         arr = {}
         while [args.length > 0]:
            type = if{args.length == 1, .expr, .multi}
            expand.step{{type, env}, args.shift{}} |>
               ~splice{*stmts} ->
                  args := stmts ++ args
               other ->
                  arr.push{{other, type}}
         ~multi{} ++
            arr each {x, type} -> expand{{type, env}, x}

      ~data{*args} ->

         is_obj = false
         obj = ~object{}
         arr = ~array{}
         parts = {}

         newpart{} =
            arr |>
               ~array{} -> false
               other ->
                  parts.push{arr}
                  arr := ~array{}

         while [args.length > 0]:
            expand.step{{type, env}, args.shift{}} |>
               ~assoc{} -> is_obj := true
               ~assoc{k, v} ->
                  is_obj := true
                  obj.push with ~array{k, v}
               ~splice{*exprs} ->
                  args := exprs ++ args
               ~dynsplice{expr} ->
                  newpart{}
                  parts.push{expr}
               other ->
                  arr.push{other}

         newpart{}

         r = parts |>
            {} when is_obj ->
               obj
            {} -> {.array}
            {arr and ~array{*things}} ->
               ? | is_obj => arr.push{obj}
               arr
            other ->
               ? | is_obj => parts.push{~array{obj}}
               patch = libf{"patch_array"}
               ~send{patch, ~array{*parts}}

         expand{{context, env}, r}

      ~lambda{bindings, body} ->
         ~lambda{bindings each x -> expand{~decl{env}, x}
                   expand{~expr{env}, body}}

      ~declare{binding, value} ->
         ~declare{expand{~decl{env}, binding}
                  expand{~expr{env}, value}}

      ~assign{lhs, rhs} ->
         ~assign{expand{~decl{env}, lhs}
                 expand{~expr{env}, rhs}}

      {type && [.js_while or .js_for or .js_for_in or .js_break
                \ or .js_continue or .js_return
                \ or .js_throw or .js_try or .js_new
                \ or .if], *args} ->
         ctxs = js_contexts[type] or {}
         {type, *args.map{f}} where
            f{x, i} = expand{{ctxs[i] or .expr, env}, x}

      ~done{expr} ->
         expr

      other -> throw {"Oops", expr, context}



expand.step := {{context, env}, expr and |>} ->
   Symbol? {s} ->
      v = env.resolve{s}
      {v, context} |>
         {undefined?, _} -> Symbol{s}
         {~macro{m}, .head} -> v
         {~macro{m}, _} -> expand.step{{context, env}, m{{context, env}, Void{}}}
         other -> v

   Void? -> Void{}
   undefined? -> throw ["undefined? why?"]

   ~macro{m} when [context == .head] ->
      expr

   ;; TODO: fix the bug that forces "when true"
   ~macro{m} when true ->
      expand.step{{context, env}, m{{context, env}, Void{}}}

   ~send{f, arg} ->
      expand.step{{.head, env}, f} |>
         ~macro{m} -> expand.step{{context, env}, m{{context, env}, arg}}
         other -> expr

   {type, *args} ->
      expr

   other ->
      <> expr
      throw {"Oops2", expr}


aslist{|>} =
   Void? -> {Void{}}
   undefined? -> {undefined}
   ~multi{*args} -> args
   other -> {other}


transform{expr, cb} =
   tr{x} = transform{x, cb}
   cb.call{tr, expr} !!
      expr |>
         Void? -> Void{}
         Symbol? s -> s
         ~value{v} -> expr
         {name, *args} ->
            {name, *args.map{tr}}


nullenv = {resolve{x} = undefined}

stdenv = Env{nullenv}

stdenv.register{"+", Symbol{"___plus"}}
stdenv.register{"-", Symbol{"___minus"}}
stdenv.register{"*", Symbol{"___times"}}
stdenv.register{"/", Symbol{"___div"}}
stdenv.register{"mod", Symbol{"___mod"}}
stdenv.register{"^", Symbol{"___binxor"}}
stdenv.register{"&", Symbol{"___binand"}}
stdenv.register{"|", Symbol{"___binor"}}
;; stdenv.register{"~", Symbol{"___binnot"}}
stdenv.register{"&&", Symbol{"___and"}}
stdenv.register{"||", Symbol{"___or"}}
;; stdenv.register{"!", Symbol{"___not"}}
stdenv.register{"and", Symbol{"___and"}}
stdenv.register{"or", Symbol{"___or"}}
stdenv.register{"not", Symbol{"___not"}}
stdenv.register{"===", Symbol{"___is"}}
stdenv.register{"!==", Symbol{"___isnt"}}
stdenv.register{"!=", Symbol{"___neq"}}
stdenv.register{"<", Symbol{"___lt"}}
stdenv.register{">", Symbol{"___gt"}}
stdenv.register{"<=", Symbol{"___lte"}}
stdenv.register{">=", Symbol{"___gte"}}
stdenv.register{"<<", Symbol{"___shl"}}
stdenv.register{">>", Symbol{"___shr"}}
stdenv.register{">>>", Symbol{"___shr2"}}
stdenv.register{"in", Symbol{"___in"}}
stdenv.register{"instanceof", Symbol{"___instanceof"}}
;; stdenv.register{"++", Symbol{"___plusplus"}}
stdenv.register{"--", Symbol{"___minusminus"}}


stdenv.register_macro{"++"} with {_, |>} ->
   ~data{Void?, x} -> '[`___plusplus` ^x]
   ~data{x, Void?} -> ~send{Symbol{"___plusplus"}, ~data{x, Void{}}}
   ~data{x, y} -> '[^x].concat{^y}
   Void? -> '[{x, y} -> x.concat{y}]

stdenv.register_macro{".."} with {_, |>} ->
   ~data{Void?, x} -> 'range{1, ^x}
   ~data{x, Void?} -> 'range{^x}
   ~data{x, y} -> 'range{^x, ^y}
   Void? -> 'range

;;stdenv.register_macro{"TEST"} with {{context, env}, expr} -> [
;;   ~splice{"a", "b"}
;;]

make_checker{value, op} = {{context, env}, ~data{expr}} ->
   ~send{op, ~data{expr, value}}


stdenv.register_macro{"**"} with {{context, env}, ~data{a, b}} ->
   'Math.pow{^a, ^b}

stdenv.register_macro{"//"} with {{context, env}, ~data{a, b}} ->
   'Math.floor{^a / ^b}

stdenv.register_macro{"<>"} with {{context, env}, ~data{Void?, x}} ->
   'pr{^x}


stdenv.register_macro{"#"} with {{context, env}, ~data{Void?, Symbol? {tag}}} ->
   tag := ~value{tag}
   ~macro with {{|>, env}, expr} ->
      .pattern ->
          checker_mac = ~macro with {_, ~data{expr}} ->
             '[[^expr]"#" == ^tag]
          expr |>
             ~data{*subp} ->
                deconstructor_mac = ~macro with {_, expr} ->
                   '{^=true, ^expr[1]}
                ~check{checker_mac
                       ~project{deconstructor_mac, {.duck, 0, *subp}}}
             Void? ->
                ~check{checker_mac, ~ignore{}}
             other ->
                ~check{checker_mac, expr}
      _ ->
          expr |>
             Void? ->
                'StructFactory{^tag}
             ~data{*args} ->
                'Struct{^tag, ^*args}
             other ->
                '[StructFactory{^tag}][^other]


stdenv.register_macro{"~"} with {{context, env}, ~data{Void?, Symbol? {tag}}} ->
   tag := ~value{tag}
   ~macro{f} where f{{|>, env}, expr} =
      .pattern ->
          checker_mac = ~multi{~macro{f1}, ~macro{f2}} where
             f1{_, ~data{expr}} =
                '[^expr instanceof Array]
             f2{_, ~data{expr}} =
                '[[^expr][0] == ^tag]
          expr |>
             ~data{*subp} -> '{^tag, ^*subp}
             Void? -> ~check{checker_mac, ~ignore{}}
             other -> ~check{checker_mac, expr}
      _ ->
          expr |>
             Void? ->
                '{^tag}
             ~data{*args} ->
                '{^tag, ^*args}
             other ->
                '{^tag}[^other]



stdenv.register_macro{"when"} with {{context, env}, ~data{|>, condition}} ->
   Void? -> {.test, condition, ~ignore{}}
   other -> {.test, condition, other}

andf{{context, env}, expr} =
   {context, expr} |>
      {.pattern, ~data{a, b}} ->
         {.all, a, b}
      {_, Void?} ->
         Symbol{"___and"}
      other ->
         ~send{Symbol{"___and"}, expr}
stdenv.register_macro{"&&"} with andf
stdenv.register_macro{"and"} with andf

orf{{context, env}, expr} =
   {context, expr} |>
      {.pattern, ~data{a, b}} ->
         {.any, a, b}
      {_, Void?} ->
         Symbol{"___or"}
      other ->
         ~send{Symbol{"___or"}, expr}
stdenv.register_macro{"||"} with orf
stdenv.register_macro{"or"} with orf


partial_pattern{operator} =
   operator := Symbol{operator}
   {{context, env}, expr} ->
      {context, expr} |>
         {.pattern, ~data{Void?, val}} ->
            ~check{~macro{make_checker{val, operator}}, ~ignore{}}
         {_, Void?} ->
            operator
         other ->
            ~send{operator, expr}

stdenv.register_macro{"=="} with partial_pattern{"___eq"}
stdenv.register_macro{"!="} with partial_pattern{"___neq"}
stdenv.register_macro{"<="} with partial_pattern{"___lte"}
stdenv.register_macro{">="} with partial_pattern{"___gte"}
stdenv.register_macro{"<"} with partial_pattern{"___lt"}
stdenv.register_macro{">"} with partial_pattern{"___gt"}


stdenv.register_macro{"*"} with {{context, env}, expr} ->
   {context, expr} |>
      {.pattern, Void?} ->
         ~dynsplice{~ignore{}}
      ;; {.pattern or .data, ~data{val, Void?}} ->
      ;;    ~dynsplice{val}
      {.pattern or .data, ~data{Void?, val}} ->
         ~dynsplice{val}
      {_, Void?} ->
         Symbol{"___times"}
      other ->
         ~send{Symbol{"___times"}, expr}


stdenv.register_macro{"."} with {{context, env}, |>} ->
   ~data{Void?, Symbol? {s}} ->
      ~value{s}
   other ->
      <> other
      throw Error{"Invalid argument for .", other}


stdenv.register_macro{"where"} with {{context, env}, ~data{a, b}} ->
   ~send{Symbol{.let}, ~data{b, a}}


stdenv.register_macro{"let"} with {{context, env}, ~data{a, b}} ->
   bindings = aslist{a}
   body = aslist{b}
   ~multi{*bindings, *body}


stdenv.register_macro{"->"} with {{context, env}, ~data{args, stmts}} ->
   body = ~multi{}
   {placeholder, newargs} = find_arrow{args}
   newargs := newargs.slice{1} each
      Symbol? {s} -> Symbol{s}
      ;; {.symbol, s} -> s
      other ->
         t = gensym{}
         body.push with '[^other = ^t]
         t
   body.push with
     ? | placeholder => '[^placeholder |> ^stmts]
       | else => stmts
   ~lambda{newargs, body}


build_each{source, patterns, aslist! prelude, aslist! tail, lvar} =
   temp = gensym{}
   len = gensym{}
   lvar := lvar or gensym{}
   stmts = ~multi{*prelude} ++ {
      ' | ^temp = ^source
      ' | ^len = [^temp].length
   }
   loop = {.js_for, a, b, c, body} where
      a = ' | ^lvar = 0
      b = ' | ^lvar < ^len
      c = ' | [^lvar]++
      body = ' | ___js_fetch{^temp, ^lvar} |> ^patterns
   stmts.push{loop}
   stmts = stmts ++ tail
   stmts


stdenv.register_macro{"each"} with {{|>, env}, ~data{arr, aslist! patterns}} ->

   .multi ->
      patterns.push with '[other -> false]
      build_each with
         arr
         ~multi{*patterns}
         ~multi{}
         'false

   other ->
      res = gensym{}
      patterns := patterns each
         ~send{Symbol? {"->"}, ~data{patt, expr}} ->
            '[^patt -> [^res].push{^expr}]
         other ->
            INVALID_PATTERN ;; TODO: fix into throw
      patterns.push with '[other -> false]
      build_each with
         arr
         ~multi{*patterns}
         ' | ^res = {}
         res


stdenv.register_macro{"=>"} with {{context, env}, ~data{binding, value}} ->
   ? | [context == .data] =>
        ~assoc{binding, value}
     | else =>
        throw ["Illegal context for '=>' (" + context + ")"]


stdenv.register_macro{"as"} with {_, ~data{expr, variable}} ->
   '[^variable = ^expr]

stdenv.register_macro{"="} with {{context, env}, expr} ->
   {context, expr} |>

      {.multi or .expr, ~data{lhs, rhs}} ->
         {make_declarations! vars, clauses} = parse_lhs{env, lhs, rhs}
         r = ~splice{*vars}

         mkif{x} =
            ~if{x, ~value{false}, ~js_throw{~value{"a condition failed"}}}

         clauses |>
            {clause} ->
               clause[clause.length - 1] |>
                  ~value{== true} ->
                     ? | [[vars.length == 1] and [clause.length == 3]] =>
                         r := ~declare{*clause[1].slice{1}}
                       | else =>
                         r := r ++ clause.slice{1, -1}
                  other ->
                     r.push{mkif{clause}}
            _ ->
               ands = make_pattern_test{clauses}
               r.push{mkif{ands}}
         r

      {.data, Void?} ->
         {.assoc}

      {.data, ~data{~send{f, args}, value}} ->
         f := f |> | ~value{_} -> f
                   | Symbol? {z} -> ~value{z}
         ~assoc{f, '[^args -> ^value]}

      {.data, ~data{b, value}} ->
         b := b |> | ~value{_} -> b
                   | Symbol? {z} -> ~value{z}
         ~assoc{b, value}

      other ->
         throw ["Illegal context for '=' (" + context + ")"]


make_assigner{op} = {{context, env}, ~data{a, b}} ->
   ~assign{a, ~send{Symbol{op}, ~data{a, b}}}

stdenv.register_macro{":="} with {{context, env}, ~data{a, b}} ->
   ~assign{a, b}

stdenv.register_macro{"+="} with make_assigner{"+"}
stdenv.register_macro{"-="} with make_assigner{"-"}
stdenv.register_macro{"*="} with make_assigner{"*"}
stdenv.register_macro{"/="} with make_assigner{"/"}
stdenv.register_macro{"<<="} with make_assigner{"<<"}
stdenv.register_macro{">>="} with make_assigner{">>"}
stdenv.register_macro{">>>="} with make_assigner{">>>"}


stdenv.register_macro{"if"} with {{context, env}, ~data{test, a, b}} ->
   ~if{test, a, b}

stdenv.register_macro{"cond"} with {{context, env}, ~data{clauses}} ->
   handle{xs} =
      xs |> | {} -> ~value{false}
            | {~send{Symbol? {"=>"}, ~data{test, body}}, *rest} ->
               test := test |>
                  Symbol? {"else"} -> ~value{true}
                  _ -> test
               ~if{test, body, handle{rest}}
   handle{aslist{clauses}}


stdenv.register_macro{"while"} with {{context, env}, expr} ->
   ~data{test, body} = expr
   {.js_while, test, body}

stdenv.register_macro{"for"} with {{context, env}, |>} ->
   ~data{~multi{a, b, c}, body} ->
      {.js_for, a, b, c, body}
   ~data{~send{Symbol? {"in"}, ~data{a, b}}, body} ->
      {.js_for_in, a, b, body}

;; stdenv.register_macro{"!!"} with {{context, env}, ~data{expr, matchers}} ->

;;    excv = gensym{}
;;    res = gensym{}
;;    m = aslist{matchers} |>
;;       ms and {~send{"->", _}, *} ->
;;          ms.push with '[___exc -> throw ___exc]
;;          '[^excv |> ^[~multi{*ms}]]
;;       x ->
;;          matchers
;;    f = '[{^excv} -> ^res := ^m]
;;    ~multi with
;;       ~declare{res, ~value{undefined}}
;;       ~js_try{~assign{res, expr}, f, null}
;;       res

stdenv.register_macro{"!!"} with {{|>, env}, ~data{expr, matchers}} ->

   .multi ->
      excv = gensym{}
      m = aslist{matchers} |>
         ms and {~send{Symbol? {"->"}, _}, *} ->
            ms.push with '[___exc -> throw ___exc]
            '[^excv |> ^[~multi{*ms}]]
         x ->
            matchers
      f = '[{^excv} -> ^m]
      ~multi with
         ~js_try{expr, f, Void{}}

   other ->
      excv = gensym{}
      res = gensym{}
      m = aslist{matchers} |>
         ms and {~send{Symbol? {"->"}, _}, *} ->
            ms.push with '[___exc -> throw ___exc]
            '[^excv |> ^[~multi{*ms}]]
         x ->
            matchers
      f = '[{^excv} -> ^res := ^m]
      ~multi with
         ~declare{res, ~value{undefined}}
         ~js_try{~assign{res, expr}, f, Void{}}
         res


stdenv.register_macro{"new"} with {_, expr} ->
   ~js_new{expr}

stdenv.register_macro{"return"} with {_, expr} ->
   ~js_return{expr}

stdenv.register_macro{"throw"} with {_, expr} ->
   ~js_throw{expr}

stdenv.register_macro{"break"} with {_, expr} ->
   ~js_break{}

stdenv.register_macro{"continue"} with {_, expr} ->
   ~js_continue{}



rx_wrap{x} =
   "(?:" + x + ")"

rx_quote{x} =
   x.replace{R.g'{in ".?*+^$[](){}|\\\\"}, "\\$1"}

rx_quote2{x} =
   x.replace{R.g'{in "[](){}^"}, "\\$1"}


rx_build2{|>} =
   Symbol? {|>} ->
      .any -> "."
      .start -> "^"
      .end -> "$"
      .alpha -> "\\a"
      .digit -> "\\d"
      .word -> "\\w"
      .space -> "\\s"
      .boundary -> "\\b"
      .a -> "\\a"
      .d -> "\\d"
      .w -> "\\w"
      .s -> "\\s"
      .b -> "\\b"

   ~value{x} -> rx_quote{x}

   ~send{Symbol? {"raw"}, ~value{s}} ->
      s

   ~send{Symbol? {|>}, ~data{a, b}} ->
      "||" ->
         rx_wrap{rx_build2{a} + "|" + rx_build2{b}}
      "or" ->
         rx_wrap{rx_build2{a} + "|" + rx_build2{b}}
      "*" ->
         Void? = a
         rx_wrap{rx_build2{b} + "*"}
      "+" ->
         Void? = a
         rx_wrap{rx_build2{b} + "+"}
      "?" ->
         Void? = a
         rx_wrap{rx_build2{b} + "?"}
      "in" ->
         Void? = a
         ~value{v} = b
         ["[" + x + "]"] where
            x = rx_quote2{v}
      "not" ->
         Void? = a
         b as ~send{Symbol? {"in"}, ~data{Void?, ~value{v}}}
         ["[^" + x + "]"] where
            x = rx_quote2{v}

   ~data{*args} ->
      "(" + args.map{rx_build2}.join{""} + ")"
   ~multi{*args} ->
      "(?:" + args.map{rx_build2}.join{""} + ")"
   otherA -> throw "OopsF"


stdenv.register_macro{"R", mac} where mac{{context, env}, expr, flags} =
   flags := flags or ""
   expr |>
      ~send{Symbol? {"."}, ~data{Void?, Symbol? {flag}}} ->
         ~macro{m} where m{ctx, x} = mac{ctx, x, flags + flag}
      ~value{String? v} -> 'RegExp{^=v, ^=flags}
      ~send{Symbol? {"'"}, ~data{Void?, arg}} -> 'RegExp{^=rx_build2{arg}, ^=flags}


stdenv.register_macro{"?"} with {{context, env}, |>} ->

   ~data{Void?, expr} ->
      ~send{Symbol{"cond"}, ~data{expr}}

   ~data{expr, Void?} ->
      orig_expr = expr

      checker = expr |>
         Void? -> throw "can't use ? on its own"
         Symbol? {.String} -> ;; or .Symbol ->
            ~macro with {_, ~data{expr}} ->
               '[typeof{^expr} == "string"]
         Symbol? {.Number} ->
            ~macro with {_, ~data{expr}} ->
               '[typeof{^expr} == "number"]
         Symbol? {.true} -> ~macro{{_, ~data{expr}} -> expr}
         Symbol? {.false} -> ~macro{{_, ~data{expr}} -> '[not ^expr]}
         ;;.null or .Void -> ~macro{make_checker{~value{null}, "___is"}}
         Symbol? {.null} -> ~macro{make_checker{~value{null}, Symbol{"___is"}}}
         Symbol? {.undefined} -> ~macro{make_checker{~value{undefined}, Symbol{"___is"}}}
         other -> '___checker{^expr}

      mac{{|>, env}, expr} =
         .pattern -> expr |>
            ~data{*subp} ->
               projector = '___deconstructor{^orig_expr}
               ;; ~check{checker, ~project{projector, expr}}
               ~check{checker, ~project{projector, ~duck{0, *subp}}}
            Void? ->
               ~check{checker, ~ignore{}}
            other ->
               ~check{checker, expr}
         other -> '[^checker]{^expr}

      ~macro{mac}


stdenv.register_macro{"!"} with {{context, env}, ~data{expr, Void?}} ->
   projector = expr |>
      Void? -> throw "can't use ! on its own"
      Symbol? {.String} ->
         ~macro with {_, ~data{expr}} -> '{true, String{^expr}}
      Symbol? {.Number} ->
         ~macro with {_, ~data{expr}} -> '{true, parseFloat{^expr}}
      other -> '___projector{^expr}

   mac{{|>, env}, expr} =
      .pattern ->
         expr |>
            Void? -> ~project{projector, ~ignore{}}
            other -> ~project{projector, expr}
      other -> '[^projector]{^expr}[1]

   ~macro{mac}


gensym_factory{prefix} =
   prefix := "τ" + prefix
   id = 0
   {} ->
      name = prefix + String{id}
      id := id + 1
      Symbol{name}

gensym = gensym_factory{""}


is_symbol{|>, env} =
   Symbol? {s} -> env.resolve{s} |>
      ~macro{m} -> false
      _ -> true
   _ -> false

parse_lhs{env, lhs, rhs, gen} =
   gen := gen or gensym_factory{"p"}

   vars = {}
   clauses = {}
   current = ~multi{}

   mktemp{} =
      t = gen{}
      vars.push{t}
      t

   newclause{} =
      ? | [current.length > 1] =>
          clauses.push{current}
      current := ~multi{}

   maybe_temp{x} =
      ? | is_symbol{x, env} =>
          x
        | else =>
          temp = mktemp{}
          current.push with
             ~assign{temp, x}
          temp

   helper{lhs, curr} =
      helper_noexpand{expand.step{~pattern{env}, lhs}, curr}

   helper_noexpand{lhs, curr} =

      helper_data{temp, specs, start} =
         fw = 0
         bw = 0
         rest = undefined
         members = specs each x ->
            v = expand.step{{.pattern, env}, x}
            v |> | ~dynsplice{variable} ->
                    rest := variable
                 | when rest == undefined ->
                    fw := fw + 1
                 | other ->
                    bw := bw + 1
            v

         cmp = ? | [rest == undefined] => Symbol{"___eq"}
                 | else => Symbol{"___gte"}

         ;; Note: I am splitting length assignment into two parts
         ;; because it lets the crude optimizer reuse it across
         ;; different clauses

         ;; Part 1: temp <- length
         len = mktemp{}
         current.push with
            ;; {.assign, len, ~send{temp, ~value{"length"}}}
            ;; ~value{true}
            '[^len := [^temp].length]
            'true
         newclause{}

         ;; Part 2: check length
         current.push with
            ;; Bounds check
            '[^cmp]{^len, ^=[fw + bw + start]}
         newclause{}

         [0 .. [fw - 1]] each j ->
            helper_noexpand{members[j], '[^temp ^=[j + start]]}

         ? | [rest != undefined] =>
              slice = if{bw > 0, '{^=[fw + start], ^=[-bw]}, '{^=[fw + start]}}
              helper_noexpand{
                 members[fw][1]
                 '[[^temp].slice ^slice]
              }

         [0 .. [bw - 1]] each j ->
            helper_noexpand{members[fw + j + 1], '[^temp][^len - ^=[bw - j]]}

      ;; <> lhs
      lhs |>

         Void? ->
            <> "AH!"
            helper_noexpand{x, curr} where
               x = ~check{~macro{make_checker{~value{null}, Symbol{"___eq"}}}, ~ignore{}}

         ["_" or ~ignore{}] ->
            ? | [not is_symbol{curr, env}] =>
                current.push{curr}
                current.push{'true}

         Symbol? {s} ->
            vars.push{Symbol{s}}
            current.push{~assign{Symbol{s}, curr}}
            current.push{~value{true}}

         ~value{v} ->
            helper_noexpand{x, curr} where
               x = ~check{~macro{make_checker{lhs, Symbol{"___eq"}}}, ~ignore{}}

         ~test{condition, pattern} ->
            helper{pattern, curr}
            current.push{condition}
            newclause{}

         ~all{*xs} ->
            temp = maybe_temp{curr}
            xs each x -> helper{x, temp}
            false

         ~any{*xs} ->
            normalize{vars} =
               [...].sort{}.join{","} with
                  vars each Symbol? {v} when v[0] != "τ" -> v

            temp = maybe_temp{curr}
            myvars = undefined
            clauses = {}
            xs each x ->
               p = parse_lhs{env, x, temp, gensym}
               ? | [myvars == undefined] =>
                    myvars := p[0]
                 | [normalize{p[0]} != normalize{myvars}] =>
                    throw with Error{
                       "Must have the same set of variables in both branches!"
                       "[" + String{myvars} + "]"
                       "[" + String{p[0]} + "]"
                    }
                 | else =>
                    vars := vars ++ p[0]
               clauses.push with make_pattern_test{p[1]}
            current.push with make_or_pattern{clauses}
            vars := vars ++ myvars
            newclause{}

         ~check{~multi{*checkers}, expr} ->
            temp = maybe_temp{curr}
            checkers each checker ->
               current.push with
                  '[^checker {^temp}]
               newclause{}
            helper{expr, temp}

         ~check{checker, expr} ->
            temp = maybe_temp{curr}
            current.push with
               '[^checker {^temp}]
            newclause{}
            helper{expr, temp}

         ~project{projector, expr} ->
            temp = maybe_temp{curr}
            temp2 = mktemp{}
            current.push with
               '[^temp2 := [^projector]{^temp}]
               '[^temp2 0]
            newclause{}
            helper{expr, '[^temp2 1]}

         ~send{fname, spec} ->
            helper{fname, '[^spec -> ^curr]}

         ~duck{i, *specs} ->
            temp = maybe_temp{curr}
            current.push with
               ~value{true}
            helper_data{temp, specs, i}

         ~data{*specs} ->

            temp = maybe_temp{curr}
            current.push with
               '[^temp instanceof Array]
            newclause{}

            current.push with
               '[[^temp]"#" == undefined]
            newclause{}

            helper_data{temp, specs, 0}

         other ->
            <> other
            <> Error{}.stack
            throw {"OopsG", other}

   helper{lhs, rhs}
   ? | [current.length > 1] => clauses.push{current}
   {vars, clauses}


make_declarations{vars, val} =
   vars each name ->
      ~declare{name, ~value{val}}

make_pattern_test{clauses} =
   ands = clauses.pop{}
   while [clauses.length > 0]:
      ands := '[^clauses.pop{} and ^ands]
   ands or ~value{true}

make_or_pattern{clauses} =
   ors = clauses.pop{}
   while [clauses.length > 0]:
      ors := '[^clauses.pop{} or ^ors]
   ors


find_arrow{|>} =
   Symbol? {"|>"} ->
      placeholder = gensym{}
      {placeholder, placeholder}
   Symbol? {"|>*"} ->
      placeholder = gensym{}
      {placeholder, '[*[^placeholder]]}
   Symbol? x or Void? x ->
      {false, x}
   ;; ~symbol{x} ->
   ;;    {false, x}
   x and ~value{v} ->
      {false, x}
   {kind, *args} ->
      placeholder = false
      new_args = args each arg ->
         {ph, new_arg} = find_arrow{arg}
         ? | ph => placeholder := ph
         new_arg
      {placeholder, {kind, *new_args}}



same{a, b} = {a, b} |>
   {Symbol? {x}, Symbol? {y}} -> x == y
   ;; {~symbol{x}, ~symbol{y}} -> x == y
   {~value{x}, ~value{y}} -> x == y
   {~macro{x}, ~macro{y}} -> x == y
   {~send{f, x}, ~send{g, y}} -> same{f, g} and same{x, y}
   {{kind1, *xs}, {kind2, *ys}} ->
      kind1 == kind2 and xs.length == ys.length and allequal where
         allequal = xs.every with {x, i} ->
            same{x, ys[i]}
   other ->
      false

stdenv.register_macro{"|>"} with {{context, env}, ~data{to_match, cl}} ->
   temp = gensym{}
   clauses = cl |>
      ~multi{*cls} -> cls
      other -> {other}

   cached_conditions = {}

   stmts = ~multi{~declare{temp, to_match}}
   clauses := clauses each clause ->
      ~send{Symbol? {"->"}, ~data{lhs, body}} = clause
      {placeholder, new_lhs} = find_arrow{lhs}
      {decls, conditions} = parse_lhs{env, new_lhs, temp}
      stmts := stmts ++ make_declarations{decls}
      {conditions.map{f}, b} where
         b = ? | placeholder => ~send{Symbol{"|>"}, ~data{placeholder, body}}
               | else => body
         f{x} = ~done{expand{{.expr, env}, x}}

   ;; BEGIN OPT
   shares = clauses.slice{1}.map{f} where f{{conditions, body}, i} =
      res = 0
      prev_conditions = clauses[i][0]
      nc = conditions.length
      for [j = 0, j < nc and same{conditions[j], prev_conditions[j]}, j++]:
         res++
      res
   max = Math.max shares
   shares.push{0}

   vars = {}
   ;; for [i = 0, i < max, i++]: vars.push{gensym{}}
   vars := vars.concat with [1 .. max] each _ -> gensym{}

   stmts := stmts ++ make_declarations{vars, false}

   shared_last = 0
   new_clauses = clauses.map with {{conditions, body}, i} ->
      shared = if{shared_last, {vars[shared_last - 1]}, {}}
      n_to_share = Math.max{shared_last, shares[i]}
      to_share = conditions.slice{shared_last, n_to_share}.map with
         {x, j} -> ~assign{vars[shared_last + j], x}
      shared_last := shares[i]
      {shared.concat{to_share}.concat{rest}, body} where
         rest = conditions.slice{n_to_share}

   clauses := new_clauses
   ;; END OPT

   r = ~js_throw{~data{~value{"Could not find a match"}, temp}}
   ;; r = '[throw Error{"Could not find a match", ^temp}]

   while [clauses.length > 0]:
      {conditions, body} = clauses.pop{}
      test = make_pattern_test{conditions}
      r := ~if{test, body, r}

   stmts.push{r}
   stmts


qqstruct{name, args} =
   ~data{~value{name}, *args}

qq{expr and |>} =
   Symbol? {s} -> qqsym{s}
   Void? -> qqvoid{}
   ~value{v} ->
      qqstruct{.value, {expr}}
   ~send{Symbol? {"^"}, ~data{Void?, insert}} ->
      insert
   ~send{Symbol? {"^="}, ~data{Void?, insert}} ->
      qqstruct{.value, {insert}}
   ~send{Symbol? {"^*"}, ~data{Void?, insert}} ->
      '[* ^insert]
   {name, *args} ->
      qqstruct{name, args each arg -> qq{arg}}

stdenv.register_macro{"'"} with {{context, env}, ~data{Void?, expr}} ->
   qq{expr}


stdenv.register_macro{"req"} with {{context, env}, ~data{expr}} ->
   'require{^expr}

stdenv.register_macro{"require"} with {{context, env}, ~data{expr}} ->

   stmts = {}

   topfetch{pkg, v} =
      stmts.push with '[^[Symbol{v}] = ___node.require{^=pkg}]
      v

   produce{|>, fetch} =

      Symbol? {s} ->
          fetch{s, s}

      ~value{String? s} ->
          fetch{s, gensym{}}

      ~multi{*subp} or ~data{*subp} ->
          subp each p -> produce{p, fetch}

      ~send{Symbol? {"as"}, ~data{~value{pkg} or pkg, Symbol? {s}}} ->
          fetch{pkg, s}

      ~send{Symbol? {"->"}, ~data{pkg, subp}} ->
          pkgv = produce{pkg, fetch}
          produce{subp} with {pkg, v} ->
              stmts.push with '[^v = ^pkgv ^=pkg]

   produce{expr, topfetch}
   ~multi{*stmts}



stdenv.register_macro{"%"} with {{context, env}, ~data{descr, contents}} ->
   tag = ~value{"div"}
   id = ~value{null}
   classes = ~data{}
   kv = ~data{}
   parse{|>} =
      Void? -> null
      Symbol? {s} -> tag := ~value{s}
      ~value{x} ->
         classes.push with ~value{x}
      ~send{Symbol? {"."}, ~data{Void?, Symbol? {x}}} ->
         classes.push with ~value{x}
      ~send{Symbol? {"#"}, ~data{Void?, Symbol? {x}}} ->
         id := ~value{x}
      ~send{Symbol? {"="}, ~data{Symbol? {prop}, value}} ->
         kv.push with ~data{~value{prop}, value}
      ~send{expr, rest} ->
         parse{expr}, parse{rest}
      ~multi{*args} or ~data{*args} ->
         args.forEach{parse}
   parse{descr}
   contents := contents |>
      Void? -> ~data{}
      ~multi{*args} -> ~data{*args}
      x -> x
   '[create_node{^tag, ^id, ^classes, ^kv, ^contents}]


var_operator{temp}{_, expr} =
   f{|>} =
      Void? -> temp
      ~data{Void?, |>} ->
         Symbol? {s} ->
            '[[^temp] [^=s]]
         ~send{obj, msg} ->
            '[^x ^msg] where x =
               f{~data{Void{}, obj}}
         other ->
            '[[^temp] [^other]]
      other -> ;; throw {"invalid @ argument", other}
         '[^temp ^other]
   f{expr}

stdenv.register_macro{"chain"} with {{context, env}, ~data{defn, body}} ->
   newenv = env.fork{}
   temp = gensym{}

   {variable, expr} = defn |>
      ~send{Symbol? {"as"}, ~data{x, y}} -> {y, x}
      other -> {Symbol{"@"}, other}

   newenv.register_macro{xsym{variable}} with var_operator{temp}

   stmts = ~multi{}.concat with aslist{body} each x -> '[^temp := ^x]
   v = ' | ^temp = ^expr
         | ^stmts
         | ^temp
   ~done{expand{{context, newenv}, v}}


partition{xs, predicate} =
   t = {}
   f = {}
   xs each
      x when predicate{x} -> t.push{x}
      x -> f.push{x}
   {t, f}

stdenv.register_macro{"class"} with {{context, env}, arg} ->

   {clsvar, aslist! body} = arg |>
      ~data{body} -> {gensym{}, body}
      ~data{name, body} -> {name, body}

   {ctors, clauses} = partition{body} with {|>} -> 
      ~send{Symbol? {"="}, ~data{~send{Symbol? {.constructor}, _}, _}} -> true
      otherwise -> false

   {ctor_args, ctor_body} = ctors |>
      {} -> {'{}, {}}
      {|>} ->
         ~send{Symbol? {"="}, ~data{~send{_, args}, aslist! body}} -> {args, body}

   selfvar = gensym{}

   ctor_body := ~multi{prep, *ctor_body, ret} where
      prep = ' | ^selfvar = if{not [^clsvar]? this
                               Object.create{[^clsvar].prototype}
                               this}
      ret = ' | ^selfvar

   newenv = env.fork{}
   newenv.register_macro{"@"} with var_operator{selfvar}

   defns = {}
   static_defns = {}
   clauses each
      ~send{Symbol? {"static"}, ~data{aslist! body}} ->
         static_defns := static_defns ++ body
      ~send{Symbol? {"="}, ~data{~send{name, args}, aslist! body}} ->
         name := name |> | ~value{_} -> name
                         | Symbol? {n} -> ~value{n}
         defns.push with
            ' | [^clsvar].prototype[^name] := ^args ->
                 ^selfvar = this
                 ^*body

   ~done{expand{{context, newenv}, ...}} with
      ' | ^clsvar = ^ctor_args -> ^ctor_body
        | augment{^clsvar, {^*static_defns}}
        | ^*defns
        | ^clsvar



stdenv.register_macro{"do"} with {{context, env}, ~data{aslist! body}} ->
   ~multi{*body}


group{xs, classifier} =
   groups = {}
   curr = {}
   newgroup{} =
      ? | curr.length > 0 => groups.push with curr
      curr := {}
   xs each x ->
      ? | classifier{x} =>
           newgroup{}
      curr.push{x}
   newgroup{}
   groups

blocktest_wrap{label, expr, accumulator} =
   value = gensym{}
   ' | ^value = [[...] !! __err -> #error{__err}] with
        ^expr |>
           true? x -> #success{x}
           false? x -> #failure{x}
     | [^accumulator].push with
        #test_result{^label, ^value}



blocktest_mac{label, tests, acc} =
   ok = gensym{}
   stmts = {}
   stmts.push with ' | ^ok = true
   tests each

      stmt and ~send{Symbol? {"do"}, _} ->
         stmts.push with
            ' | ^stmt !! __err ->
                 [^acc].push with #error{^label, __err}
                 ^ok := false

      ~send{Symbol? {"=>"}, ~data{new_label, aslist! new_tests}} ->
         labv = gensym{}
         stmts.push with
            ' | ^labv = ^label ++ [Array! ^new_label]
              | ^ ~multi{*blocktest_mac{labv, new_tests, acc}}

      ~send{Symbol? {"each"}, ~data{sources, aslist! clauses}} ->
         loopvar = gensym{}
         clauses := clauses each clause ->
            clause as ~send{Symbol? {"->"}, ~data{lhs, rhs}}
            '[^lhs -> ^[~multi{*x}]] where x =
               blocktest_mac with
                  '[^label ++ {^loopvar}]
                  aslist! rhs
                  acc
         clauses.push with
            ' | __no ->
                 [^acc].push with
                    #error{^label, "No handler for test case", __no}
         stmts.push with build_each with
            sources
            ~multi{*clauses}
            ~multi{}
            ~multi{}
            loopvar

      expr ->
         stmts.push with
            ' ? | ^ok =>
                   ^blocktest_wrap{label, expr, acc}
                | else =>
                   [^acc].push with #aborted{^label, ' ^expr}
   stmts.push{acc}
   stmts

stdenv.register_macro{"blocktest"} with {{context, env}, ~data{*args}} ->
   acc = gensym{}
   labv = gensym{}
   stmts = ~multi with '[^acc = {}]
   rval = args |>
      {aslist! tests} ->
         stmts.push with '[^labv = {}]
         stmts := stmts ++ blocktest_mac{labv, tests, acc}
      {labels, aslist! tests} ->
         stmts.push with '[^labv = [Array! ^labels]]
         stmts := stmts ++ blocktest_mac{labv, tests, acc}
   rval


stdenv.register_macro{"macro"} with {{context, env}, expr} ->
   ~data{~send{name, args}, body} = expr
   fn = '[^args -> ^body]
   code = generate_from_ast{fn}
   efn = eval{"(" + code.slice{0, -1} + ")"}
   env.register_macro{name, efn}
   ~value{undefined}



js_op_table = {
   ___plus = "+"
   ___minus = "-"
   ___times = "*"
   ___div = "/"
   ___mod = "%"
   ___binxor = "^"
   ___binand = "&"
   ___binor = "|"
   ___binnot = "~"
   ___and = "&&"
   ___or = "||"
   ___not = "!"
   ___is = "==="
   ___isnt = "!=="
   ___eq = "==="
   ___neq = "!=="
   ___lt = "<"
   ___gt = ">"
   ___lte = "<="
   ___gte = ">="
   ___shl = "<<"
   ___shr = ">>"
   ___shr2 = ">>>"
   ___in = " in "
   ___instanceof = " instanceof "
   ___plusplus = "++"
   ___minusminus = "--"
}


translate{expr and |>, mode} =

   Symbol? {s} ->
      translate.expr{translate.mangle{s}, mode}

   Void? ->
      translate.expr{"null", mode}

   ~value{v} ->
      r = v |>
         String? ->
            repl = {
               "\"" => "\\\""
               "\n" => "\\n"
               "\\" => "\\\\"
            }
            v := v.replace{R.g'{"\"" or "\\" or "\n"}, {m} -> repl[m]}
            "\"" + v + "\""
         undefined? ->
            "(void 0)"
         [Number? or [== true] or [== false] or null?] ->
            String{v}
         other ->
            <> v
            throw Error{"Unknown value"}
            "?!?[" + v + "]?!?"
      translate.expr{r, mode}

   ~send{Symbol? {"___node"}, ~value{f}} ->
      f

   ~send{Symbol? {"___js_fetch"}, ~array{f, msg}} ->
      translate.expr{trf + "[" + trmsg + "]", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   ~send{f, msg and ~value{s}} ->
      cond:
         [[typeof{s} == "string"]
          \ and s.match{R'[start, + in "a-zA-Z_$", end]}] =>
            translate.expr{trf + "." + trmsg, mode} where
               trf = translate{f, .expr}
               trmsg = translate{Symbol{s}, .expr}
         else =>
            translate.expr{trf + "[" + trmsg + "]", mode} where
               trf = translate{f, .expr}
               trmsg = translate{msg, .expr}

   ~send{f, ~array{*args}} ->
      ;; op = [typeof{f} == "string"] and js_op_table[f]
      op = f |> | Symbol? {x} -> js_op_table[x]
                | _ -> null
      ? | op =>
          translate.expr{translate.op{op, args[0], args[1]}, mode}
        | else =>
          translate.expr{trf+"("+trargs.join{","}+")", mode} where
             trf = translate{f, .expr}
             trargs = args each x ->
                translate{x, .expr}

   ;; ~send{f, msg} ->
   ;;    translate.expr{trf + "[" + trmsg + "]", mode} where
   ;;       trf = translate{f, .expr}
   ;;       trmsg = translate{msg, .expr}

   ~send{f, msg} ->
      translate.expr{"send(" + trf + "," + trmsg + ")", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   ~array{*args} ->
      r = ["[" + args.map{f}.join{","} + "]"] where
         f{x} = translate{x, .expr}
      translate.expr{r, mode}

   ~object{*args} ->
      r = ["({" + args.map{f}.join{","} + "})"] where
         f{~array{x, y}} =
            a = translate{x, .expr}
            b = translate{y, .expr}
            a + ":" + b
      translate.expr{r, mode}

   ~lambda{bindings, body} ->
      translate.expr{"function("+a+"){"+b+"}", mode} where
         a = [bindings each x -> translate{x, .expr}].join{","}
         b = translate.body{body, .return}

   ~if{test, pos, neg} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["if(" + a + "){" + b + "}else{" + c + "}"] where
               a = translate{test, .expr}
               b = translate{pos, mode}
               c = translate{neg, mode}

   ~declare{binding, ~value{undefined?}} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + ";"] where
               a = translate{binding, .expr}

   ~declare{binding, value} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + "=" + b + ";"] where
               a = translate{binding, .expr}
               b = translate{value, .expr}

   ~assign{~send{obj, msg}, rhs} ->
      translate.expr{"(" + a + "[" + b + "]=" + c + ")", mode} where
         a = translate{obj, .expr}
         b = translate{msg, .expr}
         c = translate{rhs, .expr}

   ~assign{lhs, rhs} ->
      translate.expr{"(" + a + "=" + b + ")", mode} where
         a = translate{lhs, .expr}
         b = translate{rhs, .expr}

   ~multi{*args} ->
      isdecl{|>} =
         ~declare{variable, value} -> true
         other -> false
      ? | [args.length == 1] => translate{args[0], mode}
        | [[mode == "expr"] and [not args.some{isdecl}]] =>
          ["(" + xs.join{","} + ")"] where
             xs = args each x ->
                translate{x, .expr}
        | else => translate.body{expr, mode}

   ~splice{*args} ->
      translate{~multi{*args}, mode}

   ~js_new{value} ->
      translate.expr{"(new " + translate{value, .expr} + ")", mode}

   ~js_break{} ->
      ? | [mode == "expr"] => throw "Invalid break in ctx"
        | else => "break;"

   ~js_continue{} ->
      ? | [mode == "expr"] => throw "Invalid continue in ctx"
        | else => "continue;"

   ~js_return{value} ->
      ? | [mode == "expr"] => throw "Invalid return in ctx"
        | else => "return " + translate{value, .expr} + ";"

   ~js_throw{value} ->
      ? | [mode == "expr"] =>
          "function(){throw " + translate{value, .expr} + ";}()"
        | else =>
          "throw " + translate{value, .expr} + ";"

   ~js_while{test, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["while(" + a + "){" + b + "}"] where
               a = translate{test, .expr}
               b = translate{body, .stmt}

   ~js_for{x, y, z, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["for("+a+b+c+"){"+d+"}"] where
               a = translate{x, .stmt}
               b = translate{y, .stmt}
               c = translate{z, .expr}
               d = translate{body, .stmt}

   ~js_for_in{x, y, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["for("+a+" in "+b+"){"+c+"}"] where
               a = translate{x, .expr}
               b = translate{y, .expr}
               c = translate{body, .stmt}

   ~js_try{attempt, ~lambda{{Symbol? {v}}, body}, Void?} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            "try{" + a + "}catch(" + v + "){" + b + "}" where
               a = translate{attempt, .stmt}
               b = translate{body, .stmt}

   other ->
      throw other


translate.mangle := {name} ->
   tr = {
      "+" => "__plus__"
      "-" => "__minus__"
      "*" => "__asterisk__"
      "/" => "__slash__"
      "%" => "__percent__"
      "^" => "__caret__"
      "#" => "__hash__"
      "&" => "__amp__"
      "|" => "__pipe__"
      "@" => "__at__"
      "!" => "__bang__"
      "?" => "__qmark__"
      "=" => "__equal__"
      "<" => "__lt__"
      ">" => "__gt__"
      "~" => "__tilde__"
      "." => "__dot__"
      ":" => "__colon__"
   }
   r = {}
   for [i = 0, i < name.length, ++i]:
      c = name[i]
      r.push{tr[c] or c}
   r.join{""}


translate.body := {b, mode} ->
   orig := b
   b := aslist{b}
   trst{stmt} = translate{stmt, .stmt}
   mode |>
      .expr ->
         translate{x, mode} where
            x = ~send{~lambda{{}, orig}, {.array}}
      .return ->
         stmts = b.slice{0, -1}
         ret = b[b.length - 1]
         stmts.map{trst}.join{""} + translate{ret, .return}
      .stmt ->
         b.map{trst}.join{""}
      other -> throw "OopsH"

translate.expr := {x, |>} ->
   .expr -> x
   .stmt -> x + ";"
   .return -> "return " + x + ";"
   other -> throw "OopsI"

translate.op := {op, a, b} ->
   e = {a, b} |>
          {Void?, _} -> op + translate{b, .expr}
          {_, Void?} -> translate{a, .expr} + op
          _ -> translate{a, .expr} + op + translate{b, .expr}
   "(" + e + ")"


generate_from_ast{ast} =
   ex = expand{~top{stdenv.fork{}}, ~multi{ast}}
   translate{ex, .stmt}

generate{data, prelude} =
   p = parse{data}
   ex = expand{~top{stdenv.fork{}}, ~multi{p}}
   [prelude or ""] + translate{ex, .stmt}

exports.generate := generate
