
require:
   "./location" ->
      Source, Location
      highlight_locations
      <<:
   "./lex" ->
      tokenize
   "./parse" ->
      parse
   "./translate-js" ->
      Translator
   "./stdenv" as std
   "./expand" as exp
   "./opt" as opt
   "./util" -> Body
   vm, module, path
   ;; "6to5" as to5
   traceur as to5

provide:
   evaluator
   Source, Location, highlight_locations
   tokenize, parse
   Generator, generate
   version

version = "zero"

evaluator{match options} =

   when module._nodeModulePaths ->
      paths = module._nodeModulePaths{options.cwd}

      e_module = new module{options.showname}
      e_module &: {
         filename = options.filename
         paths = paths
      }

      e_require{path} =
         module._load{path, e_module, true}
      e_require &: {
         main = e_module
         resolve{path} =
            module._resolveFileName{path, e_module}
         paths = paths
         cache = require.cache
      }

      global &: {
         __filename = options.filename
         __dirname = path.dirname{options.filename}
         module = e_module
         require = e_require
      }

      {code} ->
         script = vm.createScript{code, options.showname}
         script.runInThisContext{}

   else ->
      __eval = eval
      {code} -> __eval{code}


class Pipeline:

   constructor{} =
      @_expander = std.make_expander{@}
      @env = @_expander.mkenv{}

   parse{source} =
      t = tokenize{source}
      parse{t}

   expand{ast} =
      @_expander.expand{#top, exp.topscope, @env.mark{ast}}

   translate{ast} =
      res = opt.hoist{ast}
      tr = Translator{}
      rval = tr.translate{res, .expr}
      prep = tr.dump_store{}
      {
         code = to5.compile{r, {}}
         location = ast.location
      } where
         r = prep + ";(" + rval + ")"

   evaluate{src} =
      loc = src.location or {source = {url = "<eval>"}}
      ev{src.code} where
         ev = evaluator with {
            filename = loc.source.url
            showname = loc.source.url
            cwd = loc.source.url
         }

   go{x, match start, end} =
      when start === end or start === .eval ->
         x
      .source ->
         @go{@parse{x}, .parse, end}
      .parse ->
         @go{@expand{x}, .expand, end}
      .expand ->
         @go{@translate{x}, .translate, end}
      .translate ->
         @go{@evaluate{x}, .eval, end}
      else ->
         throw E.pipeline{"Unknown pipeline stage: " + start}


generate{source} =
   Generator{}.generate{source}

class Generator:

   constructor{interactive = false} =
      @tr = Translator{"require(\"earlgrey-runtime\");"}
      @env = std.stdenv.fork{}
      @interactive = interactive
      @_eval = null
      @pipeline = Pipeline{}
      @expander = std.make_expander{@pipeline}

   generate{source, dump = not @interactive, _to5 = true} =
      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      var ex = @expander.expand{
         #top
         exp.topscope
         @env.mark{stmt}
      } where stmt =
         if @interactive:
            then:
               Body! {*args} = p
               #interactive{*args}
            else: #multi{p}
      set ex = opt.hoist{ex}
      set ex = opt.eliminate_spurious_variables{ex}
      rval = @tr.translate{ex, .stmt}
      ;; r where r =
      ;; to5.transform{r}.code where r =
      if{_to5, to5.compile{r, {}}, r} where r =
         if dump:
            then: @tr.dump_store{} + rval
            else: rval

   evaluate{source} =
      if [not @_eval]:
         file = source.url
         @_eval = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
      @_eval{@generate{source}}
