
require:
   "./location" ->
      Source, Location
      highlight_locations
      <<:
   "./lex" ->
      tokenize
   "./parse" ->
      parse
   "./translate-js" ->
      Translator
   "./stdenv" as std
   "./expand" as exp
   "./opt" as opt
   "./util" -> Body
   vm, module, path
   ;; "6to5" as to5
   traceur as to5

provide:
   evaluator
   Source, Location, highlight_locations
   tokenize, parse
   Generator, generate
   version

version = "zero"


evaluator{match options} =

   when module._nodeModulePaths ->
      paths = module._nodeModulePaths{options.cwd}

      e_module = new module{options.showname}
      e_module &: {
         filename = options.filename
         paths = paths
      }

      e_require{path} =
         module._load{path, e_module, true}
      e_require &: {
         main = e_module
         resolve{path} =
            module._resolveFileName{path, e_module}
         paths = paths
         cache = require.cache
      }

      global &: {
         __filename = options.filename
         __dirname = path.dirname{options.filename}
         module = e_module
         require = e_require
      }

      {code} ->
         script = vm.createScript{code, options.showname}
         script.runInThisContext{}

   else ->
      __eval = eval
      {code} -> __eval{code}


generate_from_ast{ast} =
   var ex = std.expand{#top
                       std.topscope
                       std.stdenv.fork{}.mark{#multi{ast}}}
   set ex = opt.hoist{ex}
   tr = Translator{}
   rval = tr.translate{ex, .expr}
   prep = tr.dump_store{}
   to5.compile{r, {}} where r =
      prep + ";(" + rval + ")"

std.stdenv.bind{std.topscope, "macro", #macro{...}} with
   {context, scope, form, match} ->
      #data{#send{name and #symbol{sym}, arguments}, ast} ->
         ;; {prep, code} = generate_from_ast{'[^arguments -> ^ast]}
         code = generate_from_ast{'[^arguments -> ^ast]}
         file = form.location.source.url
         ev = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
         ;; mac = ev{prep + ";("+code+")"}
         mac = ev{code}
         mac2{c, s, f, e} =
            ;; ;; We bind the macro's name in the environment of what it
            ;; ;; returns; that way it can call itself recursively
            ;; env = scope.expander.mkenv{}
            ;; env.bind{scope, sym, #macro{mac2}}
            ;; r = mac{c, s, f, e}
            ;; env.mark{r}

            bindings = form.env.list_bindings{scope}
            ;; console.log with bindings
            env = exp.Env{}
            env.scopes[std.topscope.name] = bindings
            r = mac{c, s, f, e}
            env.mark{r}

         #declare_raw{name, #macro{mac2}}


std.stdenv.bind{std.topscope, "emacro", #macro{...}} with
   {context, scope, form, match} ->
      #data{#send{name and #symbol{sym}, argument}, ast} ->
         ;; {prep, code} = generate_from_ast{'[{^argument} -> ^ast]}
         code = generate_from_ast{'[{^argument} -> ^ast]}
         file = form.location.source.url
         ev = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
         ;; mac = ev{prep + ";("+code+")"}
         mac = ev{code}
         mac2{c, s, f, e} =
            ;; console.log with e
            bindings = form.env.list_bindings{scope}
            env = exp.Env{}
            env.scopes[std.topscope.name] = bindings
            r = match c:
               #project{match} ->
                  #pattern ->
                     #unconditional{#macro{mac3}} where
                        mac3{c, s, f, #data{match}} =
                           #use{env, x} ->
                              #use{env, mac{#data{x} <<: e}}
                           x ->
                              mac{#data{x} <<: x}
                  else ->
                     mac{e}
               #expr ->
                  mac{e}
            env.mark{r}

         #declare_raw{name, #macro{mac2}}


std.stdenv.bind{std.topscope, "macros", #macro{...}} with
   {context, scope, form and {=> env}, #data{body}} ->
      ;; {prep, code} = generate_from_ast{body}
      code = generate_from_ast{body}
      file = form.location.source.url
      ev = evaluator with {
         filename = file
         showname = file
         cwd = file
      }
      ;; the_macros = ev{prep + ";(" + code + ")"}
      the_macros = ev{code}
      #splice{*[...]} with
         items{the_macros} each {k, v} ->
            #declare_raw{#symbol{k} &: {env = env}, #macro{v}}

generate{source} =
   Generator{}.generate{source}

class Generator:

   constructor{interactive = false} =
      @tr = Translator{"require(\"earlgrey-runtime\");"}
      @env = std.stdenv.fork{}
      @interactive = interactive
      @_eval = null

   generate{source, dump = true, _to5 = true} =
      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      var ex = std.expand{
         #top
         std.topscope
         @env.mark{stmt}
      } where stmt =
         if @interactive:
            then:
               Body! {*args} = p
               #interactive{*args}
            else: #multi{p}
      set ex = opt.hoist{ex}
      rval = @tr.translate{ex, .stmt}
      ;; r where r =
      ;; to5.transform{r}.code where r =
      if{_to5, to5.compile{r, {}}, r} where r =
         if dump:
            then: @tr.dump_store{} + rval
            else: rval

   evaluate{source} =
      if [not @_eval]:
         file = source.url
         @_eval = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
      @_eval{@generate{source}}


