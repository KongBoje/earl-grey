
special_ops = {
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {numr,   numr_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {op4,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where

  id = Rx
     start
     [>>"a-zA-Z$_"]
     [>>"a-zA-Z$_0-9"]*

  id_f = {m, wsb, wsa, last_op} -> {.ID, .ID, m[0]}


  numr = Rx
     start
     {d+}, >>"rR"
     {[>>"A-Za-z0-9_"]+}
     [".", {[>>"A-Za-z0-9_"]+}]?

  numr_f = {m, wsb, wsa, last_op} ->
     {_, radix, int, frac} = m
     value := parseInt{int.replace{Rxg"_", ""}, radix}
     ? | frac =>
         frac := frac.replace{Rxg"_", ""}
         value := value + parseInt{frac, radix} / Math.pow{radix, frac.length}
     {.ID, .NUM, value}


  num = Rx
     start
     {[>>"0-9_"]+}
     [".", {d+}]?
     [>>"eE", {[>>"+-"]?, [>>"0-9_"]+}]?

  num_f = {m, wsb, wsa, last_op} ->
     {.ID, .NUM, parseFloat{m[0].replace{Rxg"_", ""}}}


  str = Rx
     start
     "\""
     {["\\\\" or "\\\"" or [>>! "\""]]*}
     "\""

  str_f = {m, wsb, wsa, last_op} ->
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{Rxg{"\\\"" or "\\\\" or "\\n"}, {m} -> repl[m]}
     {.ID, .STR, r}

  op = Rx
     start
     [>> "+\\-*/~^<>=%&|?!#.:"]+

  op2 = Rx
     start
     >>"([{}]),"

  op3 = Rx
     start
     "with" or "where" or "when"
       \ or "and" or "not" or "or"
       \ or "in" or "instanceof" or "mod"
       \ or "each"
     boundary

  op4 = Rx
     start
     "`", {[>>"A-Za-z0-9_"]+}, "`"

  op_f = {m, wsb, wsa, last_op, column} ->
     op = m[1] or m[0]
     ? | [op == "|"] =>
         {.INDENT, column - 1}

       | [op in special_ops] =>
         fixity = special_ops[op]
         width =
            fixity |>
               .IFX -> if{wsb or wsa, .wide, .short}
               .SFX -> if{wsb, .wide, .short}
               .PFX -> if{wsa, .wide, .short}
               other -> throw "OopsA"
         {.OP, fixity, width, op}

       | [wsa and wsb] =>
         {.OP, if{last_op, .PFX, .IFX}, .wide, op}

       | [not wsa and not wsb] =>
         {.OP, if{last_op, .PFX, .IFX}, .short, op}

       | [wsa and last_op] =>
         {.OP, .PFX, .wide, op}

       | wsa =>
         {.OP, .SFX, .short, op}

       | wsb =>
         {.OP, .PFX, .short, op}

       | else =>
         {.OP, .PFX, .short, op}

  indent = Rx
     start
     ["\n", {" "*}]+

  indent_f = {m, wsb, wsa, last_op} ->
     ilen = m[1].length
     {.INDENT, ilen}


  cmnt = Rx
     start
     ";"
     [>>!"\n"]*

  cmnt_f = {m, wsb, wsa, last_op} -> {.IGNORE}


  unkn = Rx
     start
     any

  unkn_f = {m, wsb, wsa, last_op} -> throw ["unknown character: " + m[0]]



;; TODO: ignore blank lines before continuation
ws_re = Rx[start, " "*, ["\n", " "*, "\\", " "*]*]
eol_re = Rx[start, " "*, "\n" or end]

indent_tracker{} =
   curr = false
   stack = {}
   stacks = {stack}
   {token and |>} ->

      {.INDENT, new_indent and |>} ->
         when [curr == false] ->
            curr := new_indent
            {{.OP, .IFX, .wide, ","}}

         [> curr] ->
            stack.push{curr}
             curr := new_indent
            {{.OP, .PFX, .wide, "["}}

         [== curr] ->
            {{.OP, .IFX, .wide, ","}}

         [< curr] ->
            rval = {}
            while [[stack.length > 0] and [new_indent < curr]]:
               curr := stack.pop{}
               rval.push{{.OP, .SFX, .wide, "]"}}
            rval.push{{.OP, .IFX, .wide, ","}}
            rval

      {.ID, stuff*} -> {token}

      {.OP, fixity, width, "[" or "{"} ->
         stack.push{curr}
         stacks.push{stack}
         stack := {}
         curr := false
         {token}

      {.OP, fixity, width, "]" or "}"} ->
         rval = stack.map{{x} -> {.OP, .SFX, .short, "]"}}
         stack := stacks.pop{}
         curr := stack.pop{}
         rval.push{token}
         rval

      other -> {token}


process_token{token, last_op, wsa, wsb, pos, endpos, accum} =
   {type, result*} = token
   type |>
      .IGNORE ->
         last_op

      .ID ->
         ? | [not last_op] =>
             w = {.IFX, if{wsb, .wide, .short}, .WHITE}
             w.location := {pos, pos}
             accum.push{w}
         accum.push{result}
         false

      .OP ->
         ? | last_op =>
             v = {.VOID}
             v.location := {pos, pos}
             accum.push{v}
         result[0] |>
            .IFX ->
               accum.push{result}
               true
            .PFX ->
               ? | [not last_op] =>
                   w = {.IFX, if{wsb, .wide, .short}, .WHITE}
                   w.location := {pos, pos}
                   v = {.VOID}
                   v.location := {pos, pos}
                   accum.push{w}
                   accum.push{v}
               accum.push{result}
               true
            .SFX ->
               accum.push{result}
               v = {.VOID}
               v.location := {endpos, endpos}
               accum.push{v}
               false

      other -> throw "OopsB"


tokenize{text} =
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos := wsb
   column := 0
   indent = indent_tracker{}

   while text:
      for [i = 0, i < regexps.length, ++i]:
         {re, fn} = regexps[i]
         m = text.match{re}
         ? | m =>
             skip = m[0].length
             endpos = pos + skip
             column :=
                splits = m[0].split{"\n"}
                ? | [splits.length > 1] => splits[splits.length - 1].length
                  | else => column + skip
             text := text.slice{skip}
             wsa = text.match{ws_re}[0].length
             eol = text.match{eol_re} and true
             bwsb = wsb > 0
             bwsa = if{eol, bwsb, wsa > 0}
             ;; bwsb = if{eol, true, wsb > 0}
             ;; bwsa = if{eol, true, wsa > 0}
             token = fn{m, bwsb, bwsa, last_op, column}
             tokens = indent{token}
             tokens.forEach with {x} ->
                last_op := process_token{x, last_op, bwsa, bwsb, pos, endpos, results}
             text := text.slice{wsa}
             column += wsa
             wsb := wsa
             pos := endpos + wsa
             break
   ? | last_op =>
       v = {.VOID}
       v.location := {pos, pos}
       results.push{v}
   results



MAX = 1/0

order_map = {

   IFX = {
      wide = {
         ","     => {{2r1111, 1}, {2r1111, 1}}

         "with"  => {{2r1111, 999}, {2r1111, 10}}
         "each"  => {{2r1111, 11},  {2r1111, 10}}
         "where" => {{2r1111, 11},  {2r1111, 10}}
         "|>"    => {{2r1111, 11},  {2r1111, 10}}
         "->"    => {{2r1111, 11},  {2r1111, 10}}
         "=>"    => {{2r1111, 11},  {2r1111, 10}}
         "="     => {{2r1111, 11},  {2r1111, 10}}
         ":="    => {{2r1111, 11},  {2r1111, 10}}
         "+="    => {{2r1111, 11},  {2r1111, 10}}
         "-="    => {{2r1111, 11},  {2r1111, 10}}
         "*="    => {{2r1111, 11},  {2r1111, 10}}
         "/="    => {{2r1111, 11},  {2r1111, 10}}
         "<<="   => {{2r1111, 11},  {2r1111, 10}}
         ">>="   => {{2r1111, 11},  {2r1111, 10}}
         ">>>="  => {{2r1111, 11},  {2r1111, 10}}

         ;; Logical
         "when" => {{2r1111, 100}, {2r1111, 101}}
         "||"   => {{2r1111, 110}, {2r1111, 111}}
         "&&"   => {{2r1111, 120}, {2r1111, 121}}
         "or"   => {{2r1111, 110}, {2r1111, 111}}
         "and"  => {{2r1111, 120}, {2r1111, 121}}
         "not"  => {{2r1111, 130}, {2r1111, 131}}

         ;; Comparison
         "==" => {{2r1111, 200}, {2r1111, 201}}
         "!=" => {{2r1111, 200}, {2r1111, 201}}
         ">=" => {{2r1111, 200}, {2r1111, 201}}
         "<=" => {{2r1111, 200}, {2r1111, 201}}
         ">"  => {{2r1111, 200}, {2r1111, 201}}
         "<"  => {{2r1111, 200}, {2r1111, 201}}

         ;; Binary
         "^." => {{2r1111, 400}, {2r1111, 401}}
         "|." => {{2r1111, 410}, {2r1111, 411}}
         "&." => {{2r1111, 420}, {2r1111, 421}}

         ;; Arithmetic
         "<<"  => {{2r0001, 500}, {2r0001, 501}}
         ">>"  => {{2r0001, 500}, {2r0001, 501}}
         ">>>" => {{2r0001, 500}, {2r0001, 501}}
         "+"   => {{2r0001, 550}, {2r0001, 551}}
         "-"   => {{2r0001, 550}, {2r0001, 551}}
         "*"   => {{2r0001, 560}, {2r0001, 561}}
         "/"   => {{2r0001, 560}, {2r0001, 561}}
         "mod" => {{2r0001, 560}, {2r0001, 561}}
         "**"  => {{2r0001, 571}, {2r0001, 570}}

         ;; Others
         default = {{2r1000, 900}, {2r0100, 901}}
         WHITE   = {{2r1111, 1000}, {2r1111, 1001}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
      short = {
         default = {{2r1111, 1900}, {2r1111, 1901}}
         WHITE   = {{2r1111, 2000}, {2r1111, 2001}}
         ","    => {{2r1111, 1},    {2r1111, 1}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
   }

   PFX = {
      wide = {
         default = {{2r1111, MAX}, {2r1111, 900}}
         "when" => {{2r1111, MAX}, {2r1111, 101}}
         "not"  => {{2r1111, MAX}, {2r1111, 131}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "<>" => {{2r1111, MAX}, {2r1111, 5}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
      short = {
         default = {{2r1111, MAX}, {2r1111, 1900}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
   }

   SFX = {
      wide = {
         default = {{2r1111, 901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
      short = {
         default = {{2r1111, 1901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
   }
}



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3

oparse{next, order, finalize} =
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true:
      o = ? | [not left_op and not right_op] =>
              DONE
            | else =>
              [not left_op and RIGHT]
               \ or [not right_op and LEFT]
               \ or order{left_op, right_op}
      o |>
         [== DONE] ->
            return between

         [== LEFT] ->
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1

         [== RIGHT] ->
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}

         [== BOTH] ->
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}

         [== NONE] ->
            throw ["Undefined priority between " + left_op + " and " + right_op]

         other -> throw "OopsC"


consult{{fixity, width, op}} =
   map = order_map[fixity][width]
   map[op] or map.default


order{o1, o2} =
   {code1, ord1} = consult{o1}[1]
   {code2, ord2} = consult{o2}[0]
   ? | [[code1 & code2] == 0] => throw {"Cannot mix", o1, o2}
     | [ord1 > ord2]  => LEFT
     | [ord1 < ord2]  => RIGHT
     | [ord1 == ord2] => BOTH


finalize{|>} =
   {.ID, value} -> value
   {.NUM, value} -> {.value, value}
   {.STR, value} -> {.value, value}
   {.VOID} -> null

   {ops, args*} ->
      ops := [ops.map with [{o} -> o[2]]]
      op = ops[0]
      {ops, args} |>

         {{"WHITE", ":"}, {f, arg, body}} ->
            {.send, f, {.data, {"code", arg}, {"code", body}}}

         {{":"}, {f, body}} ->
            {.send, f, {.data, {"code", body}}}

         {{"with"}, {target, body}} ->
            body := body |>
               {.multi, rest*} -> rest
               other -> {body}
            target |>
               null? ->
                  {.data}.concat{body}
               {.send, f, {.data, args*}} ->
                  {.send, f, {.data}.concat{args}.concat{body}}
               {.data, args*} ->
                  target.concat{body}
               other ->
                  {.send, target, {.data}.concat{body}}

         {{"[" or ",", _*}, _} ->
            ? | [op == "["] => args := args.slice{1, -1}
            args := args.filter{f} where
               f{x} = [x != null]

            result = args |>
               {} -> throw ["At least one expression must be enclosed in []"]
               {x} -> x
               other -> {.multi}.concat{args}
            result

         {{"{", _*}, _} ->
            {.data}.concat{args.slice{1, -1}.filter{f}} where
               f{x} = [x != null]

         {{.WHITE}, _} ->
            {.send}.concat{args}

         {{_}, |>} ->
            {null?, null?} -> op
            {a, b} -> {.send, op, {.data, a, b}}

         other ->
            throw {"Unknown node", ops, args}

   other -> throw "OopsE"


parse{text} =
   results = tokenize{text}
   ;; ___lib.pr{results}
   next{} = results.shift{}
   oparse{next, order, finalize}


Env{parent} =
   store = Object{}
   self{expr} =
      {.bind_env, self, expr}
   self.resolve := {name} ->
      attempt = store[name]
      ? | attempt => attempt
        | else => self.parent.resolve{name}
   self.register := {name, value} ->
      store[name] := value
   self.register_macro := {name, m} ->
      store[name] := {.macro, m}
   self.fork := {} ->
      Env{self}
   self.parent := parent
   self.store := store
   self


js_contexts = {
   js_for = {.multi, .multi, .multi, .multi}
}


expand{env, context, expr} =
   expr := expand.step{env, context, expr}

   expr |>
      String? -> expr

      null? -> null
      undefined? -> throw ["undefined? why?"]

      {.send, f, arg} ->
         f := expand{env, .head, f}
         {.send, f, expand{env, .tail, arg}}

      {.value, v} -> expr

      {type and [.multi or .code or .array or .object or .splice], args*} ->
         arr = {}
         while [args.length > 0]:
            expand.step{env, type, args.shift{}} |>
               {.splice, stmts*} ->
                  args := stmts.concat{args}
               other ->
                  arr.push{other}
         {type}.concat{arr.map{f}} where
            f{x} = expand{env, type, x}

      {.data, args*} ->

         is_obj = false
         obj = {.object}
         arr = {.array}
         parts = {}

         newpart{} =
            arr |>
               {.array} -> false
               other ->
                  parts.push{arr}
                  arr := {.array}

         while [args.length > 0]:
            expand.step{env, type, args.shift{}} |>
               {.assoc} -> is_obj := true
               {.assoc, k, v} ->
                  is_obj := true
                  obj.push with {.array, k, v}
               {.splice, exprs*} ->
                  args := exprs.concat{args}
               {.dynsplice, expr} ->
                  newpart{}
                  parts.push{expr}
               other ->
                  arr.push{other}

         newpart{}

         r = parts |>
            {} when is_obj ->
               obj
            {} -> {.array}
            {arr and {.array, things*}} ->
               ? | is_obj => arr.push{obj}
               arr
            other ->
               ? | is_obj => parts.push{{.array, obj}}
               patch = {.send, "___lib", {.value, "patch_array"}}
               {.send, patch, {.array}.concat{parts}}

         expand{env, context, r}

      {.lambda, bindings, body} ->
         {.lambda, bindings.map{{x} -> expand{env, .decl, x}}
                   expand{env, .multi, body}}

      {.declare, binding, value} ->
         {.declare, expand{env, .decl, binding}
                    expand{env, .multi, value}}

      {.assign, lhs, rhs} ->
         {.assign, expand{env, .decl, lhs}
                   expand{env, .multi, rhs}}

      {type && [.js_while or .js_for or .js_break
                \ or .js_continue or .js_return
                \ or .js_throw or .if], args*} ->
         ctxs = js_contexts[type] or {}
         {type}.concat{args.map{f}} where
            f{x, i} = expand{env, ctxs[i] or .expr, x}

      {.done, expr} ->
         expr

      other -> throw {"Oops", expr, context}



expand.step := {env, context, expr and |>} ->
   String? ->
      v = env.resolve{expr}
      {v, context} |>
         {undefined?, _} -> expr
         {{.macro, m}, .head} -> v
         {{.macro, m}, _} -> expand.step{env, context, m{env, context, null}}
         other -> v

   null? -> null
   undefined? -> throw ["undefined? why?"]

   {.macro, m} when [context == .head] ->
      expr

   ;; TODO: fix the bug that forces "when true"
   {.macro, m} when true ->
      expand.step{env, context, m{env, context, null}}

   {.send, f, arg} ->
      expand.step{env, .head, f} |>
         {.macro, m} -> expand.step{env, context, m{env, context, arg}}
         other -> expr

   {type, args*} ->
      expr

   other ->
      throw {"Oops2", expr}


aslist{|>} =
   null? -> {null}
   undefined? -> {undefined}
   {.multi, args*} -> args
   other -> {other}


nullenv = {resolve{x} = undefined}


stdenv = Env{nullenv}

stdenv.register{"+", "___plus"}
stdenv.register{"-", "___minus"}
stdenv.register{"*", "___times"}
stdenv.register{"/", "___div"}
stdenv.register{"%", "___mod"}
stdenv.register{"^", "___binxor"}
stdenv.register{"&", "___binand"}
stdenv.register{"|", "___binor"}
stdenv.register{"~", "___binnot"}
stdenv.register{"&&", "___and"}
stdenv.register{"||", "___or"}
;; stdenv.register{"!", "___not"}
stdenv.register{"and", "___and"}
stdenv.register{"or", "___or"}
stdenv.register{"not", "___not"}
stdenv.register{"===", "___is"}
stdenv.register{"!==", "___isnt"}
stdenv.register{"!=", "___neq"}
stdenv.register{"<", "___lt"}
stdenv.register{">", "___gt"}
stdenv.register{"<=", "___lte"}
stdenv.register{">=", "___gte"}
stdenv.register{"<<", "___shl"}
stdenv.register{">>", "___shr"}
stdenv.register{">>>", "___shr2"}
stdenv.register{"in", "___in"}
stdenv.register{"instanceof", "___instanceof"}
stdenv.register{"++", "___plusplus"}
stdenv.register{"--", "___minusminus"}
stdenv.register{"Struct", {.send, "___lib", {.value, "Struct"}}}


;;stdenv.register_macro{"TEST"} with {env, context, expr} -> [
;;   {.splice, "a", "b"}
;;]

make_checker{value, op} = {env, context, expr} ->
   {.send, op, {.data, expr[1], value}}


stdenv.register_macro{"**"} with {env, context, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .pow}}, {.data, a, b}}

stdenv.register_macro{"//"} with {env, context, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .floor}}, {.data, div}} where
      div = {.send, "___div", {.data, a, b}}

stdenv.register_macro{"<>"} with {env, context, {.data, null?, x}} ->
   {.send, {.send, "___lib", {.value, "pr"}}, {.data, x}}


stdenv.register_macro{"#"} with {env, context, {.data, null?, tag}} ->
   tag := {.value, tag}
   {.macro, f} where f{env, |>, expr} =
      .pattern ->
          checker_mac = {.macro, f} where f{env, context, expr} =
             {.send, "___eq", {.data, {.send, expr[1], {.value, "#"}}, tag}}
          expr |>
             {.data, subp*} ->
                deconstructor_mac = {.macro, f} where f{env, context, expr} =
                   {.data, {.value, true}, expr[1]}
                {.check, checker_mac, {.project, deconstructor_mac,
                                                 {.duck}.concat{subp}}}
             other ->
                {.check, checker_mac, expr or {.ignore}}
      _ ->
          expr |>
             null? ->
                {.send, {.send, "___lib", {.value, "StructFactory"}}, d} where d =
                   {.data, tag}
             {.data, args*} ->
                {.send, {.send, "___lib", {.value, "Struct"}}, d} where d =
                   {.data, tag}.concat{args}
             other ->
                factory = {.send, {.send, "___lib", {.value, "StructFactory"}}, d} where
                   d = {.data, tag}
                {.send, factory, other}


stdenv.register_macro{"when"} with {env, context, {.data, |>, condition}} ->
   null? -> {.test, condition, {.ignore}}
   other -> {.test, condition, other}

andf{env, context, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.all, a, b}
      {_, null?} ->
         "___and"
      other ->
         {.send, "___and", expr}
stdenv.register_macro{"&&"} with andf
stdenv.register_macro{"and"} with andf

orf{env, context, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.any, a, b}
      {_, null?} ->
         "___or"
      other ->
         {.send, "___or", expr}
stdenv.register_macro{"||"} with orf
stdenv.register_macro{"or"} with orf


partial_pattern{operator} = {env, context, expr} ->
   {context, expr} |>
      {.pattern, {.data, null?, val}} ->
         {.check, {.macro, make_checker{val, operator}}, {.ignore}}
      {_, null?} ->
         operator
      other ->
         {.send, operator, expr}

stdenv.register_macro{"=="} with partial_pattern{"___eq"}
stdenv.register_macro{"!="} with partial_pattern{"___neq"}
stdenv.register_macro{"<="} with partial_pattern{"___leq"}
stdenv.register_macro{">="} with partial_pattern{"___geq"}
stdenv.register_macro{"<"} with partial_pattern{"___lt"}
stdenv.register_macro{">"} with partial_pattern{"___gt"}


stdenv.register_macro{"*"} with {env, context, expr} ->
   {context, expr} |>
      {.pattern, null?} ->
         {.dynsplice, {.ignore}}
      {.pattern or .data, {.data, val, null?}} ->
         {.dynsplice, val}
      {_, null?} ->
         "___times"
      other ->
         {.send, "___times", expr}


stdenv.register_macro{"."} with {env, context, |>} ->
   {.data, null?, String? s} ->
      {.value, s}
   other ->
      throw {"invalid", other}


stdenv.register_macro{"where"} with {env, context, {.data, a, b}} ->
   {.send, .let, {.data, {.code, b}, {.code, a}}}


stdenv.register_macro{"let"} with {env, context, {.data, {.code, a}, {.code, b}}} ->
   bindings = aslist{a}
   body = aslist{b}
   {.multi}.concat{bindings}.concat{body}


;; stdenv.register_macro{"->"} with {env, context, {.data, args, stmts}} ->
;;    body = {.multi}
;;    args := args.slice{1}.map with {x} -> x |>
;;       String? -> x
;;       other ->
;;          t = gensym{}
;;          body.push with {.send, "=", {.data, x, t}}
;;          t
;;    body.push{stmts}
;;    {.lambda, args, body}

stdenv.register_macro{"->"} with {env, context, {.data, args, stmts}} ->
   body = {.multi}
   {placeholder, newargs} = find_arrow{args}
   newargs := newargs.slice{1}.map with {|>} ->
      String? s -> s
      other ->
         t = gensym{}
         body.push with {.send, "=", {.data, other, t}}
         t
   body.push with
     ? | placeholder =>
         {.send, "|>", {.data, placeholder, stmts}}
       | else => stmts
   {.lambda, newargs, body}


stdenv.register_macro{"each"} with {env, context, {.data, arr, patterns}} ->
   res = gensym{}
   temp = gensym{}
   len = gensym{}
   stmts = {.multi, {.declare, res, {.data}}
                    {.declare, temp, arr}
                    {.declare, len, {.send, temp, {.value, "length"}}}}
   patterns := aslist{patterns}.map with {|>} ->
      {.send, "->", {.data, patt, expr}} ->
         {.send, "->",
            {.data, patt
                    {.send, {.send, res, {.value, "push"}}, {.data, expr}}}}
   patterns.push with {.send, "->", {.data, "other", {.value, false}}}
   lvar = gensym{}
   loop = {.js_for, a, b, c, body} where
      a = {.declare, lvar, {.value, 0}}
      b = {.send, "___lt", {.data, lvar, len}}
      c = {.send, "___plusplus", {.data, lvar, null}}
      body = {.send, "|>", {.data, {.send, "___js_fetch", {.data, temp, lvar}}
                                   {.multi, patterns*}}}
   stmts.push{loop}
   stmts.push{res}
   stmts


stdenv.register_macro{"=>"} with {env, context, {.data, binding, value}} ->
   ? | [context == .data] =>
       {.assoc, binding, value}
     | else =>
       throw ["Illegal context for '=>' (" + context + ")"]


stdenv.register_macro{"="} with {env, context, expr} ->
   {context, expr} |>

      {.multi, {.data, lhs, rhs}} ->
         p = parse_lhs{env, lhs, rhs}
         vars = make_declarations{p[0]}
         r = {.splice}.concat{vars}
         clauses = p[1]

         mkif{x} =
            {.if, x, {.value, false}, {.js_throw, {.value, "a condition failed"}}}

         clauses |>
            {clause} ->
               clause[clause.length - 1] |>
                  {.value, == true} ->
                     ? | [[vars.length == 1] and [clause.length == 3]] =>
                         r := {.declare}.concat{clause[1].slice{1}}
                       | else =>
                         r := r.concat{clause.slice{1, -1}}
                  other ->
                     r.push{mkif{clause}}
            _ ->
               ands = make_pattern_test{clauses}
               r.push{mkif{ands}}
         r

      {.data, null?} ->
         {.assoc}

      {.data, {.data, {.send, f, {.data, args*}}, value}} ->
         {.assoc, {.value, f}, {.lambda, args, value}}

      {.data, {.data, binding, value}} ->
         {.assoc, {.value, binding}, value}

      other ->
         throw ["Illegal context for '=' (" + context + ")"]


make_assigner{op} = {env, context, {.data, a, b}} ->
   {.assign, a, {.send, op, {.data, a, b}}}

stdenv.register_macro{":="} with {env, context, {.data, a, b}} ->
   {.assign, a, b}

stdenv.register_macro{"+="} with make_assigner{"+"}
stdenv.register_macro{"-="} with make_assigner{"-"}
stdenv.register_macro{"*="} with make_assigner{"*"}
stdenv.register_macro{"/="} with make_assigner{"/"}
stdenv.register_macro{"<<="} with make_assigner{"<<"}
stdenv.register_macro{">>="} with make_assigner{">>"}
stdenv.register_macro{">>>="} with make_assigner{">>>"}


stdenv.register_macro{"if"} with {env, context, {.data, test, a, b}} ->
   {.if, test, a, b}

stdenv.register_macro{"cond"} with {env, context, {.data, {.code, clauses}}} ->
   handle{xs} =
      xs |> | {} -> {.value, false}
            | {{.send, "=>", {.data, test, body}}, rest*} ->
              test := test |>
                 "else" -> {.value, true}
                 _ -> test
              {.if, test, body, handle{rest}}
   handle{aslist{clauses}}


stdenv.register_macro{"while"} with {env, context, expr} ->
   {.data, {.code, test}, {.code, body}} = expr
   {.js_while, test, body}

stdenv.register_macro{"for"} with {env, context, expr} ->
   {.data, {.code, {.multi, a, b, c}}, {.code, body}} = expr
   {.js_for, a, b, c, body}

stdenv.register_macro{"return"} with {env, context, expr} ->
   {.js_return, expr}

stdenv.register_macro{"throw"} with {env, context, expr} ->
   {.js_throw, expr}

stdenv.register_macro{"break"} with {env, context, expr} ->
   {.js_break}

stdenv.register_macro{"continue"} with {env, context, expr} ->
   {.js_continue}


rx_wrap{x} =
   "(?:" + x + ")"

rx_quote{x} =
   x.replace{Rxg{>>".?*+^$[](){}|\\\\"}, "\\$1"}

rx_quote2{x} =
   x.replace{Rxg{>>"[](){}^"}, "\\$1"}

rx_build{|>} =
   .any -> "."
   .start -> "^"
   .end -> "$"
   .alpha -> "\\a"
   .digit -> "\\d"
   .word -> "\\w"
   .space -> "\\s"
   .boundary -> "\\b"
   .a -> "\\a"
   .d -> "\\d"
   .w -> "\\w"
   .s -> "\\s"
   .b -> "\\b"

   {.value, x} -> rx_quote{x}
   {.send, |>, {.data, a, b}} ->
      "||" ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      "or" ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      "*" ->
         null? = b
         rx_wrap{rx_build{a} + "*"}
      "+" ->
         null? = b
         rx_wrap{rx_build{a} + "+"}
      "?" ->
         null? = b
         rx_wrap{rx_build{a} + "?"}
      ">>" ->
         null? = a
         ["[" + x + "]"] where
            x = rx_quote2{b[1]}
      ">>!" ->
         null? = a
         ["[^" + x + "]"] where
            x = rx_quote2{b[1]}

   {.data, args*} ->
      "(" + args.map{rx_build}.join{""} + ")"
   {.multi, args*} ->
      "(?:" + args.map{rx_build}.join{""} + ")"
   otherA -> throw "OopsF"


stdenv.register_macro{"Rx"} with {env, context, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}}}

stdenv.register_macro{"Rxg"} with {env, context, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}, {.value, "g"}}}


stdenv.register_macro{"?"} with {env, context, |>} ->

   {.data, null?, expr} ->
      {.send, "cond", {.data, {.code, expr}}}

   {.data, expr, null?} ->
      orig_expr = expr

      checker = expr |>
         null? -> throw "can't use ? on its own"
         .String ->
            {.macro, f} where f{env, context, {.data, expr}} =
               {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                        {.value, "string"}}}
         .Number ->
            {.macro, f} where f{env, context, {.data, expr}} =
               {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                        {.value, "number"}}}
         .true -> {.macro, make_checker{{.value, true}, "___is"}}
         .false -> {.macro, make_checker{{.value, false}, "___is"}}
         .null -> {.macro, make_checker{{.value, null}, "___is"}}
         .undefined -> {.macro, make_checker{{.value, undefined}, "___is"}}
         other -> {.send, {.send, "___lib", {.value, "checker"}}, {.data, expr}}

      mac{env, |>, expr} =
         .pattern -> expr |>
            {.data, subp*} ->
               projector = {.send, {.send, "___lib", {.value, .deconstructor}}
                                   {.data, orig_expr}}
               {.check, checker, {.project, projector, expr}}
            other ->
               {.check, checker, expr or {.ignore}}
         other -> {.send, checker, {.data, expr}}

      {.macro, mac}


stdenv.register_macro{"!"} with {env, context, {.data, expr, null?}} ->
   projector = expr |>
      null? -> throw "can't use ! on its own"
      .String ->
         {.macro, f} where f{env, context, {.data, expr}} =
            {.data, {.value, true}, {.send, "String", {.data, expr}}}
      .Number ->
         {.macro, f} where f{env, context, {.data, expr}} =
            {.data, {.value, true}, {.send, "parseFloat", {.data, expr}}}
      other -> {.send, {.send, "___lib", {.value, "projector"}}, {.data, expr}}

   mac{env, |>, expr} =
      .pattern -> {.project, projector, expr or {.ignore}}
      other -> {.send, projector, {.data, expr}}

   {.macro, mac}


gensym_factory{prefix} =
   prefix := "τ" + prefix
   id = 0
   {} ->
      name = prefix + String{id}
      id := id + 1
      name

gensym = gensym_factory{""}


is_symbol{|>, env} =
   String? s -> env.resolve{s} |>
      {.macro, m} -> false
      _ -> true
   _ -> false

parse_lhs{env, lhs, rhs, gen} =
   gen := gen or gensym_factory{"p"}

   vars = {}
   clauses = {}
   current = {.multi}

   mktemp{} =
      t = gen{}
      vars.push{t}
      t

   newclause{} =
      ? | [current.length > 1] =>
          clauses.push{current}
      current := {.multi}

   maybe_temp{x} =
      ? | is_symbol{x, env} =>
          x
        | else =>
          temp = mktemp{}
          current := current.concat with {
             {.assign, temp, x}
          }
          temp

   helper{lhs, curr} =
      helper_noexpand{expand.step{env, .pattern, lhs}, curr}

   helper_noexpand{lhs, curr} =

      helper_data{temp, specs} =
         fw = 0
         bw = 0
         rest = undefined
         members = specs.map with {x} ->
            v = expand.step{env, .pattern, x}
            v |>
               {.dynsplice, variable} ->
                  rest := variable
               when rest == undefined ->
                  fw := fw + 1
               other ->
                  bw := bw + 1
            v

         cmp = ? | [rest == undefined] => "___eq"
                 | else => "___gte"

         ;; Note: I am splitting length assignment into two parts
         ;; because it lets the crude optimizer reuse it across
         ;; different clauses

         ;; Part 1: temp <- length
         len = mktemp{}
         current := current.concat with {
            {.assign, len, {.send, temp, {.value, "length"}}}
            {.value, true}
         }
         newclause{}

         ;; Part 2: check length
         current := current.concat with {
            ;; Bounds check
            {.send, cmp, {.data, len, {.value, fw + bw}}}
         }
         newclause{}

         for [j = 0, j < fw, ++j]:
            helper_noexpand{members[j], {.send, temp, {.value, j}}}

         ? | [rest != undefined] =>
             slice = ?
                [bw > 0] => {.data, {.value, fw}, {.value, -bw}}
                else => {.data, {.value, fw}}
             helper_noexpand{
                members[fw][1]
                {.send, {.send, temp, {.value, "slice"}}, slice}
             }

         for [j = 0, j < bw, ++j]:
            helper_noexpand{members[fw + j + 1],
                            {.send, temp, {.send, "___minus",
                                           {.data, len, {.value, bw - j}}}}}

      lhs |>

         ;; [null? or "_"] -> false

         null? ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{{.value, null}, "___eq"}}, {.ignore}}

         ["_" or {.ignore}] ->
            ? | [not is_symbol{curr, env}] =>
                current.push{curr}
                current.push{{.value, true}}

         String? ->
            vars.push{lhs}
            current.push{{.assign, lhs, curr}}
            current.push{{.value, true}}

         {.value, v} ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{lhs, "___eq"}}, {.ignore}}

         {.test, condition, pattern} ->
            helper{pattern, curr}
            current.push{condition}
            newclause{}

         {.all, xs*} ->
            ;; temp = mktemp{}
            ;; current := current.concat with {
            ;;    {.assign, temp, curr}
            ;;    ;; {.value, true}
            ;; }
            temp = maybe_temp{curr}
            xs.forEach with {x} ->
               helper{x, temp}

         {.any, xs*} ->
            normalize{vars} =
               vars.filter{{x} -> x[0] != "τ"}.sort{}.join{","}

            ;; temp = mktemp{}
            ;; current := current.concat with {
            ;;    {.assign, temp, curr}
            ;;    ;; {.value, true}
            ;; }

            temp = maybe_temp{curr}
            myvars = undefined
            clauses = {}
            xs.forEach with {x} ->
               p = parse_lhs{env, x, temp, gensym}
               ? | [myvars == undefined] =>
                   myvars := p[0]
                 | [normalize{p[0]} != normalize{myvars}] =>
                   throw with {
                      "Must have the same set of variables in both branches!"
                      "[" + String{myvars} + "]"
                      "[" + String{p[0]} + "]"
                   }
                 | else =>
                   vars := vars.concat{p[0]}
               clauses.push with make_pattern_test{p[1]}
            current.push with make_or_pattern{clauses}
            vars := vars.concat{myvars}
            newclause{}

         {.check, checker, expr} ->
            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.send, checker, {.data, temp}}
            }
            newclause{}
            helper{expr, temp}

         {.project, projector, expr} ->
            temp = maybe_temp{curr}
            temp2 = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.assign, temp2, {.send, projector, {.data, temp}}}
               {.send, temp2, {.value, 0}}
            }
            newclause{}
            helper{expr, {.send, temp2, {.value, 1}}}

         {.send, fname, spec} ->
            helper{fname, {.send, "->", {.data, spec, curr}}}

         {.duck, specs*} ->

            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.value, true}
            }

            helper_data{temp, specs}

         {.data, specs*} ->

            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.send, "___instanceof", {.data, temp, "Array"}}
            }
            newclause{}

            current := current.concat with {
               {.send, "___is", {.data, {.send, temp, {.value, "#"}}, {.value, undefined}}}
            }
            newclause{}

            helper_data{temp, specs}

         other -> throw {"OopsG", other}

   helper{lhs, rhs}
   ? | [current.length > 1] => clauses.push{current}
   {vars, clauses}


make_declarations{vars} =
   vars.map with {name} ->
      {.declare, name, {.value, undefined}}

make_pattern_test{clauses} =
   ands = clauses.pop{}
   while [clauses.length > 0]:
      ands := {.send, "___and", {.data, clauses.pop{}, ands}}
   ands or {.value, true}

make_or_pattern{clauses} =
   ors = clauses.pop{}
   while [clauses.length > 0]:
      ors := {.send, "___or", {.data, clauses.pop{}, ors}}
   ors


find_arrow{|>} =
   "|>" ->
      placeholder = gensym{}
      {placeholder, placeholder}
   "|>*" ->
      placeholder = gensym{}
      {placeholder, {.send, "*", {.data, placeholder, null}}}
   String? x or null? x ->
      {false, x}
   x and {.value, v} ->
      {false, x}
   {kind, args*} ->
      placeholder = false
      new_args = args.map with {arg} ->
         {ph, new_arg} = find_arrow{arg}
         ? | ph => placeholder := ph
         new_arg
      {placeholder, {kind}.concat{new_args}}


same{a, b} = {a, b} |>
   {String? x, String? y} -> x == y
   {{.value, x}, {.value, y}} -> x == y
   {{.macro, x}, {.macro, y}} -> x == y
   {{.send, f, x}, {.send, g, y}} -> same{f, g} and same{x, y}
   {{kind1, xs*}, {kind2, ys*}} ->
      kind1 == kind2 and xs.length == ys.length and allequal where
         allequal = xs.every with {x, i} ->
            same{x, ys[i]}
   other ->
      false

stdenv.register_macro{"|>"} with {env, context, {.data, to_match, cl}} ->
   temp = gensym{}
   clauses = cl |>
      {.multi, cls*} -> cls
      other -> {other}

   cached_conditions = {}

   stmts = {.multi, {.declare, temp, to_match}}
   clauses := clauses.map with {clause} ->
      {.send, "->", {.data, lhs, body}} = clause
      {placeholder, new_lhs} = find_arrow{lhs}
      {decls, conditions} = parse_lhs{env, new_lhs, temp}
      stmts := stmts.concat with make_declarations{decls}
      {conditions.map{f}, b} where
         b = ? | placeholder => {.send, "|>", {.data, placeholder, body}}
               | else => body
         f{x} = {.done, expand{env, .expr, x}}

   ;; BEGIN OPT
   shares = clauses.slice{1}.map{f} where f{{conditions, body}, i} =
      res = 0
      prev_conditions = clauses[i][0]
      nc = conditions.length
      for [j = 0, j < nc and same{conditions[j], prev_conditions[j]}, j++]:
         res++
      res
   max = Math.max shares
   shares.push{0}

   vars = {}
   for [i = 0, i < max, i++]: vars.push{gensym{}}

   stmts := stmts.concat with make_declarations{vars}

   shared_last = 0
   new_clauses = clauses.map with {{conditions, body}, i} ->
      shared = if{shared_last, {vars[shared_last - 1]}, {}}
      n_to_share = Math.max{shared_last, shares[i]}
      to_share = conditions.slice{shared_last, n_to_share}.map with
         {x, j} -> {.assign, vars[shared_last + j], x}
      shared_last := shares[i]
      {shared.concat{to_share}.concat{rest}, body} where
         rest = conditions.slice{n_to_share}

   clauses := new_clauses
   ;; END OPT

   r = {.js_throw, {.data, {.value, "Could not find a match"}, temp}}

   while [clauses.length > 0]:
      {conditions, body} = clauses.pop{}
      test = make_pattern_test{conditions}
      r := {.if, test, body, r}

   stmts.push{r}
   stmts





js_op_table = {
   ___plus = "+"
   ___minus = "-"
   ___times = "*"
   ___div = "/"
   ___mod = "%"
   ___binxor = "^"
   ___binand = "&"
   ___binor = "|"
   ___binnot = "~"
   ___and = "&&"
   ___or = "||"
   ___not = "!"
   ___is = "==="
   ___isnt = "!=="
   ___eq = "==="
   ___neq = "!=="
   ___lt = "<"
   ___gt = ">"
   ___lte = "<="
   ___gte = ">="
   ___shl = "<<"
   ___shr = ">>"
   ___shr2 = ">>>"
   ___in = " in "
   ___instanceof = " instanceof "
   ___plusplus = "++"
   ___minusminus = "--"
}


translate{expr and |>, mode} =

   String? s ->
      translate.expr{translate.mangle{s}, mode}

   null? ->
      translate.expr{"null", mode}

   {.value, v} ->
      r = v |>
         String? ->
            repl = {
               "\"" => "\\\""
               "\n" => "\\n"
               "\\" => "\\\\"
            }
            v := v.replace{Rxg{"\"" or "\\" or "\n"}, {m} -> repl[m]}
            "\"" + v + "\""
         undefined? ->
            "(void 0)"
         [Number? or [== true] or [== false] or null?] ->
            String{v}
         other ->
            "?!?[" + v + "]?!?"
      translate.expr{r, mode}

   {.lambda, bindings, body} ->
      translate.expr{"function("+a+"){"+b+"}", mode} where
         a = bindings.join{","}
         b = translate.body{body, .return}

   {.if, test, pos, neg} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["if(" + a + "){" + b + "}else{" + c + "}"] where
               a = translate{test, .expr}
               b = translate{pos, mode}
               c = translate{neg, mode}

   {.js_while, test, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["while(" + a + "){" + b + "}"] where
               a = translate{test, .expr}
               b = translate{body, .stmt}

   {.js_for, x, y, z, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["for("+a+b+c+"){"+d+"}"] where
               a = translate{x, .stmt}
               b = translate{y, .stmt}
               c = translate{z, .expr}
               d = translate{body, .stmt}

   {.declare, binding, {.value, undefined?}} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + ";"] where
               a = translate{binding, .expr}

   {.declare, binding, value} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + "=" + b + ";"] where
               a = translate{binding, .expr}
               b = translate{value, .expr}

   {.assign, {.send, obj, msg}, rhs} ->
      translate.expr{"(" + a + "[" + b + "]=" + c + ")", mode} where
         a = translate{obj, .expr}
         b = translate{msg, .expr}
         c = translate{rhs, .expr}

   {.assign, lhs, rhs} ->
      translate.expr{"(" + a + "=" + b + ")", mode} where
         a = translate{lhs, .expr}
         b = translate{rhs, .expr}

   {.multi, args*} ->
      isdecl{|>} =
         {.declare, variable, value} -> true
         other -> false
      ? | [args.length == 1] => translate{args[0], mode}
        | [[mode == "expr"] and [not args.some{isdecl}]] =>
          ["(" + xs.join{","} + ")"] where
             xs = args.map with {x} ->
                translate{x, .expr}
        | else => translate.body{expr, mode}

   {.splice, args*} ->
      translate{{.multi}.concat{args}, mode}

   {.js_break} ->
      ? | [mode == "expr"] => throw "Invalid break in ctx"
        | else => "break;"

   {.js_continue} ->
      ? | [mode == "expr"] => throw "Invalid continue in ctx"
        | else => "continue;"

   {.js_return, value} ->
      ? | [mode == "expr"] => throw "Invalid return in ctx"
        | else => "return " + translate{value, .expr} + ";"

   {.js_throw, value} ->
      cond:
         ;; [mode == "expr"] => throw "Invalid throw in ctx"
         else => "throw " + translate{value, .expr} + ";"

   {.array, args*} ->
      r = ["[" + args.map{f}.join{","} + "]"] where
         f{x} = translate{x, .expr}
      translate.expr{r, mode}

   {.object, args*} ->
      r = ["({" + args.map{f}.join{","} + "})"] where
         f{x} =
            a = translate{x[1], .expr}
            b = translate{x[2], .expr}
            a + ":" + b
      translate.expr{r, mode}

   {.send, f, msg and {.value, s}} ->
      cond:
         [[typeof{s} == "string"]
          \ and s.match{Rx[start, [>>"a-zA-Z_$"]+, end]}] =>
            translate.expr{trf + "." + trmsg, mode} where
               trf = translate{f, .expr}
               trmsg = translate{s, .expr}
         else =>
            translate.expr{trf + "[" + trmsg + "]", mode} where
               trf = translate{f, .expr}
               trmsg = translate{msg, .expr}

   {.send, "___js_fetch", {.array, f, msg}} ->
      translate.expr{trf + "[" + trmsg + "]", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   {.send, f, {.array, args*}} ->
      op = [typeof{f} == "string"] and js_op_table[f]
      ? | op =>
          translate.expr{translate.op{op, args[0], args[1]}, mode}
        | else =>
          translate.expr{trf+"("+trargs.join{","}+")", mode} where
             trf = translate{f, .expr}
             trargs = args.map with {x} ->
                translate{x, .expr}

   {.send, f, msg} ->
      translate.expr{"___lib.send(" + trf + "," + trmsg + ")", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   ;; {.send, f, msg} ->
   ;;    translate.expr{trf + "[" + trmsg + "]", mode} where
   ;;       trf = translate{f, .expr}
   ;;       trmsg = translate{msg, .expr}

   other ->
      throw other


translate.mangle := {name} ->
   tr = {
      "+" => "__plus__"
      "-" => "__minus__"
      "*" => "__asterisk__"
      "/" => "__slash__"
      "%" => "__percent__"
      "^" => "__caret__"
      "#" => "__hash__"
      "&" => "__amp__"
      "|" => "__pipe__"
      "@" => "__at__"
      "!" => "__bang__"
      "?" => "__qmark__"
      "=" => "__equal__"
      "<" => "__lt__"
      ">" => "__gt__"
      "~" => "__tilde__"
      "." => "__dot__"
   }
   r = {}
   for [i = 0, i < name.length, ++i]:
      c = name[i]
      r.push{tr[c] or c}
   r.join{""}


translate.body := {b, mode} ->
   orig := b
   b := aslist{b}
   trst{stmt} = translate{stmt, .stmt}
   mode |>
      .expr ->
         translate{x, mode} where
            x = {.send, {.lambda, {}, orig}, {.array}}
      .return ->
         stmts = b.slice{0, -1}
         ret = b[b.length - 1]
         stmts.map{trst}.join{""} + translate{ret, .return}
      .stmt ->
         b.map{trst}.join{""}
      other -> throw "OopsH"

translate.expr := {x, |>} ->
   .expr -> x
   .stmt -> x + ";"
   .return -> "return " + x + ";"
   other -> throw "OopsI"

translate.op := {op, a, b} ->
   e := ? | [a == null] => op + translate{b, .expr}
          | [b == null] => translate{a, .expr} + op
          | true => translate{a, .expr} + op + translate{b, .expr}
   ;; e = {a, b} |>
   ;;    {null?, _} -> op + translate{b, .expr}
   ;;    {_, null?} -> translate{a, .expr} + op
   ;;    _ -> translate{a, .expr} + op + translate{b, .expr}
   "(" + e + ")"


generate{data} =
   p = parse{data}
   ex = expand{stdenv, .top, {.multi, p}}
   prelude + translate{ex, .stmt} where
      prelude = "var ___lib=require(\"./lib\");"

exports.generate := generate


;; docopt = require{.docopt}

;; fs = require{.fs}

;; file = process.argv[2]
;; ;; file = "test.eg"

;; fs.readFile{file, "utf8", f} where
;;    f{err, data} =
;;       p = parse{data}
;;       ex = expand{stdenv, .top, {.multi, p}}
;;       ;; console.log with p
;;       ;; console.log with ex
;;       prelude = "var ___lib=require(\"./lib\");"
;;       console.log with prelude + translate{ex, .stmt}
