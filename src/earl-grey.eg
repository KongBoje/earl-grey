
require:
   ;; "./util" ->
   ;;    items
   "./location" ->
      Source, Location
      highlight_locations
   "./lex" ->
      tokenize
   "./parse" ->
      parse
   "./translate-js" ->
      translate, Translator
   "./stdenv" as std
   "./expand" as exp
   "./opt" as opt

provide:
   Source, Location, highlight_locations
   tokenize, parse
   Generator, generate


generate_from_ast{ast} =
   ex = std.expand{#top
                   std.topscope
                   std.stdenv.fork{}.convert{#multi{ast}}}
   ex := opt.hoist{ex}
   tr = Translator{}
   rval = tr.translate{ex, .expr}
   {tr.dump_store{}, rval}

std.stdenv.bind{std.topscope, "macro", #macro{...}} with
   {context, scope, form, match} ->
      #data{#send{name and #symbol{sym}, arguments}, ast} ->
         {prep, code} = generate_from_ast{'[^arguments -> ^ast]}
         mac = eval{prep + ";("+code+")"}
         mac2{c, s, f, e} =
            ;; We bind the macro's name in the environment of what it
            ;; returns; that way it can call itself recursively
            env = scope.expander.mkenv{}
            env.bind{scope, sym, #macro{mac2}}
            r = mac{c, s, f, e}
            env.convert{r}
         #declare_raw{name, #macro{mac2}}

std.stdenv.bind{std.topscope, "macros", #macro{...}} with
   {context, scope, {=> env}, #data{body}} ->
      {prep, code} = generate_from_ast{body}
      the_macros = eval{prep + ";(" + code + ")"}
      #splice{*[...]} with
         items{the_macros} each {k, v} ->
            #declare_raw{#symbol{k} &: {env = env}, #macro{v}}

generate{source} =
   Generator{}.generate{source}

class Generator:
   constructor{interactive = false} =
      @tr := Translator{std.stdprelude}
      @env := std.stdenv.fork{}
      @interactive := interactive
   generate{source} =
      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      ex = std.expand{#top
                      std.topscope
                      @env.convert{stmt}} where stmt =
         if @interactive:
            then: #interactive{p}
            else: #multi{p}
      ex := opt.hoist{ex}
      rval = @tr.translate{ex, .stmt}
      @tr.dump_store{} + rval

