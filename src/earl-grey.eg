
special_ops = {
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
   "'" => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {numr,   numr_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {op4,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where

  id = Rx
     start
     [>>"a-zA-Z$_"]
     [>>"a-zA-Z$_0-9"]*

  id_f = {m, wsb, wsa, last_op} -> {.ID, .ID, m[0]}


  numr = Rx
     start
     {d+}, >>"rR"
     {[>>"A-Za-z0-9_"]+}
     [".", {[>>"A-Za-z0-9_"]+}]?

  numr_f = {m, wsb, wsa, last_op} ->
     {_, radix, int, frac} = m
     value := parseInt{int.replace{Rxg"_", ""}, radix}
     ? | frac =>
         frac := frac.replace{Rxg"_", ""}
         value := value + parseInt{frac, radix} / Math.pow{radix, frac.length}
     {.ID, .NUM, value}


  num = Rx
     start
     {[>>"0-9_"]+}
     [".", {d+}]?
     [>>"eE", {[>>"+-"]?, [>>"0-9_"]+}]?

  num_f = {m, wsb, wsa, last_op} ->
     {.ID, .NUM, parseFloat{m[0].replace{Rxg"_", ""}}}


  str = Rx
     start
     "\""
     {["\\\\" or "\\\"" or [>>! "\""]]*}
     "\""

  str_f = {m, wsb, wsa, last_op} ->
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{Rxg{"\\\"" or "\\\\" or "\\n"}, {m} -> repl[m]}
     {.ID, .STR, r}

  op = Rx
     start
     [>> "+\\-*/~^<>=%&|?!@#.:'"]+

  op2 = Rx
     start
     >>"([{}]),"

  op3 = Rx
     start
     "with" or "where" or "when"
       \ or "and" or "not" or "or"
       \ or "in" or "instanceof" or "mod"
       \ or "each" or "as"
     boundary

  op4 = Rx
     start
     "`", {[>>"A-Za-z0-9_"]+}, "`"

  op_f = {m, wsb, wsa, last_op, column} ->
     op = m[1] or m[0]
     ? | [op == "|"] =>
         {.INDENT, column - 1}

       | [op in special_ops] =>
         fixity = special_ops[op]
         width =
            fixity |>
               .IFX -> if{wsb or wsa, .wide, .short}
               .SFX -> if{wsb, .wide, .short}
               .PFX -> if{wsa, .wide, .short}
               other -> throw "OopsA"
         {.OP, fixity, width, op}

       | [wsa and wsb] =>
         {.OP, if{last_op, .PFX, .IFX}, .wide, op}

       | [not wsa and not wsb] =>
         {.OP, if{last_op, .PFX, .IFX}, .short, op}

       | [wsa and last_op] =>
         {.OP, .PFX, .wide, op}

       | wsa =>
         {.OP, .SFX, .short, op}

       | wsb =>
         {.OP, .PFX, .short, op}

       | else =>
         {.OP, .PFX, .short, op}

  indent = Rx
     start
     ["\n", {" "*}]+

  indent_f = {m, wsb, wsa, last_op} ->
     ilen = m[1].length
     {.INDENT, ilen}


  cmnt = Rx
     start
     ";"
     [>>!"\n"]*

  cmnt_f = {m, wsb, wsa, last_op} -> {.IGNORE}


  unkn = Rx
     start
     any

  unkn_f = {m, wsb, wsa, last_op} -> throw ["unknown character: " + m[0]]



;; TODO: ignore blank lines before continuation
ws_re = Rx[start, " "*, ["\n", " "*, "\\", " "*]*]
eol_re = Rx[start, " "*, "\n" or end]

indent_tracker{} =
   curr = false
   stack = {}
   stacks = {stack}
   {token and |>} ->

      {.INDENT, new_indent and |>} ->
         when [curr == false] ->
            curr := new_indent
            {{.OP, .IFX, .wide, ","}}

         [> curr] ->
            stack.push{curr}
             curr := new_indent
            {{.OP, .PFX, .wide, "["}}

         [== curr] ->
            {{.OP, .IFX, .wide, ","}}

         [< curr] ->
            rval = {}
            while [[stack.length > 0] and [new_indent < curr]]:
               curr := stack.pop{}
               rval.push{{.OP, .SFX, .wide, "]"}}
            rval.push{{.OP, .IFX, .wide, ","}}
            rval

      {.ID, stuff*} -> {token}

      {.OP, fixity, width, "[" or "{"} ->
         stack.push{curr}
         stacks.push{stack}
         stack := {}
         curr := false
         {token}

      {.OP, fixity, width, "]" or "}"} ->
         rval = stack each _ -> {.OP, .SFX, .short, "]"}
         stack := stacks.pop{}
         curr := stack.pop{}
         rval.push{token}
         rval

      other -> {token}


process_token{token, last_op, wsa, wsb, pos, endpos, accum} =
   {type, result*} = token
   type |>
      .IGNORE ->
         last_op

      .ID ->
         ? | [not last_op] =>
             w = {.IFX, if{wsb, .wide, .short}, .WHITE}
             w.location := {pos, pos}
             accum.push{w}
         accum.push{result}
         false

      .OP ->
         ? | last_op =>
             v = {.VOID}
             v.location := {pos, pos}
             accum.push{v}
         result[0] |>
            .IFX ->
               accum.push{result}
               true
            .PFX ->
               ? | [not last_op] =>
                   w = {.IFX, if{wsb, .wide, .short}, .WHITE}
                   w.location := {pos, pos}
                   v = {.VOID}
                   v.location := {pos, pos}
                   accum.push{w}
                   accum.push{v}
               accum.push{result}
               true
            .SFX ->
               accum.push{result}
               v = {.VOID}
               v.location := {endpos, endpos}
               accum.push{v}
               false

      other -> throw "OopsB"


tokenize{text} =
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos := wsb
   column := 0
   indent = indent_tracker{}

   while text:
      for [i = 0, i < regexps.length, ++i]:
         {re, fn} = regexps[i]
         m = text.match{re}
         ? | m =>
             skip = m[0].length
             endpos = pos + skip
             column :=
                splits = m[0].split{"\n"}
                ? | [splits.length > 1] => splits[splits.length - 1].length
                  | else => column + skip
             text := text.slice{skip}
             wsa = text.match{ws_re}[0].length
             eol = text.match{eol_re} and true
             bwsb = wsb > 0
             bwsa = if{eol, bwsb, wsa > 0}
             ;; bwsb = if{eol, true, wsb > 0}
             ;; bwsa = if{eol, true, wsa > 0}
             token = fn{m, bwsb, bwsa, last_op, column}
             tokens = indent{token}
             tokens each x ->
                last_op := process_token{x, last_op, bwsa, bwsb, pos, endpos, results}
             text := text.slice{wsa}
             column += wsa
             wsb := wsa
             pos := endpos + wsa
             break
   ? | last_op =>
       v = {.VOID}
       v.location := {pos, pos}
       results.push{v}
   results



MAX = 1/0

order_map = {

   IFX = {
      wide = {
         ","     => {{2r1111, 1}, {2r1111, 1}}

         "with"  => {{2r1111, 999}, {2r1111, 10}}
         "each"  => {{2r1111, 11},  {2r1111, 10}}
         "where" => {{2r1111, 11},  {2r1111, 10}}
         "!!"    => {{2r1111, 11},  {2r1111, 10}}
         "|>"    => {{2r1111, 11},  {2r1111, 10}}
         "->"    => {{2r1111, 11},  {2r1111, 10}}
         "=>"    => {{2r1111, 11},  {2r1111, 10}}
         "="     => {{2r1111, 11},  {2r1111, 10}}
         ":="    => {{2r1111, 11},  {2r1111, 10}}
         "+="    => {{2r1111, 11},  {2r1111, 10}}
         "-="    => {{2r1111, 11},  {2r1111, 10}}
         "*="    => {{2r1111, 11},  {2r1111, 10}}
         "/="    => {{2r1111, 11},  {2r1111, 10}}
         "<<="   => {{2r1111, 11},  {2r1111, 10}}
         ">>="   => {{2r1111, 11},  {2r1111, 10}}
         ">>>="  => {{2r1111, 11},  {2r1111, 10}}

         ;; Misc
         "%"     => {{2r1111, 11}, {2r1111, 10}}

         ;; Logical
         "when" => {{2r1111, 100}, {2r1111, 101}}
         "||"   => {{2r1111, 110}, {2r1111, 111}}
         "&&"   => {{2r1111, 120}, {2r1111, 121}}
         "or"   => {{2r1111, 110}, {2r1111, 111}}
         "and"  => {{2r1111, 120}, {2r1111, 121}}
         "not"  => {{2r1111, 130}, {2r1111, 131}}

         ;; Comparison
         "==" => {{2r1111, 200}, {2r1111, 201}}
         "!=" => {{2r1111, 200}, {2r1111, 201}}
         ">=" => {{2r1111, 200}, {2r1111, 201}}
         "<=" => {{2r1111, 200}, {2r1111, 201}}
         ">"  => {{2r1111, 200}, {2r1111, 201}}
         "<"  => {{2r1111, 200}, {2r1111, 201}}

         ;; Binary
         "^." => {{2r1111, 400}, {2r1111, 401}}
         "|." => {{2r1111, 410}, {2r1111, 411}}
         "&." => {{2r1111, 420}, {2r1111, 421}}

         ;; Arithmetic
         "<<"  => {{2r0001, 500}, {2r0001, 501}}
         ">>"  => {{2r0001, 500}, {2r0001, 501}}
         ">>>" => {{2r0001, 500}, {2r0001, 501}}
         "+"   => {{2r0001, 550}, {2r0001, 551}}
         "-"   => {{2r0001, 550}, {2r0001, 551}}
         "*"   => {{2r0001, 560}, {2r0001, 561}}
         "/"   => {{2r0001, 560}, {2r0001, 561}}
         "mod" => {{2r0001, 560}, {2r0001, 561}}
         "**"  => {{2r0001, 571}, {2r0001, 570}}

         ;; Others
         default = {{2r1000, 900}, {2r0100, 901}}
         WHITE   = {{2r1111, 1000}, {2r1111, 1001}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
      short = {
         default = {{2r1111, 1800}, {2r1111, 1801}}
         WHITE   = {{2r1111, 2000}, {2r1111, 2001}}
         ","    => {{2r1111, 1},    {2r1111, 1}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
   }

   PFX = {
      wide = {
         default = {{2r1111, MAX}, {2r1111, 900}}
         "when" => {{2r1111, MAX}, {2r1111, 101}}
         "not"  => {{2r1111, MAX}, {2r1111, 131}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "@" => {{2r1111, MAX}, {2r1111, 3000}}
         "<>" => {{2r1111, MAX}, {2r1111, 5}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
      short = {
         default = {{2r1111, MAX}, {2r1111, 1901}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "@" => {{2r1111, MAX}, {2r1111, 3000}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
   }

   SFX = {
      wide = {
         default = {{2r1111, 901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
      short = {
         default = {{2r1111, 1900}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
   }
}



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3

oparse{next, order, finalize} =
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true:
      o = ? | [not left_op and not right_op] =>
              DONE
            | else =>
              [not left_op and RIGHT]
               \ or [not right_op and LEFT]
               \ or order{left_op, right_op}
      o |>
         [== DONE] ->
            return between

         [== LEFT] ->
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1

         [== RIGHT] ->
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}

         [== BOTH] ->
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}

         [== NONE] ->
            throw ["Undefined priority between " + left_op + " and " + right_op]

         other -> throw "OopsC"


consult{{fixity, width, op}} =
   map = order_map[fixity][width]
   map[op] or map.default


order{o1, o2} =
   {code1, ord1} = consult{o1}[1]
   {code2, ord2} = consult{o2}[0]
   ? | [[code1 & code2] == 0] => throw {"Cannot mix", o1, o2}
     | [ord1 > ord2]  => LEFT
     | [ord1 < ord2]  => RIGHT
     | [ord1 == ord2] => BOTH


finalize{|>} =
   {.ID, value} -> value
   {.NUM, value} -> {.value, value}
   {.STR, value} -> {.value, value}
   {.VOID} -> null

   {ops, args*} ->
      ops := ops each o -> o[2]
      op = ops[0]
      {ops, args} |>

         {{"WHITE", ":"}, {f, arg, body}} ->
            {.send, f, {.data, arg, body}}

         {{":"}, {f, body}} ->
            {.send, f, {.data, body}}

         {{"with"}, {target, aslist! body}} ->

            inserted = false
            result = transform{target} with {|>} ->
               "..." -> [inserted := true, {.multi, body*}]
               [x when x.fromop] and {.send, f, {.data, a, b}} ->
                   {.send, this{f}, {.data, this{a}, this{b}}}
               {.data, args*} ->
                   tr := this
                   {.data}.concat with patch_array.apply{null} with args each
                      "..." -> [inserted := true, body]
                      other -> {tr{other}}

            ? | not inserted => target |>
                null? ->
                   {.data}.concat{body}
                when target.fromop ->
                   {.send, target, {.data}.concat{body}}
                {.send, f, {.data, args*}} ->
                   {.send, f, {.data}.concat{args}.concat{body}}
                {.data, args*} ->
                   target.concat{body}
                other ->
                   {.send, target, {.data}.concat{body}}
              | else => result

         ;; {{"with"}, {target, aslist! body}} ->
         ;;    target |>
         ;;       null? ->
         ;;          {.data}.concat{body}
         ;;       when target.fromop ->
         ;;          {.send, target, {.data}.concat{body}}
         ;;       {.send, f, {.data, args*}} ->
         ;;          {.send, f, {.data}.concat{args}.concat{body}}
         ;;       {.data, args*} ->
         ;;          target.concat{body}
         ;;       other ->
         ;;          {.send, target, {.data}.concat{body}}

         {{"[" or ",", _*}, _} ->
            ? | [op == "["] => args := args.slice{1, -1}
            args := args.filter{f} where
               f{x} = [x != null]

            result = args |>
               {} -> {.value, undefined}
               ;; throw ["At least one expression must be enclosed in []"]
               {x} -> x
               other -> {.multi}.concat{args}
            result

         {{"{", _*}, _} ->
            {.data}.concat{args.slice{1, -1}.filter{f}} where
               f{x} = [x != null]

         {{.WHITE}, _} ->
            {.send}.concat{args}

         {{_}, |>} ->
            {null?, null?} -> op
            {a, b} ->
               rval = {.send, op, {.data, a, b}}
               rval.fromop := true
               rval

         other ->
            throw {"Unknown node", ops, args}

   other -> throw "OopsE"


parse{text} =
   results = tokenize{text}
   next{} = results.shift{}
   oparse{next, order, finalize}


libf{f} =
   ;; {.send, "___lib", {.value, f}}
   ;; f          ;; ORIGINAL
   {.symbol, f}  ;; TRANSITIONAL


Env{parent} =
   store = Object{}
   self{expr} =
      {.bind_env, self, expr}
   self.resolve := {name} ->
      attempt = store[name]
      ? | attempt => attempt
        | else => self.parent.resolve{name}
   self.register := {name, value} ->
      store[name] := value
   self.register_macro := {name, m} ->
      store[name] := {.macro, m}
   self.fork := {} ->
      Env{self}
   self.parent := parent
   self.store := store
   self


js_contexts = {
   js_for = {.multi, .multi, .multi, .multi}
}


expand{{context, env}, expr} =
   expr := expand.step{{context, env}, expr}

   expr |>
      String? s -> s
      {.symbol, s} -> s

      null? -> null
      undefined? -> throw ["undefined? why?"]

      {.send, f, arg} ->
         f := expand{{.head, env}, f}
         {.send, f, expand{{.tail, env}, arg}}

      {.value, v} -> expr

      {type and [.array or .object], args*} -> ;; or .splice
         arr = {}
         while [args.length > 0]:
            expand.step{{type, env}, args.shift{}} |>
               {.splice, stmts*} ->
                  args := stmts.concat{args}
               other ->
                  arr.push{other}
         {type}.concat with
            arr each x -> expand{{type, env}, x}

      {.multi, args*} ->
         arr = {}
         while [args.length > 0]:
            type = if{args.length == 1, .expr, .multi}
            expand.step{{type, env}, args.shift{}} |>
               {.splice, stmts*} ->
                  args := stmts.concat{args}
               other ->
                  arr.push{{other, type}}
         {.multi}.concat with
            arr each {x, type} -> expand{{type, env}, x}

      {.data, args*} ->

         is_obj = false
         obj = {.object}
         arr = {.array}
         parts = {}

         newpart{} =
            arr |>
               {.array} -> false
               other ->
                  parts.push{arr}
                  arr := {.array}

         while [args.length > 0]:
            expand.step{{type, env}, args.shift{}} |>
               {.assoc} -> is_obj := true
               {.assoc, k, v} ->
                  is_obj := true
                  obj.push with {.array, k, v}
               {.splice, exprs*} ->
                  args := exprs.concat{args}
               {.dynsplice, expr} ->
                  newpart{}
                  parts.push{expr}
               other ->
                  arr.push{other}

         newpart{}

         r = parts |>
            {} when is_obj ->
               obj
            {} -> {.array}
            {arr and {.array, things*}} ->
               ? | is_obj => arr.push{obj}
               arr
            other ->
               ? | is_obj => parts.push{{.array, obj}}
               patch = libf{"patch_array"}
               {.send, patch, {.array}.concat{parts}}

         expand{{context, env}, r}

      {.lambda, bindings, body} ->
         {.lambda, bindings each x -> expand{{.decl, env}, x}
                   expand{{.expr, env}, body}}

      {.declare, binding, value} ->
         {.declare, expand{{.decl, env}, binding}
                    expand{{.expr, env}, value}}

      {.assign, lhs, rhs} ->
         {.assign, expand{{.decl, env}, lhs}
                   expand{{.expr, env}, rhs}}

      {type && [.js_while or .js_for or .js_break
                \ or .js_continue or .js_return
                \ or .js_throw or .js_try
                \ or .if], args*} ->
         ctxs = js_contexts[type] or {}
         {type}.concat{args.map{f}} where
            f{x, i} = expand{{ctxs[i] or .expr, env}, x}

      {.done, expr} ->
         expr

      other -> throw {"Oops", expr, context}



expand.step := {{context, env}, expr and |>} ->
   String? s or {.symbol, s} ->
      v = env.resolve{s}
      {v, context} |>
         {undefined?, _} -> s
         {{.macro, m}, .head} -> v
         {{.macro, m}, _} -> expand.step{{context, env}, m{{context, env}, null}}
         other -> v

   null? -> null
   undefined? -> throw ["undefined? why?"]

   {.macro, m} when [context == .head] ->
      expr

   ;; TODO: fix the bug that forces "when true"
   {.macro, m} when true ->
      expand.step{{context, env}, m{{context, env}, null}}

   {.send, f, arg} ->
      expand.step{{.head, env}, f} |>
         {.macro, m} -> expand.step{{context, env}, m{{context, env}, arg}}
         other -> expr

   {type, args*} ->
      expr

   other ->
      throw {"Oops2", expr}


aslist{|>} =
   null? -> {null}
   undefined? -> {undefined}
   {.multi, args*} -> args
   other -> {other}


transform{expr, cb} =
   tr{x} = transform{x, cb}
   cb.call{tr, expr} !!
      expr |>
         null? -> null
         String? s -> s
         {.value, v} -> expr
         {name, args*} ->
            {name, args.map{tr}*}


nullenv = {resolve{x} = undefined}

stdenv = Env{nullenv}

stdenv.register{"+", "___plus"}
stdenv.register{"-", "___minus"}
stdenv.register{"*", "___times"}
stdenv.register{"/", "___div"}
stdenv.register{"mod", "___mod"}
stdenv.register{"^", "___binxor"}
stdenv.register{"&", "___binand"}
stdenv.register{"|", "___binor"}
stdenv.register{"~", "___binnot"}
stdenv.register{"&&", "___and"}
stdenv.register{"||", "___or"}
;; stdenv.register{"!", "___not"}
stdenv.register{"and", "___and"}
stdenv.register{"or", "___or"}
stdenv.register{"not", "___not"}
stdenv.register{"===", "___is"}
stdenv.register{"!==", "___isnt"}
stdenv.register{"!=", "___neq"}
stdenv.register{"<", "___lt"}
stdenv.register{">", "___gt"}
stdenv.register{"<=", "___lte"}
stdenv.register{">=", "___gte"}
stdenv.register{"<<", "___shl"}
stdenv.register{">>", "___shr"}
stdenv.register{">>>", "___shr2"}
stdenv.register{"in", "___in"}
stdenv.register{"instanceof", "___instanceof"}
;; stdenv.register{"++", "___plusplus"}
stdenv.register{"--", "___minusminus"}

stdenv.register_macro{"++"} with {_, |>} ->
   {.data, null?, x} -> '[`___plusplus` ^x]
   {.data, x, null?} -> {.send, "___plusplus", {.data, x, null}}
   {.data, x, y} -> '[^x].concat{^y}
   null? -> '[{x, y} -> x.concat{y}]

stdenv.register_macro{".."} with {_, |>} ->
   {.data, null?, x} -> 'range{1, ^x}
   {.data, x, null?} -> 'range{^x}
   {.data, x, y} -> 'range{^x, ^y}
   null? -> 'range

;;stdenv.register_macro{"TEST"} with {{context, env}, expr} -> [
;;   {.splice, "a", "b"}
;;]

make_checker{value, op} = {{context, env}, expr} ->
   {.send, op, {.data, expr[1], value}}


stdenv.register_macro{"**"} with {{context, env}, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .pow}}, {.data, a, b}}

stdenv.register_macro{"//"} with {{context, env}, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .floor}}, {.data, div}} where
      div = {.send, "___div", {.data, a, b}}

stdenv.register_macro{"<>"} with {{context, env}, {.data, null?, x}} ->
   {.send, libf{"pr"}, {.data, x}}


stdenv.register_macro{"#"} with {{context, env}, {.data, null?, tag}} ->
   tag := {.value, tag}
   {.macro, f} where f{{|>, env}, expr} =
      .pattern ->
          checker_mac = {.macro, f} where f{{context, env}, expr} =
             {.send, "___eq", {.data, {.send, expr[1], {.value, "#"}}, tag}}
          expr |>
             {.data, subp*} ->
                deconstructor_mac = {.macro, f} where f{{context, env}, expr} =
                   {.data, {.value, true}, expr[1]}
                {.check, checker_mac, {.project, deconstructor_mac,
                                                 {.duck}.concat{subp}}}
             other ->
                {.check, checker_mac, expr or {.ignore}}
      _ ->
          expr |>
             null? ->
                {.send, libf{"StructFactory"}, d} where d =
                   {.data, tag}
             {.data, args*} ->
                {.send, libf{"Struct"}, d} where d =
                   {.data, tag}.concat{args}
             other ->
                factory = {.send, libf{"StructFactory"}, d} where
                   d = {.data, tag}
                {.send, factory, other}


stdenv.register_macro{"when"} with {{context, env}, {.data, |>, condition}} ->
   null? -> {.test, condition, {.ignore}}
   other -> {.test, condition, other}

andf{{context, env}, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.all, a, b}
      {_, null?} ->
         "___and"
      other ->
         {.send, "___and", expr}
stdenv.register_macro{"&&"} with andf
stdenv.register_macro{"and"} with andf

orf{{context, env}, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.any, a, b}
      {_, null?} ->
         "___or"
      other ->
         {.send, "___or", expr}
stdenv.register_macro{"||"} with orf
stdenv.register_macro{"or"} with orf


partial_pattern{operator} = {{context, env}, expr} ->
   {context, expr} |>
      {.pattern, {.data, null?, val}} ->
         {.check, {.macro, make_checker{val, operator}}, {.ignore}}
      {_, null?} ->
         operator
      other ->
         {.send, operator, expr}

stdenv.register_macro{"=="} with partial_pattern{"___eq"}
stdenv.register_macro{"!="} with partial_pattern{"___neq"}
stdenv.register_macro{"<="} with partial_pattern{"___lte"}
stdenv.register_macro{">="} with partial_pattern{"___gte"}
stdenv.register_macro{"<"} with partial_pattern{"___lt"}
stdenv.register_macro{">"} with partial_pattern{"___gt"}


stdenv.register_macro{"*"} with {{context, env}, expr} ->
   {context, expr} |>
      {.pattern, null?} ->
         {.dynsplice, {.ignore}}
      {.pattern or .data, {.data, val, null?}} ->
         {.dynsplice, val}
      {_, null?} ->
         "___times"
      other ->
         {.send, "___times", expr}


stdenv.register_macro{"."} with {{context, env}, |>} ->
   {.data, null?, String? s or {.symbol, s}} ->
      {.value, s}
   other ->
      throw {"invalid", other}


stdenv.register_macro{"where"} with {{context, env}, {.data, a, b}} ->
   {.send, .let, {.data, b, a}}


stdenv.register_macro{"let"} with {{context, env}, {.data, a, b}} ->
   bindings = aslist{a}
   body = aslist{b}
   {.multi}.concat{bindings}.concat{body}


stdenv.register_macro{"->"} with {{context, env}, {.data, args, stmts}} ->
   body = {.multi}
   {placeholder, newargs} = find_arrow{args}
   newargs := newargs.slice{1} each
      String? s -> s
      {.symbol, s} -> s
      other ->
         t = gensym{}
         body.push with '[^other = ^t]
         t
   body.push with
     ? | placeholder => '[^placeholder |> ^stmts]
       | else => stmts
   {.lambda, newargs, body}


stdenv.register_macro{"each"} with {{|>, env}, {.data, arr, patterns}} ->
   .multi ->
      temp = gensym{}
      len = gensym{}
      stmts = '
         ^temp = ^arr
         ^len = [^temp].length
      patterns := aslist{patterns}
      patterns.push with '[other -> false]
      lvar = gensym{}
      loop = {.js_for, a, b, c, body} where
         a = ' | ^lvar = 0
         b = ' | ^lvar < ^len
         c = ' | [^lvar]++
         body = '[___js_fetch{^temp, ^lvar} |> ^{.multi, patterns*}]
      stmts.push{loop}
      stmts.push{{.value, false}}
      stmts

   other ->
      res = gensym{}
      temp = gensym{}
      len = gensym{}
      stmts = '
         ^res = {}
         ^temp = ^arr
         ^len = [^temp].length
      patterns := aslist{patterns} each
         {.send, "->", {.data, patt, expr}} ->
            '[^patt -> [^res].push{^expr}]
         other ->
            INVALID_PATTERN ;; TODO: fix into throw
      patterns.push with '[other -> false]
      lvar = gensym{}
      loop = {.js_for, a, b, c, body} where
         a = ' | ^lvar = 0
         b = ' | ^lvar < ^len
         c = ' | [^lvar]++
         body = '[___js_fetch{^temp, ^lvar} |> ^{.multi, patterns*}]
      stmts.push{loop}
      stmts.push{res}
      stmts


stdenv.register_macro{"=>"} with {{context, env}, {.data, binding, value}} ->
   ? | [context == .data] =>
       {.assoc, binding, value}
     | else =>
       throw ["Illegal context for '=>' (" + context + ")"]


stdenv.register_macro{"as"} with {{context, env}, {.data, expr, variable}} ->
   '[^variable = ^expr]

stdenv.register_macro{"="} with {{context, env}, expr} ->
   {context, expr} |>

      {.multi or .expr, {.data, lhs, rhs}} ->
         p = parse_lhs{env, lhs, rhs}
         vars = make_declarations{p[0]}
         r = {.splice}.concat{vars}
         clauses = p[1]

         mkif{x} =
            {.if, x, {.value, false}, {.js_throw, {.value, "a condition failed"}}}

         clauses |>
            {clause} ->
               clause[clause.length - 1] |>
                  {.value, == true} ->
                     ? | [[vars.length == 1] and [clause.length == 3]] =>
                         r := {.declare}.concat{clause[1].slice{1}}
                       | else =>
                         r := r.concat{clause.slice{1, -1}}
                  other ->
                     r.push{mkif{clause}}
            _ ->
               ands = make_pattern_test{clauses}
               r.push{mkif{ands}}
         r

      {.data, null?} ->
         {.assoc}

      {.data, {.data, {.send, f, {.data, args*}}, value}} ->
         {.assoc, {.value, f}, {.lambda, args, value}}

      {.data, {.data, binding, value}} ->
         {.assoc, {.value, binding}, value}

      other ->
         throw ["Illegal context for '=' (" + context + ")"]


make_assigner{op} = {{context, env}, {.data, a, b}} ->
   {.assign, a, {.send, op, {.data, a, b}}}

stdenv.register_macro{":="} with {{context, env}, {.data, a, b}} ->
   {.assign, a, b}

stdenv.register_macro{"+="} with make_assigner{"+"}
stdenv.register_macro{"-="} with make_assigner{"-"}
stdenv.register_macro{"*="} with make_assigner{"*"}
stdenv.register_macro{"/="} with make_assigner{"/"}
stdenv.register_macro{"<<="} with make_assigner{"<<"}
stdenv.register_macro{">>="} with make_assigner{">>"}
stdenv.register_macro{">>>="} with make_assigner{">>>"}


stdenv.register_macro{"if"} with {{context, env}, {.data, test, a, b}} ->
   {.if, test, a, b}

stdenv.register_macro{"cond"} with {{context, env}, {.data, clauses}} ->
   handle{xs} =
      xs |> | {} -> {.value, false}
            | {{.send, "=>", {.data, test, body}}, rest*} ->
              test := test |>
                 "else" -> {.value, true}
                 _ -> test
              {.if, test, body, handle{rest}}
   handle{aslist{clauses}}


stdenv.register_macro{"while"} with {{context, env}, expr} ->
   {.data, test, body} = expr
   {.js_while, test, body}

stdenv.register_macro{"for"} with {{context, env}, expr} ->
   {.data, {.multi, a, b, c}, body} = expr
   {.js_for, a, b, c, body}

stdenv.register_macro{"!!"} with {{context, env}, {.data, expr, matchers}} ->
   excv = gensym{}
   res = gensym{}
   m = aslist{matchers} |>
      ms and {{.send, "->", _}, *} ->
         ms.push with '[___exc -> throw ___exc]
         '[^excv |> ^{.multi, ms*}]
      x ->
         matchers
   f = '[{^excv} -> ^res := ^m]
   {.multi
      {.declare, res, {.value, undefined}}
      {.js_try, {.assign, res, expr}, f, null}
      res}


stdenv.register_macro{"return"} with {{context, env}, expr} ->
   {.js_return, expr}

stdenv.register_macro{"throw"} with {{context, env}, expr} ->
   {.js_throw, expr}

stdenv.register_macro{"break"} with {{context, env}, expr} ->
   {.js_break}

stdenv.register_macro{"continue"} with {{context, env}, expr} ->
   {.js_continue}



rx_wrap{x} =
   "(?:" + x + ")"

rx_quote{x} =
   x.replace{Rxg{>>".?*+^$[](){}|\\\\"}, "\\$1"}

rx_quote2{x} =
   x.replace{Rxg{>>"[](){}^"}, "\\$1"}

rx_build{|>} =
   .any -> "."
   .start -> "^"
   .end -> "$"
   .alpha -> "\\a"
   .digit -> "\\d"
   .word -> "\\w"
   .space -> "\\s"
   .boundary -> "\\b"
   .a -> "\\a"
   .d -> "\\d"
   .w -> "\\w"
   .s -> "\\s"
   .b -> "\\b"

   {.value, x} -> rx_quote{x}

   {.send, "raw", {.value, s}} ->
      s

   {.send, |>, {.data, a, b}} ->
      "||" ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      "or" ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      "*" ->
         null? = b
         rx_wrap{rx_build{a} + "*"}
      "+" ->
         null? = b
         rx_wrap{rx_build{a} + "+"}
      "?" ->
         null? = b
         rx_wrap{rx_build{a} + "?"}
      ">>" ->
         null? = a
         ["[" + x + "]"] where
            x = rx_quote2{b[1]}
      ">>!" ->
         null? = a
         ["[^" + x + "]"] where
            x = rx_quote2{b[1]}

   {.data, args*} ->
      "(" + args.map{rx_build}.join{""} + ")"
   {.multi, args*} ->
      "(?:" + args.map{rx_build}.join{""} + ")"
   otherA -> throw "OopsF"


stdenv.register_macro{"Rx"} with {{context, env}, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}}}

stdenv.register_macro{"Rxg"} with {{context, env}, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}, {.value, "g"}}}


stdenv.register_macro{"?"} with {{context, env}, |>} ->

   {.data, null?, expr} ->
      {.send, "cond", {.data, expr}}

   {.data, expr, null?} ->
      orig_expr = expr

      checker = expr |>
         null? -> throw "can't use ? on its own"
         .String ->
            {.macro, f} where f{{context, env}, {.data, expr}} =
               {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                        {.value, "string"}}}
         .Number ->
            {.macro, f} where f{{context, env}, {.data, expr}} =
               {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                        {.value, "number"}}}
         .true -> {.macro, {_, _, {.data, expr}} -> expr}
         .false -> {.macro, {_, _, {.data, expr}} -> '[not ^expr]}
         ;;.true -> {.macro, make_checker{{.value, true}, "___is"}}
         ;;.false -> {.macro, make_checker{{.value, false}, "___is"}}
         .null -> {.macro, make_checker{{.value, null}, "___is"}}
         .undefined -> {.macro, make_checker{{.value, undefined}, "___is"}}
         other -> {.send, libf{"checker"}, {.data, expr}}

      mac{{|>, env}, expr} =
         .pattern -> expr |>
            {.data, subp*} ->
               projector = {.send, libf{.deconstructor}
                                   {.data, orig_expr}}
               {.check, checker, {.project, projector, expr}}
            other ->
               {.check, checker, expr or {.ignore}}
         other -> {.send, checker, {.data, expr}}

      {.macro, mac}


stdenv.register_macro{"!"} with {{context, env}, {.data, expr, null?}} ->
   projector = expr |>
      null? -> throw "can't use ! on its own"
      .String ->
         {.macro, f} where f{{context, env}, {.data, expr}} =
            {.data, {.value, true}, {.send, "String", {.data, expr}}}
      .Number ->
         {.macro, f} where f{{context, env}, {.data, expr}} =
            {.data, {.value, true}, {.send, "parseFloat", {.data, expr}}}
      other -> {.send, libf{"projector"}, {.data, expr}}

   mac{{|>, env}, expr} =
      .pattern -> {.project, projector, expr or {.ignore}}
      other -> {.send, {.send, projector, {.data, expr}}, {.value, 1}}

   {.macro, mac}


gensym_factory{prefix} =
   prefix := "τ" + prefix
   id = 0
   {} ->
      name = prefix + String{id}
      id := id + 1
      name

gensym = gensym_factory{""}


is_symbol{|>, env} =
   String? s or {.symbol, s} -> env.resolve{s} |>
      {.macro, m} -> false
      _ -> true
   _ -> false

parse_lhs{env, lhs, rhs, gen} =
   gen := gen or gensym_factory{"p"}

   vars = {}
   clauses = {}
   current = {.multi}

   mktemp{} =
      t = gen{}
      vars.push{t}
      t

   newclause{} =
      ? | [current.length > 1] =>
          clauses.push{current}
      current := {.multi}

   maybe_temp{x} =
      ? | is_symbol{x, env} =>
          x
        | else =>
          temp = mktemp{}
          current := current.concat with {
             {.assign, temp, x}
          }
          temp

   helper{lhs, curr} =
      helper_noexpand{expand.step{{.pattern, env}, lhs}, curr}

   helper_noexpand{lhs, curr} =

      helper_data{temp, specs} =
         fw = 0
         bw = 0
         rest = undefined
         members = specs each x ->
            v = expand.step{{.pattern, env}, x}
            v |>
               {.dynsplice, variable} ->
                  rest := variable
               when rest == undefined ->
                  fw := fw + 1
               other ->
                  bw := bw + 1
            v

         cmp = ? | [rest == undefined] => "___eq"
                 | else => "___gte"

         ;; Note: I am splitting length assignment into two parts
         ;; because it lets the crude optimizer reuse it across
         ;; different clauses

         ;; Part 1: temp <- length
         len = mktemp{}
         current := current.concat with {
            {.assign, len, {.send, temp, {.value, "length"}}}
            {.value, true}
         }
         newclause{}

         ;; Part 2: check length
         current := current.concat with {
            ;; Bounds check
            {.send, cmp, {.data, len, {.value, fw + bw}}}
         }
         newclause{}

         for [j = 0, j < fw, ++j]:
            helper_noexpand{members[j], {.send, temp, {.value, j}}}

         ? | [rest != undefined] =>
             slice = ?
                [bw > 0] => {.data, {.value, fw}, {.value, -bw}}
                else => {.data, {.value, fw}}
             helper_noexpand{
                members[fw][1]
                {.send, {.send, temp, {.value, "slice"}}, slice}
             }

         for [j = 0, j < bw, ++j]:
            helper_noexpand{members[fw + j + 1],
                            {.send, temp, {.send, "___minus",
                                           {.data, len, {.value, bw - j}}}}}

      lhs |>

         null? ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{{.value, null}, "___eq"}}, {.ignore}}

         ["_" or {.ignore}] ->
            ? | [not is_symbol{curr, env}] =>
                current.push{curr}
                current.push{{.value, true}}

         String? s or {.symbol, s} ->
            vars.push{s}
            current.push{{.assign, s, curr}}
            current.push{{.value, true}}

         {.value, v} ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{lhs, "___eq"}}, {.ignore}}

         {.test, condition, pattern} ->
            helper{pattern, curr}
            current.push{condition}
            newclause{}

         {.all, xs*} ->
            ;; temp = mktemp{}
            ;; current := current.concat with {
            ;;    {.assign, temp, curr}
            ;;    ;; {.value, true}
            ;; }
            temp = maybe_temp{curr}
            xs each x -> helper{x, temp}
            false

         {.any, xs*} ->
            normalize{vars} =
               vars.filter{{x} -> x[0] != "τ"}.sort{}.join{","}

            ;; temp = mktemp{}
            ;; current := current.concat with {
            ;;    {.assign, temp, curr}
            ;;    ;; {.value, true}
            ;; }

            temp = maybe_temp{curr}
            myvars = undefined
            clauses = {}
            xs each x ->
               p = parse_lhs{env, x, temp, gensym}
               ? | [myvars == undefined] =>
                   myvars := p[0]
                 | [normalize{p[0]} != normalize{myvars}] =>
                   throw with {
                      "Must have the same set of variables in both branches!"
                      "[" + String{myvars} + "]"
                      "[" + String{p[0]} + "]"
                   }
                 | else =>
                   vars := vars.concat{p[0]}
               clauses.push with make_pattern_test{p[1]}
            current.push with make_or_pattern{clauses}
            vars := vars.concat{myvars}
            newclause{}

         {.check, checker, expr} ->
            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.send, checker, {.data, temp}}
            }
            newclause{}
            helper{expr, temp}

         {.project, projector, expr} ->
            temp = maybe_temp{curr}
            temp2 = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.assign, temp2, {.send, projector, {.data, temp}}}
               {.send, temp2, {.value, 0}}
            }
            newclause{}
            helper{expr, {.send, temp2, {.value, 1}}}

         {.send, fname, spec} ->
            helper{fname, {.send, "->", {.data, spec, curr}}}

         {.duck, specs*} ->

            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.value, true}
            }

            helper_data{temp, specs}

         {.data, specs*} ->

            temp = maybe_temp{curr}
            ;; temp = mktemp{}
            current := current.concat with {
               ;; {.assign, temp, curr}
               {.send, "___instanceof", {.data, temp, "Array"}}
            }
            newclause{}

            current := current.concat with {
               {.send, "___is", {.data, {.send, temp, {.value, "#"}}, {.value, undefined}}}
            }
            newclause{}

            helper_data{temp, specs}

         other -> throw {"OopsG", other}

   helper{lhs, rhs}
   ? | [current.length > 1] => clauses.push{current}
   {vars, clauses}


make_declarations{vars} =
   vars each name ->
      {.declare, name, {.value, undefined}}

make_pattern_test{clauses} =
   ands = clauses.pop{}
   while [clauses.length > 0]:
      ands := {.send, "___and", {.data, clauses.pop{}, ands}}
   ands or {.value, true}

make_or_pattern{clauses} =
   ors = clauses.pop{}
   while [clauses.length > 0]:
      ors := {.send, "___or", {.data, clauses.pop{}, ors}}
   ors


find_arrow{|>} =
   "|>" ->
      placeholder = gensym{}
      {placeholder, placeholder}
   "|>*" ->
      placeholder = gensym{}
      {placeholder, {.send, "*", {.data, placeholder, null}}}
   String? x or null? x ->
      {false, x}
   {.symbol, x} ->
      {false, x}
   x and {.value, v} ->
      {false, x}
   {kind, args*} ->
      placeholder = false
      new_args = args each arg ->
         {ph, new_arg} = find_arrow{arg}
         ? | ph => placeholder := ph
         new_arg
      {placeholder, {kind}.concat{new_args}}



same{a, b} = {a, b} |>
   {String? x, String? y} -> x == y
   {{.symbol x}, {.symbol, y}} -> x == y
   {{.value, x}, {.value, y}} -> x == y
   {{.macro, x}, {.macro, y}} -> x == y
   {{.send, f, x}, {.send, g, y}} -> same{f, g} and same{x, y}
   {{kind1, xs*}, {kind2, ys*}} ->
      kind1 == kind2 and xs.length == ys.length and allequal where
         allequal = xs.every with {x, i} ->
            same{x, ys[i]}
   other ->
      false

stdenv.register_macro{"|>"} with {{context, env}, {.data, to_match, cl}} ->
   temp = gensym{}
   clauses = cl |>
      {.multi, cls*} -> cls
      other -> {other}

   cached_conditions = {}

   stmts = {.multi, {.declare, temp, to_match}}
   clauses := clauses each clause ->
      {.send, "->", {.data, lhs, body}} = clause
      {placeholder, new_lhs} = find_arrow{lhs}
      {decls, conditions} = parse_lhs{env, new_lhs, temp}
      stmts := stmts.concat with make_declarations{decls}
      {conditions.map{f}, b} where
         b = ? | placeholder => {.send, "|>", {.data, placeholder, body}}
               | else => body
         f{x} = {.done, expand{{.expr, env}, x}}

   ;; BEGIN OPT
   shares = clauses.slice{1}.map{f} where f{{conditions, body}, i} =
      res = 0
      prev_conditions = clauses[i][0]
      nc = conditions.length
      for [j = 0, j < nc and same{conditions[j], prev_conditions[j]}, j++]:
         res++
      res
   max = Math.max shares
   shares.push{0}

   vars = {}
   for [i = 0, i < max, i++]: vars.push{gensym{}}

   stmts := stmts.concat with make_declarations{vars}

   shared_last = 0
   new_clauses = clauses.map with {{conditions, body}, i} ->
      shared = if{shared_last, {vars[shared_last - 1]}, {}}
      n_to_share = Math.max{shared_last, shares[i]}
      to_share = conditions.slice{shared_last, n_to_share}.map with
         {x, j} -> {.assign, vars[shared_last + j], x}
      shared_last := shares[i]
      {shared.concat{to_share}.concat{rest}, body} where
         rest = conditions.slice{n_to_share}

   clauses := new_clauses
   ;; END OPT

   r = {.js_throw, {.data, {.value, "Could not find a match"}, temp}}

   while [clauses.length > 0]:
      {conditions, body} = clauses.pop{}
      test = make_pattern_test{conditions}
      r := {.if, test, body, r}

   stmts.push{r}
   stmts


qqstruct{name, args} =
   {.data, {.value, name}, args*}

qq{expr and |>} =
   String? s or {.symbol, s} -> {.value, s}
   null? -> {.value, null}
   {.value, v} ->
      qqstruct{.value, {expr}}
   {.send, "^", {.data, null?, insert}} ->
      insert
   {.send, "^=", {.data, null?, insert}} ->
      qqstruct{.value, {insert}}
   {name, args*} ->
      qqstruct{name, args each arg -> qq{arg}}

stdenv.register_macro{"'"} with {{context, env}, {.data, null?, expr}} ->
   qq{expr}


stdenv.register_macro{"req"} with {{context, env}, {.data, expr}} ->

   stmts = {}

   topfetch{pkg, v} =
      stmts.push with '[^v = ___node.require{^=pkg}]
      v

   produce{|>, fetch} =

      String? s ->
          fetch{s, s}

      {.value, String? s} ->
          fetch{s, gensym{}}

      {.multi or .data, subp*} ->
          subp each p -> produce{p, fetch}

      {.send, "as", {.data, {.value, pkg} or pkg, String? s}} ->
          fetch{pkg, s}

      {.send, "->", {.data, pkg, subp}} ->
          pkgv = produce{pkg, fetch}
          produce{subp} with {pkg, v} ->
              stmts.push with '[^v = ^pkgv ^=pkg]

   produce{expr, topfetch}
   {.multi, stmts*}



stdenv.register_macro{"%"} with {{context, env}, {.data, descr, contents}} ->
   tag = {.value, "div"}
   id = {.value, null}
   classes = {.data}
   kv = {.data}
   parse{|>} =
      null? -> null
      String? s -> tag := {.value, s}
      {.value, x} ->
         classes.push with {.value, x}
      {.send, ".", {.data, null?, String? x}} ->
         classes.push with {.value, x}
      {.send, "#", {.data, null?, String? x}} ->
         id := {.value, x}
      {.send, "=", {.data, String? prop, value}} ->
         kv.push with {.data, {.value, prop}, value}
      {.send, expr, rest} ->
         parse{expr}, parse{rest}
      {.multi or .data, args*} ->
         args.forEach{parse}
   parse{descr}
   contents := contents |>
      null? -> {.data}
      {.multi, args*} -> {.data, args*}
      x -> x
   '[create_node{^tag, ^id, ^classes, ^kv, ^contents}]


stdenv.register_macro{"chain"} with {{context, env}, {.data, defn, body}} ->
   newenv = env.fork{}
   temp = gensym{}

   {variable, expr} = defn |>
      {.send, "as", {.data, x, y}} -> {y, x}
      other -> {"@", other}

   newenv.register_macro{variable} with f where f{{context, env}, |>} =
      null? -> temp
      {.data, null?, |>} ->
         String? s or {.symbol, s} ->
            '[[^temp] [^=s]]
         {.send, obj, msg} ->
            '[^x ^msg] where x =
               f{env, .head, {.data, null, obj}}
         other ->
            '[[^temp] [^other]]
      other -> ;; throw {"invalid @ argument", other}
         '[^temp ^other]
   stmts = {.multi}.concat with aslist{body} each x -> '[^temp := ^x]
   v = ' | ^temp = ^expr
         | ^stmts
         | ^temp
   {.done, expand{{context, newenv}, v}}



stdenv.register_macro{"macro"} with {{context, env}, expr} ->
   {.data, {.send, name, args}, body} = expr
   fn = '[^args -> ^body]
   code = generate_from_ast{fn}
   efn = eval{"(" + code.slice{0, -1} + ")"}
   env.register_macro{name, efn}
   {.value, undefined}



js_op_table = {
   ___plus = "+"
   ___minus = "-"
   ___times = "*"
   ___div = "/"
   ___mod = "%"
   ___binxor = "^"
   ___binand = "&"
   ___binor = "|"
   ___binnot = "~"
   ___and = "&&"
   ___or = "||"
   ___not = "!"
   ___is = "==="
   ___isnt = "!=="
   ___eq = "==="
   ___neq = "!=="
   ___lt = "<"
   ___gt = ">"
   ___lte = "<="
   ___gte = ">="
   ___shl = "<<"
   ___shr = ">>"
   ___shr2 = ">>>"
   ___in = " in "
   ___instanceof = " instanceof "
   ___plusplus = "++"
   ___minusminus = "--"
}


translate{expr and |>, mode} =

   String? s or {.symbol, s} ->
      translate.expr{translate.mangle{s}, mode}

   null? ->
      translate.expr{"null", mode}

   {.value, v} ->
      r = v |>
         String? ->
            repl = {
               "\"" => "\\\""
               "\n" => "\\n"
               "\\" => "\\\\"
            }
            v := v.replace{Rxg{"\"" or "\\" or "\n"}, {m} -> repl[m]}
            "\"" + v + "\""
         undefined? ->
            "(void 0)"
         [Number? or [== true] or [== false] or null?] ->
            String{v}
         other ->
            "?!?[" + v + "]?!?"
      translate.expr{r, mode}

   {.lambda, bindings, body} ->
      translate.expr{"function("+a+"){"+b+"}", mode} where
         a = bindings.join{","}
         b = translate.body{body, .return}

   {.if, test, pos, neg} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["if(" + a + "){" + b + "}else{" + c + "}"] where
               a = translate{test, .expr}
               b = translate{pos, mode}
               c = translate{neg, mode}

   {.js_while, test, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["while(" + a + "){" + b + "}"] where
               a = translate{test, .expr}
               b = translate{body, .stmt}

   {.js_for, x, y, z, body} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            ["for("+a+b+c+"){"+d+"}"] where
               a = translate{x, .stmt}
               b = translate{y, .stmt}
               c = translate{z, .expr}
               d = translate{body, .stmt}

   {.js_try, attempt, {.lambda, {String? v}, body}, null?} ->
      mode |>
         .expr -> translate.body{expr, .expr}
         other ->
            "try{" + a + "}catch(" + v + "){" + b + "}" where
               a = translate{attempt, .stmt}
               b = translate{body, .stmt}

   {.declare, binding, {.value, undefined?}} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + ";"] where
               a = translate{binding, .expr}

   {.declare, binding, value} ->
      mode |>
         [.expr or .return] -> throw "Invalid in expr ctx"
         other ->
            ["var " + a + "=" + b + ";"] where
               a = translate{binding, .expr}
               b = translate{value, .expr}

   {.assign, {.send, obj, msg}, rhs} ->
      translate.expr{"(" + a + "[" + b + "]=" + c + ")", mode} where
         a = translate{obj, .expr}
         b = translate{msg, .expr}
         c = translate{rhs, .expr}

   {.assign, lhs, rhs} ->
      translate.expr{"(" + a + "=" + b + ")", mode} where
         a = translate{lhs, .expr}
         b = translate{rhs, .expr}

   {.multi, args*} ->
      isdecl{|>} =
         {.declare, variable, value} -> true
         other -> false
      ? | [args.length == 1] => translate{args[0], mode}
        | [[mode == "expr"] and [not args.some{isdecl}]] =>
          ["(" + xs.join{","} + ")"] where
             xs = args each x ->
                translate{x, .expr}
        | else => translate.body{expr, mode}

   {.splice, args*} ->
      translate{{.multi}.concat{args}, mode}

   {.js_break} ->
      ? | [mode == "expr"] => throw "Invalid break in ctx"
        | else => "break;"

   {.js_continue} ->
      ? | [mode == "expr"] => throw "Invalid continue in ctx"
        | else => "continue;"

   {.js_return, value} ->
      ? | [mode == "expr"] => throw "Invalid return in ctx"
        | else => "return " + translate{value, .expr} + ";"

   {.js_throw, value} ->
      ? | [mode == "expr"] =>
          "function(){throw " + translate{value, .expr} + ";}()"
        | else =>
          "throw " + translate{value, .expr} + ";"

   {.array, args*} ->
      r = ["[" + args.map{f}.join{","} + "]"] where
         f{x} = translate{x, .expr}
      translate.expr{r, mode}

   {.object, args*} ->
      r = ["({" + args.map{f}.join{","} + "})"] where
         f{x} =
            a = translate{x[1], .expr}
            b = translate{x[2], .expr}
            a + ":" + b
      translate.expr{r, mode}

   {.send, "___node", {.value, f}} ->
      f

   {.send, "___js_fetch", {.array, f, msg}} ->
      translate.expr{trf + "[" + trmsg + "]", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   {.send, f, msg and {.value, s}} ->
      cond:
         [[typeof{s} == "string"]
          \ and s.match{Rx[start, [>>"a-zA-Z_$"]+, end]}] =>
            translate.expr{trf + "." + trmsg, mode} where
               trf = translate{f, .expr}
               trmsg = translate{s, .expr}
         else =>
            translate.expr{trf + "[" + trmsg + "]", mode} where
               trf = translate{f, .expr}
               trmsg = translate{msg, .expr}

   {.send, f, {.array, args*}} ->
      op = [typeof{f} == "string"] and js_op_table[f]
      ? | op =>
          translate.expr{translate.op{op, args[0], args[1]}, mode}
        | else =>
          translate.expr{trf+"("+trargs.join{","}+")", mode} where
             trf = translate{f, .expr}
             trargs = args each x ->
                translate{x, .expr}

   {.send, f, msg} ->
      translate.expr{"send(" + trf + "," + trmsg + ")", mode} where
         trf = translate{f, .expr}
         trmsg = translate{msg, .expr}

   ;; {.send, f, msg} ->
   ;;    translate.expr{trf + "[" + trmsg + "]", mode} where
   ;;       trf = translate{f, .expr}
   ;;       trmsg = translate{msg, .expr}

   other ->
      throw other


translate.mangle := {name} ->
   tr = {
      "+" => "__plus__"
      "-" => "__minus__"
      "*" => "__asterisk__"
      "/" => "__slash__"
      "%" => "__percent__"
      "^" => "__caret__"
      "#" => "__hash__"
      "&" => "__amp__"
      "|" => "__pipe__"
      "@" => "__at__"
      "!" => "__bang__"
      "?" => "__qmark__"
      "=" => "__equal__"
      "<" => "__lt__"
      ">" => "__gt__"
      "~" => "__tilde__"
      "." => "__dot__"
   }
   r = {}
   for [i = 0, i < name.length, ++i]:
      c = name[i]
      r.push{tr[c] or c}
   r.join{""}


translate.body := {b, mode} ->
   orig := b
   b := aslist{b}
   trst{stmt} = translate{stmt, .stmt}
   mode |>
      .expr ->
         translate{x, mode} where
            x = {.send, {.lambda, {}, orig}, {.array}}
      .return ->
         stmts = b.slice{0, -1}
         ret = b[b.length - 1]
         stmts.map{trst}.join{""} + translate{ret, .return}
      .stmt ->
         b.map{trst}.join{""}
      other -> throw "OopsH"

translate.expr := {x, |>} ->
   .expr -> x
   .stmt -> x + ";"
   .return -> "return " + x + ";"
   other -> throw "OopsI"

translate.op := {op, a, b} ->
   e = {a, b} |>
          {null?, _} -> op + translate{b, .expr}
          {_, null?} -> translate{a, .expr} + op
          _ -> translate{a, .expr} + op + translate{b, .expr}
   "(" + e + ")"


generate_from_ast{ast} =
   ex = expand{{.top, stdenv.fork{}}, {.multi, ast}}
   translate{ex, .stmt}

generate{data, prelude} =
   p = parse{data}
   ex = expand{{.top, stdenv.fork{}}, {.multi, p}}
   [prelude or ""] + translate{ex, .stmt}

exports.generate := generate
