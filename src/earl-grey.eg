
require:
   "./location" ->
      Source, Location
      highlight_locations
   "./lex" ->
      tokenize
   "./parse" ->
      parse
   "./translate-js" ->
      translate, Translator
   "./stdenv" as std
   "./expand" as exp
   "./opt" as opt
   vm, module, path

provide:
   evaluator
   Source, Location, highlight_locations
   tokenize, parse
   Generator, generate
   version

version = "zero"


evaluator{match options} =

   when module._nodeModulePaths ->
      paths = module._nodeModulePaths{options.cwd}

      e_module = new module{options.showname}
      e_module &: {
         filename = options.filename
         paths = paths
      }

      e_require{path} =
         module._load{path, e_module, true}
      e_require &: {
         main = e_module
         resolve{path} =
            module._resolveFileName{path, e_module}
         paths = paths
         cache = require.cache
      }

      global &: {
         __filename = options.filename
         __dirname = path.dirname{options.filename}
         module = e_module
         require = e_require
      }

      {code} ->
         script = vm.createScript{code, options.showname}
         script.runInThisContext{}

   else ->
      {code} -> eval{code}


generate_from_ast{ast} =
   var ex = std.expand{#top
                       std.topscope
                       std.stdenv.fork{}.mark{#multi{ast}}}
   set ex = opt.hoist{ex}
   tr = Translator{}
   rval = tr.translate{ex, .expr}
   {tr.dump_store{}, rval}

std.stdenv.bind{std.topscope, "macro", #macro{...}} with
   {context, scope, form, match} ->
      #data{#send{name and #symbol{sym}, arguments}, ast} ->
         {prep, code} = generate_from_ast{'[^arguments -> ^ast]}
         file = form.location.source.url
         ev = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
         mac = ev{prep + ";("+code+")"}
         mac2{c, s, f, e} =
            ;; ;; We bind the macro's name in the environment of what it
            ;; ;; returns; that way it can call itself recursively
            ;; env = scope.expander.mkenv{}
            ;; env.bind{scope, sym, #macro{mac2}}
            ;; r = mac{c, s, f, e}
            ;; env.mark{r}

            bindings = form.env.list_bindings{scope}
            ;; console.log with bindings
            env = exp.Env{}
            env.scopes[std.topscope.name] = bindings
            r = mac{c, s, f, e}
            env.mark{r}

         #declare_raw{name, #macro{mac2}}

std.stdenv.bind{std.topscope, "macros", #macro{...}} with
   {context, scope, {=> env}, #data{body}} ->
      {prep, code} = generate_from_ast{body}
      the_macros = eval{prep + ";(" + code + ")"}
      #splice{*[...]} with
         items{the_macros} each {k, v} ->
            #declare_raw{#symbol{k} &: {env = env}, #macro{v}}

generate{source} =
   Generator{}.generate{source}

class Generator:

   constructor{interactive = false} =
      @tr = Translator{std.stdprelude}
      @env = std.stdenv.fork{}
      @interactive = interactive
      @_eval = null

   generate{source, dump = true} =
      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      var ex = std.expand{
         #top
         std.topscope
         @env.mark{stmt}
      } where stmt =
         if @interactive:
            then:
               #multi! {*args} = p
               #interactive{*args}
            else: #multi{p}
      set ex = opt.hoist{ex}
      rval = @tr.translate{ex, .stmt}
      if dump:
         then: @tr.dump_store{} + rval
         else: rval

   evaluate{source} =
      if [not @_eval]:
         file = source.url
         @_eval = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
      @_eval{@generate{source}}


