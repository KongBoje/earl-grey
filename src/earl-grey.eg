
require:
   "./location" ->
      Source, Location
      highlight_locations
      <<:
   "./lex" ->
      tokenize
   "./parse" ->
      parse
   "./translate-js" ->
      Translator
   "./stdenv" as std
   "./expand" as exp
   "./opt" as opt
   "./util" -> Body
   vm, module, path
   "6to5" as to5
   ;; traceur as to5
   "source-map" as smap ->
      SourceNode
   "multi-stage-sourcemap" -> transfer

provide:
   evaluator
   Source, Location, highlight_locations
   tokenize, parse
   Generator, generate
   version

version = "zero"

evaluator{match options} =

   when module._nodeModulePaths ->
      paths = module._nodeModulePaths{options.cwd}

      e_module = new module{options.showname}
      e_module &: {
         filename = options.filename
         paths = paths
      }

      e_require{path} =
         module._load{path, e_module, true}
      e_require &: {
         main = e_module
         resolve{path} =
            module._resolveFileName{path, e_module}
         paths = paths
         cache = require.cache
      }

      save = {
         __filename = global.__filename
         __dirname = global.__dirname
         module = global.module
         require = global.require
         exports = global.exports
      }

      setup = {
         __filename = options.filename
         __dirname = path.dirname{options.filename}
         module = e_module
         require = e_require
         exports = {=}
      }

      {code} ->
         global &: setup
         script = vm.createScript{code, options.showname}
         rval = script.runInThisContext{}
         global &: save
         rval

   else ->
      __eval = eval
      {code} -> __eval{code}


class Pipeline:

   constructor{} =
      @_expander = std.make_expander{@}
      @env = @_expander.mkenv{}

   parse{source} =
      t = tokenize{source}
      parse{t}

   expand{ast} =
      @_expander.expand{#top, exp.topscope, @env.mark{ast}}

   translate{ast} =
      res = opt.hoist{ast}
      tr = Translator{}
      rval = collapse{tr.translate{res, .expr}}
      prep = tr.dump_store{}
      {
         ;; code = to5.compile{r, {}}
         {=> code} = to5.transform{r}
         location = ast.location
      } where
         r = prep + ";(" + rval + ")"

   evaluate{src} =
      loc = src.location or {source = {url = "<eval>"}}
      ev{src.code} where
         ev = evaluator with {
            filename = loc.source.url
            showname = loc.source.url
            cwd = loc.source.url
         }

   go{x, match start, end} =
      when start === end or start === .eval ->
         x
      .source ->
         @go{@parse{x}, .parse, end}
      .parse ->
         @go{@expand{x}, .expand, end}
      .expand ->
         @go{@translate{x}, .translate, end}
      .translate ->
         @go{@evaluate{x}, .eval, end}
      else ->
         throw E.pipeline{"Unknown pipeline stage: " + start}


generate{source} =
   Generator{}.generate{source}


collapse{match node} =
   Node? {=> tags, => props, => children} ->
      parts = {}
      acc{children} where acc{match} =
         String? s -> parts.push with s
         Array? [each x] -> acc{x}
         Node? n -> parts.push with collapse{n}
      parts.join{""}
   String? s ->
      s
   else ->
      print node
      throw E.invalid_translation_node{node}

makeAnnotatedAST{match node} =
   Node? {=> tags, => props, => children} ->
      parts = {}
      acc{children} where acc{match} =
         String? s -> parts.push with s
         Array? [each x] -> acc{x}
         Node? n -> parts.push with makeAnnotatedAST{n}

      if props.origin and props.origin.location:
         loc = props.origin.location
         {{var l, var c}, _} = loc.linecol{}
         src = loc.source.url
         rval = new SourceNode{l, c, src or "<unknown>", parts}
         ;; print {l, c, loc.text{}, rval.toStringWithSourceMap{{=}}.code}
         rval
      else:
         parts
   String? s ->
      s
   else ->
      print node
      throw E.invalid_translation_node{node}

toCodeAndSourceMap{node, url} =
   var ast = makeAnnotatedAST{node}
   if not SourceNode? ast:
      ast = new SourceNode{1, 0, null, ast}
   obj = ast.toStringWithSourceMap with {file = url}
   obj


class Generator:

   constructor{interactive = false} =
      @tr = Translator{}
      @env = std.stdenv.fork{}
      @interactive = interactive
      @_eval = null
      @pipeline = Pipeline{}
      @expander = std.make_expander{@pipeline}

   generateInteractive{source, opts} =
      opts = {noboil = @interactive, to5 = false} & opts

      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      var ex = @expander.expand{
         #top
         exp.topscope
         @env.mark{stmt}
      } where stmt =
         if @interactive:
            then:
               Body! {*args} = p
               #interactive{*args}
            else: #multi{p}

      wrap{body} =
         #send{#variable{.spawn}, #array{#lambda{{}, body, #value{true}}}}

      ex = match ex:
         #scope{vars, body} ->
            #scope{vars, wrap{body}}
         body ->
            wrap{body}

      set ex = opt.hoist{ex}
      var result = @tr.translate{ex, .stmt}
      result = splice %
         "\n'use strict';"
         ;; if{opts.to5, "require('traceur-runtime');", ""}
         if{opts.to5, "require('6to5/polyfill');", ""}
         "require('earlgrey-runtime');"
         result
      result = collapse{result}

      if opts.to5:
         result = to5.transform{result, {=}}.code
         ;; result = to5.compile{result, {=}}

      result


   generate{source, opts} =
      opts = {noboil = @interactive, to5 = true} & opts

      t = tokenize{source}
      p = parse{t}
      ;; #interactive forces declarations into the top scope, which
      ;; means successive calls to generate{} will see global
      ;; variables set by the previous. It also makes all variables
      ;; declared in the top scope mutable (because that's more
      ;; practical in interactive mode)
      var ex = @expander.expand{
         #top
         exp.topscope
         @env.mark{stmt}
      } where stmt =
         if @interactive:
            then:
               Body! {*args} = p
               #interactive{*args}
            else: #multi{p}
      set ex = opt.hoist{ex}
      ;; set ex = opt.eliminate_spurious_variables{ex}

      var result = @tr.translate{ex, .stmt}
      if not opts.noboil:
         result = splice %
            "\n'use strict';"
            ;; if{opts.to5, "require('traceur-runtime');", ""}
            if{opts.to5, "require('6to5/polyfill');", ""}
            "require('earlgrey-runtime');"
            @tr.dump_store{} ;; useless at this point I think
            result

      if not opts.sourceMap:
         result = collapse{result}
         if opts.to5:
            result = to5.transform{result, {=}}.code
            ;; result = to5.compile{result, {=}}
         {code = result, map = null}

      else:

         result = toCodeAndSourceMap{result, source.url}

         if opts.to5:
            ;; nc = new to5.NodeCompiler{{sourceMaps = .file}}
            ;; code = nc.compile{result.code, source.url}
            ;; newmap = transfer with {
            ;;    fromSourceMap = nc.getSourceMap{}.toString{}
            ;;    toSourceMap = result.map.toString{}
            ;; }

            {=> code, => map} = to5.transform{result.code, {sourceMap = true}}
            newmap = transfer with {
               fromSourceMap = map
               toSourceMap = result.map.toString{}
            }

            result = {code = code, map = newmap}

         ;; if opts.to5:
         ;;    result.code =
         ;;       "require('traceur-runtime');" + result.code

         match opts.sourceMap:
            .inline ->
               result.code
                  \ + "\n/"+"/# sourceMappingURL=data:application/json;base64,"
                  \ + [new Buffer{result.map.toString{}}.toString{.base64}]
                  \ + ".map\n"
            else ->
               parts = source.url.split{"/"}
               smname = parts[parts.length - 1].replace{R".eg$", ".js"}
               result.code +=
                  "\n/" + "/# sourceMappingURL=" + smname + ".map\n"
               result


   evaluate{source} =
      if [not @_eval]:
         file = source.url
         @_eval = evaluator with {
            filename = file
            showname = file
            cwd = file
         }
      @_eval{@generate{source}}
