
<!DOCTYPE html>
<html>
  <head>
    <title>Earl Grey documentation</title>
    <meta http-equiv="Content-type" content="text/html" charset="UTF-8"><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans|Mate+SC|Mate+SC"><link rel="stylesheet" type="text/css" href="resources/look-nice/nav.css"><link rel="stylesheet" type="text/css" href="resources/look-nice/side.css"><script type="text/javascript" src="resources/look-nice/toc-scroll.js"></script><link rel="stylesheet" type="text/css" href="resources/look-nice/main.css"><script type="text/javascript" src="resources/look-nice/nav.js"></script><link rel="stylesheet" type="text/css" href="resources/style/highlight/xcode.css"><link rel="stylesheet" type="text/css" href="resources/style.css"></head>
  <body>

<div class="nav-container-desktop"><nav id="nav-leftmost" class="nav-leftmost"><ul></ul></nav><nav id="nav-main" class="nav-main"><ul><li><a href="/earl-grey/index.html"><div id="logo"><img src="/earl-grey/assets/earlgrey-text.svg" alt="Earl Grey" title="" height="60px" width="284px"></div></a></li><li>
  <li class="spacer0"></li></li><li class="dropdown"><a href="/earl-grey/use.html">learn</a><ul class="dropdown-menu"><li><a href="/earl-grey/use.html">Install</a></li><li><a href="/earl-grey/doc.html">Documentation</a></li><li><a href="/earl-grey/tooling.html">Tooling</a></li><li><a href="/earl-grey/contrib.html">Contribute</a></li></ul></li><li><a href="/earl-grey/repl.html">try it!</a></li><li>
  <li class="spacer"></li></li><li><a href="https://github.com/breuleux/earl-grey" class="github-badge"><img src="/earl-grey/assets/github.png" alt="breuleux/earl-grey on GitHub" title="breuleux/earl-grey" height="32px"></a></li><li><a href="https://twitter.com/earlgreylang" class="twitter-badge"><img src="/earl-grey/assets/twitter.png" alt="@earlgreylang" title="@earlgreylang" height="50px"></a></li></ul></nav><nav id="nav-rightmost" class="nav-rightmost"><ul></ul></nav></div><div class="nav-container-mobile"><nav class="nav-mobile-menu dropdown"><div class="hamburger"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></div><ul><li><a href="/earl-grey/index.html">home</a></li><li class="dropdown"><a href="/earl-grey/use.html">learn</a><ul class="dropdown-menu"><li><a href="/earl-grey/use.html">Install</a></li><li><a href="/earl-grey/doc.html">Documentation</a></li><li><a href="/earl-grey/tooling.html">Tooling</a></li><li><a href="/earl-grey/contrib.html">Contribute</a></li></ul></li><li><a href="/earl-grey/repl.html">try it!</a></li></ul></nav><nav id="nav-mobile" class="nav-mobile"><ul><li><a href="/earl-grey/index.html"><div id="logo"><img src="/earl-grey/assets/earlgrey-text.svg" alt="Earl Grey" title="" height="60px" width="284px"></div></a></li></ul></nav></div><div id="side"><nav id="nav-side" class="nav-side"><ul><li>
  <ul class="toc"><li><a href="#basicsyntax">Basic syntax</a><ul><li><a href="#comments">Comments</a></li><li><a href="#blocks">Blocks</a></li><li><a href="#variables">Variables</a><ul><li><a href="#globalvariables">Global variables</a></li></ul></li><li><a href="#data">Data</a><ul><li><a href="#strings">Strings</a></li><li><a href="#interpolatedstrings">Interpolated strings</a></li><li><a href="#numbers">Numbers</a></li><li><a href="#arraysandobjects">Arrays and objects</a></li></ul></li><li><a href="#functions">Functions</a><ul><li><a href="#splicing">Splicing</a></li><li><a href="#declaringfunctions">Declaring functions</a></li><li><a href="#redeclaringoperators">(Re-)declaring operators</a></li></ul></li><li><a href="#ifandwhile">if and while</a></li><li><a href="#looping">Looping</a><ul><li><a href="#each">each</a></li></ul></li></ul></li><li><a href="#patternmatching">Pattern matching</a><ul><li><a href="#checkers">Checkers</a></li><li><a href="#projectors">Projectors</a></li><li><a href="#inlineprojectors">Inline projectors</a></li><li><a href="#destructuring">Destructuring</a></li><li><a href="#destructuringobjects">Destructuring objects</a></li><li><a href="#when">when</a></li><li><a href="#or">or</a></li><li><a href="#and">and</a></li><li><a href="#operators">Operators</a></li><li><a href="#embeddedcontrolstructures">Embedded control structures</a></li><li><a href="#is">is</a></li><li><a href="#assignmentwrappers">Assignment wrappers</a></li></ul></li><li><a href="#asynchronouscode">Asynchronous code</a><ul><li><a href="#generators">Generators</a></li><li><a href="#promisesandasyncawait">Promises and async/await</a></li></ul></li><li><a href="#classes">Classes</a><ul><li><a href="#defining">Defining</a></li><li><a href="#instantiating">Instantiating</a></li><li><a href="#subclassing">Subclassing</a></li><li><a href="#staticmethods">Static methods</a></li><li><a href="#specialmethods">Special methods</a></li><li><a href="#todo">TODO</a></li></ul></li><li><a href="#miscellaneous">Miscellaneous</a><ul><li><a href="#chain">chain</a></li><li><a href="#regularexpressions">Regular expressions</a></li><li><a href="#errorsandexceptions">Errors and exceptions</a></li></ul></li><li><a href="#modulesystem">Module system</a><ul><li><a href="#require"><code class="hlinline">require</code></a></li><li><a href="#provide"><code class="hlinline">provide</code></a></li><li><a href="#inject"><code class="hlinline">inject</code></a></li><li><a href="#requiremacros"><code class="hlinline">require-macros</code></a></li></ul></li><li><a href="#documentbuildingsyntax">Document-building syntax</a></li><li><a href="#macros">Macros</a><ul><li><a href="#invariants">Invariants</a></li><li><a href="#quote">quote</a></li><li><a href="#inlinemacro">inline-macro</a></li><li><a href="#macro">macro</a><ul><li><a href="#dependencies">Dependencies</a></li></ul></li><li><a href="#hygiene">Hygiene</a><ul><li><a href="#capturingnames">Capturing names</a></li></ul></li></ul></li></ul></li></ul></nav></div>
<div class="container">

















<script>document.querySelector("#nav-main > ul > :nth-child(4)").className = "dropdown curnav"</script>

<h1 id="basicsyntax">Basic syntax</h1>

<h2 id="comments">Comments</h2>

<p>Comments must be prefixed with two semicolons and go until the end of
the line.</p>

<pre class="hljs"><span class="hljs-comment">;; This is a comment.</span></pre>


<h2 id="blocks">Blocks</h2>

<p>Indent groups statements in Earl Grey. Alternatively, you can use
square <code class="hlinline">[]</code> brackets:</p>

<pre class="hljs">hello
   superb
   world</pre>

<p>is equivalent to:</p>

<pre class="hljs">hello<span class="hljs-punctuation">[</span>superb<span class="hljs-punctuation">;</span> world<span class="hljs-punctuation">]</span></pre>

<p>It is recommended to use indent to denote blocks, so you will not use
square brackets much in practice. Just be aware that the expression
<code class="hlinline">[a]</code> is equivalent to plain <code class="hlinline">a</code>, and <code class="hlinline">[a, b, c]</code> is going to return
<code class="hlinline">c</code> (commas and semi-colons are equivalent in EG).</p>

<p>Save for indented blocks, <em>all</em> line breaks are semi-colons in Earl
Grey. There is <em>no</em> implicit line continuation. This being said, you
can break a statement over multiple lines by <em>prefixing</em> continuating
lines with <code class="hlinline">\ </code>:</p>

<pre class="hljs">a
\ <span class="hljs-operator">+</span> b
\ <span class="hljs-operator">+</span> c</pre>

<p>is equivalent to:</p>

<pre class="hljs">a <span class="hljs-operator">+</span> b <span class="hljs-operator">+</span> c</pre>

<p>Be aware that indent isn't going to work for this: replacing the
backslashes with indent will yield <code class="hlinline">a[+ b; + c]</code>.</p>


<h2 id="variables">Variables</h2>

<p>Variables can be declared as mutable or immutable</p>

<pre class="hljs"><span class="hljs-keyword">var </span>x <span class="hljs-operator">=</span> <span class="hljs-number">123</span>        <span class="hljs-comment">;; mutable variable</span>
<span class="hljs-keyword">let </span>y <span class="hljs-operator">=</span> <span class="hljs-string">"hello"</span>    <span class="hljs-comment">;; const variable (immutable)</span></pre>

<p>Hyphens are allowed inside variable names. This is valid:</p>

<pre class="hljs"><span class="hljs-keyword">var </span>my-variable <span class="hljs-operator">=</span> <span class="hljs-number">1234</span></pre>

<p>Scoping is lexical: variables declared in a block are only valid in
that block.</p>

<p>If you simply write:</p>

<pre class="hljs">x <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span></pre>

<p>Then what happens depends on whether a variable called <code class="hlinline">x</code> already
exists in scope.</p>

<ul><li>It <strong>exists</strong> and is <strong>mutable</strong>: the variable is modified.</li>
<li>It <strong>exists</strong> and is <strong>immutable</strong>: compile time error.</li>
<li>It <strong>does not exist</strong>: it is declared in the current block as <em>immutable</em>.</li></ul>

<p>This means that most of the time you can declare variables without the
<code class="hlinline">let</code> keyword, assuming they don't already exist. You only need <code class="hlinline">let</code>
if you are shadowing an existing variable. I recommend only using
<code class="hlinline">var</code> if absolutely necessary -- if you follow that advice it is
basically impossible to make scoping errors.</p>

<p>Note that the <code class="hlinline">var</code> and <code class="hlinline">let</code> keywords can be used inside
patterns. For instance:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-keyword">var </span><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">let </span>z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>   <span class="hljs-comment">;; x and y are mutable; z isn't</span></pre>

<p>The <strong><code class="hlinline">where</code></strong> statement is another alternative to declare variables
local to single expressions. Here's a funny example:</p>

<pre class="hljs">x <span class="hljs-operator">+</span> y <span class="hljs-wordop">where</span>
   x <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
   y <span class="hljs-operator">=</span> <span class="hljs-number">200</span>
   x <span class="hljs-operator">+</span> y <span class="hljs-operator">=</span> x <span class="hljs-operator">-</span> y
<span class="hljs-comment">;; ==&gt; -100</span></pre>

<p>(Yes, you can do that)</p>

<h3 id="globalvariables">Global variables</h3>

<p>Global variables need to be declared to be accessible:</p>

<pre class="hljs"><span class="hljs-keyword">globals</span><span class="hljs-punctuation">:</span>
   document<span class="hljs-punctuation">,</span> google<span class="hljs-punctuation">,</span> React</pre>


<h2 id="data">Data</h2>

<h3 id="strings">Strings</h3>

<p>Use double quotes:</p>

<pre class="hljs"><span class="hljs-string">"this is a string"</span>
<span class="hljs-string">"Escape \" with a backslash"</span>
<span class="hljs-string">'single-quoted strings support interpolation'</span>
<span class="hljs-string">"""this is a
   "long"
   multiline string"""</span></pre>

<p>The prefix dot operator creates strings as well, but only if the
string represents a valid variable name:</p>

<pre class="hljs"><span class="hljs-string">.hello</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">"hello"</span></pre>

<p>If there are dashes in a dot-string, it is converted to camelCase:</p>

<pre class="hljs"><span class="hljs-string">.hello-world</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">"helloWorld"</span></pre>

<p>This means that if you write a method call with dashes, for instance
<code class="hlinline">document.get-element-by-id("some-id")</code>, it will compile to
<code class="hlinline">document.getElementById("some-id")</code>. You have the choice of either
notation.</p>


<h3 id="interpolatedstrings">Interpolated strings</h3>

<p>Single quotes are interpolated.</p>

<pre class="hljs">n <span class="hljs-operator">=</span> <span class="hljs-number">3</span>
<span class="hljs-keyword">print </span><span class="hljs-string">'there are {n} little piggies'</span>
<span class="hljs-comment">;; ==&gt; there are 3 little piggies</span></pre>

<h3 id="numbers">Numbers</h3>

<pre class="hljs"><span class="hljs-number">123</span>                <span class="hljs-comment">;; decimal</span>
<span class="hljs-number">16rDEADBEEF</span>        <span class="hljs-comment">;; hex</span>
<span class="hljs-number">2r100101011.101</span>    <span class="hljs-comment">;; binary</span></pre>

<h3 id="arraysandobjects">Arrays and objects</h3>

<p>Both arrays and object literals are defined with curly braces:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>            <span class="hljs-comment">;; an array</span>
<span class="hljs-punctuation">{</span>a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>       <span class="hljs-comment">;; an object</span>
<span class="hljs-punctuation">{</span><span class="hljs-string">"a"</span> <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"b"</span> <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span> <span class="hljs-comment">;; the same object</span></pre>

<p>You can also "mix" the notations:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> a <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> b <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-punctuation">}</span> <span class="hljs-comment">;; an array with fields named a and b</span></pre>

<p><strong>Empty data structures</strong> are denoted as follows:</p>

<pre class="hljs">empty-array  <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
empty-object <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-operator">=</span><span class="hljs-punctuation">}</span></pre>


<h2 id="functions">Functions</h2>

<p>There are several different, but equivalent notations to call functions:</p>

<pre class="hljs">func<span class="hljs-punctuation">(</span>arg1<span class="hljs-punctuation">,</span> arg2<span class="hljs-punctuation">)</span>           <span class="hljs-comment">;; the usual notation</span>
func<span class="hljs-punctuation">{</span>arg1<span class="hljs-punctuation">,</span> arg2<span class="hljs-punctuation">}</span>           <span class="hljs-comment">;; curly bracket notation</span>
func<span class="hljs-punctuation">(</span>arg1<span class="hljs-punctuation">)</span> <span class="hljs-wordop">with</span> arg2       <span class="hljs-comment">;; with-notation</span>
func<span class="hljs-punctuation">(</span>___<span class="hljs-punctuation">,</span> arg2<span class="hljs-punctuation">)</span> <span class="hljs-wordop">with</span> arg1  <span class="hljs-comment">;; with-notation (using placeholder)</span>
func <span class="hljs-wordop">with</span> arg              <span class="hljs-comment">;; with-notation (single argument)</span></pre>

<p>The with-notation can be used to increase readability. For instance:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-string">.map</span><span class="hljs-punctuation">(</span>x <span class="hljs-operator">-&gt;</span> x <span class="hljs-operator">*</span> x<span class="hljs-punctuation">)</span>
<span class="hljs-operator">&lt;=&gt;</span>
<span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-string">.map</span> <span class="hljs-wordop">with</span> x <span class="hljs-operator">-&gt;</span>
   x <span class="hljs-operator">*</span> x</pre>

<p>The gains are most visible when the body of the function is large.</p>


<h3 id="splicing">Splicing</h3>

<p>You can apply a function to a list of arguments using the <code class="hlinline">*</code>
splicing operator, <code class="hlinline">[]</code>, or simple juxtaposition:</p>

<pre class="hljs">args <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>
func<span class="hljs-punctuation">(</span><span class="hljs-operator">*</span>args<span class="hljs-punctuation">)</span> <span class="hljs-operator">&lt;=&gt;</span> func<span class="hljs-punctuation">[</span>args<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;=&gt;</span> <span class="hljs-keyword">func </span>args</pre>

<p>EG considers function application to be a special case of indexing
where the index is a list of arguments, hence why the above works.</p>

<h3 id="declaringfunctions">Declaring functions</h3>

<pre class="hljs">square<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   x <span class="hljs-operator">*</span> x

square <span class="hljs-operator">=</span> x <span class="hljs-operator">-&gt;</span> x <span class="hljs-operator">*</span> x</pre>

<p>The notation also works inside an object:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> mul<span class="hljs-punctuation">(</span>b<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> this<span class="hljs-string">.a</span> <span class="hljs-operator">*</span> b<span class="hljs-punctuation">}</span><span class="hljs-string">.mul</span><span class="hljs-punctuation">(</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; =&gt; 200</span></pre>

<p>There is no need to <code class="hlinline">return</code> from a function (although you can). The
last evaluated expression is used as the return value.</p>

<h3 id="redeclaringoperators">(Re-)declaring operators</h3>

<p>Operator applications in EG, such as <code class="hlinline">a + b</code>, desugar to the function
call <code class="hlinline">[+]{a, b}</code>. You can thus redefine almost any operator locally:</p>

<pre class="hljs">bizarro<span class="hljs-punctuation">(</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-keyword">let </span>x <span class="hljs-operator">+</span> y <span class="hljs-operator">=</span> outer<span class="hljs-punctuation">{</span><span class="hljs-operator">+</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span>
   <span class="hljs-keyword">let </span>x <span class="hljs-operator">-</span> y <span class="hljs-operator">=</span> outer<span class="hljs-punctuation">{</span><span class="hljs-operator">-</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span>
   a <span class="hljs-operator">+</span> b <span class="hljs-operator">-</span> c
bizarro<span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span>  <span class="hljs-comment">;; ==&gt; 0</span></pre>

<div class="note">
  <ul><li><code class="hlinline">let</code> must be used in order to shadow the existing bindings.</li>
  <li><code class="hlinline">outer</code> returns the previous binding of a variable, which is
    necessary above to avoid unwanted mutual recursion.</li>
  <li>The curly braces notation must be used because <code class="hlinline">outer</code>, <code class="hlinline">+</code> and <code class="hlinline">-</code>
    are macros and <code class="hlinline">()</code> cannot be used to provide macro arguments.</li></ul></div>


<h2 id="ifandwhile">if and while</h2>


<p><strong>If statements</strong> are written as they are in Python:</p>

<pre class="hljs"><span class="hljs-keyword">if </span>x <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span><span class="hljs-punctuation">:</span>
   do_something<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
<span class="hljs-keyword">elif </span>x <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><span class="hljs-punctuation">:</span>
   do_something_else<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
<span class="hljs-keyword">else</span><span class="hljs-punctuation">:</span>
   flail_incoherently<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span></pre>

<p><code class="hlinline">if</code> can also be written as an expression. It's not a ternary operator
because I honestly don't think it's worth tweaking syntax for:</p>

<pre class="hljs">if<span class="hljs-punctuation">{</span>x <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> x<span class="hljs-punctuation">}</span></pre>


<p><strong>While statements</strong>, again, look like Python's:</p>

<pre class="hljs"><span class="hljs-keyword">var </span>i <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
<span class="hljs-keyword">while </span>i <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>i
   i<span class="hljs-operator">--</span></pre>

<p>If you want to give a label to a <code class="hlinline">while</code> loop (or to <em>any</em> loop), you
need to use <code class="hlinline">while.label</code>, just like this:</p>

<pre class="hljs"><span class="hljs-keyword">var </span>i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
while<span class="hljs-string">.outer</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">var </span>j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
   while<span class="hljs-string">.inner</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">:</span>
      <span class="hljs-keyword">if </span>i <span class="hljs-operator">*</span> j <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-punctuation">:</span>
         <span class="hljs-keyword">break </span>outer  <span class="hljs-comment">;; this will break out of both while loops!</span>
      j<span class="hljs-operator">++</span>
   i<span class="hljs-operator">++</span></pre>


<h2 id="looping">Looping</h2>

<p>EG defines <code class="hlinline">for</code> statements that are a cross between JavaScript's
semantics and Python's syntax, which means that it comes in three
flavors:</p>

<pre class="hljs"><span class="hljs-keyword">for </span><span class="hljs-punctuation">(</span><span class="hljs-keyword">var </span>i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">;</span> i <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span><span class="hljs-punctuation">;</span> i<span class="hljs-operator">++</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>i

<span class="hljs-keyword">for </span>key <span class="hljs-operator">in</span> object<span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>key

<span class="hljs-keyword">for </span>element <span class="hljs-operator">of</span> iterable<span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>element</pre>
They work like you'd expect (with one little gotcha*). I'm telling you
about them because you are free to use what you see fit, but in my
opinion, <strong><code class="hlinline">for</code> should not be used</strong>:

<div class="warning"><p>
  *Earl Grey parses commas and semicolons as essentially the same, so
  this will not work:</p>

  <pre class="hljs"><span class="hljs-keyword">for </span><span class="hljs-punctuation">(</span><span class="hljs-keyword">var </span>i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">var </span>j <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">;</span> i <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span><span class="hljs-punctuation">;</span> i<span class="hljs-operator">++</span><span class="hljs-punctuation">,</span> j<span class="hljs-operator">++</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>i <span class="hljs-operator">+</span> j</pre>

  <p>EG will think the first comma is a semicolon. Here's a valid
  alternative:</p>

  <pre class="hljs"><span class="hljs-keyword">for </span><span class="hljs-punctuation">(</span><span class="hljs-keyword">var </span><span class="hljs-punctuation">{</span>i<span class="hljs-punctuation">,</span> j<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">;</span> i <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span><span class="hljs-punctuation">;</span> <span class="hljs-punctuation">(</span>i<span class="hljs-operator">++</span><span class="hljs-punctuation">;</span> j<span class="hljs-operator">++</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span>i <span class="hljs-operator">+</span> j</pre></div>


<h3 id="each">each</h3>

<p>EG's <strong><code class="hlinline">each</code></strong> operator should be used instead of <code class="hlinline">for</code>, either as a
statement:</p>

<pre class="hljs"><span class="hljs-number">1</span><span class="hljs-operator">..</span><span class="hljs-number">10</span> <span class="hljs-wordop">each</span> i <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">print </span>i <span class="hljs-operator">*</span> i</pre>

<p>or as an expression:</p>

<pre class="hljs">squares <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-operator">..</span><span class="hljs-number">10</span> <span class="hljs-wordop">each</span> i <span class="hljs-operator">-&gt;</span> i <span class="hljs-operator">*</span> i</pre>

<p><code class="hlinline">each</code> in a statement position compiles to a straight <code class="hlinline">for..of</code> loop, so
it's no less efficient. In expression position, it acts as an array
comprehension.</p>

<p>Besides doubling up as array comprehensions, what makes <code class="hlinline">each</code> a useful
looping method is that it makes use of EG's built-in pattern matcher:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">13</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"car"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"tramway"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">517</span><span class="hljs-punctuation">}</span> <span class="hljs-wordop">each</span>
   Number<span class="hljs-operator">?</span> n <span class="hljs-operator">-&gt;</span> n <span class="hljs-operator">+</span> <span class="hljs-number">1</span>
   String<span class="hljs-operator">?</span> s <span class="hljs-operator">-&gt;</span> s <span class="hljs-operator">+</span> <span class="hljs-string">"s"</span>
   <span class="hljs-keyword">else</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">throw </span>E<span class="hljs-string">.unknown</span><span class="hljs-punctuation">(</span><span class="hljs-string">"I don't know."</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; ==&gt; {14, "cars", "tramways", 518}</span></pre>

<p>You can also use <code class="hlinline">when</code> to filter data:</p>

<pre class="hljs"><span class="hljs-number">1</span><span class="hljs-operator">..</span><span class="hljs-number">10</span> <span class="hljs-wordop">each</span> i <span class="hljs-wordop">when</span> i <span class="hljs-wordop">mod</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-operator">-&gt;</span> i
<span class="hljs-comment">;; ==&gt; {2, 4, 6, 8, 10}</span></pre>

<p><code class="hlinline">break</code> and <code class="hlinline">continue</code> work with <code class="hlinline">each</code>:</p>

<ul><li><code class="hlinline">break</code> stops the comprehension. It is the only way to halt
  iteration before the end of the sequence.</li>
<li><code class="hlinline">continue</code> starts the next iteration but without accumulating a
  value. You can use it as an alternative way to filter.</li></ul>

<pre class="hljs"><span class="hljs-number">1</span><span class="hljs-operator">..</span><span class="hljs-number">100</span> <span class="hljs-wordop">each</span> i <span class="hljs-operator">-&gt;</span>
   <span class="hljs-keyword">if </span>i <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span><span class="hljs-punctuation">:</span>
      <span class="hljs-keyword">break</span>
   <span class="hljs-keyword">elif </span>i <span class="hljs-wordop">mod</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">:</span>
      i
   <span class="hljs-keyword">else</span><span class="hljs-punctuation">:</span>
      <span class="hljs-keyword">continue</span>
<span class="hljs-comment">;; ==&gt; {2, 4, 6, 8, 10}</span></pre>

<p>When using pattern matching with <code class="hlinline">each</code>, EG will throw an exception if
a value does not match any of the patterns <em>unless</em> the last pattern
contains a <code class="hlinline">when</code> clause. In other words:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"x"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span> <span class="hljs-wordop">each</span>
   Number<span class="hljs-operator">?</span> n <span class="hljs-operator">-&gt;</span> n            <span class="hljs-comment">;; ERROR! "x" does not match</span></pre>

<p>But these expressions will not throw exceptions:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"x"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span> <span class="hljs-wordop">each</span>
   n <span class="hljs-wordop">when</span> Number<span class="hljs-operator">?</span> n <span class="hljs-operator">-&gt;</span> n     <span class="hljs-comment">;; ==&gt; {1, 2, 3}</span>

<span class="hljs-punctuation">{</span><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">4</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">6</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-wordop">each</span>
   <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span> <span class="hljs-wordop">when</span> true <span class="hljs-operator">-&gt;</span> x <span class="hljs-operator">+</span> y <span class="hljs-comment">;; ==&gt; {5, 11}</span>

<span class="hljs-punctuation">{</span><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">4</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">6</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-wordop">each</span>
   <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> x <span class="hljs-operator">+</span> y
   <span class="hljs-keyword">else</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">continue</span>          <span class="hljs-comment">;; ==&gt; {5, 11}</span></pre>

<p>The first form is recommended if it is easy to express the condition
as an expression. However, some filters are best expressed by
patterns, in which case the third form would be preferred (because it
is less confusing -- you can use the second form if you insist on
writing a one-liner, though).</p>

<p><code class="hlinline">each</code> is <em>eager</em>: it will iterate over all elements and execute the
payload on each, returning an array. The <em>lazy</em> version of <code class="hlinline">each</code> is the
<code class="hlinline">each*</code> operator.</p>


<h1 id="patternmatching">Pattern matching</h1>

<p>The <code class="hlinline">match</code> operator feeds an input into a series of "clauses" and
enters the body of the first matching clause. In a clause, one can
check the type of a value, cast or transform it, deconstruct an array
into elements and bind them to variables, and more:</p>

<pre class="hljs"><span class="hljs-keyword">match </span>command:
   <span class="hljs-punctuation">{</span><span class="hljs-string">"move"</span><span class="hljs-punctuation">,</span> Number<span class="hljs-operator">!</span> dx<span class="hljs-punctuation">,</span> Number<span class="hljs-operator">!</span> dy<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-comment">;; Isn't this nicer than calling parseFloat manually?</span>
      this<span class="hljs-string">.x</span> <span class="hljs-operator">+=</span> dx
      this<span class="hljs-string">.y</span> <span class="hljs-operator">+=</span> dy
   <span class="hljs-punctuation">{</span><span class="hljs-string">"rest"</span><span class="hljs-punctuation">,</span> Number<span class="hljs-operator">!</span> nhours<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      this<span class="hljs-string">.hp</span> <span class="hljs-operator">+=</span> nhours
   <span class="hljs-punctuation">{</span><span class="hljs-string">"attack"</span><span class="hljs-punctuation">,</span> Grue<span class="hljs-operator">?</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-comment">;; We can special-case commands but they have to come before</span>
      <span class="hljs-comment">;; the generic version.</span>
      this<span class="hljs-string">.die-horribly</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
   <span class="hljs-punctuation">{</span><span class="hljs-string">"attack"</span><span class="hljs-punctuation">,</span> enemy<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      enemy<span class="hljs-string">.hp</span> <span class="hljs-operator">-=</span> this<span class="hljs-string">.attack</span>
      this<span class="hljs-string">.hp</span> <span class="hljs-operator">-=</span> enemy<span class="hljs-string">.attack</span></pre>

<p>A pattern can also be found on the left side of a declaration or
assignment, for example:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>String<span class="hljs-operator">?</span> x<span class="hljs-punctuation">,</span> Number<span class="hljs-operator">?</span> y<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-string">"apple"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3.14159</span><span class="hljs-punctuation">}</span></pre>


<h3 id="checkers">Checkers</h3>

<p>A <strong>checker</strong> verifies that the thing to match satisfies some predicate,
for instance that it is of a certain type.</p>

<pre class="hljs">Number<span class="hljs-operator">?</span> n <span class="hljs-operator">=</span> <span class="hljs-number">123</span>     <span class="hljs-comment">;; OK</span>
Number<span class="hljs-operator">?</span> n <span class="hljs-operator">=</span> <span class="hljs-string">"hello"</span> <span class="hljs-comment">;; ERROR</span></pre>


<h3 id="projectors">Projectors</h3>

<p>A <strong>projector</strong> transforms the thing to match, for instance it casts
it to a certain type or applies some kind of transformation. Further
pattern matching can be applied on the transformed value.</p>

<pre class="hljs">Number<span class="hljs-operator">!</span> n <span class="hljs-operator">=</span> <span class="hljs-string">"123"</span>          <span class="hljs-comment">;; n is the number 123</span>
Array<span class="hljs-operator">!</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>               <span class="hljs-comment">;; a is the array {5}</span>
Array<span class="hljs-operator">!</span> <span class="hljs-punctuation">{</span>Number<span class="hljs-operator">!</span> a<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-string">"10"</span>  <span class="hljs-comment">;; a is the number 10</span></pre>

<p><strong>Important</strong>: Projectors are applied <strong>left to right</strong>. This could be a
bit counter-intuitive sometimes, so let me give you clear examples
that you can use as reference:</p>

<pre class="hljs">add-one<span class="hljs-operator">!</span> multiply-by-two<span class="hljs-operator">!</span> x <span class="hljs-operator">=</span> <span class="hljs-number">10</span>   <span class="hljs-comment">;; x is ((10 + 1) * 2) = 22</span>
multiply-by-two<span class="hljs-operator">!</span> add-one<span class="hljs-operator">!</span> x <span class="hljs-operator">=</span> <span class="hljs-number">10</span>   <span class="hljs-comment">;; x is ((10 * 2) + 1) = 21</span></pre>

<p>Projectors also work on functions, where they are quite useful. For
example:</p>

<pre class="hljs">curry<span class="hljs-operator">!</span> f<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> x <span class="hljs-operator">+</span> y</pre>

<p>They can also save you some typing if you use them on function
arguments. If you wanted to implement a <code class="hlinline">save-all</code> function that works
on an array of files, but also on a single file, you could write:</p>

<pre class="hljs">save-all<span class="hljs-punctuation">(</span>Array<span class="hljs-operator">!</span> files<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   files <span class="hljs-wordop">each</span> file <span class="hljs-operator">-&gt;</span> file<span class="hljs-string">.save</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span></pre>

<p>instead of, say:</p>

<pre class="hljs">save-all<span class="hljs-punctuation">(</span><span class="hljs-keyword">var </span>files<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   if <span class="hljs-wordop">not</span> Array<span class="hljs-operator">?</span> files<span class="hljs-punctuation">:</span>
      files <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>files<span class="hljs-punctuation">}</span>
   files <span class="hljs-wordop">each</span> file <span class="hljs-operator">-&gt;</span> file<span class="hljs-string">.save</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span></pre>


<h3 id="inlineprojectors">Inline projectors</h3>

<p>The <code class="hlinline">&gt;&gt;</code> operator, in a pattern, transforms the match result. That
can be useful sometimes, usually in argument lists or nested patterns
where you can't simply apply the transform on the expression to the
right of the equal sign.</p>

<pre class="hljs">x <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span>x <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>    <span class="hljs-comment">;; x is 22</span>
x <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> x<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>            <span class="hljs-comment">;; x is {6, 6}</span>
x <span class="hljs-operator">&gt;&gt;</span> x<span class="hljs-string">.trim</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-string">"  xyz "</span>   <span class="hljs-comment">;; x is "xyz"</span></pre>


<h3 id="destructuring">Destructuring</h3>

<p>An array of patterns matches an array of the same length, and then
tries to match each value with the corresponding pattern:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>      <span class="hljs-comment">;; x is 1, y is 2, z is 3</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>         <span class="hljs-comment">;; ERROR</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span>y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>    <span class="hljs-comment">;; ERROR</span></pre>

<p>The <code class="hlinline">*</code> splicing operator matches any number of elements:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-operator">*</span>y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">}</span>   <span class="hljs-comment">;; x is 1, y is {2, 3, 4}, z is 5</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-operator">*</span>y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>            <span class="hljs-comment">;; x is 1, y is {}, z is 2</span></pre>

<p>You can assign a default value to a pattern in case it is missing.</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> z <span class="hljs-operator">=</span> <span class="hljs-string">"absent"</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>  <span class="hljs-comment">;; x is 1, y is 2, z is "absent"</span></pre>

<p>This also works to define default values for arguments in
functions. Note that the default value will be recomputed every time
it is needed (or not at all, if it is unneeded). For example:</p>

<pre class="hljs">f<span class="hljs-punctuation">(</span>x <span class="hljs-operator">=</span> <span class="hljs-punctuation">[</span><span class="hljs-keyword">print </span><span class="hljs-string">"missing"</span><span class="hljs-punctuation">;</span> <span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> x
f<span class="hljs-punctuation">(</span><span class="hljs-number">55</span><span class="hljs-punctuation">)</span>     <span class="hljs-comment">;; ==&gt; returns 55</span>
f<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>       <span class="hljs-comment">;; ==&gt; prints "missing", and returns 0</span>
f<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>       <span class="hljs-comment">;; ==&gt; prints "missing" *again*, and returns 0</span></pre>

<p>(remember that <code class="hlinline">stmt1; stmt2</code> executes both statements in sequence
and returns <code class="hlinline">stmt2</code>. It's not an array).</p>

<p>This means that unlike in Python, if you define an empty array <code class="hlinline">{}</code> as
a default value, it will always be a fresh array.</p>


<h3 id="destructuringobjects">Destructuring objects</h3>

<p>The <code class="hlinline">=&gt;</code> operator inside patterns lets you extract object fields.</p>

<p><code class="hlinline">=&gt; xyz</code> will extract the field named <code class="hlinline">xyz</code> into the variable <code class="hlinline">xyz</code>:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> x<span class="hljs-punctuation">,</span> <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> y<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>        <span class="hljs-comment">;; x is 1, y is 2</span></pre>

<p><code class="hlinline">xyz =&gt; abc</code> will extract the field named <code class="hlinline">xyz</code> into the variable <code class="hlinline">abc</code>:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> a<span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>    <span class="hljs-comment">;; a is 1, b is 2</span></pre>

<p>The right hand side can be a pattern. If there is no left hand side,
but that the right hand side defines a single variable, then the left
hand side is set to the name of that sole variable:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-punctuation">{</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-punctuation">{</span>y<span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-comment">;; a is 1, b is 2, y is 3</span></pre>

<p>You don't have to extract all fields:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> x<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>              <span class="hljs-comment">;; x is 1, the y field is ignored</span></pre>

<p>The unquote operator <code class="hlinline">^</code> can be used to match a dynamic key if needed:</p>

<pre class="hljs">key <span class="hljs-operator">=</span> <span class="hljs-string">"x"</span>
<span class="hljs-punctuation">{</span><span class="hljs-operator">^</span>key <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> y<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>x <span class="hljs-operator">=</span> <span class="hljs-number">66</span><span class="hljs-punctuation">}</span>               <span class="hljs-comment">;; y is 66</span></pre>



<h3 id="when">when</h3>

<p>The <strong>when</strong> operator lets you write arbitrary conditions for a
clause:</p>

<pre class="hljs"><span class="hljs-keyword">match </span>command:
   <span class="hljs-punctuation">{</span><span class="hljs-string">"move"</span><span class="hljs-punctuation">,</span> dx<span class="hljs-punctuation">,</span> dy<span class="hljs-punctuation">}</span> <span class="hljs-wordop">when</span> dx<span class="hljs-operator">*</span>dx <span class="hljs-operator">+</span> dy<span class="hljs-operator">*</span>dy <span class="hljs-operator">&gt;</span> threshold <span class="hljs-operator">-&gt;</span>
      running<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
   <span class="hljs-punctuation">{</span><span class="hljs-string">"move"</span><span class="hljs-punctuation">,</span> dx<span class="hljs-punctuation">,</span> dy<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      walking<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
   <span class="hljs-operator">...</span></pre>


<h3 id="or">or</h3>

<p><strong>or</strong> will try to match one of a series of patterns</p>

<pre class="hljs"><span class="hljs-keyword">match </span>x:
   <span class="hljs-comment">;; match 0, or 1</span>
   <span class="hljs-number">0</span> <span class="hljs-wordop">or</span> <span class="hljs-number">1</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-operator">...</span>

   <span class="hljs-comment">;; match a number or a string</span>
   Number<span class="hljs-operator">?</span> x <span class="hljs-wordop">or</span> String<span class="hljs-operator">?</span> x <span class="hljs-operator">-&gt;</span> <span class="hljs-operator">...</span>

   <span class="hljs-comment">;; will match {123} or 123, putting 123 in x in both situations</span>
   <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">}</span> <span class="hljs-wordop">or</span> x <span class="hljs-operator">-&gt;</span> <span class="hljs-operator">...</span></pre>

<p><strong>All sub-patterns must contain the same variables.</strong></p>

<p>Also, patterns are evaluated in the order they are defined, so the
most specific should come first.</p>


<h3 id="and">and</h3>

<p><strong>and</strong> will try to match every pattern (again, in order):</p>

<pre class="hljs">Number<span class="hljs-operator">?</span> n <span class="hljs-wordop">and</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">5</span>     <span class="hljs-comment">;; ERROR!</span></pre>

<p>That may not be obvious at first, but <code class="hlinline">and</code> is useful to create
aliases:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span> <span class="hljs-wordop">and</span> z <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>   <span class="hljs-comment">;; x is 1, y is 2, z is {1, 2}</span></pre>

<p>So instead of writing something like <code class="hlinline">x = y = 0</code> to initialize two
variables to zero, you should write <code class="hlinline">x and y = 0</code>.</p>


<h3 id="operators">Operators</h3>

<p><strong>Comparison operators</strong> (<code class="hlinline">== != &lt; &lt;= &gt; &gt;= in</code>) can be used partially
(except for <code class="hlinline">is</code> which has a different meaning). The left hand side is
a pattern, which will only be matched if the predicate on the current
value is true. In other words:</p>

<pre class="hljs">n <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>     <span class="hljs-comment">;; n is 10</span>
n <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">10</span>    <span class="hljs-comment">;; ERROR</span></pre>

<p>You can also leave the left hand side empty:</p>

<pre class="hljs">compare<span class="hljs-punctuation">(</span>value<span class="hljs-punctuation">,</span> threshold<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-keyword">match </span>value:
      <span class="hljs-operator">&gt;</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"above"</span>
      <span class="hljs-operator">&lt;</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"below"</span>
      <span class="hljs-operator">=</span><span class="hljs-operator">=</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"equal"</span></pre>


<h3 id="embeddedcontrolstructures">Embedded control structures</h3>

<p>The previous idiom of creating a function and matching one argument is
useful enough to have a <strong>shorthand</strong>:</p>

<pre class="hljs">compare<span class="hljs-punctuation">(</span><span class="hljs-keyword">match </span>value<span class="hljs-punctuation">,</span> threshold<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-operator">&gt;</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"above"</span>
   <span class="hljs-operator">&lt;</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"below"</span>
   <span class="hljs-operator">=</span><span class="hljs-operator">=</span> threshold <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"equal"</span></pre>

<p>Using the word <code class="hlinline">match</code> in <em>any</em> pattern will cause the body associated
to the pattern to become a list of clauses, matching in <code class="hlinline">match</code>'s
place. To illustrate:</p>

<pre class="hljs"><span class="hljs-keyword">match </span>expr: <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span>y<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span>z<span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-operator">...</span></pre>

<p>can also be written:</p>

<pre class="hljs"><span class="hljs-keyword">match </span>expr: <span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-keyword">match</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-punctuation">{</span>y<span class="hljs-punctuation">,</span> <span class="hljs-keyword">match</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-punctuation">{</span>z<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-operator">...</span></pre>

<p>Here's naive fibonacci using the shorthand:</p>

<pre class="hljs">fib<span class="hljs-punctuation">(</span><span class="hljs-keyword">match</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-number">0</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-number">0</span>
   <span class="hljs-number">1</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-number">1</span>
   n <span class="hljs-operator">-&gt;</span> fib<span class="hljs-punctuation">(</span>n <span class="hljs-operator">-</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> fib<span class="hljs-punctuation">(</span>n <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span></pre>

<p>You can give a name to the match and it will be bound in all clauses:</p>

<pre class="hljs">fib<span class="hljs-punctuation">(</span><span class="hljs-keyword">match </span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-number">0</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-number">0</span>
   <span class="hljs-number">1</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-number">1</span>
   <span class="hljs-keyword">else</span> <span class="hljs-operator">-&gt;</span> fib<span class="hljs-punctuation">(</span>n <span class="hljs-operator">-</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> fib<span class="hljs-punctuation">(</span>n <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span></pre>

<p>The feature also works for rest arguments:</p>

<pre class="hljs">concat<span class="hljs-punctuation">(</span><span class="hljs-operator">*</span><span class="hljs-keyword">match</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
    <span class="hljs-punctuation">{</span>String<span class="hljs-operator">?</span> a<span class="hljs-punctuation">,</span> String<span class="hljs-operator">?</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> a <span class="hljs-operator">+</span> b
    <span class="hljs-punctuation">{</span>Array<span class="hljs-operator">?</span> a<span class="hljs-punctuation">,</span> Array<span class="hljs-operator">?</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span> a <span class="hljs-operator">++</span> b</pre>

<p>Other features can be embedded in arguments. For instance, <code class="hlinline">each</code> can
be used in a pattern:</p>

<pre class="hljs">f<span class="hljs-punctuation">(</span><span class="hljs-wordop">each</span> x<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> x <span class="hljs-operator">*</span> x
f<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-operator">..</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span>                 <span class="hljs-comment">;; =&gt; {1, 4, 9, 16, 25}</span>

enhance<span class="hljs-punctuation">(</span><span class="hljs-keyword">match</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   Number<span class="hljs-operator">?</span> n <span class="hljs-operator">-&gt;</span> n <span class="hljs-operator">*</span> n
   String<span class="hljs-operator">?</span> s <span class="hljs-operator">-&gt;</span> s <span class="hljs-operator">+</span> <span class="hljs-string">"s"</span>
   <span class="hljs-punctuation">(</span><span class="hljs-wordop">each</span> x<span class="hljs-punctuation">)</span> <span class="hljs-operator">-&gt;</span> enhance<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-comment">;; short for xs -&gt; xs each x -&gt; enhance(x)</span>
enhance<span class="hljs-punctuation">(</span><span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"cake"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">;; =&gt; {1, 4, "cakes"}</span></pre>

<p><div class="warning">
  The parentheses around <code class="hlinline">(each x)</code> are needed above, otherwise the
  clause is parsed like <code class="hlinline">each (x -&gt; enhance(x))</code>, which is not legal
  (at least not yet).</div></p>

<p><code class="hlinline">each</code> in this case can be anywhere in a pattern, and multiple <code class="hlinline">each</code>
found in the same pattern will nest in the order that they are found:</p>

<pre class="hljs">f<span class="hljs-punctuation">(</span><span class="hljs-wordop">each</span> x<span class="hljs-punctuation">,</span> <span class="hljs-wordop">each</span> y<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> x <span class="hljs-operator">+</span> y
f<span class="hljs-punctuation">(</span><span class="hljs-punctuation">{</span><span class="hljs-string">"a"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"b"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-string">"x"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"y"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; ==&gt; {{"ax", "ay"}, {"bx", "by"}}</span></pre>

<p><code class="hlinline">chain</code> can be embedded and you get a nice pipeline going on:</p>

<pre class="hljs">capitalize-words<span class="hljs-punctuation">(</span><span class="hljs-keyword">chain</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-member">@trim</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
   <span class="hljs-member">@split</span><span class="hljs-punctuation">(</span>R<span class="hljs-string">" +"</span><span class="hljs-punctuation">)</span> <span class="hljs-wordop">each</span> w <span class="hljs-wordop">when</span> w <span class="hljs-operator">!=</span> <span class="hljs-string">""</span> <span class="hljs-operator">-&gt;</span>
      w<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-string">.to-upper-case</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> w<span class="hljs-string">.slice</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>
   <span class="hljs-member">@join</span><span class="hljs-punctuation">(</span><span class="hljs-string">" "</span><span class="hljs-punctuation">)</span>
capitalize-words<span class="hljs-punctuation">(</span><span class="hljs-string">" pulp  fiction "</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; =&gt; "Pulp Fiction"</span></pre>


<h3 id="is">is</h3>

<p>Sometimes you may need or want to give a value to a variable inside a
pattern. You can do this with <code class="hlinline">is</code>:</p>

<pre class="hljs">x <span class="hljs-wordop">and</span> y <span class="hljs-wordop">is</span> <span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>                     <span class="hljs-comment">;; x is 5, y is 10</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span> <span class="hljs-wordop">or</span> x <span class="hljs-wordop">is</span> <span class="hljs-number">0</span> <span class="hljs-wordop">and</span> y <span class="hljs-wordop">is</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> <span class="hljs-string">"blah"</span>  <span class="hljs-comment">;; x is 0, y is 0</span></pre>

<p>One use case is to remove one level of nesting in the following code:</p>

<pre class="hljs">f<span class="hljs-punctuation">(</span><span class="hljs-keyword">match</span><span class="hljs-punctuation">,</span> x<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-punctuation">{</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-keyword">match </span>x:
         <span class="hljs-operator">...</span></pre>

<p>The above can be rewritten:</p>

<pre class="hljs">f<span class="hljs-punctuation">(</span><span class="hljs-keyword">match</span><span class="hljs-punctuation">,</span> x<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-punctuation">{</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">}</span> <span class="hljs-wordop">and</span> <span class="hljs-keyword">match</span> <span class="hljs-wordop">is</span> x <span class="hljs-operator">-&gt;</span>
      <span class="hljs-operator">...</span></pre>

<h3 id="assignmentwrappers">Assignment wrappers</h3>

<p>The keywords <code class="hlinline">expr-value</code>, <code class="hlinline">return</code>, <code class="hlinline">yield</code> and <code class="hlinline">await</code> may be used in a
pattern on the left hand side of an assignment. Normally, an
assignment returns the variable it declares, or if there is more than
one variable, an array of the declared variables:</p>

<pre class="hljs">x <span class="hljs-operator">=</span> <span class="hljs-number">4</span>                           <span class="hljs-comment">;; ==&gt; 4</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span>y<span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>       <span class="hljs-comment">;; ==&gt; {1, 2, 3}</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> _<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span>   <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>         <span class="hljs-comment">;; ==&gt; {1, 2}</span>
<span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> String<span class="hljs-operator">!</span> y<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>         <span class="hljs-comment">;; ==&gt; {1, "2"}</span></pre>

<p>You can, however, modify this behavior:</p>

<pre class="hljs"><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> <span class="hljs-keyword">expr-value</span><span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>  <span class="hljs-comment">;; ==&gt; 2</span>
<span class="hljs-punctuation">{</span>_<span class="hljs-punctuation">,</span> <span class="hljs-keyword">return</span><span class="hljs-punctuation">,</span> _<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">}</span>      <span class="hljs-comment">;; immediately returns 2 from the function</span>
<span class="hljs-punctuation">{</span><span class="hljs-keyword">yield</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">yield</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">}</span>         <span class="hljs-comment">;; yields 1, then yields 2</span></pre>

<p>Note that it's not particularly useful to declare variables alongside
<code class="hlinline">return</code> since there's no way to use them after the function returns.</p>

<p><div class="warning">
  Combining more than one of these in the same pattern is currently a
  bit flaky.</div></p>



<h1 id="asynchronouscode">Asynchronous code</h1>

<p>Like ES6, EG has generators. Like ES7 (proposed), it has <code class="hlinline">async</code> and
<code class="hlinline">await</code> keywords.</p>

<h3 id="generators">Generators</h3>

<p>A generator is a function that can produce (<code class="hlinline">yield</code>) an arbitrary
number of values as they are requested by a consumer. For instance,
this is a generator for the Fibonacci numbers:</p>

<pre class="hljs"><span class="hljs-keyword">gen </span>fib<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-keyword">var </span><span class="hljs-punctuation">{</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">}</span>
   <span class="hljs-keyword">while </span>true:
      <span class="hljs-keyword">yield </span>a
      <span class="hljs-punctuation">{</span>a<span class="hljs-punctuation">,</span> b<span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>b<span class="hljs-punctuation">,</span> a <span class="hljs-operator">+</span> b<span class="hljs-punctuation">}</span></pre>

<p>That function is an infinite loop, but at each invocation of <code class="hlinline">yield
a</code>, it sends the value of <code class="hlinline">a</code> to the consumer and stops until the
consumer asks for the next value. The <code class="hlinline">consume</code> function can be used
to retrieve a certain number of values from the generator:</p>

<pre class="hljs">consume<span class="hljs-punctuation">(</span>fib<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">;; ==&gt; {0, 1, 1, 2, 3, 5, 8, 13, 21, 34}</span></pre>

<p><code class="hlinline">each</code> and <code class="hlinline">for...of</code> will consume a generator until a <code class="hlinline">break</code>
statement is encountered. <code class="hlinline">each*</code> will create a new generator:</p>

<pre class="hljs">fibsquared <span class="hljs-operator">=</span> fib<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-wordop">each</span><span class="hljs-operator">*</span> n <span class="hljs-operator">-&gt;</span> n <span class="hljs-operator">*</span> n
consume<span class="hljs-punctuation">(</span>fibsquared<span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; ==&gt; {0, 1, 1, 4, 9, 25, 64, 169, 441, 1156}</span></pre>

<p>Here the difference between <code class="hlinline">each</code> and <code class="hlinline">each*</code> is that <code class="hlinline">each</code> will
keep accumulating values until it runs out of memory, whereas <code class="hlinline">each*</code>
is lazy just like <code class="hlinline">fib</code>.</p>


<h3 id="promisesandasyncawait">Promises and async/await</h3>

<p>Promises and generators are ES6's answer to callback hell and EG
supports them. <code class="hlinline">async</code> and <code class="hlinline">await</code> make them even easier to use:</p>

<pre class="hljs"><span class="hljs-keyword">require</span><span class="hljs-punctuation">:</span> fs
readFile <span class="hljs-operator">=</span> promisify<span class="hljs-punctuation">(</span>fs<span class="hljs-string">.readFile</span><span class="hljs-punctuation">)</span>

<span class="hljs-keyword">async </span>cat<span class="hljs-punctuation">(</span><span class="hljs-operator">*</span>files<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-keyword">var </span>rval <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
   files <span class="hljs-wordop">each</span> file <span class="hljs-operator">-&gt;</span>
      rval <span class="hljs-operator">+=</span> <span class="hljs-keyword">await </span>readFile<span class="hljs-punctuation">(</span>file<span class="hljs-punctuation">,</span> <span class="hljs-string">.utf8</span><span class="hljs-punctuation">)</span>
   <span class="hljs-keyword">print </span>rval

<span class="hljs-keyword">async</span><span class="hljs-punctuation">:</span>
   cat<span class="hljs-punctuation">(</span><span class="hljs-string">"file1"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"file2"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"file3"</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; returns immediately</span></pre>

<p>Here's how it works:</p>

<ul><li><code class="hlinline">require: fs</code> fetches node.js's filesystem module</li>

<li><p><code class="hlinline">promisify(fs.readFile)</code> changes <code class="hlinline">fs.readFile</code>'s callback-based
  interface to a Promise-based interface, which is necessary to work
  with async.</p>

  <p><code class="hlinline">promisify</code> should work on any function that implements node's callback
  interface, i.e. where the last argument has the form <code class="hlinline">{error, result} -&gt; ...</code></p></li>

<li><code class="hlinline">await readFile(file, .utf8)</code> reads the file <em>asynchronously</em>, in
  the background. At that moment, the execution of <code class="hlinline">cat</code> stops and
  other tasks can be executed while waiting for the file to be read.</li>

<li>Once the file is read, the result is given back to <code class="hlinline">cat</code>. It keeps
  going until all the files have been read, and then it prints them.</li>

<li>If <code class="hlinline">readFile</code> calls back with an error, an exception will be raised.
  However, when an async function is called without a corresponding
  <code class="hlinline">await</code>, the error will be ignored. The <code class="hlinline">async:</code> block mitigates
  this issue by wrapping the async call, catching the error, and
  logging it.</li>


</ul><h1 id="classes">Classes</h1>

<p>The <code class="hlinline">class</code> keyword can be used to declare a new class.</p>

<p>Each method has a reference to the object in the variable <code class="hlinline">self</code> and as
the <code class="hlinline">@</code> operator. Here's a simple class to get you started:</p>

<h3 id="defining">Defining</h3>

<pre class="hljs"><span class="hljs-keyword">class </span>Person:
   constructor<span class="hljs-punctuation">(</span>name<span class="hljs-punctuation">,</span> age<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-member">@name</span> <span class="hljs-operator">=</span> name
      <span class="hljs-member">@age</span> <span class="hljs-operator">=</span> age
   advance-inexorably-towards-death<span class="hljs-punctuation">(</span>n <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-member">@age</span> <span class="hljs-operator">+=</span> n
   say-name<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-keyword">print </span><span class="hljs-string">'Hello! My name is {@name}!'</span></pre>

<p>Instead of setting values in the constructor manually as the above
you can also use the following shortcut:</p>

<pre class="hljs"><span class="hljs-keyword">class </span>Person:
   constructor<span class="hljs-punctuation">(</span><span class="hljs-member">@name</span><span class="hljs-punctuation">,</span> <span class="hljs-member">@age</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-comment">;; pass is a placeholder keyword; like in Python it just means "do nothing"</span>
      pass</pre>

<p>This works for all methods, not just the constructor.</p>


<h3 id="instantiating">Instantiating</h3>

<p>Instantiating a class can be done with the <code class="hlinline">new</code> keyword, or not. It
doesn't matter.</p>

<pre class="hljs">alice <span class="hljs-operator">=</span> <span class="hljs-keyword">new </span>Person<span class="hljs-punctuation">(</span><span class="hljs-string">"alice"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">25</span><span class="hljs-punctuation">)</span>
bob <span class="hljs-operator">=</span> Person<span class="hljs-punctuation">(</span><span class="hljs-string">"bob"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">44</span><span class="hljs-punctuation">)</span>
bob<span class="hljs-string">.advance-inexorably-towards-death</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span></pre>

<div class="note">
  The <code class="hlinline">new</code> keyword may be needed to instantiate some classes in third
  party packages, check their documentation to be sure.</div>


<h3 id="subclassing">Subclassing</h3>

<p>The <code class="hlinline">&lt;</code> operator is used to define the superclass of a new class.</p>

<pre class="hljs"><span class="hljs-keyword">class </span>Baker <span class="hljs-operator">&lt;</span> Person<span class="hljs-punctuation">:</span>
   bake<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-keyword">print </span><span class="hljs-string">'{@name} is baking {n} cake{if{n &gt; 1, "s", ""}}!'</span>

carmen <span class="hljs-operator">=</span> Baker<span class="hljs-punctuation">(</span><span class="hljs-string">"carmen"</span><span class="hljs-punctuation">,</span> <span class="hljs-number">30</span><span class="hljs-punctuation">)</span>
carmen<span class="hljs-string">.bake</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span>
carmen<span class="hljs-string">.advance-inexorably-towards-death</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>
carmen<span class="hljs-string">.bake</span><span class="hljs-punctuation">(</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span></pre>

<p>There is no <code class="hlinline">super</code> keyword at the moment. I'll fix that at some point.</p>


<h3 id="staticmethods">Static methods</h3>

<p>Define static methods for a class using a <code class="hlinline">static:</code> block:</p>

<pre class="hljs"><span class="hljs-keyword">class </span>Person:
   <span class="hljs-keyword">static</span><span class="hljs-punctuation">:</span>
      make-twins<span class="hljs-punctuation">(</span>name1<span class="hljs-punctuation">,</span> name2<span class="hljs-punctuation">,</span> age<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
         <span class="hljs-punctuation">{</span>Person<span class="hljs-punctuation">(</span>name1<span class="hljs-punctuation">,</span> age<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> Person<span class="hljs-punctuation">(</span>name2<span class="hljs-punctuation">,</span> age<span class="hljs-punctuation">)</span><span class="hljs-punctuation">}</span>
   constructor<span class="hljs-punctuation">(</span><span class="hljs-member">@name</span><span class="hljs-punctuation">,</span> <span class="hljs-member">@age</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      pass
   <span class="hljs-operator">...</span></pre>


<h3 id="specialmethods">Special methods</h3>

<p>There are a few interesting special methods you can define on a class
to customize its behavior:</p>

<ul><li><code class="hlinline">Symbol.iterator</code> is used by <code class="hlinline">each</code> and <code class="hlinline">for..of</code> to iterate over your
  object. You must return a generator (use <code class="hlinline">gen</code> and <code class="hlinline">yield</code>, see
  below).</li>

<li><code class="hlinline">Symbol.check</code> is consulted by the <code class="hlinline">?</code> operator.</li>

<li><code class="hlinline">Symbol.project</code> is consulted by the <code class="hlinline">!</code> operator.</li>

<li><code class="hlinline">Symbol.contains</code> is consulted by the <code class="hlinline">in</code> operator.</li>

</ul><p>Under ES6 semantics, these methods are not strings, but special
symbols. You will therefore need the unquote operator <code class="hlinline">^</code> to set
them, but it's easy enough:</p>


<pre class="hljs"><span class="hljs-keyword">class </span>Multiples:
   constructor<span class="hljs-punctuation">(</span><span class="hljs-member">@n</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      pass

   <span class="hljs-comment">;; Iterate through all multiples of @n using a generator</span>
   <span class="hljs-keyword">gen </span><span class="hljs-punctuation">(</span><span class="hljs-operator">^</span>Symbol<span class="hljs-string">.iterator</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      <span class="hljs-comment">;; This is an infinite iterator. Be careful.</span>
      <span class="hljs-number">0</span><span class="hljs-operator">..</span> <span class="hljs-wordop">each</span> i <span class="hljs-operator">-&gt;</span>
         <span class="hljs-keyword">yield </span>i <span class="hljs-operator">*</span> <span class="hljs-member">@n</span>

   <span class="hljs-comment">;; Check that a number is a multiple of @n</span>
   <span class="hljs-punctuation">(</span><span class="hljs-operator">^</span>Symbol<span class="hljs-string">.check</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      Number<span class="hljs-operator">?</span> n <span class="hljs-wordop">and</span> n <span class="hljs-wordop">mod</span> <span class="hljs-member">@n</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>

   <span class="hljs-comment">;; Round down n to a multiple of @n</span>
   <span class="hljs-punctuation">(</span><span class="hljs-operator">^</span>Symbol<span class="hljs-string">.project</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
      n <span class="hljs-operator">-</span> <span class="hljs-punctuation">(</span>n <span class="hljs-wordop">mod</span> <span class="hljs-member">@n</span><span class="hljs-punctuation">)</span>

   <span class="hljs-comment">;; We'll define this the same as Symbol.check</span>
   <span class="hljs-punctuation">(</span><span class="hljs-operator">^</span>Symbol<span class="hljs-string">.contains</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">(</span><span class="hljs-operator">@</span><span class="hljs-punctuation">)</span><span class="hljs-operator">?</span> n

mul3 <span class="hljs-operator">=</span> Multiples<span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span>

<span class="hljs-comment">;; print all multiples of 3 no greater than 100</span>
mul3 <span class="hljs-wordop">each</span>
   <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">break</span>
   n <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">print </span>n

<span class="hljs-comment">;; this will fail because 25 is not a multiple of 3</span>
mul3<span class="hljs-operator">?</span> x <span class="hljs-operator">=</span> <span class="hljs-number">25</span>

<span class="hljs-comment">;; this will set y to 24</span>
mul3<span class="hljs-operator">!</span> y <span class="hljs-operator">=</span> <span class="hljs-number">25</span>

<span class="hljs-comment">;; the following is true</span>
<span class="hljs-number">3</span> <span class="hljs-operator">in</span> mul3</pre>

<div class="note">
  Don't forget the parentheses around <code class="hlinline">(^Symbol.iterator)</code> and friends.
  Otherwise you will get an error like "symbol/string is not a function".
  That's normal because <code class="hlinline">^</code> means to set the key corresponding to the
  value of an expression and without the parentheses it'll think the key
  is the value of the whole expression <code class="hlinline">Symbol.iterator()</code> instead of just
  <code class="hlinline">Symbol.iterator</code>.</div>


<h3 id="todo">TODO</h3>

<p>There are some missing features I'll add at some point, tell me if you
need them.</p>

<ul><li><code class="hlinline">super</code> keyword</li>
<li>getter/setters</li></ul>




<h1 id="miscellaneous">Miscellaneous</h1>

<h3 id="chain">chain</h3>

<p><code class="hlinline">chain</code> is how you chain methods in EG.</p>

<p>The body of <code class="hlinline">chain</code> should contain a sequence of statements. The return
value of each statement is tied to the <code class="hlinline">@</code> operator in the next.</p>

<p>Here's an example:</p>

<pre class="hljs"><span class="hljs-keyword">chain </span><span class="hljs-string">"hello"</span><span class="hljs-punctuation">:</span>
   <span class="hljs-comment">;; @ is "hello"</span>
   <span class="hljs-member">@replace</span><span class="hljs-punctuation">(</span><span class="hljs-string">"o"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">""</span><span class="hljs-punctuation">)</span>
   <span class="hljs-comment">;; @ is "hell"</span>
   <span class="hljs-punctuation">{</span><span class="hljs-operator">@</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"is"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"freezing"</span><span class="hljs-punctuation">}</span>
   <span class="hljs-comment">;; @ is {"hell", "is", "freezing"}</span>
   <span class="hljs-member">@join</span><span class="hljs-punctuation">(</span><span class="hljs-string">" "</span><span class="hljs-punctuation">)</span>
<span class="hljs-comment">;; ==&gt; "hell is freezing"</span></pre>


<h3 id="regularexpressions">Regular expressions</h3>

<p>Regular expressions are written with the <code class="hlinline">R</code> prefix, for instance,
<code class="hlinline">R"\d+(\.\d*)?"</code></p>

<p>They can be used as checkers or projectors. For example:</p>

<pre class="hljs">mangle<span class="hljs-punctuation">(</span><span class="hljs-keyword">match </span>email<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>

   <span class="hljs-comment">;; regexp! transforms the input into an array of match groups</span>
   <span class="hljs-comment">;; (the first is always the whole match)</span>
   R<span class="hljs-string">"^([a-z.]+)@([a-z.]+)$"</span><span class="hljs-operator">!</span> <span class="hljs-punctuation">{</span>_<span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">,</span> host<span class="hljs-punctuation">}</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-string">'{name} AT {host}'</span>

   <span class="hljs-comment">;; regexp? will just test if the regexp matches, but it won't</span>
   <span class="hljs-comment">;; transform the input</span>
   R<span class="hljs-string">"@"</span><span class="hljs-operator">?</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-string">"It looks like an email but I'm too daft to parse it."</span>

   <span class="hljs-keyword">else</span> <span class="hljs-operator">-&gt;</span>
      <span class="hljs-string">"This is not an email at all!"</span></pre>


<h3 id="errorsandexceptions">Errors and exceptions</h3>

<ul><li><code class="hlinline">throw</code> is used to throw an exception</li>
<li><code class="hlinline">try</code> and <code class="hlinline">catch</code> are used to catch an exception</li>
<li><code class="hlinline">finally</code> is used for cleanup</li>
<li><code class="hlinline">E</code> is used to build customized exceptions</li></ul>

<pre class="hljs"><span class="hljs-keyword">try</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">throw </span>E<span class="hljs-string">.test</span><span class="hljs-string">.my-error</span><span class="hljs-punctuation">(</span><span class="hljs-string">"This is my error."</span><span class="hljs-punctuation">)</span>
<span class="hljs-keyword">catch </span>TypeError<span class="hljs-operator">?</span> e<span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span><span class="hljs-string">"There was a type error."</span>
<span class="hljs-keyword">catch </span>E<span class="hljs-string">.my-error</span><span class="hljs-operator">?</span> e<span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span><span class="hljs-string">"My error!"</span>
<span class="hljs-keyword">catch </span>e:
   <span class="hljs-keyword">print </span><span class="hljs-string">"Some other error."</span>
<span class="hljs-keyword">finally</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span><span class="hljs-string">"We are done."</span></pre>



<h1 id="modulesystem">Module system</h1>

<p><code class="hlinline">require</code> may be used to import functionality from other
modules. <code class="hlinline">provide</code> may be used to export functionality.</p>

<h3 id="require"><code class="hlinline">require</code></h3>

<p>Ideally, all of a module's imports should be in a single <code class="hlinline">require</code>
block.</p>

<pre class="hljs"><span class="hljs-keyword">require</span><span class="hljs-punctuation">:</span>
   fs<span class="hljs-punctuation">,</span> path
   react <span class="hljs-wordop">as</span> React
   something<span class="hljs-punctuation">(</span><span class="hljs-number">1234</span><span class="hljs-punctuation">)</span>
   <span class="hljs-string">"./mymodule"</span> <span class="hljs-operator">-&gt;</span>
      some-function<span class="hljs-punctuation">,</span> other-function <span class="hljs-operator">as</span> blah</pre>

<p>This is roughly equivalent to the following JavaScript:</p>

<pre class="hljs"><span class="hljs-keyword">var</span> fs           = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>)
  , path         = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>)
  , React        = <span class="hljs-built_in">require</span>(<span class="hljs-string">"react"</span>)
  , something    = <span class="hljs-built_in">require</span>(<span class="hljs-string">"something"</span>)(<span class="hljs-number">1234</span>)
  , _temp        = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./mymodule"</span>)
  , someFunction = _temp.someFunction
  , blah         = _temp.otherFunction;</pre>

<h3 id="provide"><code class="hlinline">provide</code></h3>

<p><code class="hlinline">provide</code> fills the module's exports:</p>

<pre class="hljs"><span class="hljs-keyword">provide</span><span class="hljs-punctuation">:</span>
   fn1<span class="hljs-punctuation">,</span> fn2
   fn3 <span class="hljs-operator">as</span> xyz</pre>

<p>It is recommended to put it at the beginning of the file so that it is
clear what symbols the module provides.</p>

<h3 id="inject"><code class="hlinline">inject</code></h3>

<p>TODO</p>

<h3 id="requiremacros"><code class="hlinline">require-macros</code></h3>

<p><code class="hlinline">require-macros</code> works like <code class="hlinline">require</code>, but the imported symbols are
defined as macros.</p>

<p><code class="hlinline">earl</code> currently does not take into account the dependencies listed by
<code class="hlinline">require-macros</code> when deciding whether to recompile a file or not. If
those dependencies change, dependents may not be recompiled, so you
will need to <code class="hlinline">touch</code> them or use the <code class="hlinline">-r</code> flag to force them to be.</p>


<h1 id="documentbuildingsyntax">Document-building syntax</h1>

<p>The <code class="hlinline">%</code> operator can be used to build structured "documents". It
creates an instance of the <code class="hlinline">ENode</code> data structure, which contains a
set of tags and attributes along with a list of children.</p>

<p><code class="hlinline">ENode</code> instances mostly just hold structure and are meant to be
converted into something else, for instance HTML:</p>


<pre class="hljs">node <span class="hljs-operator">=</span>
   div<span class="hljs-struct">#main</span> <span class="hljs-operator">%</span>
      <span class="hljs-string">"Some text"</span>
      strong <span class="hljs-operator">%</span> <span class="hljs-number">1234</span>
      a<span class="hljs-string">.large</span><span class="hljs-string">.red</span> <span class="hljs-operator">%</span>
         href <span class="hljs-operator">=</span> <span class="hljs-string">"http://example.com"</span>
         <span class="hljs-string">"stuff"</span>

<span class="hljs-keyword">require</span><span class="hljs-punctuation">:</span> <span class="hljs-operator">/</span>html
html<span class="hljs-punctuation">(</span>node<span class="hljs-punctuation">)</span></pre>

<p>Would produce:</p>

<pre class="hljs"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"main"</span>&gt;</span>
  Some text
  <span class="hljs-tag">&lt;<span class="hljs-title">strong</span>&gt;</span>1234<span class="hljs-tag">&lt;/<span class="hljs-title">strong</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"large blue"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://example.com"</span>&gt;</span>stuff<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></pre>


<h1 id="macros">Macros</h1>

<p>There are two means of defining macros in EG:</p>

<ul><li><code class="hlinline">inline-macro</code> defines a macro for use in the current file and the
  current scope. They cannot be exported from the module at the
  moment.</li>

<li><code class="hlinline">macro</code> defines an exportable macro. It cannot be used in the file or
  scope in which it is defined, but it can be imported with
  <code class="hlinline">require-macros</code> and used from other modules.</li>

</ul><p>I wouldn't say it's the best setup, but it's still fairly good, and
the one that exists at the moment.</p>

<p>Macros in EG cannot extend the parser; however, EG's syntax is
flexible enough that there isn't much of a need to extend it.</p>

<p>First, though, some basics must be laid out:</p>

<h3 id="invariants">Invariants</h3>

<p>A lot of EG's syntax is sugar. Here's what you should know:</p>

<ul><li><strong>Parenthesis elimination</strong>: parentheses are sugar for the other two
  bracket types:
  <pre class="hljs">a(b)          &lt;=&gt; a{b}
a(b, c)       &lt;=&gt; a{b, c}
(a)           &lt;=&gt; [a]       &lt;=&gt; a
(a, b)        &lt;=&gt; [a, b]</pre></li>

<li><strong>Operator rules</strong>: operator applications desugar to function/macro
  calls. If the operator is prefix or postfix, one of the arguments
  will be void. Except for commas, colons and <code class="hlinline">with</code>, <em>all</em> operators
  undergo that simplification, including core ones like <code class="hlinline">=</code> or <code class="hlinline">-&gt;</code>:
  <pre class="hljs">a + b         &lt;=&gt; [+]{a, b}
+ a           &lt;=&gt; [+]{[], a}
a +           &lt;=&gt; [+]{a, []}</pre></li>

<li><strong>Colon rules:</strong>
  <pre class="hljs">a: b          &lt;=&gt; a{b}
a b: c        &lt;=&gt; a{b, c}</pre></li>

<li><strong>Juxtaposition rule:</strong>
  <pre class="hljs">a[b]           &lt;=&gt; a b</pre></li>

</ul><p>So for instance:</p>

<pre class="hljs"><span class="hljs-keyword">if </span>x <span class="hljs-operator">&lt;</span> y<span class="hljs-punctuation">:</span> z   <span class="hljs-operator">&lt;=&gt;</span> if<span class="hljs-punctuation">{</span><span class="hljs-punctuation">[</span><span class="hljs-operator">&lt;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> z<span class="hljs-punctuation">}</span>
<span class="hljs-keyword">return </span>x <span class="hljs-operator">+</span> y  <span class="hljs-operator">&lt;=&gt;</span> <span class="hljs-keyword">return</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span><span class="hljs-operator">+</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">{</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span>
<span class="hljs-keyword">var </span>x <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>  <span class="hljs-operator">&lt;=&gt;</span> <span class="hljs-punctuation">[</span><span class="hljs-operator">=</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">{</span>var<span class="hljs-punctuation">[</span>x<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1234</span><span class="hljs-punctuation">}</span></pre>


<h3 id="quote">quote</h3>

<p>EG code can be "quoted" by putting it inside backticks:</p>

<pre class="hljs"><span class="hljs-quote">`a + 2`</span>
<span class="hljs-comment">;; =&gt; the AST of "a + 2"</span>
<span class="hljs-comment">;; =&gt; #send{#symbol{"+"}, #data{#symbol{"a"}, #value{2}}}</span></pre>

<p>You can "unquote" with the caret operators. Use <code class="hlinline">^</code> to insert a bit of
AST or <code class="hlinline">^=</code> to insert a value.</p>

<pre class="hljs">apb <span class="hljs-operator">=</span> <span class="hljs-quote">`a * b`</span>
two <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-quote">`^=two * ^apb`</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-quote">`2 * (a + b)`</span></pre>

<p>Together these features let you pattern match on code:</p>

<pre class="hljs"><span class="hljs-keyword">match </span><span class="hljs-quote">`a + b * c`</span><span class="hljs-punctuation">:</span>
   <span class="hljs-quote">`^x + ^y`</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"addition"</span>
   <span class="hljs-quote">`^x * ^y`</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"multiplication"</span>
   <span class="hljs-quote">`^f ^arg`</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-string">"application"</span></pre>

<p>Be careful about the order of patterns. The "application" pattern may
not look like it, but it would match the expression <code class="hlinline">a + b</code> with <code class="hlinline">+</code>
in <code class="hlinline">f</code> and <code class="hlinline">{a, b}</code> in <code class="hlinline">arg</code> (because <code class="hlinline">a + b</code> &lt;=&gt; <code class="hlinline">[+] {a, b}</code>).</p>


<h3 id="inlinemacro">inline-macro</h3>

<p>The syntax goes like this:</p>

<pre class="hljs"><span class="hljs-keyword">inline-macro </span>macro-name<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   build-new-expression<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span></pre>

<p>The expression is the AST of the argument given to the macro call and
it is determined like this:</p>

<table><tr><th>Situation</th><th>Value of expression</th></tr>
<tr><td><code class="hlinline">macro-name(x)</code></td><td><code class="hlinline">`{x}`</code></td></tr>
<tr><td><code class="hlinline">macro-name{x}</code></td><td><code class="hlinline">`{x}`</code></td></tr>
<tr><td><code class="hlinline">macro-name(x, y)</code></td><td><code class="hlinline">`{x, y}`</code></td></tr>
<tr><td><code class="hlinline">macro-name[x]</code></td><td><code class="hlinline">`x`</code></td></tr>
<tr><td><code class="hlinline">macro-name x</code></td><td><code class="hlinline">`x`</code></td></tr>
<tr><td><code class="hlinline">macro-name[x, y]</code></td><td><code class="hlinline">`[x, y]`</code></td></tr>
<tr><td><code class="hlinline">macro-name: x</code></td><td><code class="hlinline">`{x}`</code></td></tr>
<tr><td><code class="hlinline">macro-name x: y</code></td><td><code class="hlinline">`{x, y}`</code></td></tr>
<tr><td><code class="hlinline">macro-name x: y, z</code></td><td><code class="hlinline">`{x, [y, z]}`</code></td></tr>
<tr><td><code class="hlinline">macro-name</code></td><td><code class="hlinline">#void{}</code></td></tr></table>

<p>The last situation is only triggered if the expander encounters
<code class="hlinline">macro-name</code> alone and with <em>no</em> arguments. Note that the expression
isn't inside backticks, you have to match <code class="hlinline">#void{}</code>, literally.</p>

<p><strong>Example</strong>: <strong>unless</strong> as a counterpart to <code class="hlinline">if</code>:</p>

<pre class="hljs"><span class="hljs-keyword">inline-macro </span>unless<span class="hljs-punctuation">(</span><span class="hljs-quote">`{^cond, ^body}`</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-quote">`if not ^cond: ^body`</span>

unless<span class="hljs-punctuation">(</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">print </span><span class="hljs-string">"all is well"</span><span class="hljs-punctuation">)</span>  <span class="hljs-comment">;; prints "all is well"</span>

<span class="hljs-keyword">unless </span><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span><span class="hljs-string">"all is well"</span>               <span class="hljs-comment">;; same as above</span></pre>

<p>Here is a simple macro for <strong>assert</strong>:</p>

<pre class="hljs"><span class="hljs-keyword">inline-macro </span>assert<span class="hljs-punctuation">(</span>cond<span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   code <span class="hljs-operator">=</span> <span class="hljs-member">@raw</span><span class="hljs-punctuation">(</span>cond<span class="hljs-punctuation">)</span>
   <span class="hljs-quote">`if{cond, true, throw E.assert("Assertion failed: " + ^code)}`</span>

<span class="hljs-keyword">assert </span><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span>
<span class="hljs-comment">;; =&gt; throws E.assert("Assertion failed: 1 == 2")</span></pre>


<h3 id="macro">macro</h3>

<p>Unlike <code class="hlinline">inline-macro</code>, <code class="hlinline">macro</code> is built to create exportable macros. The
basic syntax is as follows:</p>

<pre class="hljs"><span class="hljs-keyword">macro </span>macro-name<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   build-new-expression<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span></pre>

<p>For example:</p>

<p><code class="hlinline">unless.eg</code>:</p>

<pre class="hljs"><span class="hljs-keyword">provide</span><span class="hljs-punctuation">:</span> unless
<span class="hljs-keyword">macro </span>unless<span class="hljs-punctuation">(</span><span class="hljs-quote">`{^cond, ^body}`</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-quote">`if not ^cond: ^body`</span></pre>

<p><code class="hlinline">script.eg</code>:</p>

<pre class="hljs"><span class="hljs-keyword">require-macros</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./unless"</span> <span class="hljs-operator">-&gt;</span> unless
<span class="hljs-keyword">unless </span><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">:</span>
   <span class="hljs-keyword">print </span><span class="hljs-string">"all is well"</span></pre>

<h4 id="dependencies">Dependencies</h4>

<p>Some macros may need to produce code that refers to particular
libraries, data structures, and so on. For this purpose it is possible
to declare a list of dependencies for a macro:</p>

<pre class="hljs">macro<span class="hljs-punctuation">{</span>dependencies<span class="hljs-punctuation">,</span> <span class="hljs-operator">...</span><span class="hljs-punctuation">}</span> macro-name<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   build-new-expression<span class="hljs-punctuation">(</span>expression<span class="hljs-punctuation">)</span></pre>

<p>Each listed dependency is then associated to a special symbol in
<code class="hlinline">@deps</code>, and that symbol can be inserted in the generated code.</p>

<p>Here's an example:</p>

<p><code class="hlinline">uniq.eg</code>:</p>

<pre class="hljs"><span class="hljs-keyword">provide</span><span class="hljs-punctuation">:</span> unique-id
<span class="hljs-keyword">var </span>id <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
next-id<span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span> <span class="hljs-operator">=</span> id<span class="hljs-operator">++</span>
macro<span class="hljs-punctuation">{</span>next-id<span class="hljs-punctuation">}</span> unique-id<span class="hljs-punctuation">(</span><span class="hljs-struct">#void</span><span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span>
   <span class="hljs-keyword">let </span>next-id-sym <span class="hljs-operator">=</span> <span class="hljs-member">@deps</span><span class="hljs-string">.next-id</span>
   <span class="hljs-quote">`[^next-id-sym]{}`</span></pre>

<p><code class="hlinline">script.eg</code>:</p>

<pre class="hljs"><span class="hljs-keyword">require-macros</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./uniq"</span> <span class="hljs-operator">-&gt;</span> unique-id
<span class="hljs-keyword">print </span>unique-id    <span class="hljs-comment">;; 0</span>
<span class="hljs-keyword">print </span>unique-id    <span class="hljs-comment">;; 1</span>
<span class="hljs-keyword">print </span>unique-id    <span class="hljs-comment">;; 2</span>
<span class="hljs-operator">...</span></pre>

<p>The unexported function <code class="hlinline">next-id</code> in <code class="hlinline">uniq.eg</code> is declared as a
dependency by <code class="hlinline">unique-id</code>, which can generate code using it. Behind the
scenes, Earl Grey exports <code class="hlinline">next-id</code> under a mangled name and
automatically imports it along with <code class="hlinline">unique-id</code>. In other words, the
generated code will look a bit like this:</p>

<pre class="hljs"><span class="hljs-keyword">require-macros</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./uniq"</span> <span class="hljs-operator">-&gt;</span> unique-id
<span class="hljs-keyword">require</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./uniq"</span> <span class="hljs-operator">-&gt;</span> next-id$0
<span class="hljs-keyword">print </span>next-id$0<span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
<span class="hljs-keyword">print </span>next-id$0<span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
<span class="hljs-keyword">print </span>next-id$0<span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span>
<span class="hljs-operator">...</span></pre>

<h3 id="hygiene">Hygiene</h3>

<p><strong>Hygiene</strong> is an important property of macro systems: the goal is to
keep macros well-behaved by making sure that the variables defined in
user code do not leak into macro-generated code, and vice versa. For
instance, a macro generating an <code class="hlinline">if</code> statement ought not to stop
working if, for some reason, the user rebinds the <code class="hlinline">if</code> variable.</p>

<p>EG tags every node output by the parser with an <code class="hlinline">env</code> field. Two
symbols refer to the same variable if and only if looking up their
names in their respective environments in their respective scopes
yields the same reference for both. By default, code constructed using
quote has no <code class="hlinline">env</code>, but when it is returned to the macro expander,
untagged nodes are tagged with a fresh environment that looks up
bindings at the definition site. This protects the user's bindings
from interfering with the macro's, and vice versa.</p>

<p>By extracting the environment of its form or argument and tagging
generated code snippets with it, a macro can "violate" hygiene. This
lets it intentionally define variables for use inside the macro. This
is typically done with the <code class="hlinline">@env.mark</code> method. Here is an example:</p>

<h4 id="capturingnames">Capturing names</h4>

<pre class="hljs"><span class="hljs-keyword">inline-macro </span>func<span class="hljs-punctuation">(</span>body<span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span>
   <span class="hljs-comment">;; Create a function with a single argument named $</span>
   dolla <span class="hljs-operator">=</span> <span class="hljs-member">@env</span><span class="hljs-string">.mark</span><span class="hljs-punctuation">(</span><span class="hljs-quote">`$`</span><span class="hljs-punctuation">)</span>
   <span class="hljs-quote">`^dolla -&gt; ^body`</span>

add10 <span class="hljs-operator">=</span> <span class="hljs-keyword">func </span>$ <span class="hljs-operator">+</span> <span class="hljs-number">10</span>
add10<span class="hljs-punctuation">(</span><span class="hljs-number">91</span><span class="hljs-punctuation">)</span>        <span class="hljs-comment">;; ==&gt; 101</span>

first4 <span class="hljs-operator">=</span> <span class="hljs-keyword">func </span>$<span class="hljs-string">.substring</span><span class="hljs-punctuation">(</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span><span class="hljs-punctuation">)</span>
first4<span class="hljs-punctuation">(</span><span class="hljs-string">"hello"</span><span class="hljs-punctuation">)</span>  <span class="hljs-comment">;; ==&gt; "hell"</span></pre>

<p>What we want to do is simple: we want to let the body of <code class="hlinline">func</code> refer
to its argument with <code class="hlinline">$</code>. If we did this naively, e.g. by returning
<code class="hlinline">`$ -&gt; ^body`</code>, it would not work, because EG will think that the
argument named <code class="hlinline">$</code> and the occurrences of <code class="hlinline">$</code> in the body refer to
<em>different variables</em>. This is usually a good thing, but now we want
to defeat it.</p>

<p><strong><code class="hlinline">@env</code></strong> is the environment in which the call to the <code class="hlinline">func</code>
statement was made (it could be user code, or it could be another
macro). <code class="hlinline">@env.mark{`$`}</code> will therefore "mark" a <code class="hlinline">$</code> symbol as
belonging to that same environment, and we save that marked symbol in
the <code class="hlinline">dolla</code> variable. All we have to do, then, is to use this marked
variable to declare the argument.</p>

<div class="note">
  You can also get an <code class="hlinline">env</code> from <code class="hlinline">body</code> or any other node (e.g. we could
  have called <code class="hlinline">body.env.mark(`$`)</code>). This will only make a difference
  if they come from different environments, for instance if another
  macro was to build the expression <code class="hlinline">`func ^x`</code>. <strong>It is usually
  safest</strong> to use <code class="hlinline">@env</code> because it refers to the macro call itself,
  so unintended interference is rather unlikely.</div>

</div>
<script type="text/javascript">$$quaintNavFunctionality()</script></body></html>
