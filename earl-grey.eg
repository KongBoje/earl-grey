
special_ops = {
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {numr,   numr_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {op4,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where

  id = Rx
     start
     [>>"a-zA-Z$_"]
     [>>"a-zA-Z$_0-9"]*

  id_f = {m, wsb, wsa, last_op} -> {.ID, .ID, m[0]}


  numr = Rx
     start
     {d+}, >>"rR"
     {[>>"A-Za-z0-9_"]+}
     [".", {[>>"A-Za-z0-9_"]+}]?

  numr_f = {m, wsb, wsa, last_op} ->
     {_, radix, int, frac} = m
     value := parseInt{int.replace{Rxg"_", ""}, radix}
     cond:
        frac =>
           frac := frac.replace{Rxg"_", ""}
           value := value + parseInt{frac, radix} / Math.pow{radix, frac.length}
     {.ID, .NUM, value}


  num = Rx
     start
     {[>>"0-9_"]+}
     [".", {d+}]?
     [>>"eE", {[>>"+-"]?, [>>"0-9_"]+}]?

  num_f = {m, wsb, wsa, last_op} ->
     {.ID, .NUM, parseFloat{m[0].replace{Rxg"_", ""}}}


  str = Rx
     start
     "\""
     {["\\\\" or "\\\"" or [>>! "\""]]*}
     "\""

  str_f = {m, wsb, wsa, last_op} ->
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{Rxg{"\\\"" or "\\\\" or "\\n"}, {m} -> repl[m]}
     {.ID, .STR, r}

  op = Rx
     start
     [>> "+\\-*/~^<>=%&|?!#.:"]+

  op2 = Rx
     start
     >>"([{}]),"

  op3 = Rx
     start
     "with" or "where" or "when"
       \ or "and" or "not" or "or"
       \ or "in" or "instanceof" or "mod"
     boundary

  op4 = Rx
     start
     "`", {[>>"A-Za-z0-9_"]+}, "`"

  op_f = {m, wsb, wsa, last_op} ->
     op = m[1] or m[0]
     cond:
        [op in special_ops] =>
           fixity = special_ops[op]
           width =
              fixity |>
                 .IFX -> if{wsb or wsa, .wide, .short}
                 .SFX -> if{wsb, .wide, .short}
                 .PFX -> if{wsa, .wide, .short}
                 other -> throw "OopsA"
           {.OP, fixity, width, op}

        [wsa and wsb] =>
           {.OP, [cond: [[last_op => .PFX], [true => .IFX]]], .wide, op}

        [not wsa and not wsb] =>
           {.OP, [cond: [[last_op => .PFX], [true => .IFX]]], .short, op}

        wsa =>
           cond:
              last_op => {.OP, .PFX, .wide, op}
              true => {.OP, .SFX, .short, op}

        wsb =>
           {.OP, .PFX, .short, op}

        true =>
           {.OP, .PFX, .short, op}

  indent = Rx
     start
     ["\n", {" "*}]+

  indent_f = {m, wsb, wsa, last_op} ->
     ilen = m[1].length
     {.INDENT, ilen}


  cmnt = Rx
     start
     ";"
     [>>!"\n"]*

  cmnt_f = {m, wsb, wsa, last_op} -> {.IGNORE}


  unkn = Rx
     start
     any

  unkn_f = {m, wsb, wsa, last_op} -> throw ["unknown character: " + m[0]]



;; TODO: ignore blank lines before continuation
ws_re = Rx[start, " "*, ["\n", " "*, "\\", " "*]*]
eol_re = Rx[start, " "*, "\n" or end]

indent_tracker{} =
   curr = false
   stack = {}
   stacks = {stack}
   {token} ->
      token |>
         {.INDENT, new_indent} ->
            cond:
               [curr === false] =>
                  curr := new_indent
                  {{.OP, .IFX, .wide, ","}}

               [new_indent > curr] =>
                  stack.push{curr}
                  curr := new_indent
                  {{.OP, .PFX, .wide, "["}}

               [new_indent == curr] =>
                  {{.OP, .IFX, .wide, ","}}

               [new_indent < curr] =>
                  rval = {}
                  while [[stack.length > 0] and [new_indent < curr]]:
                     curr := stack.pop{}
                     rval.push{{.OP, .SFX, .wide, "]"}}
                  rval.push{{.OP, .IFX, .wide, ","}}
                  rval

               true => throw {curr, new_indent}

         {.ID, stuff*} -> {token}

         {.OP, fixity, width, "[" or "{"} ->
            stack.push{curr}
            stacks.push{stack}
            stack := {}
            curr := false
            {token}

         {.OP, fixity, width, "]" or "}"} ->
            rval = stack.map{{x} -> {.OP, .SFX, .short, "]"}}
            stack := stacks.pop{}
            curr := stack.pop{}
            rval.push{token}
            rval

         other -> {token}


process_token{token, last_op, wsa, wsb, pos, endpos, accum} =
   {type, result*} = token
   type |>
      .IGNORE ->
         last_op

      .ID ->
         cond:
            [not last_op] =>
               w = {.IFX, if{wsb, .wide, .short}, .WHITE}
               w.location := {pos, pos}
               accum.push{w}
         accum.push{result}
         false

      .OP ->
         cond:
            last_op =>
               v = {.VOID}
               v.location := {pos, pos}
               accum.push{v}
         result[0] |>
            .IFX ->
               accum.push{result}
               true
            .PFX ->
               cond:
                  [not last_op] =>
                     w = {.IFX, if{wsb, .wide, .short}, .WHITE}
                     w.location := {pos, pos}
                     v = {.VOID}
                     v.location := {pos, pos}
                     accum.push{w}
                     accum.push{v}
               accum.push{result}
               true
            .SFX ->
               accum.push{result}
               v = {.VOID}
               v.location := {endpos, endpos}
               accum.push{v}
               false
      other -> throw "OopsB"


tokenize{text} =
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos := wsb
   indent = indent_tracker{}

   while text:
      for [i = 0, i < regexps.length, ++i]:
         {re, fn} = regexps[i]
         m = text.match{re}
         cond:
            m =>
               skip = m[0].length
               endpos = pos + skip
               text := text.slice{skip}
               wsa = text.match{ws_re}[0].length
               eol = text.match{eol_re} and true
               bwsb = wsb > 0
               bwsa = if{eol, bwsb, wsa > 0}
               ;; bwsb = if{eol, true, wsb > 0}
               ;; bwsa = if{eol, true, wsa > 0}
               token = fn{m, bwsb, bwsa, last_op}
               tokens = indent{token}
               tokens.forEach with {x} ->
                  last_op := process_token{x, last_op, bwsa, bwsb, pos, endpos, results}
               text := text.slice{wsa}
               wsb := wsa
               pos := endpos + wsa
               break
   cond:
      last_op =>
         v = {.VOID}
         v.location := {pos, pos}
         results.push{v}
   results



MAX = 1/0

order_map = {

   IFX = {
      wide = {
         ","     => {{2r1111, 1}, {2r1111, 1}}

         "with"  => {{2r1111, 999}, {2r1111, 10}}
         "where" => {{2r1111, 11},  {2r1111, 10}}
         "|>"    => {{2r1111, 11},  {2r1111, 10}}
         "->"    => {{2r1111, 11},  {2r1111, 10}}
         "=>"    => {{2r1111, 11},  {2r1111, 10}}
         "="     => {{2r1111, 11},  {2r1111, 10}}
         ":="    => {{2r1111, 11},  {2r1111, 10}}
         "+="    => {{2r1111, 11},  {2r1111, 10}}
         "-="    => {{2r1111, 11},  {2r1111, 10}}
         "*="    => {{2r1111, 11},  {2r1111, 10}}
         "/="    => {{2r1111, 11},  {2r1111, 10}}
         "<<="   => {{2r1111, 11},  {2r1111, 10}}
         ">>="   => {{2r1111, 11},  {2r1111, 10}}
         ">>>="  => {{2r1111, 11},  {2r1111, 10}}

         ;; Logical
         "when" => {{2r1111, 100}, {2r1111, 101}}
         "||"   => {{2r1111, 110}, {2r1111, 111}}
         "&&"   => {{2r1111, 120}, {2r1111, 121}}
         "or"   => {{2r1111, 110}, {2r1111, 111}}
         "and"  => {{2r1111, 120}, {2r1111, 121}}
         "not"  => {{2r1111, 130}, {2r1111, 131}}

         ;; Comparison
         "==" => {{2r1111, 200}, {2r1111, 201}}
         "!=" => {{2r1111, 200}, {2r1111, 201}}
         ">=" => {{2r1111, 200}, {2r1111, 201}}
         "<=" => {{2r1111, 200}, {2r1111, 201}}
         ">"  => {{2r1111, 200}, {2r1111, 201}}
         "<"  => {{2r1111, 200}, {2r1111, 201}}

         ;; Binary
         "^." => {{2r1111, 400}, {2r1111, 401}}
         "|." => {{2r1111, 410}, {2r1111, 411}}
         "&." => {{2r1111, 420}, {2r1111, 421}}

         ;; Arithmetic
         "<<"  => {{2r0001, 500}, {2r0001, 501}}
         ">>"  => {{2r0001, 500}, {2r0001, 501}}
         ">>>" => {{2r0001, 500}, {2r0001, 501}}
         "+"   => {{2r0001, 550}, {2r0001, 551}}
         "-"   => {{2r0001, 550}, {2r0001, 551}}
         "*"   => {{2r0001, 560}, {2r0001, 561}}
         "/"   => {{2r0001, 560}, {2r0001, 561}}
         "mod" => {{2r0001, 560}, {2r0001, 561}}
         "**"  => {{2r0001, 571}, {2r0001, 570}}

         ;; Others
         default = {{2r1000, 900}, {2r0100, 901}}
         WHITE   = {{2r1111, 1000}, {2r1111, 1001}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
      short = {
         default = {{2r1111, 1900}, {2r1111, 1901}}
         WHITE   = {{2r1111, 2000}, {2r1111, 2001}}
         ","    => {{2r1111, 1},    {2r1111, 1}}
         ":"    => {{2r1111, 1001}, {2r1111, 2}}
      }
   }

   PFX = {
      wide = {
         default = {{2r1111, MAX}, {2r1111, 900}}
         "not"  => {{2r1111, 130}, {2r1111, 131}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "<>" => {{2r1111, MAX}, {2r1111, 5}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
      short = {
         default = {{2r1111, MAX}, {2r1111, 1900}}
         "." => {{2r1111, MAX}, {2r1111, 3000}}
         "#" => {{2r1111, MAX}, {2r1111, 3000}}
         "(" => {{2r1111, MAX}, {2r1111, 1}}
         "[" => {{2r1111, MAX}, {2r1111, 1}}
         "{" => {{2r1111, MAX}, {2r1111, 1}}
      }
   }

   SFX = {
      wide = {
         default = {{2r1111, 901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
      short = {
         default = {{2r1111, 1901}, {2r1111, MAX}}
         ")" => {{2r1111, 1}, {2r1111, MAX}}
         "]" => {{2r1111, 1}, {2r1111, MAX}}
         "}" => {{2r1111, 1}, {2r1111, MAX}}
      }
   }
}



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3

oparse{next, order, finalize} =
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true:
      o = cond:
             [not left_op and not right_op] =>
                DONE
             true =>
                [not left_op and RIGHT]
                 \ or [not right_op and LEFT]
                 \ or order{left_op, right_op}
      o |>
         [== DONE] ->
            return between

         [== LEFT] ->
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1

         [== RIGHT] ->
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}

         [== BOTH] ->
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}

         [== NONE] ->
            throw ["Undefined priority between " + left_op + " and " + right_op]

         other -> throw "OopsC"


consult{{fixity, width, op}} =
   map = order_map[fixity][width]
   map[op] or map.default


order{o1, o2} =
   {code1, ord1} = consult{o1}[1]
   {code2, ord2} = consult{o2}[0]
   cond:
      [[code1 & code2] == 0] => throw {"Cannot mix", o1, o2}
      [ord1 > ord2]  => LEFT
      [ord1 < ord2]  => RIGHT
      [ord1 == ord2] => BOTH


finalize{x} =
   x |>
      {.ID, value} -> value
      {.NUM, value} -> {.value, value}
      {.STR, value} -> {.value, value}
      {.VOID} -> null

      {ops, args*} ->
         ops := [ops.map with [{o} -> o[2]]]
         op = ops[0]
         {ops, args} |>

            {{"WHITE", ":"}, {f, arg, body}} ->
               {.send, f, {.data, {"code", arg}, {"code", body}}}

            {{":"}, {f, body}} ->
               {.send, f, {.data, {"code", body}}}

            {{"with"}, {target, body}} ->
               body := body |>
                  {.multi, rest*} -> rest
                  other -> {body}
               target |>
                  null? ->
                     {.data}.concat{body}
                  {.send, f, {.data, args*}} ->
                     {.send, f, {.data}.concat{args}.concat{body}}
                  {.data, args*} ->
                     target.concat{body}
                  other ->
                     {.send, target, {.data}.concat{body}}

            {{"[" or ",", _*}, _} ->
               cond:
                  [op == "["] => args := args.slice{1, -1}
               args := args.filter{f} where
                  f{x} = [x !== null]

               result = args |>
                  {} -> throw ["At least one expression must be enclosed in []"]
                  {x} -> x
                  other -> {.multi}.concat{args}
               result

            {{"{", _*}, _} ->
               {.data}.concat{args.slice{1, -1}.filter{f}} where
                  f{x} = [x !== null]

            {{.WHITE}, _} ->
               {.send}.concat{args}

            {{_}, {null?, null?}} ->
               op
            {{_}, {a, b}} ->
               {.send, op, {.data, a, b}}

            other ->
               throw {"Unknown node", ops, args}

      other -> throw "OopsE"


parse{text} =
   results = tokenize{text}
   ;; ___lib.pr{results}
   next{} = results.shift{}
   oparse{next, order, finalize}


Env{parent} =
   store = Object{}
   self{expr} =
      {.bind_env, self, expr}
   self.resolve := {name} ->
      attempt = store[name]
      cond:
         attempt => attempt
         true => self.parent.resolve{name}
   self.register := {name, value} ->
      store[name] := value
   self.register_macro := {name, m} ->
      store[name] := {.macro, m}
   self.fork := {} ->
      Env{self}
   self.parent := parent
   self.store := store
   self


js_contexts = {
   js_for = {.multi, .multi, .multi, .multi}
}


expand{env, context, expr} =
   expr := expand.step{env, context, expr}

   expr |>
      String? -> expr

      null? -> null
      undefined? -> throw ["undefined? why?"]

      {.send, f, arg} ->
         f := expand{env, .head, f}
         {.send, f, expand{env, .tail, arg}}

      {.value, v} -> expr

      {type and [.multi or .code or .array or .object or .splice], args*} ->
         arr = {}
         while [args.length > 0]:
            x = expand.step{env, type, args.shift{}}
            x |>
               {.splice, stmts*} ->
                  args := stmts.concat{args}
               other ->
                  arr.push{x}
         {type}.concat{arr.map{f}} where
            f{x} = expand{env, type, x}

      {.data, args*} ->

         is_obj = false
         obj = {.object}
         arr = {.array}

         while [args.length > 0]:
            x = expand.step{env, .data, args.shift{}}
            x |>
               {.assoc} -> is_obj := true
               {.assoc, k, v} ->
                  is_obj := true
                  obj.push with {.array, k, v}
               {.splice, exprs*} ->
                  args := exprs.concat{args}
               other ->
                  arr.push{other}
         r = cond:
            [[arr.length > 1] and is_obj] =>
               arr.push{obj}
               arr
            is_obj =>
               obj
            true =>
               arr
         expand{env, context, r}

      {.lambda, bindings, body} ->
         {.lambda, bindings.map{{x} -> expand{env, .decl, x}}
                   expand{env, .multi, body}}

      {.declare, binding, value} ->
         {.declare, expand{env, .decl, binding}
                    expand{env, .multi, value}}

      {.assign, lhs, rhs} ->
         {.assign, expand{env, .decl, lhs}
                   expand{env, .multi, rhs}}

      {type && [.js_while or .js_for or .js_break
                \ or .js_continue or .js_return
                \ or .js_throw or .if], args*} ->
         ctxs = js_contexts[type] or {}
         {type}.concat{args.map{f}} where
            f{x, i} = expand{env, ctxs[i] or .expr, x}

      other -> throw {"Oops", expr, context}



expand.step := {env, context, expr} ->
   expr |>
      String? ->
         v = env.resolve{expr}
         {v, context} |>
            {undefined?, _} -> expr
            {{.macro, m}, .head} -> v
            {{.macro, m}, _} -> expand.step{env, context, m{env, context, null}}
            other -> v

      null? -> null
      undefined? -> throw ["undefined? why?"]

      {.macro, m} ->
         cond:
            [context == "head"] => expr
            true => expand.step{env, context, m{env, context, null}}

      {.send, f, arg} ->
         f := expand.step{env, .head, f}
         f |>
            {.macro, m} -> expand.step{env, context, m{env, context, arg}}
            other -> expr

      {type, args*} ->
         expr

      other ->
         throw {"Oops2", expr}


aslist{expr} =
   expr |>
      null? -> {null}
      undefined? -> {undefined}
      {.multi, args*} -> args
      other -> {other}


nullenv = {resolve{x} = undefined}


stdenv = Env{nullenv}

stdenv.register{"+", "___plus"}
stdenv.register{"-", "___minus"}
stdenv.register{"*", "___times"}
stdenv.register{"/", "___div"}
stdenv.register{"%", "___mod"}
stdenv.register{"^", "___binxor"}
stdenv.register{"&", "___binand"}
stdenv.register{"|", "___binor"}
stdenv.register{"~", "___binnot"}
stdenv.register{"&&", "___and"}
stdenv.register{"||", "___or"}
stdenv.register{"!", "___not"}
stdenv.register{"and", "___and"}
stdenv.register{"or", "___or"}
stdenv.register{"not", "___not"}
stdenv.register{"===", "___is"}
stdenv.register{"!==", "___isnt"}
stdenv.register{"!=", "___neq"}
stdenv.register{"<", "___lt"}
stdenv.register{">", "___gt"}
stdenv.register{"<=", "___lte"}
stdenv.register{">=", "___gte"}
stdenv.register{"<<", "___shl"}
stdenv.register{">>", "___shr"}
stdenv.register{">>>", "___shr2"}
stdenv.register{"in", "___in"}
stdenv.register{"instanceof", "___instanceof"}
stdenv.register{"++", "___plusplus"}
stdenv.register{"--", "___minusminus"}


;;stdenv.register_macro{"TEST"} with {env, context, expr} -> [
;;   {.splice, "a", "b"}
;;]


stdenv.register_macro{"**"} with {env, context, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .pow}}, {.data, a, b}}

stdenv.register_macro{"//"} with {env, context, {.data, a, b}} ->
   {.send, {.send, .Math, {.value, .floor}}, {.data, div}} where
      div = {.send, "___div", {.data, a, b}}

stdenv.register_macro{"<>"} with {env, context, {.data, null?, x}} ->
   {.send, {.send, "___lib", {.value, "pr"}}, {.data, x}}


make_checker{value, op} = {env, context, expr} ->
   {.send, op, {.data, expr[1], value}}


stdenv.register_macro{"#"} with {env, context, {.data, null?, tag}} ->
   tag := {.value, tag}
   {.macro, f} where f{env, context, expr} =
      cond:
         [context == "pattern"] =>
            {.check, {.macro, f}, expr or {.ignore}} where f{env, context, expr} =
               {.send, "___eq", {.data, {.send, expr[1], {.value, "#"}}, tag}}
         true =>
            {.send, {.send, "___lib", {.value, "Struct"}}, d} where d =
               {.data, tag}.concat{expr.slice{1}}


stdenv.register_macro{"when"} with {env, context, {.data, pattern, condition}} ->
   pattern |>
      null? -> {.test, condition, {.ignore}}
      other -> {.test, condition, pattern}

andf{env, context, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.all, a, b}
      {_, null?} ->
         "___and"
      other ->
         {.send, "___and", expr}
stdenv.register_macro{"&&"} with andf
stdenv.register_macro{"and"} with andf

orf{env, context, expr} =
   {context, expr} |>
      {.pattern, {.data, a, b}} ->
         {.any, a, b}
      {_, null?} ->
         "___or"
      other ->
         {.send, "___or", expr}
stdenv.register_macro{"||"} with orf
stdenv.register_macro{"or"} with orf


partial_pattern{operator} = {env, context, expr} ->
   {context, expr} |>
      {.pattern, {.data, null?, val}} ->
         {.check, {.macro, make_checker{val, operator}}, {.ignore}}
      {_, null?} ->
         operator
      other ->
         {.send, operator, expr}

stdenv.register_macro{"=="} with partial_pattern{"___eq"}
stdenv.register_macro{"!="} with partial_pattern{"___neq"}
stdenv.register_macro{"<="} with partial_pattern{"___leq"}
stdenv.register_macro{">="} with partial_pattern{"___geq"}
stdenv.register_macro{"<"} with partial_pattern{"___lt"}
stdenv.register_macro{">"} with partial_pattern{"___gt"}


stdenv.register_macro{"*"} with {env, context, expr} ->
   {context, expr} |>
      {.pattern, {.data, val, null?}} ->
         {.dynsplice, val}
      {_, null?} ->
         "___times"
      other ->
         {.send, "___times", expr}


stdenv.register_macro{"."} with {env, context, expr} ->
   expr |>
      {.data, null?, String? s} ->
         {.value, s}
      other ->
         throw {"invalid", expr}


stdenv.register_macro{"where"} with {env, context, {.data, a, b}} ->
   {.send, .let, {.data, {.code, b}, {.code, a}}}


stdenv.register_macro{"let"} with {env, context, {.data, {.code, a}, {.code, b}}} ->
   bindings = aslist{a}
   body = aslist{b}
   {.multi}.concat{bindings}.concat{body}


stdenv.register_macro{"->"} with {env, context, {.data, args, stmts}} ->
   body = {.multi}
   args := args.slice{1}.map with {x} -> x |>
      String? -> x
      other ->
         t = gensym{}
         body.push with {.send, "=", {.data, x, t}}
         t
   body.push{stmts}
   {.lambda, args, body}


stdenv.register_macro{"=>"} with {env, context, {.data, binding, value}} ->
   cond:
      [context == .data] =>
         {.assoc, binding, value}
      true =>
         throw ["Illegal context for '=>' (" + context + ")"]


stdenv.register_macro{"="} with {env, context, expr} ->
   {context, expr} |>

      {.multi, {.data, lhs, rhs}} ->
         p = parse_lhs{env, lhs, rhs}
         vars = make_declarations{p[0]}
         r = {.splice}.concat{vars}
         clauses = p[1]

         mkif{x} =
            {.if, x, {.value, false}, {.js_throw, {.value, "a condition failed"}}}

         cond:
            [clauses.length == 1] =>
               clause = clauses[0]
               last = clause[clause.length - 1]
               last |>
                  {.value, true?} ->
                     cond:
                        [[vars.length == 1] and [clause.length == 3]] =>
                           r := {.declare}.concat{clause[1].slice{1}}
                        true =>
                           r := r.concat{clause.slice{1, -1}}
                  other ->
                     r.push{mkif{clause}}
            true =>
               ands = make_pattern_test{clauses}
               r.push{mkif{ands}}
         r

      {.data, null?} ->
         {.assoc}

      {.data, {.data, {.send, f, {.data, args*}}, value}} ->
         {.assoc, {.value, f}, {.lambda, args, value}}

      {.data, {.data, binding, value}} ->
         {.assoc, {.value, binding}, value}

      other ->
         throw ["Illegal context for '=' (" + context + ")"]


make_assigner{op} = {env, context, {.data, a, b}} ->
   {.assign, a, {.send, op, {.data, a, b}}}

stdenv.register_macro{":="} with {env, context, {.data, a, b}} ->
   {.assign, a, b}

stdenv.register_macro{"+="} with make_assigner{"+"}
stdenv.register_macro{"-="} with make_assigner{"-"}
stdenv.register_macro{"*="} with make_assigner{"*"}
stdenv.register_macro{"/="} with make_assigner{"/"}
stdenv.register_macro{"<<="} with make_assigner{"<<"}
stdenv.register_macro{">>="} with make_assigner{">>"}
stdenv.register_macro{">>>="} with make_assigner{">>>"}


stdenv.register_macro{"if"} with {env, context, {.data, test, a, b}} ->
   {.if, test, a, b}

stdenv.register_macro{"cond"} with {env, context, {.data, {.code, clauses}}} ->
   handle{xs} =
      cond:
         [xs.length == 0] => {.value, false}
         true =>
            first = xs[0][2]
            rest = xs.slice{1}
            {.if, first[1], first[2], handle{rest}}
   handle{aslist{clauses}}


stdenv.register_macro{"while"} with {env, context, expr} ->
   {.data, {.code, test}, {.code, body}} = expr
   {.js_while, test, body}

stdenv.register_macro{"for"} with {env, context, expr} ->
   {.data, {.code, {.multi, a, b, c}}, {.code, body}} = expr
   {.js_for, a, b, c, body}

stdenv.register_macro{"return"} with {env, context, expr} ->
   {.js_return, expr}

stdenv.register_macro{"throw"} with {env, context, expr} ->
   {.js_throw, expr}

stdenv.register_macro{"break"} with {env, context, expr} ->
   {.js_break}

stdenv.register_macro{"continue"} with {env, context, expr} ->
   {.js_continue}


rx_wrap{x} =
   "(?:" + x + ")"

rx_quote{x} =
   x.replace{Rxg{>>".?*+^$[](){}|\\\\"}, "\\$1"}

rx_quote2{x} =
   x.replace{Rxg{>>"[](){}^"}, "\\$1"}

rx_build{expr} =
   expr |>
      .any -> "."
      .start -> "^"
      .end -> "$"
      .alpha -> "\\a"
      .digit -> "\\d"
      .word -> "\\w"
      .space -> "\\s"
      .boundary -> "\\b"
      .a -> "\\a"
      .d -> "\\d"
      .w -> "\\w"
      .s -> "\\s"
      .b -> "\\b"

      {.value, x} -> rx_quote{x}
      {.send, "||", {.data, a, b}} ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      {.send, "or", {.data, a, b}} ->
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      {.send, "*", {.data, a, null?}} ->
         rx_wrap{rx_build{a} + "*"}
      {.send, "+", {.data, a, null?}} ->
         rx_wrap{rx_build{a} + "+"}
      {.send, "?", {.data, a, null?}} ->
         rx_wrap{rx_build{a} + "?"}
      {.send, ">>", {.data, null?, b}} ->
         ["[" + x + "]"] where
            x = rx_quote2{b[1]}
      {.send, ">>!", {.data, null?, b}} ->
         ["[^" + x + "]"] where
            x = rx_quote2{b[1]}
      {.data, args*} ->
         "(" + args.map{rx_build}.join{""} + ")"
      {.multi, args*} ->
         "(?:" + args.map{rx_build}.join{""} + ")"
      otherA -> throw "OopsF"


stdenv.register_macro{"Rx"} with {env, context, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}}}

stdenv.register_macro{"Rxg"} with {env, context, expr} ->
   {.send, "RegExp", {.array, {.value, rx_build{expr}}, {.value, "g"}}}


stdenv.register_macro{"?"} with {env, context, {.data, expr, null?}} ->
   checker = expr |>
      null? -> {.send, expr, {.value, "__check__"}}
      .String ->
         {.macro, f} where f{env, context, {.data, expr}} =
            {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                     {.value, "string"}}}
      .Number ->
         {.macro, f} where f{env, context, {.data, expr}} =
            {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                     {.value, "number"}}}
      .true -> {.macro, make_checker{{.value, true}, "___is"}}
      .false -> {.macro, make_checker{{.value, false}, "___is"}}
      .null -> {.macro, make_checker{{.value, null}, "___is"}}
      .undefined -> {.macro, make_checker{{.value, undefined}, "___is"}}
      other -> {.send, expr, {.value, "__check__"}}

   mac{env, context, expr} =
      context |>
         .pattern -> {.check, checker, expr or {.ignore}}
         other -> {.send, checker, {.data, expr}}

   {.macro, mac}


;; stdenv.register_macro{"!"} with {env, context, expr} -> [
;;    projector = {.send, expr[1], {.value, "__project__"}}
;;    mac{env, context, expr} = [
;;       cond: [
;;          [context == "pattern"] => [
;;             {.project, projector, expr}
;;          ]
;;          true => [
;;             {.send, projector, {.data, expr}}
;;          ]
;;       ]
;;    ]
;;    {.macro, mac}
;; ]


tempnum = 0
gensym{} =
   name = "_tmp" + tempnum
   tempnum := tempnum + 1
   name

parse_lhs{env, lhs, rhs} =
   vars = {}
   clauses = {}
   current = {.multi}

   mktemp{} =
      t = gensym{}
      vars.push{t}
      t

   newclause{} =
      cond:
         [current.length > 1] =>
            clauses.push{current}
      current := {.multi}

   helper{lhs, curr} =
      helper_noexpand{expand.step{env, .pattern, lhs}, curr}

   helper_noexpand{lhs, curr} =
      lhs |>

         ;; [null? or "_"] -> false

         null? ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{{.value, null}, "___eq"}}, {.ignore}}

         ["_" or {.ignore}] ->
            current.push{curr}
            current.push{{.value, true}}

         String? ->
            vars.push{lhs}
            current.push{{.assign, lhs, curr}}
            current.push{{.value, true}}

         {.value, v} ->
            helper_noexpand{x, curr} where
               x = {.check, {.macro, make_checker{lhs, "___eq"}}, {.ignore}}

         {.test, condition, pattern} ->
            helper{pattern, curr}
            current.push{condition}
            newclause{}

         {.all, xs*} ->
            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
            }
            xs.forEach with {x} ->
               helper{x, temp}

         {.any, xs*} ->
            normalize{vars} =
               vars.filter{{x} -> x.slice{0, 4} !== "_tmp"}.sort{}.join{","}

            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
            }
            myvars = undefined
            clauses = {}
            xs.forEach with {x} ->
               p = parse_lhs{env, x, temp}
               cond:
                  [myvars === undefined] =>
                     myvars := p[0]
                  [normalize{p[0]} !== normalize{myvars}] =>
                     throw with {
                        "Must have the same set of variables in both branches!"
                        myvars
                     }
                  true =>
                     vars := vars.concat{p[0]}
               clauses.push with make_pattern_test{p[1]}
            current.push with make_or_pattern{clauses}
            vars := vars.concat{myvars}
            newclause{}

         {.check, checker, expr} ->
            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
               {.send, checker, {.data, temp}}
            }
            newclause{}
            helper{expr, temp}

         {.send, fname, spec} ->
            helper{fname, {.send, "->", {.data, spec, curr}}}

         {.data, specs*} ->
            fw = 0
            bw = 0
            rest = undefined
            members = specs.map with {x} ->
               v = expand.step{env, .pattern, x}
               v |>
                  {.dynsplice, variable} ->
                     rest := variable
                  other ->
                     cond:
                        [rest === undefined] => [fw := fw + 1]
                        true => [bw := bw + 1]
               v

            cmp =
               cond:
                  [rest === undefined] => "___eq"
                  true => "___gte"
            temp = mktemp{}
            len = mktemp{}

            current := current.concat with {
               {.assign, temp, curr}
               {.send, "___instanceof", {.data, temp, "Array"}}
            }
            newclause{}

            current := current.concat with {
               {.assign, len, {.send, temp, {.value, "length"}}}
               ;; Bounds check
               {.send, cmp, {.data, len, {.value, fw + bw}}}
            }
            newclause{}

            for [j = 0, j < fw, ++j]:
               helper_noexpand{members[j], {.send, temp, {.value, j}}}

            cond: [[rest !== undefined] => [
               slice = cond:
                  [bw > 0] => {.data, {.value, fw}, {.value, -bw}}
                  true => {.data, {.value, fw}}
               helper_noexpand{
                  members[fw][1]
                  {.send, {.send, temp, {.value, "slice"}}, slice}
               }
            ]]

            for [j = 0, j < bw, ++j]:
               helper_noexpand{members[fw + j + 1],
                               {.send, temp, {.send, "___minus",
                                              {.data, len, {.value, bw - j}}}}}
         other -> throw "OopsG"

   helper{lhs, rhs}
   cond:
      [current.length > 1] => clauses.push{current}
   {vars, clauses}


make_declarations{vars} =
   vars.map with {name} ->
      {.declare, name, {.value, undefined}}

make_pattern_test{clauses} =
   ands = clauses.pop{}
   while [clauses.length > 0]:
      ands := {.send, "___and", {.data, clauses.pop{}, ands}}
   ands

make_or_pattern{clauses} =
   ors = clauses.pop{}
   while [clauses.length > 0]:
      ors := {.send, "___or", {.data, clauses.pop{}, ors}}
   ors

stdenv.register_macro{"|>"} with {env, context, {.data, to_match, cl}} ->
   temp = gensym{}
   clauses = cl |>
      {.multi, cls*} -> cls
      other -> {other}
   decls = {.multi, {.declare, temp, to_match}}
   r = {.js_throw, {.data, {.value, "Could not find a match"}, temp}}
   ;; r = {.js_throw, {.value, "Could not find a match"}}
   while [clauses.length > 0]:
      {.send, "->", {.data, lhs, body}} = clauses.pop{}
      p = parse_lhs{env, lhs, temp}
      test = make_pattern_test{p[1]}
      r := {.if, test, body, r}
      decls := decls.concat{make_declarations{p[0]}}
   decls.push{r}
   decls





js_op_table = {
   ___plus = "+"
   ___minus = "-"
   ___times = "*"
   ___div = "/"
   ___mod = "%"
   ___binxor = "^"
   ___binand = "&"
   ___binor = "|"
   ___binnot = "~"
   ___and = "&&"
   ___or = "||"
   ___not = "!"
   ___is = "==="
   ___isnt = "!=="
   ___eq = "=="
   ___neq = "!="
   ___lt = "<"
   ___gt = ">"
   ___lte = "<="
   ___gte = ">="
   ___shl = "<<"
   ___shr = ">>"
   ___shr2 = ">>>"
   ___in = " in "
   ___instanceof = " instanceof "
   ___plusplus = "++"
   ___minusminus = "--"
}


translate{expr, mode} =

   expr |>

      String? ->
         translate.expr{translate.mangle{expr}, mode}

      null? ->
         translate.expr{"null", mode}

      {.value, v} ->
         r = v |>
            String? ->
               repl = {
                  "\"" => "\\\""
                  "\n" => "\\n"
                  "\\" => "\\\\"
               }
               v := v.replace{Rxg{"\"" or "\\" or "\n"}, {m} -> repl[m]}
               "\"" + v + "\""
            [Number? or true? or false? or null? or undefined?] ->
               String{v}
            other ->
               "?!?[" + v + "]?!?"
         translate.expr{r, mode}

      {.lambda, bindings, body} ->
         translate.expr{"function("+a+"){"+b+"}", mode} where
            a = bindings.join{","}
            b = translate.body{body, .return}

      {.if, test, pos, neg} ->
         mode |>
            .expr -> translate.body{expr, .expr}
            other ->
               ["if(" + a + "){" + b + "}else{" + c + "}"] where
                  a = translate{test, .expr}
                  b = translate{pos, mode}
                  c = translate{neg, mode}

      {.js_while, test, body} ->
         mode |>
            .expr -> translate.body{expr, .expr}
            other ->
               ["while(" + a + "){" + b + "}"] where
                  a = translate{test, .expr}
                  b = translate{body, .stmt}

      {.js_for, x, y, z, body} ->
         mode |>
            .expr -> translate.body{expr, .expr}
            other ->
               ["for("+a+b+c+"){"+d+"}"] where
                  a = translate{x, .stmt}
                  b = translate{y, .stmt}
                  c = translate{z, .expr}
                  d = translate{body, .stmt}

      {.declare, binding, {.value, undefined?}} ->
         mode |>
            [.expr or .return] -> throw "Invalid in expr ctx"
            other ->
               ["var " + a + ";"] where
                  a = translate{binding, .expr}

      {.declare, binding, value} ->
         mode |>
            [.expr or .return] -> throw "Invalid in expr ctx"
            other ->
               ["var " + a + "=" + b + ";"] where
                  a = translate{binding, .expr}
                  b = translate{value, .expr}

      {.assign, {.send, obj, msg}, rhs} ->
         translate.expr{"(" + a + "[" + b + "]=" + c + ")", mode} where
            a = translate{obj, .expr}
            b = translate{msg, .expr}
            c = translate{rhs, .expr}

      {.assign, lhs, rhs} ->
         translate.expr{"(" + a + "=" + b + ")", mode} where
            a = translate{lhs, .expr}
            b = translate{rhs, .expr}

      {.multi, args*} ->
         isdecl{x} = x |>
            {.declare, variable, value} -> true
            other -> false
         cond:
             [args.length == 1] => translate{args[0], mode}
             [[mode == "expr"] and [not args.some{isdecl}]] =>
                ["(" + xs.join{","} + ")"] where
                   xs = args.map with {x} ->
                      translate{x, .expr}
             true => translate.body{expr, mode}

      {.splice, args*} ->
         translate{{.multi}.concat{args}, mode}

      {.js_break} ->
         cond:
            [mode == "expr"] => throw "Invalid break in ctx"
            true => "break;"

      {.js_continue} ->
         cond:
            [mode == "expr"] => throw "Invalid continue in ctx"
            true => "continue;"

      {.js_return, value} ->
         cond:
            [mode == "expr"] => throw "Invalid return in ctx"
            true => "return " + translate{value, .expr} + ";"

      {.js_throw, value} ->
         cond:
            ;; [mode == "expr"] => throw "Invalid throw in ctx"
            true => "throw " + translate{value, .expr} + ";"

      {.array, args*} ->
         r = ["[" + args.map{f}.join{","} + "]"] where
            f{x} = translate{x, .expr}
         translate.expr{r, mode}

      {.object, args*} ->
         r = ["({" + args.map{f}.join{","} + "})"] where
            f{x} =
               a = translate{x[1], .expr}
               b = translate{x[2], .expr}
               a + ":" + b
         translate.expr{r, mode}

      {.send, f, msg and {.value, s}} ->
         cond:
            [[typeof{s} == "string"]
             \ and s.match{Rx[start, [>>"a-zA-Z_$"]+, end]}] =>
               translate.expr{trf + "." + trmsg, mode} where
                  trf = translate{f, .expr}
                  trmsg = translate{s, .expr}
            true =>
               translate.expr{trf + "[" + trmsg + "]", mode} where
                  trf = translate{f, .expr}
                  trmsg = translate{msg, .expr}

      {.send, f, {.array, args*}} ->
         op = [typeof{f} == "string"] and js_op_table[f]
         cond:
            op =>
               translate.expr{translate.op{op, args[0], args[1]}, mode}
            true =>
               translate.expr{trf+"("+trargs.join{","}+")", mode} where
                  trf = translate{f, .expr}
                  trargs = args.map with {x} ->
                     translate{x, .expr}

      ;; {.send, f, msg} ->
      ;;    translate.expr{trf + "[" + trmsg + "]", mode} where
      ;;       trf = translate{f, .expr}
      ;;       trmsg = translate{msg, .expr}

      {.send, f, msg} ->
         translate.expr{"___lib.send(" + trf + "," + trmsg + ")", mode} where
            trf = translate{f, .expr}
            trmsg = translate{msg, .expr}

      other ->
         throw other


translate.mangle := {name} ->
   tr = {
      "+" => "__plus__"
      "-" => "__minus__"
      "*" => "__asterisk__"
      "/" => "__slash__"
      "%" => "__percent__"
      "^" => "__caret__"
      "#" => "__hash__"
      "&" => "__amp__"
      "|" => "__pipe__"
      "@" => "__at__"
      "!" => "__bang__"
      "?" => "__qmark__"
      "=" => "__equal__"
      "<" => "__lt__"
      ">" => "__gt__"
      "~" => "__tilde__"
      "." => "__dot__"
   }
   r = {}
   for [i = 0, i < name.length, ++i]:
      c = name[i]
      r.push{tr[c] or c}
   r.join{""}


translate.body := {b, mode} ->
   orig := b
   b := aslist{b}
   trst{stmt} = translate{stmt, .stmt}
   mode |>
      .expr ->
         translate{x, mode} where
            x = {.send, {.lambda, {}, orig}, {.array}}
      .return ->
         stmts = b.slice{0, -1}
         ret = b[b.length - 1]
         stmts.map{trst}.join{""} + translate{ret, .return}
      .stmt ->
         b.map{trst}.join{""}
      other -> throw "OopsH"

translate.expr := {x, mode} ->
   mode |>
      .expr -> x
      .stmt -> x + ";"
      .return -> "return " + x + ";"
      other -> throw "OopsI"

translate.op := {op, a, b} ->
   e := cond:
           [a === null] => op + translate{b, .expr}
           [b === null] => translate{a, .expr} + op
           true => translate{a, .expr} + op + translate{b, .expr}
   "(" + e + ")"



fs = require{.fs}

file = process.argv[2]
;; file = "test.eg"

fs.readFile{file, "utf8", f} where
   f{err, data} =
      p = parse{data}
      ex = expand{stdenv, .top, {.multi, p}}
      ;; console.log with p
      ;; console.log with ex
      prelude = "var ___lib=require(\"./lib\");"
      console.log with prelude + translate{ex, .stmt}
