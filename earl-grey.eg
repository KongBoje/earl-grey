
special_ops = {
   "(" => .PFX
   "[" => .PFX
   "{" => .PFX
   ")" => .SFX
   "]" => .SFX
   "}" => .SFX
   "," => .IFX
   ":" => .IFX
   "." => .PFX
}

regexps = {
   {op3,    op_f}
   {id,     id_f}
   {num,    num_f}
   {str,    str_f}
   {op,     op_f}
   {op2,    op_f}
   {indent, indent_f}
   {cmnt,   cmnt_f}
   {unkn,   unkn_f}
} where [

  id = Rx [
     start
     [>>"a-zA-Z$_"]
     [>>"a-zA-Z$_0-9"]*
  ]

  id_f = {m, wsb, wsa, last_op} -> {.ID, .ID, m[0]}


  num = Rx [
     start
     {d+}
     [".", {d+}]?
     [>>"eE", {[>>"+-"]?, d+}]?
  ]

  ;;num_f = {m, wsb, wsa, last_op} -> {.ID, .NUM, m[1], m[2], m[3]}
  num_f = {m, wsb, wsa, last_op} -> {.ID, .NUM, m[0]}


  str = Rx [
     start
     "\""
     {["\\\\" || "\\\"" || [>>! "\""]]*}
     "\""
  ]

  str_f = {m, wsb, wsa, last_op} -> [
     repl = {
        "\\\"" => "\""
        "\\\\" => "\\"
        "\\n" => "\n"
     }
     r = m[1].replace{Rxg{"\\\"" || "\\\\" || "\\n"}, {m} -> repl[m]}
     {.ID, .STR, r}
  ]

  op = Rx [
     start
     [>> "+\\-*/~^<>=%&|?!#.:"]+
  ]

  op2 = Rx [
     start
     >>"([{}]),"
  ]

  op3 = Rx [
     start
     "with" || "where" || "and" || "or" || "in" || "instanceof"
     boundary
  ]

  op_f = {m, wsb, wsa, last_op} -> [
     op = m[0]
     cond: [
        [op in special_ops] => [
           fixity = special_ops[op]
           width = [
              cond: [
                 [fixity == "IFX"] => if{wsb || wsa, .wide, .short}
                 [fixity == "SFX"] => if{wsb, .wide, .short}
                 [fixity == "PFX"] => if{wsa, .wide, .short}
              ]
           ]
           {.OP, fixity, width, op}
        ]
        [wsa && wsb] => [
           {.OP, [cond: [[last_op => .PFX], [true => .IFX]]], .wide, op}
        ]
        [[!wsa] && [!wsb]] => [
           {.OP, [cond: [[last_op => .PFX], [true => .IFX]]], .short, op}
        ]
        wsa => [
           {.OP, [cond: [[last_op => .PFX], [true => .SFX]]], .short, op}
        ]
        wsb => [
           {.OP, .PFX, .short, op}
        ]
        true => [
           {.OP, .PFX, .short, op}
        ]
     ]
  ]

  indent = Rx [
     start
     ["\n", " "*]+
  ]

  indent_f = {m, wsb, wsa, last_op} -> {.OP, .IFX, .wide, ","}


  cmnt = Rx [
     start
     ";"
     [>>!"\n"]*
  ]

  cmnt_f = {m, wsb, wsa, last_op} -> {.IGNORE}


  unkn = Rx [
     start
     any
  ]

  unkn_f = {m, wsb, wsa, last_op} -> throw ["unknown character: " + m[0]]

]


;; TODO: ignore blank lines before continuation
ws_re = Rx[" "*, ["\n", " "*, "\\", " "*]*]
;; ws_re = Rx[" "*]


tokenize{text} = [
   last_op = true
   results = {}
   wsb = text.match{ws_re}[0].length
   text := text.slice{wsb}
   pos := wsb
   while text: [
      for [i = 0, i < regexps.length, ++i]: [
         spec = regexps[i]
         re = spec[0]
         m = text.match{re}
         cond: [
            m => [
               fn = spec[1]
               skip = m[0].length
               text := text.slice{skip}
               wsa = text.match{ws_re}[0].length
               r = fn{m, wsb > 0, wsa > 0, last_op}
               type = r[0]
               result = r.slice{1}
               result.location := {pos, pos + skip}
               cond: [
                  [type == .IGNORE] => [
                     null
                  ]
                  [type == .ID] => [
                     cond: [
                        [!last_op] => [
                           w = {.IFX, if{wsa || wsb, .wide, .short}, .WHITE}
                           w.location := {pos, pos}
                           results.push{w}
                        ]
                     ]
                     results.push{result}
                     last_op := false
                  ]
                  [type == .OP] => [
                     cond: [
                        last_op => [
                           v = {.VOID}
                           v.location := {pos, pos}
                           results.push{v}
                        ]
                     ]
                     cond: [
                        [result[0] == .IFX] => [
                           results.push{result}
                           last_op := true
                        ]
                        [result[0] == .PFX] => [
                           cond: [
                              [!last_op] => [
                                 w = {.IFX, if{wsa || wsb, .wide, .short}, .WHITE}
                                 w.location := {pos, pos}
                                 v = {.VOID}
                                 v.location := {pos, pos}
                                 results.push{w}
                                 results.push{v}
                              ]
                           ]
                           results.push{result}
                           last_op := true
                        ]
                        [result[0] == .SFX] => [
                           results.push{result}
                           v = {.VOID}
                           v.location := {pos + skip, pos + skip}
                           results.push{v}
                           last_op := false
                        ]
                     ]
                  ]
               ]
               text := text.slice{wsa}
               wsb := wsa
               pos := pos + skip + wsa
               break
            ]
         ]
      ]
   ]
   cond: [
      last_op => [
         v = {.VOID}
         v.location := {pos, pos}
         results.push{v}
      ]
   ]
   results
]



MAX = 1/0

order_map = {

   IFX = {
      wide = {
         default = {900, 901}
         WHITE = {1000, 1001}
         "," => {1, 1}
         "with" => {11, 10}
         "where" => {11, 10}
         "->" => {11, 10}
         "=>" => {11, 10}
         "=" => {11, 10}
         ":=" => {11, 10}
         "+" => {300, 301}
         "*" => {400, 401}
         "**" => {501, 500}
         ":" => {1001, 2}
      }
      short = {
         default = {1900, 1901}
         WHITE = {2000, 2001}
         "," => {1, 1}
         ":" => {1001, 2}
      }
   }

   PFX = {
      wide = {
         default = {MAX, 900}
         "." => {MAX, 3000}
         "#" => {MAX, 3000}
         "(" => {MAX, 1}
         "[" => {MAX, 1}
         "{" => {MAX, 1}
      }
      short = {
         default = {MAX, 1900}
         "." => {MAX, 3000}
         "#" => {MAX, 3000}
         "(" => {MAX, 1}
         "[" => {MAX, 1}
         "{" => {MAX, 1}
      }
   }

   SFX = {
      wide = {
         default = {901, MAX}
         ")" => {1, MAX}
         "]" => {1, MAX}
         "}" => {1, MAX}
      }
      short = {
         default = {1901, MAX}
         ")" => {1, MAX}
         "]" => {1, MAX}
         "}" => {1, MAX}
      }
   }
}



DONE = -1
NONE = 0
LEFT = 1
RIGHT = 2
BOTH = 3

oparse{next, order, finalize} = [
   between = finalize{next{}}
   right_op = next{}
   stack = {}
   left_op = null
   current = null
   while true: [
      o = cond: [
             [[!left_op] && [!right_op]] => [
                DONE
             ]
             true => [
                [[!left_op] && RIGHT]
                 \ || [[!right_op] && LEFT]
                 \ || order{left_op, right_op}
             ]
          ]
      o |> [
         [== DONE] -> [
            return between
         ]
         [== LEFT] -> [
            current.push{between}
            between := finalize{current}
            v = stack.pop{}
            left_op := v 0
            current := v 1
         ]
         [== RIGHT] -> [
            stack.push{{left_op, current}}
            left_op := right_op
            current := {{right_op}, between}
            between := finalize{next{}}
            right_op := next{}
         ]
         [== BOTH] -> [
            current[0].push{right_op}
            current.push{between}
            left_op := right_op
            between := finalize{next{}}
            right_op := next{}
         ]
         [== NONE] -> [
            throw ["Undefined priority between " + left_op + " and " + right_op]
         ]
      ]
   ]
]


consult{o} = [
   map = order_map[o 0][o 1]
   map[o 2] || map.default
]

order{o1, o2} = [
   ord1 = consult{o1}[1]
   ord2 = consult{o2}[0]
   cond: [
      [ord1 > ord2]  => LEFT
      [ord1 < ord2]  => RIGHT
      [ord1 == ord2] => BOTH
   ]
]

finalize{x} = [
   x |> [
      {.ID, value} -> value
      {.NUM, value} -> {.value, parseFloat{value}}
      {.STR, value} -> {.value, value}
      {.VOID} -> null
      {ops, args*} -> [
         opcat = [ops.map with [{o} -> o[2]]].join{""}
         op = ops[0][2]
         {opcat, args} |> [
            {"WHITE:", {f, arg, body}} -> [
               {"send", f, {"data", {"code", arg}, {"code", body}}}
            ]
            {":", {f, body}} -> [
               {"send", f, {"data", {"code", body}}}
            ]
            {"with", {target, body}} -> [
               body := body |> [
                  {.multi, rest*} -> rest
                  other -> {body}
               ]
               target |> [
                  {.send, f, {.data, args*}} -> [
                     {.send, f, {.data}.concat{args}.concat{body}}
                  ]
                  {.data, args*} -> [
                     target.concat{body}
                  ]
                  other -> [
                     {"send", target, {"data"}.concat{body}}
                  ]
               ]
            ]
            other -> [
               cond: [

                  [[op == "["] || [op == ","]] => [
                     cond: [
                        [op == "["] => args := args.slice{1, -1}
                     ]
                     args := args.filter{f} where [
                        f{x} = [x !== null]
                     ]

                     args |> [
                        {} -> throw ["At least one expression must be enclosed in []"]
                        {x} -> x
                        other -> {"multi"}.concat{args}
                     ]
                  ]

                  [op == "{"] => [
                     {"data"}.concat{args.slice{1, -1}.filter{f}} where [
                        f{x} = [x !== null]
                     ]
                  ]

                  [op == "WHITE"] => [
                     {"send"}.concat{args}
                  ]

                  [[args.length == 2] && [args[0] === null] && [args[1] === null]] => [
                     op
                  ]

                  true => [
                     {"send", op, {"data"}.concat{args}}
                  ]
               ]
            ]
         ]
      ]
   ]
]


parse{text} = [
   results = tokenize{text}
   next{} = results.shift{}
   oparse{next, order, finalize}
]


Env{parent} = [
   store = Object{}
   self{expr} = [
      {.bind_env, self, expr}
   ]
   self.resolve := {name} -> [
      attempt = store[name]
      cond: [
         attempt => attempt
         true => self.parent.resolve{name}
      ]
   ]
   self.register := {name, value} -> [
      store[name] := value
   ]
   self.register_macro := {name, m} -> [
      store[name] := {.macro, m}
   ]
   self.fork := {} -> [
      Env{self}
   ]
   self.parent := parent
   self.store := store
   self
]


js_contexts = {
   js_for = {.multi, .multi, .multi, .multi}
}


expand{env, context, expr} = [
   expr := expand.step{env, context, expr}

   expr |> [
      String? -> expr

      null? -> null
      undefined? -> throw ["undefined? why?"]

      {.send, f, arg} -> [
         f = expand{env, .head, expr[1]}
         arg = expr[2]
         {.send, f, expand{env, .tail, arg}}
      ]

      {.value, v} -> expr

      {type && [.multi || .code || .array || .object || .splice], args*} -> [
         arr = {}
         while [args.length > 0]: [
            x = expand.step{env, type, args.shift{}}
            cond: [
               [[x instanceof Array] && [x[0] == "splice"]] => [
                  args := x.slice{1}.concat{args}
               ]
               true => [
                  arr.push{x}
               ]
            ]
         ]
         {type}.concat{arr.map{f}} where [
            f{x} = expand{env, type, x}
         ]
      ]

      {.data, args*} -> [

         is_obj = false
         obj = {.object}
         arr = {.array}

         while [args.length > 0]: [
            x = expand.step{env, type, args.shift{}}
            x |> [
               ;; TODO: add a check for null in the pattern matcher
               ;; so that the null? clause isn't necessary
               null? -> arr.push{null}
               {.assoc} -> is_obj := true
               {.assoc, k, v} -> [
                  is_obj := true
                  obj.push with {.array, k, v}
               ]
               {.splice, exprs*} -> [
                  args := exprs.concat{args}
               ]
               other -> [
                  arr.push{other}
               ]
            ]
         ]
         r = cond: [
            [[arr.length > 1] && is_obj] => [
               arr.push{obj}
               arr
            ]
            is_obj => [
               obj
            ]
            true => [
               arr
            ]
         ]
         expand{env, context, r}
      ]

      {.lambda, bindings, body} -> [
         {.lambda, bindings.map{{x} -> expand{env, .decl, x}}
                   expand{env, .multi, body}}
      ]

      {.declare, binding, value} -> [
         {.declare, expand{env, .decl, binding}
                    expand{env, .multi, value}}
      ]

      {.assign, lhs, rhs} -> [
         {.assign, expand{env, .decl, lhs}
                   expand{env, .multi, rhs}}
      ]

      {.js_while || .js_for || .js_break
       \ || .js_continue || .js_return || .js_throw || .if, args*} -> [
         ctxs = js_contexts[type] || {}
         {type}.concat{args.map{f}} where [
            f{x, i} = expand{env, ctxs[i] || .expr, x}
         ]
      ]

      other -> throw {"Oops", type, context}
   ]
]


expand.step := {env, context, expr} -> [
   expr |> [
      String? -> [
         v = env.resolve{expr}
         {v, context} |> [
            {undefined?, _} -> expr
            {{.macro, m}, .head} -> v
            {{.macro, m}, _} -> expand.step{env, context, m{env, context, null}}
            other -> v
         ]
      ]
      null? -> null
      undefined? -> throw ["undefined? why?"]
      {.macro, m} -> [
         cond: [
            [context == "head"] => expr
            true => expand.step{env, context, m{env, context, null}}
         ]         
      ]
      {.send, f, arg} -> [
         f := expand.step{env, .head, f}
         f |> [
            {.macro, m} -> expand.step{env, context, m{env, context, arg}}
            other -> expr
         ]
      ]
      {type, args*} -> [
         expr
      ]
      other => [
         throw {"Oops2", expr}
      ]      
   ]
]

aslist{expr} = [
   expr |> [
      null? -> {null}
      undefined? -> {undefined}
      {.multi, args*} -> args
      other -> {other}
   ]
]


nullenv = {resolve{x} = undefined}

stdenv = Env{nullenv}

stdenv.register{"+", "___plus"}
stdenv.register{"-", "___minus"}
stdenv.register{"*", "___times"}
stdenv.register{"/", "___div"}
stdenv.register{"%", "___mod"}
stdenv.register{"^", "___binxor"}
stdenv.register{"&", "___binand"}
stdenv.register{"|", "___binor"}
stdenv.register{"~", "___binnot"}
stdenv.register{"&&", "___and"}
stdenv.register{"||", "___or"}
stdenv.register{"!", "___not"}
stdenv.register{"===", "___is"}
stdenv.register{"!==", "___isnt"}
stdenv.register{"!=", "___neq"}
stdenv.register{"<", "___lt"}
stdenv.register{">", "___gt"}
stdenv.register{"<=", "___lte"}
stdenv.register{">=", "___gte"}
stdenv.register{"in", "___in"}
stdenv.register{"instanceof", "___instanceof"}
stdenv.register{"++", "___plusplus"}
stdenv.register{"--", "___minusminus"}


;;stdenv.register_macro{"TEST"} with {env, context, expr} -> [
;;   {.splice, "a", "b"}
;;]


make_checker{value} = {env, context, expr} -> [
   {.send, "___eq", {.data, expr[1], value}}
]

make_exact_checker{value} = {env, context, expr} -> [
   {.send, "___is", {.data, expr[1], value}}
]

stdenv.register_macro{"#"} with {env, context, expr} -> [
   tag = {.value, expr[2]}
   {.macro, f} where f{env, context, expr} = [
      cond: [
         [context == "pattern"] => [
            {.check, {.macro, f}, expr} where f{env, context, expr} = [
               {.send, "___eq", {.data, {.send, expr[1], {.value, "#"}}, tag}}
            ]
         ]
         true => [
            {.send, {.send, "___lib", {.value, "Struct"}}, d} where d = [
               {.data, tag}.concat{expr.slice{1}}
            ]
         ]
      ]
   ]
]

stdenv.register_macro{"&&"} with {env, context, expr} -> [
   {context, expr} |> [
      {.pattern, {.data, a, b}} -> [
         {.all, a, b}
      ]
      {_, null?} -> [
         "___and"
      ]
      other -> [
         {.send, "___and", expr}
      ]
   ]
]

stdenv.register_macro{"||"} with {env, context, expr} -> [
   {context, expr} |> [
      {.pattern, {.data, a, b}} -> [
         {.any, a, b}
      ]
      {_, null?} -> [
         "___or"
      ]
      other -> [
         {.send, "___or", expr}
      ]
   ]
]

stdenv.register_macro{"=="} with {env, context, expr} -> [
   {context, expr} |> [
      {.pattern, {.data, null?, val}} -> [
         {.check, {.macro, make_checker{val}}, null}
      ]
      {_, null?} -> [
         "___eq"
      ]
      other -> [
         {.send, "___eq", expr}
      ]
   ]
]

stdenv.register_macro{"*"} with {env, context, expr} -> [
   {context, expr} |> [
      {.pattern, {.data, val, null?}} -> [
         {.dynsplice, val}
      ]
      {_, null?} -> [
         "___times"
      ]
      other -> [
         {.send, "___times", expr}
      ]
   ]
]


stdenv.register_macro{"."} with {env, context, expr} -> [
   expr |> [
      {.data, null?, String? s} -> [
         {.value, s}
      ]
      other -> [
         throw {"invalid", expr}
      ]
   ]
]

stdenv.register_macro{"where"} with {env, context, {.data, a, b}} -> [
   {.send, .let, {.data, {.code, b}, {.code, a}}}
]

stdenv.register_macro{"let"} with {env, context, {.data, {.code, a}, {.code, b}}} -> [
   bindings = aslist{a}
   body = aslist{b}
   {.multi}.concat{bindings}.concat{body}
]

stdenv.register_macro{"->"} with {env, context, {.data, args, stmts}} -> [
   body = {.multi}
   args := args.slice{1}.map with {x} -> x |> [
      String? -> x
      other -> [
         t = gensym{}
         body.push with {.send, "=", {.data, x, t}}
         t
      ]
   ]
   body.push{stmts}
   {.lambda, args, body}
]

stdenv.register_macro{"=>"} with {env, context, {.data, binding, value}} -> [
   cond: [
      [context == "data"] => [
         {.assoc, binding, value}
      ]
      true => [
         throw ["Illegal context for '=>' (" + context + ")"]
      ]
   ]
]

stdenv.register_macro{"="} with {env, context, expr} -> [
   {context, expr} |> [

      {.multi, {.data, lhs, rhs}} -> [
         p = parse_lhs{env, lhs, rhs}
         vars = make_declarations{p[0]}
         r = {.splice}.concat{vars}
         clauses = p[1]

         mkif{x} = [
            {.if, x, {.value, false}, {.js_throw, {.value, "a condition failed"}}}
         ]

         cond: [
            [clauses.length == 1] => [
               clause = clauses[0]
               last = clause[clause.length - 1]
               cond: [
                  [[last instanceof Array]
                   \ && [last[0] == "value"] && [last[1] === true]] => [
                     cond: [
                        [[vars.length == 1] && [clause.length == 3]] => [
                           r := {.declare}.concat{clause[1].slice{1}}
                        ]
                        true => [
                           r := r.concat{clause.slice{1, -1}}
                        ]
                     ]
                  ]
                  true => [
                     r.push{mkif{clause}}
                  ]
               ]
            ]
            true => [
               ands = make_pattern_test{clauses}
               r.push{mkif{ands}}
            ]
         ]
         r
      ]

      {.data, null?} -> [
         {.assoc}
      ]

      {.data, {.data, {.send, f, {.data, args*}}, value}} -> [
         {.assoc, {.value, f}, {.lambda, args, value}}
      ]

      {.data, {.data, binding, value}} -> [
         {.assoc, {.value, binding}, value}
      ]

      other => [
         throw ["Illegal context for '=' (" + context + ")"]
      ]
   ]
]

stdenv.register_macro{":="} with {env, context, {.data, a, b}} -> [
   {.assign, a, b}
]

stdenv.register_macro{"if"} with {env, context, {.data, test, a, b}} -> [
   {.if, test, a, b}
]

stdenv.register_macro{"cond"} with {env, context, {.data, {.code, clauses}}} -> [
   handle{xs} = [
      cond: [
         [xs.length == 0] => {.value, false}
         true => [
            first = xs[0][2]
            rest = xs.slice{1}
            {.if, first[1], first[2], handle{rest}}
         ]
      ]
   ]
   handle{aslist{clauses}}
]



stdenv.register_macro{"while"} with
      \ {env, context, {.data, {.code, test}, {.code, body}}} -> [
   {.js_while, test, body}
]

stdenv.register_macro{"for"} with
      \ {env, context, {.data, {.code, {.multi, a, b, c}}, {.code, body}}} -> [
   {.js_for, a, b, c, body}
]

stdenv.register_macro{"return"} with {env, context, expr} -> [
   {.js_return, expr}
]

stdenv.register_macro{"throw"} with {env, context, expr} -> [
   {.js_throw, expr}
]

stdenv.register_macro{"break"} with {env, context, expr} -> [
   {.js_break}
]

stdenv.register_macro{"continue"} with {env, context, expr} -> [
   {.js_continue}
]


rx_wrap{x} = [
   "(?:" + x + ")"
]

rx_quote{x} = [
   x.replace{Rxg{>>".?*+^$[](){}|\\\\"}, "\\$1"}
]

rx_quote2{x} = [
   x.replace{Rxg{>>"[](){}^"}, "\\$1"}
]

rx_build{expr} = [
   expr |> [
      .any -> "."
      .start -> "^"
      .end -> "$"
      .alpha -> "\\a"
      .digit -> "\\d"
      .word -> "\\w"
      .space -> "\\s"
      .boundary -> "\\b"
      .a -> "\\a"
      .d -> "\\d"
      .w -> "\\w"
      .s -> "\\s"
      .b -> "\\b"

      {.value, x} -> rx_quote{x}
      {.send, "||", {.data, a, b}} -> [
         rx_wrap{rx_build{a} + "|" + rx_build{b}}
      ]
      {.send, "*", {.data, a, null?}} -> [
         rx_wrap{rx_build{a} + "*"}
      ]
      {.send, "+", {.data, a, null?}} -> [
         rx_wrap{rx_build{a} + "+"}
      ]
      {.send, "?", {.data, a, null?}} -> [
         rx_wrap{rx_build{a} + "?"}
      ]
      {.send, ">>", {.data, null?, b}} -> [
         ["[" + x + "]"] where [
            x = rx_quote2{b[1]}
         ]
      ]
      {.send, ">>!", {.data, null?, b}} -> [
         ["[^" + x + "]"] where [
            x = rx_quote2{b[1]}
         ]
      ]
      {.data, args*} -> [
         "(" + args.map{rx_build}.join{""} + ")"
      ]
      {.multi, args*} -> [
         "(?:" + args.map{rx_build}.join{""} + ")"
      ]
   ]
]


stdenv.register_macro{"Rx"} with {env, context, expr} -> [
   {.send, "RegExp", {.array, {.value, rx_build{expr}}}}
]

stdenv.register_macro{"Rxg"} with {env, context, expr} -> [
   {.send, "RegExp", {.array, {.value, rx_build{expr}}, {.value, "g"}}}
]


stdenv.register_macro{"?"} with {env, context, {.data, expr, null?}} -> [
   checker = expr |> [
      null? -> {.send, expr, {.value, "__check__"}}
      .String -> [
         {.macro, f} where f{env, context, {.data, expr}} = [
            {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                     {.value, "string"}}}
         ]
      ]
      .Number -> [
         {.macro, f} where f{env, context, {.data, expr}} = [
            {.send, "___eq", {.data, {.send, "typeof", {.data, expr}}
                                     {.value, "number"}}}
         ]
      ]
      .true -> {.macro, make_exact_checker{{.value, true}}}
      .false -> {.macro, make_exact_checker{{.value, false}}}
      .null -> {.macro, make_exact_checker{{.value, null}}}
      .undefined -> {.macro, make_exact_checker{{.value, undefined}}}
      other -> {.send, expr, {.value, "__check__"}}
   ]
   mac{env, context, expr} = [
      context |> [
         .pattern -> {.check, checker, expr}
         other => {.send, checker, {.data, expr}}
      ]
   ]
   {.macro, mac}
]


;; stdenv.register_macro{"!"} with {env, context, expr} -> [
;;    projector = {.send, expr[1], {.value, "__project__"}}
;;    mac{env, context, expr} = [
;;       cond: [
;;          [context == "pattern"] => [
;;             {.project, projector, expr}
;;          ]
;;          true => [
;;             {.send, projector, {.data, expr}}
;;          ]
;;       ]
;;    ]
;;    {.macro, mac}
;; ]


tempnum = 0
gensym{} = [
   name = "_tmp" + tempnum
   tempnum := tempnum + 1
   name
]

parse_lhs{env, lhs, rhs} = [
   vars = {}
   clauses = {}
   current = {.multi}

   mktemp{} = [
      t = gensym{}
      vars.push{t}
      t
   ]

   newclause{} = [
      cond: [
         [current.length > 1] => [
            clauses.push{current}
         ]
      ]
      current := {.multi}
   ]

   helper{lhs, curr} = [
      helper_noexpand{expand.step{env, .pattern, lhs}, curr}
   ]

   helper_noexpand{lhs, curr} = [
      cond: [
         [lhs === null] => [false]

         [typeof{lhs} == "string"] => [
            vars.push{lhs}
            current.push{{.assign, lhs, curr}}
            current.push{{.value, true}}
         ]

         [[lhs instanceof Array] && [lhs[0] == "value"]] => [
            helper_noexpand{x, curr} where [
               x = {.check, {.macro, make_checker{lhs}}, null}
            ]
         ]

         [[lhs instanceof Array] && [lhs[0] == "all"]] => [
            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
            }
            lhs.slice{1}.forEach with {x} -> [
               helper{x, temp}
            ]
         ]

         [[lhs instanceof Array] && [lhs[0] == "any"]] => [
            normalize{vars} = [
               vars.filter{{x} -> x.slice{0, 4} !== "_tmp"}.sort{}.join{","}
            ]

            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
            }
            myvars = undefined
            clauses = {}
            lhs.slice{1}.forEach with {x} -> [
               p = parse_lhs{env, x, temp}
               cond: [
                  [myvars === undefined] => [
                     myvars := p[0]
                  ]
                  [normalize{p[0]} !== normalize{myvars}] => [
                     throw with {
                        "Must have the same set of variables in both branches!"
                        myvars
                     }
                  ]
                  true => [
                     vars := vars.concat{p[0]}
                  ]
               ]
               clauses.push with make_pattern_test{p[1]}
            ]
            current.push with make_or_pattern{clauses}
            vars := vars.concat{myvars}
            newclause{}
         ]

         [[lhs instanceof Array] && [lhs[0] == "check"]] => [
            checker = lhs[1]
            expr = lhs[2]
            temp = mktemp{}
            current := current.concat with {
               {.assign, temp, curr}
               {.send, checker, {.data, temp}}
            }
            newclause{}
            helper{expr, temp}
         ]

         [[lhs instanceof Array] && [lhs[0] == "send"]] => [
            fname = lhs[1]
            spec = lhs[2]
            helper{fname, {.send, "->", {.data, spec, curr}}}
         ]

         [[lhs instanceof Array] && [lhs[0] == "data"]] => [
            fw = 0
            bw = 0
            rest = undefined
            members = lhs.slice{1}.map with {x} -> [
               v = expand.step{env, .pattern, x}
               cond: [
                  [[v instanceof Array] && [v[0] == "dynsplice"]] => [
                     rest := v[1]
                  ]
                  [rest === undefined] => [fw := fw + 1]
                  true => [bw := bw + 1]
               ]
               v
            ]

            cmp = [
               cond: [
                  [rest === undefined] => "___eq"
                  true => "___gte"
               ]
            ]
            temp = mktemp{}
            len = mktemp{}

            current := current.concat with {
               {.assign, temp, curr}
               {.send, "___instanceof", {.data, temp, "Array"}}
            }
            newclause{}

            current := current.concat with {
               {.assign, len, {.send, temp, {.value, "length"}}}
               ;; Bounds check
               {.send, cmp, {.data, len, {.value, fw + bw}}}
            }
            newclause{}

            for [j = 0, j < fw, ++j]: [
               helper_noexpand{members[j], {.send, temp, {.value, j}}}
            ]

            cond: [[rest !== undefined] => [
               slice = cond: [
                  [bw > 0] => {.data, {.value, fw}, {.value, -bw}}
                  true => {.data, {.value, fw}}
               ]
               helper_noexpand{
                  members[fw][1]
                  {.send, {.send, temp, {.value, "slice"}}, slice}}
            ]]

            for [j = 0, j < bw, ++j]: [
               helper_noexpand{members[fw + j + 1],
                               {.send, temp, {.send, "___minus",
                                              {.data, len, {.value, bw - j}}}}}
            ]
         ]

         true => [
            console.log with {"oops_lhs", lhs, curr}
         ]
      ]
   ]
   helper{lhs, rhs}
   cond: [
      [current.length > 1] => clauses.push{current}
   ]
   {vars, clauses}
]

make_declarations{vars} = [
   vars.map with {name} -> [
      {.declare, name, {.value, undefined}}
   ]
]

make_pattern_test{clauses} = [
   ands = clauses.pop{}
   while [clauses.length > 0]: [
      ands := {.send, "___and", {.data, clauses.pop{}, ands}}
   ]
   ands
]

make_or_pattern{clauses} = [
   ors = clauses.pop{}
   while [clauses.length > 0]: [
      ors := {.send, "___or", {.data, clauses.pop{}, ors}}
   ]
   ors
]

stdenv.register_macro{"|>"} with {env, context, expr} -> [
   to_match = expr[1]
   clauses = cond: [
      [expr[2][0] == .multi] => expr[2].slice{1}
      true => {expr[2]}
   ]
   decls = {.multi}
   r = {.js_throw, {.value, "Could not find a match"}}
   while [clauses.length > 0]: [
      clause = clauses.pop{}
      lhs = clause[2][1]
      body = clause[2][2]
      p = parse_lhs{env, lhs, to_match}
      test = make_pattern_test{p[1]}
      r := {.if, test, body, r}
      decls := decls.concat{make_declarations{p[0]}}
   ]
   decls.push{r}
   decls
]


;; stdenv.register_macro{"%"} with {env, context, expr} -> [
;; ]





js_op_table = {
   ___plus = "+"
   ___minus = "-"
   ___times = "*"
   ___div = "/"
   ___mod = "%"
   ___binxor = "^"
   ___binand = "&"
   ___binor = "|"
   ___binnot = "~"
   ___and = "&&"
   ___or = "||"
   ___not = "!"
   ___is = "==="
   ___isnt = "!=="
   ___eq = "=="
   ___neq = "!="
   ___lt = "<"
   ___gt = ">"
   ___lte = "<="
   ___gte = ">="
   ___in = " in "
   ___instanceof = " instanceof "
   ___plusplus = "++"
   ___minusminus = "--"
}


translate{expr, mode} = [
   cond: [
      [typeof{expr} == "string"] => [
         translate.expr{translate.mangle{expr}, mode}
      ]
      [expr === null] => [
         translate.expr{"null", mode}
      ]
      [expr instanceof Array] => [
         type = expr[0]
         args = expr.slice{1}
         cond: [

            [type == "value"] => [
               v = args[0]
               r = cond: [
                  [typeof{v} == "string"] => [
                     repl = {
                        "\"" => "\\\""
                        "\n" => "\\n"
                        "\\" => "\\\\"
                     }
                     v := v.replace{Rxg{"\"" || "\\" || "\n"}, {m} -> repl[m]}
                     "\"" + v + "\""
                  ]
                  [typeof{v} == "number"] => [
                     String{v}
                  ]
                  [[v === true] || [v === false] || [v === null] || [v === undefined]] => [
                     String{v}
                  ]
                  true => [
                     console.log with expr
                     "?!?[" + v + "]?!?"
                  ]
               ]
               translate.expr{r, mode}
            ]

            [type == "lambda"] => [
               bindings = args[0]
               body = args[1]
               translate.expr{"function("+a+"){"+b+"}", mode} where [
                  a = bindings.join{","}
                  b = translate.body{body, .return}
               ]
            ]

            [type == "if"] => [
               cond: [
                  [mode == "expr"] => translate.body{expr, .expr}
                  true => [
                     ["if(" + a + "){" + b + "}else{" + c + "}"] where [
                        a = translate{args[0], .expr}
                        b = translate{args[1], mode}
                        c = translate{args[2], mode}
                     ]
                  ]
               ]
            ]

            [type == "js_while"] => [
               cond: [
                  [mode == "expr"] => translate.body{expr, .expr}
                  true => [
                     ["while(" + a + "){" + b + "}"] where [
                        a = translate{args[0], .expr}
                        b = translate{args[1], .stmt}
                     ]
                  ]
               ]
            ]

            [type == "js_for"] => [
               cond: [
                  [mode == "expr"] => translate.body{expr, .expr}
                  true => [
                     ["for("+a+b+c+"){"+d+"}"] where [
                        a = translate{args[0], .stmt}
                        b = translate{args[1], .stmt}
                        c = translate{args[2], .expr}
                        d = translate{args[3], .stmt}
                     ]
                  ]
               ]
            ]

            [type == "declare"] => [
               cond: [
                  [[mode == "expr"] || [mode == "return"]] => throw "Invalid in expr ctx"
                  true => [
                     ["var " + a + "=" + b + ";"] where [
                        a = translate{args[0], .expr}
                        b = translate{args[1], .expr}
                     ]
                  ]
               ]
            ]

            [type == "assign"] => [
               translate.expr{"(" + a + "=" + b + ")", mode} where [
                  a = translate{args[0], .expr}
                  b = translate{args[1], .expr}
               ]
            ]

            [type == "multi"] => [
               isdecl{x} = [[x instanceof Array] && [x[0] == .declare]]
               cond: [
                   [args.length == 1] => translate{args[0], mode}
                   [[mode == "expr"] && [args.filter{isdecl}.length == 0]] => [
                      ["(" + xs.join{","} + ")"] where [
                         xs = args.map with {x} -> [
                            translate{x, .expr}
                         ]
                      ]
                   ]
                   true => translate.body{expr, mode}
               ]
            ]

            [type == "splice"] => [
               translate{{.multi}.concat{args}, mode}
            ]

            [type == "js_break"] => [
               cond: [
                  [mode == "expr"] => throw "Invalid break in ctx"
                  true => "break;"
               ]
            ]

            [type == "js_continue"] => [
               cond: [
                  [mode == "expr"] => throw "Invalid continue in ctx"
                  true => "continue;"
               ]
            ]

            [type == "js_return"] => [
               cond: [
                  [mode == "expr"] => throw "Invalid return in ctx"
                  true => "return " + translate{args[0], .expr} + ";"
               ]
            ]

            [type == "js_throw"] => [
               cond: [
                  ;; [mode == "expr"] => throw "Invalid throw in ctx"
                  true => "throw " + translate{args[0], .expr} + ";"
               ]
            ]

            [type == "array"] => [
               r = ["[" + args.map{f}.join{","} + "]"] where [
                  f{x} = translate{x, .expr}
               ]
               translate.expr{r, mode}
            ]

            [type == "object"] => [
               r = ["({" + args.map{f}.join{","} + "})"] where [
                  f{x} = [
                     a = translate{x[1], .expr}
                     b = translate{x[2], .expr}
                     a + ":" + b
                  ]
               ]
               translate.expr{r, mode}
            ]

            [type == "send"] => [
               f = args[0]
               msg = args[1]
               cond: [

                  [[msg instanceof Array] && [msg[0] == "value"]] => [
                     s = msg[1]
                     cond: [
                        [[typeof{s} == "string"]
                         \ && s.match{Rx[start, [>>"a-zA-Z_$"]+, end]}] => [
                           translate.expr{trf + "." + trmsg, mode} where [
                              trf = translate{f, .expr}
                              trmsg = translate{msg[1], .expr}
                           ]
                        ]
                        true => [
                           translate.expr{trf + "[" + trmsg + "]", mode} where [
                              trf = translate{f, .expr}
                              trmsg = translate{msg, .expr}
                           ]
                        ]
                     ]
                  ]

                  [[msg instanceof Array] && [msg[0] == "array"]] => [
                     op = [typeof{f} == "string"] && js_op_table[f]
                     cond: [
                        op => [
                           translate.expr{translate.op{op, msg[1], msg[2]}, mode}
                        ]
                        true => [
                           translate.expr{trf+"("+trargs.join{","}+")", mode} where [
                              trf = translate{f, .expr}
                              trargs = msg.slice{1}.map with {x} -> [
                                 translate{x, .expr}
                              ]
                           ]
                        ]
                     ]
                  ]

                  true => [
                     translate.expr{trf + "[" + trmsg + "]", mode} where [
                        trf = translate{f, .expr}
                        trmsg = translate{msg, .expr}
                     ]
                  ]

               ]
            ]

         ]
      ]
   ]
]


translate.mangle := {name} -> [
   tr = {
      "+" => "__plus__"
      "-" => "__minus__"
      "*" => "__asterisk__"
      "/" => "__slash__"
      "%" => "__percent__"
      "^" => "__caret__"
      "#" => "__hash__"
      "&" => "__amp__"
      "|" => "__pipe__"
      "@" => "__at__"
      "!" => "__bang__"
      "?" => "__qmark__"
      "=" => "__equal__"
      "<" => "__lt__"
      ">" => "__gt__"
      "~" => "__tilde__"
   }
   r = {}
   for [i = 0, i < name.length, ++i]: [
      c = name[i]
      r.push{tr[c] || c}
   ]
   r.join{""}
]


translate.body := {b, mode} -> [
   orig := b
   b := aslist{b}
   trst{stmt} = translate{stmt, .stmt}
   cond: [
      [mode == .expr] => [
         translate{x, mode} where [
            x = {.send, {.lambda, {}, orig}, {.array}}
         ]
      ]
      [mode == .return] => [
         stmts = b.slice{0, -1}
         ret = b[b.length - 1]
         stmts.map{trst}.join{""} + translate{ret, .return}
      ]
      [mode == .stmt] => [
         b.map{trst}.join{""}
      ]
   ]
]

translate.expr := {x, mode} -> [
   cond: [
      [mode == .expr] => x
      [mode == .stmt] => x + ";"
      [mode == .return] => "return " + x + ";"
   ]
]

translate.op := {op, a, b} -> [
   e := cond: [
           [a === null] => op + translate{b, .expr}
           [b === null] => translate{a, .expr} + op
           true => translate{a, .expr} + op + translate{b, .expr}
        ]
   "(" + e + ")"
]



fs = require{.fs}

file = process.argv[2]
;; file = "test.eg"

fs.readFile{file, "utf8", f} where [
   f{err, data} = [
      p = parse{data}
      ex = expand{stdenv, .top, {.multi, p}}
      ;; console.log with p
      ;; console.log with ex
      prelude = "var ___lib=require(\"./lib\");"
      console.log with prelude + translate{ex, .stmt}
   ]
]
